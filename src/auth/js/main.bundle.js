(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"/Users/jon/jupyter/notebook/node_modules/marked/lib/marked.js":[function(require,module,exports){
(function (global){
/**
 * marked - a markdown parser
 * Copyright (c) 2011-2014, Christopher Jeffrey. (MIT Licensed)
 * https://github.com/chjj/marked
 */

;(function() {

/**
 * Block-Level Grammar
 */

var block = {
  newline: /^\n+/,
  code: /^( {4}[^\n]+\n*)+/,
  fences: noop,
  hr: /^( *[-*_]){3,} *(?:\n+|$)/,
  heading: /^ *(#{1,6}) *([^\n]+?) *#* *(?:\n+|$)/,
  nptable: noop,
  lheading: /^([^\n]+)\n *(=|-){2,} *(?:\n+|$)/,
  blockquote: /^( *>[^\n]+(\n(?!def)[^\n]+)*\n*)+/,
  list: /^( *)(bull) [\s\S]+?(?:hr|def|\n{2,}(?! )(?!\1bull )\n*|\s*$)/,
  html: /^ *(?:comment *(?:\n|\s*$)|closed *(?:\n{2,}|\s*$)|closing *(?:\n{2,}|\s*$))/,
  def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +["(]([^\n]+)[")])? *(?:\n+|$)/,
  table: noop,
  paragraph: /^((?:[^\n]+\n?(?!hr|heading|lheading|blockquote|tag|def))+)\n*/,
  text: /^[^\n]+/
};

block.bullet = /(?:[*+-]|\d+\.)/;
block.item = /^( *)(bull) [^\n]*(?:\n(?!\1bull )[^\n]*)*/;
block.item = replace(block.item, 'gm')
  (/bull/g, block.bullet)
  ();

block.list = replace(block.list)
  (/bull/g, block.bullet)
  ('hr', '\\n+(?=\\1?(?:[-*_] *){3,}(?:\\n+|$))')
  ('def', '\\n+(?=' + block.def.source + ')')
  ();

block.blockquote = replace(block.blockquote)
  ('def', block.def)
  ();

block._tag = '(?!(?:'
  + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code'
  + '|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo'
  + '|span|br|wbr|ins|del|img)\\b)\\w+(?!:/|[^\\w\\s@]*@)\\b';

block.html = replace(block.html)
  ('comment', /<!--[\s\S]*?-->/)
  ('closed', /<(tag)[\s\S]+?<\/\1>/)
  ('closing', /<tag(?:"[^"]*"|'[^']*'|[^'">])*?>/)
  (/tag/g, block._tag)
  ();

block.paragraph = replace(block.paragraph)
  ('hr', block.hr)
  ('heading', block.heading)
  ('lheading', block.lheading)
  ('blockquote', block.blockquote)
  ('tag', '<' + block._tag)
  ('def', block.def)
  ();

/**
 * Normal Block Grammar
 */

block.normal = merge({}, block);

/**
 * GFM Block Grammar
 */

block.gfm = merge({}, block.normal, {
  fences: /^ *(`{3,}|~{3,})[ \.]*(\S+)? *\n([\s\S]*?)\s*\1 *(?:\n+|$)/,
  paragraph: /^/,
  heading: /^ *(#{1,6}) +([^\n]+?) *#* *(?:\n+|$)/
});

block.gfm.paragraph = replace(block.paragraph)
  ('(?!', '(?!'
    + block.gfm.fences.source.replace('\\1', '\\2') + '|'
    + block.list.source.replace('\\1', '\\3') + '|')
  ();

/**
 * GFM + Tables Block Grammar
 */

block.tables = merge({}, block.gfm, {
  nptable: /^ *(\S.*\|.*)\n *([-:]+ *\|[-| :]*)\n((?:.*\|.*(?:\n|$))*)\n*/,
  table: /^ *\|(.+)\n *\|( *[-:]+[-| :]*)\n((?: *\|.*(?:\n|$))*)\n*/
});

/**
 * Block Lexer
 */

function Lexer(options) {
  this.tokens = [];
  this.tokens.links = {};
  this.options = options || marked.defaults;
  this.rules = block.normal;

  if (this.options.gfm) {
    if (this.options.tables) {
      this.rules = block.tables;
    } else {
      this.rules = block.gfm;
    }
  }
}

/**
 * Expose Block Rules
 */

Lexer.rules = block;

/**
 * Static Lex Method
 */

Lexer.lex = function(src, options) {
  var lexer = new Lexer(options);
  return lexer.lex(src);
};

/**
 * Preprocessing
 */

Lexer.prototype.lex = function(src) {
  src = src
    .replace(/\r\n|\r/g, '\n')
    .replace(/\t/g, '    ')
    .replace(/\u00a0/g, ' ')
    .replace(/\u2424/g, '\n');

  return this.token(src, true);
};

/**
 * Lexing
 */

Lexer.prototype.token = function(src, top, bq) {
  var src = src.replace(/^ +$/gm, '')
    , next
    , loose
    , cap
    , bull
    , b
    , item
    , space
    , i
    , l;

  while (src) {
    // newline
    if (cap = this.rules.newline.exec(src)) {
      src = src.substring(cap[0].length);
      if (cap[0].length > 1) {
        this.tokens.push({
          type: 'space'
        });
      }
    }

    // code
    if (cap = this.rules.code.exec(src)) {
      src = src.substring(cap[0].length);
      cap = cap[0].replace(/^ {4}/gm, '');
      this.tokens.push({
        type: 'code',
        text: !this.options.pedantic
          ? cap.replace(/\n+$/, '')
          : cap
      });
      continue;
    }

    // fences (gfm)
    if (cap = this.rules.fences.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'code',
        lang: cap[2],
        text: cap[3] || ''
      });
      continue;
    }

    // heading
    if (cap = this.rules.heading.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'heading',
        depth: cap[1].length,
        text: cap[2]
      });
      continue;
    }

    // table no leading pipe (gfm)
    if (top && (cap = this.rules.nptable.exec(src))) {
      src = src.substring(cap[0].length);

      item = {
        type: 'table',
        header: cap[1].replace(/^ *| *\| *$/g, '').split(/ *\| */),
        align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
        cells: cap[3].replace(/\n$/, '').split('\n')
      };

      for (i = 0; i < item.align.length; i++) {
        if (/^ *-+: *$/.test(item.align[i])) {
          item.align[i] = 'right';
        } else if (/^ *:-+: *$/.test(item.align[i])) {
          item.align[i] = 'center';
        } else if (/^ *:-+ *$/.test(item.align[i])) {
          item.align[i] = 'left';
        } else {
          item.align[i] = null;
        }
      }

      for (i = 0; i < item.cells.length; i++) {
        item.cells[i] = item.cells[i].split(/ *\| */);
      }

      this.tokens.push(item);

      continue;
    }

    // lheading
    if (cap = this.rules.lheading.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'heading',
        depth: cap[2] === '=' ? 1 : 2,
        text: cap[1]
      });
      continue;
    }

    // hr
    if (cap = this.rules.hr.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'hr'
      });
      continue;
    }

    // blockquote
    if (cap = this.rules.blockquote.exec(src)) {
      src = src.substring(cap[0].length);

      this.tokens.push({
        type: 'blockquote_start'
      });

      cap = cap[0].replace(/^ *> ?/gm, '');

      // Pass `top` to keep the current
      // "toplevel" state. This is exactly
      // how markdown.pl works.
      this.token(cap, top, true);

      this.tokens.push({
        type: 'blockquote_end'
      });

      continue;
    }

    // list
    if (cap = this.rules.list.exec(src)) {
      src = src.substring(cap[0].length);
      bull = cap[2];

      this.tokens.push({
        type: 'list_start',
        ordered: bull.length > 1
      });

      // Get each top-level item.
      cap = cap[0].match(this.rules.item);

      next = false;
      l = cap.length;
      i = 0;

      for (; i < l; i++) {
        item = cap[i];

        // Remove the list item's bullet
        // so it is seen as the next token.
        space = item.length;
        item = item.replace(/^ *([*+-]|\d+\.) +/, '');

        // Outdent whatever the
        // list item contains. Hacky.
        if (~item.indexOf('\n ')) {
          space -= item.length;
          item = !this.options.pedantic
            ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '')
            : item.replace(/^ {1,4}/gm, '');
        }

        // Determine whether the next list item belongs here.
        // Backpedal if it does not belong in this list.
        if (this.options.smartLists && i !== l - 1) {
          b = block.bullet.exec(cap[i + 1])[0];
          if (bull !== b && !(bull.length > 1 && b.length > 1)) {
            src = cap.slice(i + 1).join('\n') + src;
            i = l - 1;
          }
        }

        // Determine whether item is loose or not.
        // Use: /(^|\n)(?! )[^\n]+\n\n(?!\s*$)/
        // for discount behavior.
        loose = next || /\n\n(?!\s*$)/.test(item);
        if (i !== l - 1) {
          next = item.charAt(item.length - 1) === '\n';
          if (!loose) loose = next;
        }

        this.tokens.push({
          type: loose
            ? 'loose_item_start'
            : 'list_item_start'
        });

        // Recurse.
        this.token(item, false, bq);

        this.tokens.push({
          type: 'list_item_end'
        });
      }

      this.tokens.push({
        type: 'list_end'
      });

      continue;
    }

    // html
    if (cap = this.rules.html.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: this.options.sanitize
          ? 'paragraph'
          : 'html',
        pre: !this.options.sanitizer
          && (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),
        text: cap[0]
      });
      continue;
    }

    // def
    if ((!bq && top) && (cap = this.rules.def.exec(src))) {
      src = src.substring(cap[0].length);
      this.tokens.links[cap[1].toLowerCase()] = {
        href: cap[2],
        title: cap[3]
      };
      continue;
    }

    // table (gfm)
    if (top && (cap = this.rules.table.exec(src))) {
      src = src.substring(cap[0].length);

      item = {
        type: 'table',
        header: cap[1].replace(/^ *| *\| *$/g, '').split(/ *\| */),
        align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
        cells: cap[3].replace(/(?: *\| *)?\n$/, '').split('\n')
      };

      for (i = 0; i < item.align.length; i++) {
        if (/^ *-+: *$/.test(item.align[i])) {
          item.align[i] = 'right';
        } else if (/^ *:-+: *$/.test(item.align[i])) {
          item.align[i] = 'center';
        } else if (/^ *:-+ *$/.test(item.align[i])) {
          item.align[i] = 'left';
        } else {
          item.align[i] = null;
        }
      }

      for (i = 0; i < item.cells.length; i++) {
        item.cells[i] = item.cells[i]
          .replace(/^ *\| *| *\| *$/g, '')
          .split(/ *\| */);
      }

      this.tokens.push(item);

      continue;
    }

    // top-level paragraph
    if (top && (cap = this.rules.paragraph.exec(src))) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'paragraph',
        text: cap[1].charAt(cap[1].length - 1) === '\n'
          ? cap[1].slice(0, -1)
          : cap[1]
      });
      continue;
    }

    // text
    if (cap = this.rules.text.exec(src)) {
      // Top-level should never reach here.
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'text',
        text: cap[0]
      });
      continue;
    }

    if (src) {
      throw new
        Error('Infinite loop on byte: ' + src.charCodeAt(0));
    }
  }

  return this.tokens;
};

/**
 * Inline-Level Grammar
 */

var inline = {
  escape: /^\\([\\`*{}\[\]()#+\-.!_>])/,
  autolink: /^<([^ >]+(@|:\/)[^ >]+)>/,
  url: noop,
  tag: /^<!--[\s\S]*?-->|^<\/?\w+(?:"[^"]*"|'[^']*'|[^'">])*?>/,
  link: /^!?\[(inside)\]\(href\)/,
  reflink: /^!?\[(inside)\]\s*\[([^\]]*)\]/,
  nolink: /^!?\[((?:\[[^\]]*\]|[^\[\]])*)\]/,
  strong: /^__([\s\S]+?)__(?!_)|^\*\*([\s\S]+?)\*\*(?!\*)/,
  em: /^\b_((?:[^_]|__)+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,
  code: /^(`+)\s*([\s\S]*?[^`])\s*\1(?!`)/,
  br: /^ {2,}\n(?!\s*$)/,
  del: noop,
  text: /^[\s\S]+?(?=[\\<!\[_*`]| {2,}\n|$)/
};

inline._inside = /(?:\[[^\]]*\]|[^\[\]]|\](?=[^\[]*\]))*/;
inline._href = /\s*<?([\s\S]*?)>?(?:\s+['"]([\s\S]*?)['"])?\s*/;

inline.link = replace(inline.link)
  ('inside', inline._inside)
  ('href', inline._href)
  ();

inline.reflink = replace(inline.reflink)
  ('inside', inline._inside)
  ();

/**
 * Normal Inline Grammar
 */

inline.normal = merge({}, inline);

/**
 * Pedantic Inline Grammar
 */

inline.pedantic = merge({}, inline.normal, {
  strong: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
  em: /^_(?=\S)([\s\S]*?\S)_(?!_)|^\*(?=\S)([\s\S]*?\S)\*(?!\*)/
});

/**
 * GFM Inline Grammar
 */

inline.gfm = merge({}, inline.normal, {
  escape: replace(inline.escape)('])', '~|])')(),
  url: /^(https?:\/\/[^\s<]+[^<.,:;"')\]\s])/,
  del: /^~~(?=\S)([\s\S]*?\S)~~/,
  text: replace(inline.text)
    (']|', '~]|')
    ('|', '|https?://|')
    ()
});

/**
 * GFM + Line Breaks Inline Grammar
 */

inline.breaks = merge({}, inline.gfm, {
  br: replace(inline.br)('{2,}', '*')(),
  text: replace(inline.gfm.text)('{2,}', '*')()
});

/**
 * Inline Lexer & Compiler
 */

function InlineLexer(links, options) {
  this.options = options || marked.defaults;
  this.links = links;
  this.rules = inline.normal;
  this.renderer = this.options.renderer || new Renderer;
  this.renderer.options = this.options;

  if (!this.links) {
    throw new
      Error('Tokens array requires a `links` property.');
  }

  if (this.options.gfm) {
    if (this.options.breaks) {
      this.rules = inline.breaks;
    } else {
      this.rules = inline.gfm;
    }
  } else if (this.options.pedantic) {
    this.rules = inline.pedantic;
  }
}

/**
 * Expose Inline Rules
 */

InlineLexer.rules = inline;

/**
 * Static Lexing/Compiling Method
 */

InlineLexer.output = function(src, links, options) {
  var inline = new InlineLexer(links, options);
  return inline.output(src);
};

/**
 * Lexing/Compiling
 */

InlineLexer.prototype.output = function(src) {
  var out = ''
    , link
    , text
    , href
    , cap;

  while (src) {
    // escape
    if (cap = this.rules.escape.exec(src)) {
      src = src.substring(cap[0].length);
      out += cap[1];
      continue;
    }

    // autolink
    if (cap = this.rules.autolink.exec(src)) {
      src = src.substring(cap[0].length);
      if (cap[2] === '@') {
        text = cap[1].charAt(6) === ':'
          ? this.mangle(cap[1].substring(7))
          : this.mangle(cap[1]);
        href = this.mangle('mailto:') + text;
      } else {
        text = escape(cap[1]);
        href = text;
      }
      out += this.renderer.link(href, null, text);
      continue;
    }

    // url (gfm)
    if (!this.inLink && (cap = this.rules.url.exec(src))) {
      src = src.substring(cap[0].length);
      text = escape(cap[1]);
      href = text;
      out += this.renderer.link(href, null, text);
      continue;
    }

    // tag
    if (cap = this.rules.tag.exec(src)) {
      if (!this.inLink && /^<a /i.test(cap[0])) {
        this.inLink = true;
      } else if (this.inLink && /^<\/a>/i.test(cap[0])) {
        this.inLink = false;
      }
      src = src.substring(cap[0].length);
      out += this.options.sanitize
        ? this.options.sanitizer
          ? this.options.sanitizer(cap[0])
          : escape(cap[0])
        : cap[0]
      continue;
    }

    // link
    if (cap = this.rules.link.exec(src)) {
      src = src.substring(cap[0].length);
      this.inLink = true;
      out += this.outputLink(cap, {
        href: cap[2],
        title: cap[3]
      });
      this.inLink = false;
      continue;
    }

    // reflink, nolink
    if ((cap = this.rules.reflink.exec(src))
        || (cap = this.rules.nolink.exec(src))) {
      src = src.substring(cap[0].length);
      link = (cap[2] || cap[1]).replace(/\s+/g, ' ');
      link = this.links[link.toLowerCase()];
      if (!link || !link.href) {
        out += cap[0].charAt(0);
        src = cap[0].substring(1) + src;
        continue;
      }
      this.inLink = true;
      out += this.outputLink(cap, link);
      this.inLink = false;
      continue;
    }

    // strong
    if (cap = this.rules.strong.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.strong(this.output(cap[2] || cap[1]));
      continue;
    }

    // em
    if (cap = this.rules.em.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.em(this.output(cap[2] || cap[1]));
      continue;
    }

    // code
    if (cap = this.rules.code.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.codespan(escape(cap[2], true));
      continue;
    }

    // br
    if (cap = this.rules.br.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.br();
      continue;
    }

    // del (gfm)
    if (cap = this.rules.del.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.del(this.output(cap[1]));
      continue;
    }

    // text
    if (cap = this.rules.text.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.text(escape(this.smartypants(cap[0])));
      continue;
    }

    if (src) {
      throw new
        Error('Infinite loop on byte: ' + src.charCodeAt(0));
    }
  }

  return out;
};

/**
 * Compile Link
 */

InlineLexer.prototype.outputLink = function(cap, link) {
  var href = escape(link.href)
    , title = link.title ? escape(link.title) : null;

  return cap[0].charAt(0) !== '!'
    ? this.renderer.link(href, title, this.output(cap[1]))
    : this.renderer.image(href, title, escape(cap[1]));
};

/**
 * Smartypants Transformations
 */

InlineLexer.prototype.smartypants = function(text) {
  if (!this.options.smartypants) return text;
  return text
    // em-dashes
    .replace(/---/g, '\u2014')
    // en-dashes
    .replace(/--/g, '\u2013')
    // opening singles
    .replace(/(^|[-\u2014/(\[{"\s])'/g, '$1\u2018')
    // closing singles & apostrophes
    .replace(/'/g, '\u2019')
    // opening doubles
    .replace(/(^|[-\u2014/(\[{\u2018\s])"/g, '$1\u201c')
    // closing doubles
    .replace(/"/g, '\u201d')
    // ellipses
    .replace(/\.{3}/g, '\u2026');
};

/**
 * Mangle Links
 */

InlineLexer.prototype.mangle = function(text) {
  if (!this.options.mangle) return text;
  var out = ''
    , l = text.length
    , i = 0
    , ch;

  for (; i < l; i++) {
    ch = text.charCodeAt(i);
    if (Math.random() > 0.5) {
      ch = 'x' + ch.toString(16);
    }
    out += '&#' + ch + ';';
  }

  return out;
};

/**
 * Renderer
 */

function Renderer(options) {
  this.options = options || {};
}

Renderer.prototype.code = function(code, lang, escaped) {
  if (this.options.highlight) {
    var out = this.options.highlight(code, lang);
    if (out != null && out !== code) {
      escaped = true;
      code = out;
    }
  }

  if (!lang) {
    return '<pre><code>'
      + (escaped ? code : escape(code, true))
      + '\n</code></pre>';
  }

  return '<pre><code class="'
    + this.options.langPrefix
    + escape(lang, true)
    + '">'
    + (escaped ? code : escape(code, true))
    + '\n</code></pre>\n';
};

Renderer.prototype.blockquote = function(quote) {
  return '<blockquote>\n' + quote + '</blockquote>\n';
};

Renderer.prototype.html = function(html) {
  return html;
};

Renderer.prototype.heading = function(text, level, raw) {
  return '<h'
    + level
    + ' id="'
    + this.options.headerPrefix
    + raw.toLowerCase().replace(/[^\w]+/g, '-')
    + '">'
    + text
    + '</h'
    + level
    + '>\n';
};

Renderer.prototype.hr = function() {
  return this.options.xhtml ? '<hr/>\n' : '<hr>\n';
};

Renderer.prototype.list = function(body, ordered) {
  var type = ordered ? 'ol' : 'ul';
  return '<' + type + '>\n' + body + '</' + type + '>\n';
};

Renderer.prototype.listitem = function(text) {
  return '<li>' + text + '</li>\n';
};

Renderer.prototype.paragraph = function(text) {
  return '<p>' + text + '</p>\n';
};

Renderer.prototype.table = function(header, body) {
  return '<table>\n'
    + '<thead>\n'
    + header
    + '</thead>\n'
    + '<tbody>\n'
    + body
    + '</tbody>\n'
    + '</table>\n';
};

Renderer.prototype.tablerow = function(content) {
  return '<tr>\n' + content + '</tr>\n';
};

Renderer.prototype.tablecell = function(content, flags) {
  var type = flags.header ? 'th' : 'td';
  var tag = flags.align
    ? '<' + type + ' style="text-align:' + flags.align + '">'
    : '<' + type + '>';
  return tag + content + '</' + type + '>\n';
};

// span level renderer
Renderer.prototype.strong = function(text) {
  return '<strong>' + text + '</strong>';
};

Renderer.prototype.em = function(text) {
  return '<em>' + text + '</em>';
};

Renderer.prototype.codespan = function(text) {
  return '<code>' + text + '</code>';
};

Renderer.prototype.br = function() {
  return this.options.xhtml ? '<br/>' : '<br>';
};

Renderer.prototype.del = function(text) {
  return '<del>' + text + '</del>';
};

Renderer.prototype.link = function(href, title, text) {
  if (this.options.sanitize) {
    try {
      var prot = decodeURIComponent(unescape(href))
        .replace(/[^\w:]/g, '')
        .toLowerCase();
    } catch (e) {
      return '';
    }
    if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0) {
      return '';
    }
  }
  var out = '<a href="' + href + '"';
  if (title) {
    out += ' title="' + title + '"';
  }
  out += '>' + text + '</a>';
  return out;
};

Renderer.prototype.image = function(href, title, text) {
  var out = '<img src="' + href + '" alt="' + text + '"';
  if (title) {
    out += ' title="' + title + '"';
  }
  out += this.options.xhtml ? '/>' : '>';
  return out;
};

Renderer.prototype.text = function(text) {
  return text;
};

/**
 * Parsing & Compiling
 */

function Parser(options) {
  this.tokens = [];
  this.token = null;
  this.options = options || marked.defaults;
  this.options.renderer = this.options.renderer || new Renderer;
  this.renderer = this.options.renderer;
  this.renderer.options = this.options;
}

/**
 * Static Parse Method
 */

Parser.parse = function(src, options, renderer) {
  var parser = new Parser(options, renderer);
  return parser.parse(src);
};

/**
 * Parse Loop
 */

Parser.prototype.parse = function(src) {
  this.inline = new InlineLexer(src.links, this.options, this.renderer);
  this.tokens = src.reverse();

  var out = '';
  while (this.next()) {
    out += this.tok();
  }

  return out;
};

/**
 * Next Token
 */

Parser.prototype.next = function() {
  return this.token = this.tokens.pop();
};

/**
 * Preview Next Token
 */

Parser.prototype.peek = function() {
  return this.tokens[this.tokens.length - 1] || 0;
};

/**
 * Parse Text Tokens
 */

Parser.prototype.parseText = function() {
  var body = this.token.text;

  while (this.peek().type === 'text') {
    body += '\n' + this.next().text;
  }

  return this.inline.output(body);
};

/**
 * Parse Current Token
 */

Parser.prototype.tok = function() {
  switch (this.token.type) {
    case 'space': {
      return '';
    }
    case 'hr': {
      return this.renderer.hr();
    }
    case 'heading': {
      return this.renderer.heading(
        this.inline.output(this.token.text),
        this.token.depth,
        this.token.text);
    }
    case 'code': {
      return this.renderer.code(this.token.text,
        this.token.lang,
        this.token.escaped);
    }
    case 'table': {
      var header = ''
        , body = ''
        , i
        , row
        , cell
        , flags
        , j;

      // header
      cell = '';
      for (i = 0; i < this.token.header.length; i++) {
        flags = { header: true, align: this.token.align[i] };
        cell += this.renderer.tablecell(
          this.inline.output(this.token.header[i]),
          { header: true, align: this.token.align[i] }
        );
      }
      header += this.renderer.tablerow(cell);

      for (i = 0; i < this.token.cells.length; i++) {
        row = this.token.cells[i];

        cell = '';
        for (j = 0; j < row.length; j++) {
          cell += this.renderer.tablecell(
            this.inline.output(row[j]),
            { header: false, align: this.token.align[j] }
          );
        }

        body += this.renderer.tablerow(cell);
      }
      return this.renderer.table(header, body);
    }
    case 'blockquote_start': {
      var body = '';

      while (this.next().type !== 'blockquote_end') {
        body += this.tok();
      }

      return this.renderer.blockquote(body);
    }
    case 'list_start': {
      var body = ''
        , ordered = this.token.ordered;

      while (this.next().type !== 'list_end') {
        body += this.tok();
      }

      return this.renderer.list(body, ordered);
    }
    case 'list_item_start': {
      var body = '';

      while (this.next().type !== 'list_item_end') {
        body += this.token.type === 'text'
          ? this.parseText()
          : this.tok();
      }

      return this.renderer.listitem(body);
    }
    case 'loose_item_start': {
      var body = '';

      while (this.next().type !== 'list_item_end') {
        body += this.tok();
      }

      return this.renderer.listitem(body);
    }
    case 'html': {
      var html = !this.token.pre && !this.options.pedantic
        ? this.inline.output(this.token.text)
        : this.token.text;
      return this.renderer.html(html);
    }
    case 'paragraph': {
      return this.renderer.paragraph(this.inline.output(this.token.text));
    }
    case 'text': {
      return this.renderer.paragraph(this.parseText());
    }
  }
};

/**
 * Helpers
 */

function escape(html, encode) {
  return html
    .replace(!encode ? /&(?!#?\w+;)/g : /&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');
}

function unescape(html) {
  return html.replace(/&([#\w]+);/g, function(_, n) {
    n = n.toLowerCase();
    if (n === 'colon') return ':';
    if (n.charAt(0) === '#') {
      return n.charAt(1) === 'x'
        ? String.fromCharCode(parseInt(n.substring(2), 16))
        : String.fromCharCode(+n.substring(1));
    }
    return '';
  });
}

function replace(regex, opt) {
  regex = regex.source;
  opt = opt || '';
  return function self(name, val) {
    if (!name) return new RegExp(regex, opt);
    val = val.source || val;
    val = val.replace(/(^|[^\[])\^/g, '$1');
    regex = regex.replace(name, val);
    return self;
  };
}

function noop() {}
noop.exec = noop;

function merge(obj) {
  var i = 1
    , target
    , key;

  for (; i < arguments.length; i++) {
    target = arguments[i];
    for (key in target) {
      if (Object.prototype.hasOwnProperty.call(target, key)) {
        obj[key] = target[key];
      }
    }
  }

  return obj;
}


/**
 * Marked
 */

function marked(src, opt, callback) {
  if (callback || typeof opt === 'function') {
    if (!callback) {
      callback = opt;
      opt = null;
    }

    opt = merge({}, marked.defaults, opt || {});

    var highlight = opt.highlight
      , tokens
      , pending
      , i = 0;

    try {
      tokens = Lexer.lex(src, opt)
    } catch (e) {
      return callback(e);
    }

    pending = tokens.length;

    var done = function(err) {
      if (err) {
        opt.highlight = highlight;
        return callback(err);
      }

      var out;

      try {
        out = Parser.parse(tokens, opt);
      } catch (e) {
        err = e;
      }

      opt.highlight = highlight;

      return err
        ? callback(err)
        : callback(null, out);
    };

    if (!highlight || highlight.length < 3) {
      return done();
    }

    delete opt.highlight;

    if (!pending) return done();

    for (; i < tokens.length; i++) {
      (function(token) {
        if (token.type !== 'code') {
          return --pending || done();
        }
        return highlight(token.text, token.lang, function(err, code) {
          if (err) return done(err);
          if (code == null || code === token.text) {
            return --pending || done();
          }
          token.text = code;
          token.escaped = true;
          --pending || done();
        });
      })(tokens[i]);
    }

    return;
  }
  try {
    if (opt) opt = merge({}, marked.defaults, opt);
    return Parser.parse(Lexer.lex(src, opt), opt);
  } catch (e) {
    e.message += '\nPlease report this to https://github.com/chjj/marked.';
    if ((opt || marked.defaults).silent) {
      return '<p>An error occured:</p><pre>'
        + escape(e.message + '', true)
        + '</pre>';
    }
    throw e;
  }
}

/**
 * Options
 */

marked.options =
marked.setOptions = function(opt) {
  merge(marked.defaults, opt);
  return marked;
};

marked.defaults = {
  gfm: true,
  tables: true,
  breaks: false,
  pedantic: false,
  sanitize: false,
  sanitizer: null,
  mangle: true,
  smartLists: false,
  silent: false,
  highlight: null,
  langPrefix: 'lang-',
  smartypants: false,
  headerPrefix: '',
  renderer: new Renderer,
  xhtml: false
};

/**
 * Expose
 */

marked.Parser = Parser;
marked.parser = Parser.parse;

marked.Renderer = Renderer;

marked.Lexer = Lexer;
marked.lexer = Lexer.lex;

marked.InlineLexer = InlineLexer;
marked.inlineLexer = InlineLexer.output;

marked.parse = marked;

if (typeof module !== 'undefined' && typeof exports === 'object') {
  module.exports = marked;
} else if (typeof define === 'function' && define.amd) {
  define(function() { return marked; });
} else {
  this.marked = marked;
}

}).call(function() {
  return this || (typeof window !== 'undefined' ? window : global);
}());

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],"/Users/jon/jupyter/notebook/node_modules/moment/moment.js":[function(require,module,exports){
(function (global){
//! moment.js
//! version : 2.8.4
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com

(function (undefined) {
    /************************************
        Constants
    ************************************/

    var moment,
        VERSION = '2.8.4',
        // the global-scope this is NOT the global object in Node.js
        globalScope = typeof global !== 'undefined' ? global : this,
        oldGlobalMoment,
        round = Math.round,
        hasOwnProperty = Object.prototype.hasOwnProperty,
        i,

        YEAR = 0,
        MONTH = 1,
        DATE = 2,
        HOUR = 3,
        MINUTE = 4,
        SECOND = 5,
        MILLISECOND = 6,

        // internal storage for locale config files
        locales = {},

        // extra moment internal properties (plugins register props here)
        momentProperties = [],

        // check for nodeJS
        hasModule = (typeof module !== 'undefined' && module && module.exports),

        // ASP.NET json date format regex
        aspNetJsonRegex = /^\/?Date\((\-?\d+)/i,
        aspNetTimeSpanJsonRegex = /(\-)?(?:(\d*)\.)?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/,

        // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
        // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
        isoDurationRegex = /^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/,

        // format tokens
        formattingTokens = /(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Q|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,4}|x|X|zz?|ZZ?|.)/g,
        localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,

        // parsing token regexes
        parseTokenOneOrTwoDigits = /\d\d?/, // 0 - 99
        parseTokenOneToThreeDigits = /\d{1,3}/, // 0 - 999
        parseTokenOneToFourDigits = /\d{1,4}/, // 0 - 9999
        parseTokenOneToSixDigits = /[+\-]?\d{1,6}/, // -999,999 - 999,999
        parseTokenDigits = /\d+/, // nonzero number of digits
        parseTokenWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i, // any word (or two) characters or numbers including two/three word month in arabic.
        parseTokenTimezone = /Z|[\+\-]\d\d:?\d\d/gi, // +00:00 -00:00 +0000 -0000 or Z
        parseTokenT = /T/i, // T (ISO separator)
        parseTokenOffsetMs = /[\+\-]?\d+/, // 1234567890123
        parseTokenTimestampMs = /[\+\-]?\d+(\.\d{1,3})?/, // 123456789 123456789.123

        //strict parsing regexes
        parseTokenOneDigit = /\d/, // 0 - 9
        parseTokenTwoDigits = /\d\d/, // 00 - 99
        parseTokenThreeDigits = /\d{3}/, // 000 - 999
        parseTokenFourDigits = /\d{4}/, // 0000 - 9999
        parseTokenSixDigits = /[+-]?\d{6}/, // -999,999 - 999,999
        parseTokenSignedNumber = /[+-]?\d+/, // -inf - inf

        // iso 8601 regex
        // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
        isoRegex = /^\s*(?:[+-]\d{6}|\d{4})-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,

        isoFormat = 'YYYY-MM-DDTHH:mm:ssZ',

        isoDates = [
            ['YYYYYY-MM-DD', /[+-]\d{6}-\d{2}-\d{2}/],
            ['YYYY-MM-DD', /\d{4}-\d{2}-\d{2}/],
            ['GGGG-[W]WW-E', /\d{4}-W\d{2}-\d/],
            ['GGGG-[W]WW', /\d{4}-W\d{2}/],
            ['YYYY-DDD', /\d{4}-\d{3}/]
        ],

        // iso time formats and regexes
        isoTimes = [
            ['HH:mm:ss.SSSS', /(T| )\d\d:\d\d:\d\d\.\d+/],
            ['HH:mm:ss', /(T| )\d\d:\d\d:\d\d/],
            ['HH:mm', /(T| )\d\d:\d\d/],
            ['HH', /(T| )\d\d/]
        ],

        // timezone chunker '+10:00' > ['10', '00'] or '-1530' > ['-15', '30']
        parseTimezoneChunker = /([\+\-]|\d\d)/gi,

        // getter and setter names
        proxyGettersAndSetters = 'Date|Hours|Minutes|Seconds|Milliseconds'.split('|'),
        unitMillisecondFactors = {
            'Milliseconds' : 1,
            'Seconds' : 1e3,
            'Minutes' : 6e4,
            'Hours' : 36e5,
            'Days' : 864e5,
            'Months' : 2592e6,
            'Years' : 31536e6
        },

        unitAliases = {
            ms : 'millisecond',
            s : 'second',
            m : 'minute',
            h : 'hour',
            d : 'day',
            D : 'date',
            w : 'week',
            W : 'isoWeek',
            M : 'month',
            Q : 'quarter',
            y : 'year',
            DDD : 'dayOfYear',
            e : 'weekday',
            E : 'isoWeekday',
            gg: 'weekYear',
            GG: 'isoWeekYear'
        },

        camelFunctions = {
            dayofyear : 'dayOfYear',
            isoweekday : 'isoWeekday',
            isoweek : 'isoWeek',
            weekyear : 'weekYear',
            isoweekyear : 'isoWeekYear'
        },

        // format function strings
        formatFunctions = {},

        // default relative time thresholds
        relativeTimeThresholds = {
            s: 45,  // seconds to minute
            m: 45,  // minutes to hour
            h: 22,  // hours to day
            d: 26,  // days to month
            M: 11   // months to year
        },

        // tokens to ordinalize and pad
        ordinalizeTokens = 'DDD w W M D d'.split(' '),
        paddedTokens = 'M D H h m s w W'.split(' '),

        formatTokenFunctions = {
            M    : function () {
                return this.month() + 1;
            },
            MMM  : function (format) {
                return this.localeData().monthsShort(this, format);
            },
            MMMM : function (format) {
                return this.localeData().months(this, format);
            },
            D    : function () {
                return this.date();
            },
            DDD  : function () {
                return this.dayOfYear();
            },
            d    : function () {
                return this.day();
            },
            dd   : function (format) {
                return this.localeData().weekdaysMin(this, format);
            },
            ddd  : function (format) {
                return this.localeData().weekdaysShort(this, format);
            },
            dddd : function (format) {
                return this.localeData().weekdays(this, format);
            },
            w    : function () {
                return this.week();
            },
            W    : function () {
                return this.isoWeek();
            },
            YY   : function () {
                return leftZeroFill(this.year() % 100, 2);
            },
            YYYY : function () {
                return leftZeroFill(this.year(), 4);
            },
            YYYYY : function () {
                return leftZeroFill(this.year(), 5);
            },
            YYYYYY : function () {
                var y = this.year(), sign = y >= 0 ? '+' : '-';
                return sign + leftZeroFill(Math.abs(y), 6);
            },
            gg   : function () {
                return leftZeroFill(this.weekYear() % 100, 2);
            },
            gggg : function () {
                return leftZeroFill(this.weekYear(), 4);
            },
            ggggg : function () {
                return leftZeroFill(this.weekYear(), 5);
            },
            GG   : function () {
                return leftZeroFill(this.isoWeekYear() % 100, 2);
            },
            GGGG : function () {
                return leftZeroFill(this.isoWeekYear(), 4);
            },
            GGGGG : function () {
                return leftZeroFill(this.isoWeekYear(), 5);
            },
            e : function () {
                return this.weekday();
            },
            E : function () {
                return this.isoWeekday();
            },
            a    : function () {
                return this.localeData().meridiem(this.hours(), this.minutes(), true);
            },
            A    : function () {
                return this.localeData().meridiem(this.hours(), this.minutes(), false);
            },
            H    : function () {
                return this.hours();
            },
            h    : function () {
                return this.hours() % 12 || 12;
            },
            m    : function () {
                return this.minutes();
            },
            s    : function () {
                return this.seconds();
            },
            S    : function () {
                return toInt(this.milliseconds() / 100);
            },
            SS   : function () {
                return leftZeroFill(toInt(this.milliseconds() / 10), 2);
            },
            SSS  : function () {
                return leftZeroFill(this.milliseconds(), 3);
            },
            SSSS : function () {
                return leftZeroFill(this.milliseconds(), 3);
            },
            Z    : function () {
                var a = -this.zone(),
                    b = '+';
                if (a < 0) {
                    a = -a;
                    b = '-';
                }
                return b + leftZeroFill(toInt(a / 60), 2) + ':' + leftZeroFill(toInt(a) % 60, 2);
            },
            ZZ   : function () {
                var a = -this.zone(),
                    b = '+';
                if (a < 0) {
                    a = -a;
                    b = '-';
                }
                return b + leftZeroFill(toInt(a / 60), 2) + leftZeroFill(toInt(a) % 60, 2);
            },
            z : function () {
                return this.zoneAbbr();
            },
            zz : function () {
                return this.zoneName();
            },
            x    : function () {
                return this.valueOf();
            },
            X    : function () {
                return this.unix();
            },
            Q : function () {
                return this.quarter();
            }
        },

        deprecations = {},

        lists = ['months', 'monthsShort', 'weekdays', 'weekdaysShort', 'weekdaysMin'];

    // Pick the first defined of two or three arguments. dfl comes from
    // default.
    function dfl(a, b, c) {
        switch (arguments.length) {
            case 2: return a != null ? a : b;
            case 3: return a != null ? a : b != null ? b : c;
            default: throw new Error('Implement me');
        }
    }

    function hasOwnProp(a, b) {
        return hasOwnProperty.call(a, b);
    }

    function defaultParsingFlags() {
        // We need to deep clone this object, and es5 standard is not very
        // helpful.
        return {
            empty : false,
            unusedTokens : [],
            unusedInput : [],
            overflow : -2,
            charsLeftOver : 0,
            nullInput : false,
            invalidMonth : null,
            invalidFormat : false,
            userInvalidated : false,
            iso: false
        };
    }

    function printMsg(msg) {
        if (moment.suppressDeprecationWarnings === false &&
                typeof console !== 'undefined' && console.warn) {
            console.warn('Deprecation warning: ' + msg);
        }
    }

    function deprecate(msg, fn) {
        var firstTime = true;
        return extend(function () {
            if (firstTime) {
                printMsg(msg);
                firstTime = false;
            }
            return fn.apply(this, arguments);
        }, fn);
    }

    function deprecateSimple(name, msg) {
        if (!deprecations[name]) {
            printMsg(msg);
            deprecations[name] = true;
        }
    }

    function padToken(func, count) {
        return function (a) {
            return leftZeroFill(func.call(this, a), count);
        };
    }
    function ordinalizeToken(func, period) {
        return function (a) {
            return this.localeData().ordinal(func.call(this, a), period);
        };
    }

    while (ordinalizeTokens.length) {
        i = ordinalizeTokens.pop();
        formatTokenFunctions[i + 'o'] = ordinalizeToken(formatTokenFunctions[i], i);
    }
    while (paddedTokens.length) {
        i = paddedTokens.pop();
        formatTokenFunctions[i + i] = padToken(formatTokenFunctions[i], 2);
    }
    formatTokenFunctions.DDDD = padToken(formatTokenFunctions.DDD, 3);


    /************************************
        Constructors
    ************************************/

    function Locale() {
    }

    // Moment prototype object
    function Moment(config, skipOverflow) {
        if (skipOverflow !== false) {
            checkOverflow(config);
        }
        copyConfig(this, config);
        this._d = new Date(+config._d);
    }

    // Duration Constructor
    function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            quarters = normalizedInput.quarter || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;

        // representation for dateAddRemove
        this._milliseconds = +milliseconds +
            seconds * 1e3 + // 1000
            minutes * 6e4 + // 1000 * 60
            hours * 36e5; // 1000 * 60 * 60
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately
        this._days = +days +
            weeks * 7;
        // It is impossible translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.
        this._months = +months +
            quarters * 3 +
            years * 12;

        this._data = {};

        this._locale = moment.localeData();

        this._bubble();
    }

    /************************************
        Helpers
    ************************************/


    function extend(a, b) {
        for (var i in b) {
            if (hasOwnProp(b, i)) {
                a[i] = b[i];
            }
        }

        if (hasOwnProp(b, 'toString')) {
            a.toString = b.toString;
        }

        if (hasOwnProp(b, 'valueOf')) {
            a.valueOf = b.valueOf;
        }

        return a;
    }

    function copyConfig(to, from) {
        var i, prop, val;

        if (typeof from._isAMomentObject !== 'undefined') {
            to._isAMomentObject = from._isAMomentObject;
        }
        if (typeof from._i !== 'undefined') {
            to._i = from._i;
        }
        if (typeof from._f !== 'undefined') {
            to._f = from._f;
        }
        if (typeof from._l !== 'undefined') {
            to._l = from._l;
        }
        if (typeof from._strict !== 'undefined') {
            to._strict = from._strict;
        }
        if (typeof from._tzm !== 'undefined') {
            to._tzm = from._tzm;
        }
        if (typeof from._isUTC !== 'undefined') {
            to._isUTC = from._isUTC;
        }
        if (typeof from._offset !== 'undefined') {
            to._offset = from._offset;
        }
        if (typeof from._pf !== 'undefined') {
            to._pf = from._pf;
        }
        if (typeof from._locale !== 'undefined') {
            to._locale = from._locale;
        }

        if (momentProperties.length > 0) {
            for (i in momentProperties) {
                prop = momentProperties[i];
                val = from[prop];
                if (typeof val !== 'undefined') {
                    to[prop] = val;
                }
            }
        }

        return to;
    }

    function absRound(number) {
        if (number < 0) {
            return Math.ceil(number);
        } else {
            return Math.floor(number);
        }
    }

    // left zero fill a number
    // see http://jsperf.com/left-zero-filling for performance comparison
    function leftZeroFill(number, targetLength, forceSign) {
        var output = '' + Math.abs(number),
            sign = number >= 0;

        while (output.length < targetLength) {
            output = '0' + output;
        }
        return (sign ? (forceSign ? '+' : '') : '-') + output;
    }

    function positiveMomentsDifference(base, other) {
        var res = {milliseconds: 0, months: 0};

        res.months = other.month() - base.month() +
            (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, 'M').isAfter(other)) {
            --res.months;
        }

        res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

        return res;
    }

    function momentsDifference(base, other) {
        var res;
        other = makeAs(other, base);
        if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
        } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
        }

        return res;
    }

    // TODO: remove 'name' arg after deprecation is removed
    function createAdder(direction, name) {
        return function (val, period) {
            var dur, tmp;
            //invert the arguments, but complain about it
            if (period !== null && !isNaN(+period)) {
                deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period).');
                tmp = val; val = period; period = tmp;
            }

            val = typeof val === 'string' ? +val : val;
            dur = moment.duration(val, period);
            addOrSubtractDurationFromMoment(this, dur, direction);
            return this;
        };
    }

    function addOrSubtractDurationFromMoment(mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds,
            days = duration._days,
            months = duration._months;
        updateOffset = updateOffset == null ? true : updateOffset;

        if (milliseconds) {
            mom._d.setTime(+mom._d + milliseconds * isAdding);
        }
        if (days) {
            rawSetter(mom, 'Date', rawGetter(mom, 'Date') + days * isAdding);
        }
        if (months) {
            rawMonthSetter(mom, rawGetter(mom, 'Month') + months * isAdding);
        }
        if (updateOffset) {
            moment.updateOffset(mom, days || months);
        }
    }

    // check if is an array
    function isArray(input) {
        return Object.prototype.toString.call(input) === '[object Array]';
    }

    function isDate(input) {
        return Object.prototype.toString.call(input) === '[object Date]' ||
            input instanceof Date;
    }

    // compare two arrays, return the number of differences
    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
        for (i = 0; i < len; i++) {
            if ((dontConvert && array1[i] !== array2[i]) ||
                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }

    function normalizeUnits(units) {
        if (units) {
            var lowered = units.toLowerCase().replace(/(.)s$/, '$1');
            units = unitAliases[units] || camelFunctions[lowered] || lowered;
        }
        return units;
    }

    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {},
            normalizedProp,
            prop;

        for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }

        return normalizedInput;
    }

    function makeList(field) {
        var count, setter;

        if (field.indexOf('week') === 0) {
            count = 7;
            setter = 'day';
        }
        else if (field.indexOf('month') === 0) {
            count = 12;
            setter = 'month';
        }
        else {
            return;
        }

        moment[field] = function (format, index) {
            var i, getter,
                method = moment._locale[field],
                results = [];

            if (typeof format === 'number') {
                index = format;
                format = undefined;
            }

            getter = function (i) {
                var m = moment().utc().set(setter, i);
                return method.call(moment._locale, m, format || '');
            };

            if (index != null) {
                return getter(index);
            }
            else {
                for (i = 0; i < count; i++) {
                    results.push(getter(i));
                }
                return results;
            }
        };
    }

    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion,
            value = 0;

        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            if (coercedNumber >= 0) {
                value = Math.floor(coercedNumber);
            } else {
                value = Math.ceil(coercedNumber);
            }
        }

        return value;
    }

    function daysInMonth(year, month) {
        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
    }

    function weeksInYear(year, dow, doy) {
        return weekOfYear(moment([year, 11, 31 + dow - doy]), dow, doy).week;
    }

    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }

    function isLeapYear(year) {
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    }

    function checkOverflow(m) {
        var overflow;
        if (m._a && m._pf.overflow === -2) {
            overflow =
                m._a[MONTH] < 0 || m._a[MONTH] > 11 ? MONTH :
                m._a[DATE] < 1 || m._a[DATE] > daysInMonth(m._a[YEAR], m._a[MONTH]) ? DATE :
                m._a[HOUR] < 0 || m._a[HOUR] > 24 ||
                    (m._a[HOUR] === 24 && (m._a[MINUTE] !== 0 ||
                                           m._a[SECOND] !== 0 ||
                                           m._a[MILLISECOND] !== 0)) ? HOUR :
                m._a[MINUTE] < 0 || m._a[MINUTE] > 59 ? MINUTE :
                m._a[SECOND] < 0 || m._a[SECOND] > 59 ? SECOND :
                m._a[MILLISECOND] < 0 || m._a[MILLISECOND] > 999 ? MILLISECOND :
                -1;

            if (m._pf._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                overflow = DATE;
            }

            m._pf.overflow = overflow;
        }
    }

    function isValid(m) {
        if (m._isValid == null) {
            m._isValid = !isNaN(m._d.getTime()) &&
                m._pf.overflow < 0 &&
                !m._pf.empty &&
                !m._pf.invalidMonth &&
                !m._pf.nullInput &&
                !m._pf.invalidFormat &&
                !m._pf.userInvalidated;

            if (m._strict) {
                m._isValid = m._isValid &&
                    m._pf.charsLeftOver === 0 &&
                    m._pf.unusedTokens.length === 0 &&
                    m._pf.bigHour === undefined;
            }
        }
        return m._isValid;
    }

    function normalizeLocale(key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
    }

    // pick the locale from the array
    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
    function chooseLocale(names) {
        var i = 0, j, next, locale, split;

        while (i < names.length) {
            split = normalizeLocale(names[i]).split('-');
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split('-') : null;
            while (j > 0) {
                locale = loadLocale(split.slice(0, j).join('-'));
                if (locale) {
                    return locale;
                }
                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                    //the next array item is better than a shallower substring of this one
                    break;
                }
                j--;
            }
            i++;
        }
        return null;
    }

    function loadLocale(name) {
        var oldLocale = null;
        if (!locales[name] && hasModule) {
            try {
                oldLocale = moment.locale();
                require('./locale/' + name);
                // because defineLocale currently also sets the global locale, we want to undo that for lazy loaded locales
                moment.locale(oldLocale);
            } catch (e) { }
        }
        return locales[name];
    }

    // Return a moment from input, that is local/utc/zone equivalent to model.
    function makeAs(input, model) {
        var res, diff;
        if (model._isUTC) {
            res = model.clone();
            diff = (moment.isMoment(input) || isDate(input) ?
                    +input : +moment(input)) - (+res);
            // Use low-level api, because this fn is low-level api.
            res._d.setTime(+res._d + diff);
            moment.updateOffset(res, false);
            return res;
        } else {
            return moment(input).local();
        }
    }

    /************************************
        Locale
    ************************************/


    extend(Locale.prototype, {

        set : function (config) {
            var prop, i;
            for (i in config) {
                prop = config[i];
                if (typeof prop === 'function') {
                    this[i] = prop;
                } else {
                    this['_' + i] = prop;
                }
            }
            // Lenient ordinal parsing accepts just a number in addition to
            // number + (possibly) stuff coming from _ordinalParseLenient.
            this._ordinalParseLenient = new RegExp(this._ordinalParse.source + '|' + /\d{1,2}/.source);
        },

        _months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
        months : function (m) {
            return this._months[m.month()];
        },

        _monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        monthsShort : function (m) {
            return this._monthsShort[m.month()];
        },

        monthsParse : function (monthName, format, strict) {
            var i, mom, regex;

            if (!this._monthsParse) {
                this._monthsParse = [];
                this._longMonthsParse = [];
                this._shortMonthsParse = [];
            }

            for (i = 0; i < 12; i++) {
                // make the regex if we don't have it already
                mom = moment.utc([2000, i]);
                if (strict && !this._longMonthsParse[i]) {
                    this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
                    this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
                }
                if (!strict && !this._monthsParse[i]) {
                    regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                    this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
                }
                // test the regex
                if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
                    return i;
                } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
                    return i;
                } else if (!strict && this._monthsParse[i].test(monthName)) {
                    return i;
                }
            }
        },

        _weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
        weekdays : function (m) {
            return this._weekdays[m.day()];
        },

        _weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        weekdaysShort : function (m) {
            return this._weekdaysShort[m.day()];
        },

        _weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        weekdaysMin : function (m) {
            return this._weekdaysMin[m.day()];
        },

        weekdaysParse : function (weekdayName) {
            var i, mom, regex;

            if (!this._weekdaysParse) {
                this._weekdaysParse = [];
            }

            for (i = 0; i < 7; i++) {
                // make the regex if we don't have it already
                if (!this._weekdaysParse[i]) {
                    mom = moment([2000, 1]).day(i);
                    regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
                    this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
                }
                // test the regex
                if (this._weekdaysParse[i].test(weekdayName)) {
                    return i;
                }
            }
        },

        _longDateFormat : {
            LTS : 'h:mm:ss A',
            LT : 'h:mm A',
            L : 'MM/DD/YYYY',
            LL : 'MMMM D, YYYY',
            LLL : 'MMMM D, YYYY LT',
            LLLL : 'dddd, MMMM D, YYYY LT'
        },
        longDateFormat : function (key) {
            var output = this._longDateFormat[key];
            if (!output && this._longDateFormat[key.toUpperCase()]) {
                output = this._longDateFormat[key.toUpperCase()].replace(/MMMM|MM|DD|dddd/g, function (val) {
                    return val.slice(1);
                });
                this._longDateFormat[key] = output;
            }
            return output;
        },

        isPM : function (input) {
            // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
            // Using charAt should be more compatible.
            return ((input + '').toLowerCase().charAt(0) === 'p');
        },

        _meridiemParse : /[ap]\.?m?\.?/i,
        meridiem : function (hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? 'pm' : 'PM';
            } else {
                return isLower ? 'am' : 'AM';
            }
        },

        _calendar : {
            sameDay : '[Today at] LT',
            nextDay : '[Tomorrow at] LT',
            nextWeek : 'dddd [at] LT',
            lastDay : '[Yesterday at] LT',
            lastWeek : '[Last] dddd [at] LT',
            sameElse : 'L'
        },
        calendar : function (key, mom, now) {
            var output = this._calendar[key];
            return typeof output === 'function' ? output.apply(mom, [now]) : output;
        },

        _relativeTime : {
            future : 'in %s',
            past : '%s ago',
            s : 'a few seconds',
            m : 'a minute',
            mm : '%d minutes',
            h : 'an hour',
            hh : '%d hours',
            d : 'a day',
            dd : '%d days',
            M : 'a month',
            MM : '%d months',
            y : 'a year',
            yy : '%d years'
        },

        relativeTime : function (number, withoutSuffix, string, isFuture) {
            var output = this._relativeTime[string];
            return (typeof output === 'function') ?
                output(number, withoutSuffix, string, isFuture) :
                output.replace(/%d/i, number);
        },

        pastFuture : function (diff, output) {
            var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
            return typeof format === 'function' ? format(output) : format.replace(/%s/i, output);
        },

        ordinal : function (number) {
            return this._ordinal.replace('%d', number);
        },
        _ordinal : '%d',
        _ordinalParse : /\d{1,2}/,

        preparse : function (string) {
            return string;
        },

        postformat : function (string) {
            return string;
        },

        week : function (mom) {
            return weekOfYear(mom, this._week.dow, this._week.doy).week;
        },

        _week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 1st is the first week of the year.
        },

        _invalidDate: 'Invalid date',
        invalidDate: function () {
            return this._invalidDate;
        }
    });

    /************************************
        Formatting
    ************************************/


    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, '');
        }
        return input.replace(/\\/g, '');
    }

    function makeFormatFunction(format) {
        var array = format.match(formattingTokens), i, length;

        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }

        return function (mom) {
            var output = '';
            for (i = 0; i < length; i++) {
                output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
            }
            return output;
        };
    }

    // format date using native date object
    function formatMoment(m, format) {
        if (!m.isValid()) {
            return m.localeData().invalidDate();
        }

        format = expandFormat(format, m.localeData());

        if (!formatFunctions[format]) {
            formatFunctions[format] = makeFormatFunction(format);
        }

        return formatFunctions[format](m);
    }

    function expandFormat(format, locale) {
        var i = 5;

        function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) || input;
        }

        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }

        return format;
    }


    /************************************
        Parsing
    ************************************/


    // get the regex to find the next token
    function getParseRegexForToken(token, config) {
        var a, strict = config._strict;
        switch (token) {
        case 'Q':
            return parseTokenOneDigit;
        case 'DDDD':
            return parseTokenThreeDigits;
        case 'YYYY':
        case 'GGGG':
        case 'gggg':
            return strict ? parseTokenFourDigits : parseTokenOneToFourDigits;
        case 'Y':
        case 'G':
        case 'g':
            return parseTokenSignedNumber;
        case 'YYYYYY':
        case 'YYYYY':
        case 'GGGGG':
        case 'ggggg':
            return strict ? parseTokenSixDigits : parseTokenOneToSixDigits;
        case 'S':
            if (strict) {
                return parseTokenOneDigit;
            }
            /* falls through */
        case 'SS':
            if (strict) {
                return parseTokenTwoDigits;
            }
            /* falls through */
        case 'SSS':
            if (strict) {
                return parseTokenThreeDigits;
            }
            /* falls through */
        case 'DDD':
            return parseTokenOneToThreeDigits;
        case 'MMM':
        case 'MMMM':
        case 'dd':
        case 'ddd':
        case 'dddd':
            return parseTokenWord;
        case 'a':
        case 'A':
            return config._locale._meridiemParse;
        case 'x':
            return parseTokenOffsetMs;
        case 'X':
            return parseTokenTimestampMs;
        case 'Z':
        case 'ZZ':
            return parseTokenTimezone;
        case 'T':
            return parseTokenT;
        case 'SSSS':
            return parseTokenDigits;
        case 'MM':
        case 'DD':
        case 'YY':
        case 'GG':
        case 'gg':
        case 'HH':
        case 'hh':
        case 'mm':
        case 'ss':
        case 'ww':
        case 'WW':
            return strict ? parseTokenTwoDigits : parseTokenOneOrTwoDigits;
        case 'M':
        case 'D':
        case 'd':
        case 'H':
        case 'h':
        case 'm':
        case 's':
        case 'w':
        case 'W':
        case 'e':
        case 'E':
            return parseTokenOneOrTwoDigits;
        case 'Do':
            return strict ? config._locale._ordinalParse : config._locale._ordinalParseLenient;
        default :
            a = new RegExp(regexpEscape(unescapeFormat(token.replace('\\', '')), 'i'));
            return a;
        }
    }

    function timezoneMinutesFromString(string) {
        string = string || '';
        var possibleTzMatches = (string.match(parseTokenTimezone) || []),
            tzChunk = possibleTzMatches[possibleTzMatches.length - 1] || [],
            parts = (tzChunk + '').match(parseTimezoneChunker) || ['-', 0, 0],
            minutes = +(parts[1] * 60) + toInt(parts[2]);

        return parts[0] === '+' ? -minutes : minutes;
    }

    // function to convert string input to date
    function addTimeToArrayFromToken(token, input, config) {
        var a, datePartArray = config._a;

        switch (token) {
        // QUARTER
        case 'Q':
            if (input != null) {
                datePartArray[MONTH] = (toInt(input) - 1) * 3;
            }
            break;
        // MONTH
        case 'M' : // fall through to MM
        case 'MM' :
            if (input != null) {
                datePartArray[MONTH] = toInt(input) - 1;
            }
            break;
        case 'MMM' : // fall through to MMMM
        case 'MMMM' :
            a = config._locale.monthsParse(input, token, config._strict);
            // if we didn't find a month name, mark the date as invalid.
            if (a != null) {
                datePartArray[MONTH] = a;
            } else {
                config._pf.invalidMonth = input;
            }
            break;
        // DAY OF MONTH
        case 'D' : // fall through to DD
        case 'DD' :
            if (input != null) {
                datePartArray[DATE] = toInt(input);
            }
            break;
        case 'Do' :
            if (input != null) {
                datePartArray[DATE] = toInt(parseInt(
                            input.match(/\d{1,2}/)[0], 10));
            }
            break;
        // DAY OF YEAR
        case 'DDD' : // fall through to DDDD
        case 'DDDD' :
            if (input != null) {
                config._dayOfYear = toInt(input);
            }

            break;
        // YEAR
        case 'YY' :
            datePartArray[YEAR] = moment.parseTwoDigitYear(input);
            break;
        case 'YYYY' :
        case 'YYYYY' :
        case 'YYYYYY' :
            datePartArray[YEAR] = toInt(input);
            break;
        // AM / PM
        case 'a' : // fall through to A
        case 'A' :
            config._isPm = config._locale.isPM(input);
            break;
        // HOUR
        case 'h' : // fall through to hh
        case 'hh' :
            config._pf.bigHour = true;
            /* falls through */
        case 'H' : // fall through to HH
        case 'HH' :
            datePartArray[HOUR] = toInt(input);
            break;
        // MINUTE
        case 'm' : // fall through to mm
        case 'mm' :
            datePartArray[MINUTE] = toInt(input);
            break;
        // SECOND
        case 's' : // fall through to ss
        case 'ss' :
            datePartArray[SECOND] = toInt(input);
            break;
        // MILLISECOND
        case 'S' :
        case 'SS' :
        case 'SSS' :
        case 'SSSS' :
            datePartArray[MILLISECOND] = toInt(('0.' + input) * 1000);
            break;
        // UNIX OFFSET (MILLISECONDS)
        case 'x':
            config._d = new Date(toInt(input));
            break;
        // UNIX TIMESTAMP WITH MS
        case 'X':
            config._d = new Date(parseFloat(input) * 1000);
            break;
        // TIMEZONE
        case 'Z' : // fall through to ZZ
        case 'ZZ' :
            config._useUTC = true;
            config._tzm = timezoneMinutesFromString(input);
            break;
        // WEEKDAY - human
        case 'dd':
        case 'ddd':
        case 'dddd':
            a = config._locale.weekdaysParse(input);
            // if we didn't get a weekday name, mark the date as invalid
            if (a != null) {
                config._w = config._w || {};
                config._w['d'] = a;
            } else {
                config._pf.invalidWeekday = input;
            }
            break;
        // WEEK, WEEK DAY - numeric
        case 'w':
        case 'ww':
        case 'W':
        case 'WW':
        case 'd':
        case 'e':
        case 'E':
            token = token.substr(0, 1);
            /* falls through */
        case 'gggg':
        case 'GGGG':
        case 'GGGGG':
            token = token.substr(0, 2);
            if (input) {
                config._w = config._w || {};
                config._w[token] = toInt(input);
            }
            break;
        case 'gg':
        case 'GG':
            config._w = config._w || {};
            config._w[token] = moment.parseTwoDigitYear(input);
        }
    }

    function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp;

        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;

            // TODO: We need to take the current isoWeekYear, but that depends on
            // how we interpret now (local, utc, fixed offset). So create
            // a now version of current config (take local/utc/offset flags, and
            // create now).
            weekYear = dfl(w.GG, config._a[YEAR], weekOfYear(moment(), 1, 4).year);
            week = dfl(w.W, 1);
            weekday = dfl(w.E, 1);
        } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;

            weekYear = dfl(w.gg, config._a[YEAR], weekOfYear(moment(), dow, doy).year);
            week = dfl(w.w, 1);

            if (w.d != null) {
                // weekday -- low day numbers are considered next week
                weekday = w.d;
                if (weekday < dow) {
                    ++week;
                }
            } else if (w.e != null) {
                // local weekday -- counting starts from begining of week
                weekday = w.e + dow;
            } else {
                // default to begining of week
                weekday = dow;
            }
        }
        temp = dayOfYearFromWeeks(weekYear, week, weekday, doy, dow);

        config._a[YEAR] = temp.year;
        config._dayOfYear = temp.dayOfYear;
    }

    // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]
    function dateFromConfig(config) {
        var i, date, input = [], currentDate, yearToUse;

        if (config._d) {
            return;
        }

        currentDate = currentDateArray(config);

        //compute day of the year from weeks and weekdays
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
        }

        //if the day of the year is set, figure out what it is
        if (config._dayOfYear) {
            yearToUse = dfl(config._a[YEAR], currentDate[YEAR]);

            if (config._dayOfYear > daysInYear(yearToUse)) {
                config._pf._overflowDayOfYear = true;
            }

            date = makeUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }

        // Default to current date.
        // * if no year, month, day of month are given, default to today
        // * if day of month is given, default month and year
        // * if month is given, default only year
        // * if year is given, don't default anything
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }

        // Zero out whatever was not defaulted, including time
        for (; i < 7; i++) {
            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
        }

        // Check for 24:00:00.000
        if (config._a[HOUR] === 24 &&
                config._a[MINUTE] === 0 &&
                config._a[SECOND] === 0 &&
                config._a[MILLISECOND] === 0) {
            config._nextDay = true;
            config._a[HOUR] = 0;
        }

        config._d = (config._useUTC ? makeUTCDate : makeDate).apply(null, input);
        // Apply timezone offset from input. The actual zone can be changed
        // with parseZone.
        if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() + config._tzm);
        }

        if (config._nextDay) {
            config._a[HOUR] = 24;
        }
    }

    function dateFromObject(config) {
        var normalizedInput;

        if (config._d) {
            return;
        }

        normalizedInput = normalizeObjectUnits(config._i);
        config._a = [
            normalizedInput.year,
            normalizedInput.month,
            normalizedInput.day || normalizedInput.date,
            normalizedInput.hour,
            normalizedInput.minute,
            normalizedInput.second,
            normalizedInput.millisecond
        ];

        dateFromConfig(config);
    }

    function currentDateArray(config) {
        var now = new Date();
        if (config._useUTC) {
            return [
                now.getUTCFullYear(),
                now.getUTCMonth(),
                now.getUTCDate()
            ];
        } else {
            return [now.getFullYear(), now.getMonth(), now.getDate()];
        }
    }

    // date from string and format string
    function makeDateFromStringAndFormat(config) {
        if (config._f === moment.ISO_8601) {
            parseISO(config);
            return;
        }

        config._a = [];
        config._pf.empty = true;

        // This array is used to make a Date, either with `new Date` or `Date.UTC`
        var string = '' + config._i,
            i, parsedInput, tokens, token, skipped,
            stringLength = string.length,
            totalParsedInputLength = 0;

        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    config._pf.unusedInput.push(skipped);
                }
                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                totalParsedInputLength += parsedInput.length;
            }
            // don't parse if it's not a known token
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    config._pf.empty = false;
                }
                else {
                    config._pf.unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            }
            else if (config._strict && !parsedInput) {
                config._pf.unusedTokens.push(token);
            }
        }

        // add remaining unparsed input length to the string
        config._pf.charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
            config._pf.unusedInput.push(string);
        }

        // clear _12h flag if hour is <= 12
        if (config._pf.bigHour === true && config._a[HOUR] <= 12) {
            config._pf.bigHour = undefined;
        }
        // handle am pm
        if (config._isPm && config._a[HOUR] < 12) {
            config._a[HOUR] += 12;
        }
        // if is 12 am, change hours to 0
        if (config._isPm === false && config._a[HOUR] === 12) {
            config._a[HOUR] = 0;
        }
        dateFromConfig(config);
        checkOverflow(config);
    }

    function unescapeFormat(s) {
        return s.replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
        });
    }

    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
    function regexpEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    // date from string and array of format strings
    function makeDateFromStringAndArray(config) {
        var tempConfig,
            bestMoment,

            scoreToBeat,
            i,
            currentScore;

        if (config._f.length === 0) {
            config._pf.invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }

        for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) {
                tempConfig._useUTC = config._useUTC;
            }
            tempConfig._pf = defaultParsingFlags();
            tempConfig._f = config._f[i];
            makeDateFromStringAndFormat(tempConfig);

            if (!isValid(tempConfig)) {
                continue;
            }

            // if there is any input that was not parsed add a penalty for that format
            currentScore += tempConfig._pf.charsLeftOver;

            //or tokens
            currentScore += tempConfig._pf.unusedTokens.length * 10;

            tempConfig._pf.score = currentScore;

            if (scoreToBeat == null || currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
            }
        }

        extend(config, bestMoment || tempConfig);
    }

    // date from iso format
    function parseISO(config) {
        var i, l,
            string = config._i,
            match = isoRegex.exec(string);

        if (match) {
            config._pf.iso = true;
            for (i = 0, l = isoDates.length; i < l; i++) {
                if (isoDates[i][1].exec(string)) {
                    // match[5] should be 'T' or undefined
                    config._f = isoDates[i][0] + (match[6] || ' ');
                    break;
                }
            }
            for (i = 0, l = isoTimes.length; i < l; i++) {
                if (isoTimes[i][1].exec(string)) {
                    config._f += isoTimes[i][0];
                    break;
                }
            }
            if (string.match(parseTokenTimezone)) {
                config._f += 'Z';
            }
            makeDateFromStringAndFormat(config);
        } else {
            config._isValid = false;
        }
    }

    // date from iso format or fallback
    function makeDateFromString(config) {
        parseISO(config);
        if (config._isValid === false) {
            delete config._isValid;
            moment.createFromInputFallback(config);
        }
    }

    function map(arr, fn) {
        var res = [], i;
        for (i = 0; i < arr.length; ++i) {
            res.push(fn(arr[i], i));
        }
        return res;
    }

    function makeDateFromInput(config) {
        var input = config._i, matched;
        if (input === undefined) {
            config._d = new Date();
        } else if (isDate(input)) {
            config._d = new Date(+input);
        } else if ((matched = aspNetJsonRegex.exec(input)) !== null) {
            config._d = new Date(+matched[1]);
        } else if (typeof input === 'string') {
            makeDateFromString(config);
        } else if (isArray(input)) {
            config._a = map(input.slice(0), function (obj) {
                return parseInt(obj, 10);
            });
            dateFromConfig(config);
        } else if (typeof(input) === 'object') {
            dateFromObject(config);
        } else if (typeof(input) === 'number') {
            // from milliseconds
            config._d = new Date(input);
        } else {
            moment.createFromInputFallback(config);
        }
    }

    function makeDate(y, m, d, h, M, s, ms) {
        //can't just apply() to create a date:
        //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
        var date = new Date(y, m, d, h, M, s, ms);

        //the date constructor doesn't accept years < 1970
        if (y < 1970) {
            date.setFullYear(y);
        }
        return date;
    }

    function makeUTCDate(y) {
        var date = new Date(Date.UTC.apply(null, arguments));
        if (y < 1970) {
            date.setUTCFullYear(y);
        }
        return date;
    }

    function parseWeekday(input, locale) {
        if (typeof input === 'string') {
            if (!isNaN(input)) {
                input = parseInt(input, 10);
            }
            else {
                input = locale.weekdaysParse(input);
                if (typeof input !== 'number') {
                    return null;
                }
            }
        }
        return input;
    }

    /************************************
        Relative Time
    ************************************/


    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function relativeTime(posNegDuration, withoutSuffix, locale) {
        var duration = moment.duration(posNegDuration).abs(),
            seconds = round(duration.as('s')),
            minutes = round(duration.as('m')),
            hours = round(duration.as('h')),
            days = round(duration.as('d')),
            months = round(duration.as('M')),
            years = round(duration.as('y')),

            args = seconds < relativeTimeThresholds.s && ['s', seconds] ||
                minutes === 1 && ['m'] ||
                minutes < relativeTimeThresholds.m && ['mm', minutes] ||
                hours === 1 && ['h'] ||
                hours < relativeTimeThresholds.h && ['hh', hours] ||
                days === 1 && ['d'] ||
                days < relativeTimeThresholds.d && ['dd', days] ||
                months === 1 && ['M'] ||
                months < relativeTimeThresholds.M && ['MM', months] ||
                years === 1 && ['y'] || ['yy', years];

        args[2] = withoutSuffix;
        args[3] = +posNegDuration > 0;
        args[4] = locale;
        return substituteTimeAgo.apply({}, args);
    }


    /************************************
        Week of Year
    ************************************/


    // firstDayOfWeek       0 = sun, 6 = sat
    //                      the day of the week that starts the week
    //                      (usually sunday or monday)
    // firstDayOfWeekOfYear 0 = sun, 6 = sat
    //                      the first week is the week that contains the first
    //                      of this day of the week
    //                      (eg. ISO weeks use thursday (4))
    function weekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {
        var end = firstDayOfWeekOfYear - firstDayOfWeek,
            daysToDayOfWeek = firstDayOfWeekOfYear - mom.day(),
            adjustedMoment;


        if (daysToDayOfWeek > end) {
            daysToDayOfWeek -= 7;
        }

        if (daysToDayOfWeek < end - 7) {
            daysToDayOfWeek += 7;
        }

        adjustedMoment = moment(mom).add(daysToDayOfWeek, 'd');
        return {
            week: Math.ceil(adjustedMoment.dayOfYear() / 7),
            year: adjustedMoment.year()
        };
    }

    //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
    function dayOfYearFromWeeks(year, week, weekday, firstDayOfWeekOfYear, firstDayOfWeek) {
        var d = makeUTCDate(year, 0, 1).getUTCDay(), daysToAdd, dayOfYear;

        d = d === 0 ? 7 : d;
        weekday = weekday != null ? weekday : firstDayOfWeek;
        daysToAdd = firstDayOfWeek - d + (d > firstDayOfWeekOfYear ? 7 : 0) - (d < firstDayOfWeek ? 7 : 0);
        dayOfYear = 7 * (week - 1) + (weekday - firstDayOfWeek) + daysToAdd + 1;

        return {
            year: dayOfYear > 0 ? year : year - 1,
            dayOfYear: dayOfYear > 0 ?  dayOfYear : daysInYear(year - 1) + dayOfYear
        };
    }

    /************************************
        Top Level Functions
    ************************************/

    function makeMoment(config) {
        var input = config._i,
            format = config._f,
            res;

        config._locale = config._locale || moment.localeData(config._l);

        if (input === null || (format === undefined && input === '')) {
            return moment.invalid({nullInput: true});
        }

        if (typeof input === 'string') {
            config._i = input = config._locale.preparse(input);
        }

        if (moment.isMoment(input)) {
            return new Moment(input, true);
        } else if (format) {
            if (isArray(format)) {
                makeDateFromStringAndArray(config);
            } else {
                makeDateFromStringAndFormat(config);
            }
        } else {
            makeDateFromInput(config);
        }

        res = new Moment(config);
        if (res._nextDay) {
            // Adding is smart enough around DST
            res.add(1, 'd');
            res._nextDay = undefined;
        }

        return res;
    }

    moment = function (input, format, locale, strict) {
        var c;

        if (typeof(locale) === 'boolean') {
            strict = locale;
            locale = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c = {};
        c._isAMomentObject = true;
        c._i = input;
        c._f = format;
        c._l = locale;
        c._strict = strict;
        c._isUTC = false;
        c._pf = defaultParsingFlags();

        return makeMoment(c);
    };

    moment.suppressDeprecationWarnings = false;

    moment.createFromInputFallback = deprecate(
        'moment construction falls back to js Date. This is ' +
        'discouraged and will be removed in upcoming major ' +
        'release. Please refer to ' +
        'https://github.com/moment/moment/issues/1407 for more info.',
        function (config) {
            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
        }
    );

    // Pick a moment m from moments so that m[fn](other) is true for all
    // other. This relies on the function fn to be transitive.
    //
    // moments should either be an array of moment objects or an array, whose
    // first element is an array of moment objects.
    function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
            moments = moments[0];
        }
        if (!moments.length) {
            return moment();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
            if (moments[i][fn](res)) {
                res = moments[i];
            }
        }
        return res;
    }

    moment.min = function () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isBefore', args);
    };

    moment.max = function () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isAfter', args);
    };

    // creating with utc
    moment.utc = function (input, format, locale, strict) {
        var c;

        if (typeof(locale) === 'boolean') {
            strict = locale;
            locale = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c = {};
        c._isAMomentObject = true;
        c._useUTC = true;
        c._isUTC = true;
        c._l = locale;
        c._i = input;
        c._f = format;
        c._strict = strict;
        c._pf = defaultParsingFlags();

        return makeMoment(c).utc();
    };

    // creating with unix timestamp (in seconds)
    moment.unix = function (input) {
        return moment(input * 1000);
    };

    // duration
    moment.duration = function (input, key) {
        var duration = input,
            // matching against regexp is expensive, do it on demand
            match = null,
            sign,
            ret,
            parseIso,
            diffRes;

        if (moment.isDuration(input)) {
            duration = {
                ms: input._milliseconds,
                d: input._days,
                M: input._months
            };
        } else if (typeof input === 'number') {
            duration = {};
            if (key) {
                duration[key] = input;
            } else {
                duration.milliseconds = input;
            }
        } else if (!!(match = aspNetTimeSpanJsonRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y: 0,
                d: toInt(match[DATE]) * sign,
                h: toInt(match[HOUR]) * sign,
                m: toInt(match[MINUTE]) * sign,
                s: toInt(match[SECOND]) * sign,
                ms: toInt(match[MILLISECOND]) * sign
            };
        } else if (!!(match = isoDurationRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            parseIso = function (inp) {
                // We'd normally use ~~inp for this, but unfortunately it also
                // converts floats to ints.
                // inp may be undefined, so careful calling replace on it.
                var res = inp && parseFloat(inp.replace(',', '.'));
                // apply sign while we're at it
                return (isNaN(res) ? 0 : res) * sign;
            };
            duration = {
                y: parseIso(match[2]),
                M: parseIso(match[3]),
                d: parseIso(match[4]),
                h: parseIso(match[5]),
                m: parseIso(match[6]),
                s: parseIso(match[7]),
                w: parseIso(match[8])
            };
        } else if (typeof duration === 'object' &&
                ('from' in duration || 'to' in duration)) {
            diffRes = momentsDifference(moment(duration.from), moment(duration.to));

            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
        }

        ret = new Duration(duration);

        if (moment.isDuration(input) && hasOwnProp(input, '_locale')) {
            ret._locale = input._locale;
        }

        return ret;
    };

    // version number
    moment.version = VERSION;

    // default format
    moment.defaultFormat = isoFormat;

    // constant that refers to the ISO standard
    moment.ISO_8601 = function () {};

    // Plugins that add properties should also add the key here (null value),
    // so we can properly clone ourselves.
    moment.momentProperties = momentProperties;

    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.
    moment.updateOffset = function () {};

    // This function allows you to set a threshold for relative time strings
    moment.relativeTimeThreshold = function (threshold, limit) {
        if (relativeTimeThresholds[threshold] === undefined) {
            return false;
        }
        if (limit === undefined) {
            return relativeTimeThresholds[threshold];
        }
        relativeTimeThresholds[threshold] = limit;
        return true;
    };

    moment.lang = deprecate(
        'moment.lang is deprecated. Use moment.locale instead.',
        function (key, value) {
            return moment.locale(key, value);
        }
    );

    // This function will load locale and then set the global locale.  If
    // no arguments are passed in, it will simply return the current global
    // locale key.
    moment.locale = function (key, values) {
        var data;
        if (key) {
            if (typeof(values) !== 'undefined') {
                data = moment.defineLocale(key, values);
            }
            else {
                data = moment.localeData(key);
            }

            if (data) {
                moment.duration._locale = moment._locale = data;
            }
        }

        return moment._locale._abbr;
    };

    moment.defineLocale = function (name, values) {
        if (values !== null) {
            values.abbr = name;
            if (!locales[name]) {
                locales[name] = new Locale();
            }
            locales[name].set(values);

            // backwards compat for now: also set the locale
            moment.locale(name);

            return locales[name];
        } else {
            // useful for testing
            delete locales[name];
            return null;
        }
    };

    moment.langData = deprecate(
        'moment.langData is deprecated. Use moment.localeData instead.',
        function (key) {
            return moment.localeData(key);
        }
    );

    // returns locale data
    moment.localeData = function (key) {
        var locale;

        if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
        }

        if (!key) {
            return moment._locale;
        }

        if (!isArray(key)) {
            //short-circuit everything else
            locale = loadLocale(key);
            if (locale) {
                return locale;
            }
            key = [key];
        }

        return chooseLocale(key);
    };

    // compare moment object
    moment.isMoment = function (obj) {
        return obj instanceof Moment ||
            (obj != null && hasOwnProp(obj, '_isAMomentObject'));
    };

    // for typechecking Duration objects
    moment.isDuration = function (obj) {
        return obj instanceof Duration;
    };

    for (i = lists.length - 1; i >= 0; --i) {
        makeList(lists[i]);
    }

    moment.normalizeUnits = function (units) {
        return normalizeUnits(units);
    };

    moment.invalid = function (flags) {
        var m = moment.utc(NaN);
        if (flags != null) {
            extend(m._pf, flags);
        }
        else {
            m._pf.userInvalidated = true;
        }

        return m;
    };

    moment.parseZone = function () {
        return moment.apply(null, arguments).parseZone();
    };

    moment.parseTwoDigitYear = function (input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
    };

    /************************************
        Moment Prototype
    ************************************/


    extend(moment.fn = Moment.prototype, {

        clone : function () {
            return moment(this);
        },

        valueOf : function () {
            return +this._d + ((this._offset || 0) * 60000);
        },

        unix : function () {
            return Math.floor(+this / 1000);
        },

        toString : function () {
            return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
        },

        toDate : function () {
            return this._offset ? new Date(+this) : this._d;
        },

        toISOString : function () {
            var m = moment(this).utc();
            if (0 < m.year() && m.year() <= 9999) {
                if ('function' === typeof Date.prototype.toISOString) {
                    // native implementation is ~50x faster, use it when we can
                    return this.toDate().toISOString();
                } else {
                    return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
                }
            } else {
                return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
            }
        },

        toArray : function () {
            var m = this;
            return [
                m.year(),
                m.month(),
                m.date(),
                m.hours(),
                m.minutes(),
                m.seconds(),
                m.milliseconds()
            ];
        },

        isValid : function () {
            return isValid(this);
        },

        isDSTShifted : function () {
            if (this._a) {
                return this.isValid() && compareArrays(this._a, (this._isUTC ? moment.utc(this._a) : moment(this._a)).toArray()) > 0;
            }

            return false;
        },

        parsingFlags : function () {
            return extend({}, this._pf);
        },

        invalidAt: function () {
            return this._pf.overflow;
        },

        utc : function (keepLocalTime) {
            return this.zone(0, keepLocalTime);
        },

        local : function (keepLocalTime) {
            if (this._isUTC) {
                this.zone(0, keepLocalTime);
                this._isUTC = false;

                if (keepLocalTime) {
                    this.add(this._dateTzOffset(), 'm');
                }
            }
            return this;
        },

        format : function (inputString) {
            var output = formatMoment(this, inputString || moment.defaultFormat);
            return this.localeData().postformat(output);
        },

        add : createAdder(1, 'add'),

        subtract : createAdder(-1, 'subtract'),

        diff : function (input, units, asFloat) {
            var that = makeAs(input, this),
                zoneDiff = (this.zone() - that.zone()) * 6e4,
                diff, output, daysAdjust;

            units = normalizeUnits(units);

            if (units === 'year' || units === 'month') {
                // average number of days in the months in the given dates
                diff = (this.daysInMonth() + that.daysInMonth()) * 432e5; // 24 * 60 * 60 * 1000 / 2
                // difference in months
                output = ((this.year() - that.year()) * 12) + (this.month() - that.month());
                // adjust by taking difference in days, average number of days
                // and dst in the given months.
                daysAdjust = (this - moment(this).startOf('month')) -
                    (that - moment(that).startOf('month'));
                // same as above but with zones, to negate all dst
                daysAdjust -= ((this.zone() - moment(this).startOf('month').zone()) -
                        (that.zone() - moment(that).startOf('month').zone())) * 6e4;
                output += daysAdjust / diff;
                if (units === 'year') {
                    output = output / 12;
                }
            } else {
                diff = (this - that);
                output = units === 'second' ? diff / 1e3 : // 1000
                    units === 'minute' ? diff / 6e4 : // 1000 * 60
                    units === 'hour' ? diff / 36e5 : // 1000 * 60 * 60
                    units === 'day' ? (diff - zoneDiff) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
                    units === 'week' ? (diff - zoneDiff) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
                    diff;
            }
            return asFloat ? output : absRound(output);
        },

        from : function (time, withoutSuffix) {
            return moment.duration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
        },

        fromNow : function (withoutSuffix) {
            return this.from(moment(), withoutSuffix);
        },

        calendar : function (time) {
            // We want to compare the start of today, vs this.
            // Getting start-of-today depends on whether we're zone'd or not.
            var now = time || moment(),
                sod = makeAs(now, this).startOf('day'),
                diff = this.diff(sod, 'days', true),
                format = diff < -6 ? 'sameElse' :
                    diff < -1 ? 'lastWeek' :
                    diff < 0 ? 'lastDay' :
                    diff < 1 ? 'sameDay' :
                    diff < 2 ? 'nextDay' :
                    diff < 7 ? 'nextWeek' : 'sameElse';
            return this.format(this.localeData().calendar(format, this, moment(now)));
        },

        isLeapYear : function () {
            return isLeapYear(this.year());
        },

        isDST : function () {
            return (this.zone() < this.clone().month(0).zone() ||
                this.zone() < this.clone().month(5).zone());
        },

        day : function (input) {
            var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
            if (input != null) {
                input = parseWeekday(input, this.localeData());
                return this.add(input - day, 'd');
            } else {
                return day;
            }
        },

        month : makeAccessor('Month', true),

        startOf : function (units) {
            units = normalizeUnits(units);
            // the following switch intentionally omits break keywords
            // to utilize falling through the cases.
            switch (units) {
            case 'year':
                this.month(0);
                /* falls through */
            case 'quarter':
            case 'month':
                this.date(1);
                /* falls through */
            case 'week':
            case 'isoWeek':
            case 'day':
                this.hours(0);
                /* falls through */
            case 'hour':
                this.minutes(0);
                /* falls through */
            case 'minute':
                this.seconds(0);
                /* falls through */
            case 'second':
                this.milliseconds(0);
                /* falls through */
            }

            // weeks are a special case
            if (units === 'week') {
                this.weekday(0);
            } else if (units === 'isoWeek') {
                this.isoWeekday(1);
            }

            // quarters are also special
            if (units === 'quarter') {
                this.month(Math.floor(this.month() / 3) * 3);
            }

            return this;
        },

        endOf: function (units) {
            units = normalizeUnits(units);
            if (units === undefined || units === 'millisecond') {
                return this;
            }
            return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
        },

        isAfter: function (input, units) {
            var inputMs;
            units = normalizeUnits(typeof units !== 'undefined' ? units : 'millisecond');
            if (units === 'millisecond') {
                input = moment.isMoment(input) ? input : moment(input);
                return +this > +input;
            } else {
                inputMs = moment.isMoment(input) ? +input : +moment(input);
                return inputMs < +this.clone().startOf(units);
            }
        },

        isBefore: function (input, units) {
            var inputMs;
            units = normalizeUnits(typeof units !== 'undefined' ? units : 'millisecond');
            if (units === 'millisecond') {
                input = moment.isMoment(input) ? input : moment(input);
                return +this < +input;
            } else {
                inputMs = moment.isMoment(input) ? +input : +moment(input);
                return +this.clone().endOf(units) < inputMs;
            }
        },

        isSame: function (input, units) {
            var inputMs;
            units = normalizeUnits(units || 'millisecond');
            if (units === 'millisecond') {
                input = moment.isMoment(input) ? input : moment(input);
                return +this === +input;
            } else {
                inputMs = +moment(input);
                return +(this.clone().startOf(units)) <= inputMs && inputMs <= +(this.clone().endOf(units));
            }
        },

        min: deprecate(
                 'moment().min is deprecated, use moment.min instead. https://github.com/moment/moment/issues/1548',
                 function (other) {
                     other = moment.apply(null, arguments);
                     return other < this ? this : other;
                 }
         ),

        max: deprecate(
                'moment().max is deprecated, use moment.max instead. https://github.com/moment/moment/issues/1548',
                function (other) {
                    other = moment.apply(null, arguments);
                    return other > this ? this : other;
                }
        ),

        // keepLocalTime = true means only change the timezone, without
        // affecting the local hour. So 5:31:26 +0300 --[zone(2, true)]-->
        // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist int zone
        // +0200, so we adjust the time as needed, to be valid.
        //
        // Keeping the time actually adds/subtracts (one hour)
        // from the actual represented time. That is why we call updateOffset
        // a second time. In case it wants us to change the offset again
        // _changeInProgress == true case, then we have to adjust, because
        // there is no such time in the given timezone.
        zone : function (input, keepLocalTime) {
            var offset = this._offset || 0,
                localAdjust;
            if (input != null) {
                if (typeof input === 'string') {
                    input = timezoneMinutesFromString(input);
                }
                if (Math.abs(input) < 16) {
                    input = input * 60;
                }
                if (!this._isUTC && keepLocalTime) {
                    localAdjust = this._dateTzOffset();
                }
                this._offset = input;
                this._isUTC = true;
                if (localAdjust != null) {
                    this.subtract(localAdjust, 'm');
                }
                if (offset !== input) {
                    if (!keepLocalTime || this._changeInProgress) {
                        addOrSubtractDurationFromMoment(this,
                                moment.duration(offset - input, 'm'), 1, false);
                    } else if (!this._changeInProgress) {
                        this._changeInProgress = true;
                        moment.updateOffset(this, true);
                        this._changeInProgress = null;
                    }
                }
            } else {
                return this._isUTC ? offset : this._dateTzOffset();
            }
            return this;
        },

        zoneAbbr : function () {
            return this._isUTC ? 'UTC' : '';
        },

        zoneName : function () {
            return this._isUTC ? 'Coordinated Universal Time' : '';
        },

        parseZone : function () {
            if (this._tzm) {
                this.zone(this._tzm);
            } else if (typeof this._i === 'string') {
                this.zone(this._i);
            }
            return this;
        },

        hasAlignedHourOffset : function (input) {
            if (!input) {
                input = 0;
            }
            else {
                input = moment(input).zone();
            }

            return (this.zone() - input) % 60 === 0;
        },

        daysInMonth : function () {
            return daysInMonth(this.year(), this.month());
        },

        dayOfYear : function (input) {
            var dayOfYear = round((moment(this).startOf('day') - moment(this).startOf('year')) / 864e5) + 1;
            return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
        },

        quarter : function (input) {
            return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
        },

        weekYear : function (input) {
            var year = weekOfYear(this, this.localeData()._week.dow, this.localeData()._week.doy).year;
            return input == null ? year : this.add((input - year), 'y');
        },

        isoWeekYear : function (input) {
            var year = weekOfYear(this, 1, 4).year;
            return input == null ? year : this.add((input - year), 'y');
        },

        week : function (input) {
            var week = this.localeData().week(this);
            return input == null ? week : this.add((input - week) * 7, 'd');
        },

        isoWeek : function (input) {
            var week = weekOfYear(this, 1, 4).week;
            return input == null ? week : this.add((input - week) * 7, 'd');
        },

        weekday : function (input) {
            var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
            return input == null ? weekday : this.add(input - weekday, 'd');
        },

        isoWeekday : function (input) {
            // behaves the same as moment#day except
            // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
            // as a setter, sunday should belong to the previous week.
            return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);
        },

        isoWeeksInYear : function () {
            return weeksInYear(this.year(), 1, 4);
        },

        weeksInYear : function () {
            var weekInfo = this.localeData()._week;
            return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
        },

        get : function (units) {
            units = normalizeUnits(units);
            return this[units]();
        },

        set : function (units, value) {
            units = normalizeUnits(units);
            if (typeof this[units] === 'function') {
                this[units](value);
            }
            return this;
        },

        // If passed a locale key, it will set the locale for this
        // instance.  Otherwise, it will return the locale configuration
        // variables for this instance.
        locale : function (key) {
            var newLocaleData;

            if (key === undefined) {
                return this._locale._abbr;
            } else {
                newLocaleData = moment.localeData(key);
                if (newLocaleData != null) {
                    this._locale = newLocaleData;
                }
                return this;
            }
        },

        lang : deprecate(
            'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
            function (key) {
                if (key === undefined) {
                    return this.localeData();
                } else {
                    return this.locale(key);
                }
            }
        ),

        localeData : function () {
            return this._locale;
        },

        _dateTzOffset : function () {
            // On Firefox.24 Date#getTimezoneOffset returns a floating point.
            // https://github.com/moment/moment/pull/1871
            return Math.round(this._d.getTimezoneOffset() / 15) * 15;
        }
    });

    function rawMonthSetter(mom, value) {
        var dayOfMonth;

        // TODO: Move this out of here!
        if (typeof value === 'string') {
            value = mom.localeData().monthsParse(value);
            // TODO: Another silent failure?
            if (typeof value !== 'number') {
                return mom;
            }
        }

        dayOfMonth = Math.min(mom.date(),
                daysInMonth(mom.year(), value));
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
        return mom;
    }

    function rawGetter(mom, unit) {
        return mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]();
    }

    function rawSetter(mom, unit, value) {
        if (unit === 'Month') {
            return rawMonthSetter(mom, value);
        } else {
            return mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
        }
    }

    function makeAccessor(unit, keepTime) {
        return function (value) {
            if (value != null) {
                rawSetter(this, unit, value);
                moment.updateOffset(this, keepTime);
                return this;
            } else {
                return rawGetter(this, unit);
            }
        };
    }

    moment.fn.millisecond = moment.fn.milliseconds = makeAccessor('Milliseconds', false);
    moment.fn.second = moment.fn.seconds = makeAccessor('Seconds', false);
    moment.fn.minute = moment.fn.minutes = makeAccessor('Minutes', false);
    // Setting the hour should keep the time, because the user explicitly
    // specified which hour he wants. So trying to maintain the same hour (in
    // a new timezone) makes sense. Adding/subtracting hours does not follow
    // this rule.
    moment.fn.hour = moment.fn.hours = makeAccessor('Hours', true);
    // moment.fn.month is defined separately
    moment.fn.date = makeAccessor('Date', true);
    moment.fn.dates = deprecate('dates accessor is deprecated. Use date instead.', makeAccessor('Date', true));
    moment.fn.year = makeAccessor('FullYear', true);
    moment.fn.years = deprecate('years accessor is deprecated. Use year instead.', makeAccessor('FullYear', true));

    // add plural methods
    moment.fn.days = moment.fn.day;
    moment.fn.months = moment.fn.month;
    moment.fn.weeks = moment.fn.week;
    moment.fn.isoWeeks = moment.fn.isoWeek;
    moment.fn.quarters = moment.fn.quarter;

    // add aliased format methods
    moment.fn.toJSON = moment.fn.toISOString;

    /************************************
        Duration Prototype
    ************************************/


    function daysToYears (days) {
        // 400 years have 146097 days (taking into account leap year rules)
        return days * 400 / 146097;
    }

    function yearsToDays (years) {
        // years * 365 + absRound(years / 4) -
        //     absRound(years / 100) + absRound(years / 400);
        return years * 146097 / 400;
    }

    extend(moment.duration.fn = Duration.prototype, {

        _bubble : function () {
            var milliseconds = this._milliseconds,
                days = this._days,
                months = this._months,
                data = this._data,
                seconds, minutes, hours, years = 0;

            // The following code bubbles up values, see the tests for
            // examples of what that means.
            data.milliseconds = milliseconds % 1000;

            seconds = absRound(milliseconds / 1000);
            data.seconds = seconds % 60;

            minutes = absRound(seconds / 60);
            data.minutes = minutes % 60;

            hours = absRound(minutes / 60);
            data.hours = hours % 24;

            days += absRound(hours / 24);

            // Accurately convert days to years, assume start from year 0.
            years = absRound(daysToYears(days));
            days -= absRound(yearsToDays(years));

            // 30 days to a month
            // TODO (iskren): Use anchor date (like 1st Jan) to compute this.
            months += absRound(days / 30);
            days %= 30;

            // 12 months -> 1 year
            years += absRound(months / 12);
            months %= 12;

            data.days = days;
            data.months = months;
            data.years = years;
        },

        abs : function () {
            this._milliseconds = Math.abs(this._milliseconds);
            this._days = Math.abs(this._days);
            this._months = Math.abs(this._months);

            this._data.milliseconds = Math.abs(this._data.milliseconds);
            this._data.seconds = Math.abs(this._data.seconds);
            this._data.minutes = Math.abs(this._data.minutes);
            this._data.hours = Math.abs(this._data.hours);
            this._data.months = Math.abs(this._data.months);
            this._data.years = Math.abs(this._data.years);

            return this;
        },

        weeks : function () {
            return absRound(this.days() / 7);
        },

        valueOf : function () {
            return this._milliseconds +
              this._days * 864e5 +
              (this._months % 12) * 2592e6 +
              toInt(this._months / 12) * 31536e6;
        },

        humanize : function (withSuffix) {
            var output = relativeTime(this, !withSuffix, this.localeData());

            if (withSuffix) {
                output = this.localeData().pastFuture(+this, output);
            }

            return this.localeData().postformat(output);
        },

        add : function (input, val) {
            // supports only 2.0-style add(1, 's') or add(moment)
            var dur = moment.duration(input, val);

            this._milliseconds += dur._milliseconds;
            this._days += dur._days;
            this._months += dur._months;

            this._bubble();

            return this;
        },

        subtract : function (input, val) {
            var dur = moment.duration(input, val);

            this._milliseconds -= dur._milliseconds;
            this._days -= dur._days;
            this._months -= dur._months;

            this._bubble();

            return this;
        },

        get : function (units) {
            units = normalizeUnits(units);
            return this[units.toLowerCase() + 's']();
        },

        as : function (units) {
            var days, months;
            units = normalizeUnits(units);

            if (units === 'month' || units === 'year') {
                days = this._days + this._milliseconds / 864e5;
                months = this._months + daysToYears(days) * 12;
                return units === 'month' ? months : months / 12;
            } else {
                // handle milliseconds separately because of floating point math errors (issue #1867)
                days = this._days + Math.round(yearsToDays(this._months / 12));
                switch (units) {
                    case 'week': return days / 7 + this._milliseconds / 6048e5;
                    case 'day': return days + this._milliseconds / 864e5;
                    case 'hour': return days * 24 + this._milliseconds / 36e5;
                    case 'minute': return days * 24 * 60 + this._milliseconds / 6e4;
                    case 'second': return days * 24 * 60 * 60 + this._milliseconds / 1000;
                    // Math.floor prevents floating point math errors here
                    case 'millisecond': return Math.floor(days * 24 * 60 * 60 * 1000) + this._milliseconds;
                    default: throw new Error('Unknown unit ' + units);
                }
            }
        },

        lang : moment.fn.lang,
        locale : moment.fn.locale,

        toIsoString : deprecate(
            'toIsoString() is deprecated. Please use toISOString() instead ' +
            '(notice the capitals)',
            function () {
                return this.toISOString();
            }
        ),

        toISOString : function () {
            // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
            var years = Math.abs(this.years()),
                months = Math.abs(this.months()),
                days = Math.abs(this.days()),
                hours = Math.abs(this.hours()),
                minutes = Math.abs(this.minutes()),
                seconds = Math.abs(this.seconds() + this.milliseconds() / 1000);

            if (!this.asSeconds()) {
                // this is the same as C#'s (Noda) and python (isodate)...
                // but not other JS (goog.date)
                return 'P0D';
            }

            return (this.asSeconds() < 0 ? '-' : '') +
                'P' +
                (years ? years + 'Y' : '') +
                (months ? months + 'M' : '') +
                (days ? days + 'D' : '') +
                ((hours || minutes || seconds) ? 'T' : '') +
                (hours ? hours + 'H' : '') +
                (minutes ? minutes + 'M' : '') +
                (seconds ? seconds + 'S' : '');
        },

        localeData : function () {
            return this._locale;
        }
    });

    moment.duration.fn.toString = moment.duration.fn.toISOString;

    function makeDurationGetter(name) {
        moment.duration.fn[name] = function () {
            return this._data[name];
        };
    }

    for (i in unitMillisecondFactors) {
        if (hasOwnProp(unitMillisecondFactors, i)) {
            makeDurationGetter(i.toLowerCase());
        }
    }

    moment.duration.fn.asMilliseconds = function () {
        return this.as('ms');
    };
    moment.duration.fn.asSeconds = function () {
        return this.as('s');
    };
    moment.duration.fn.asMinutes = function () {
        return this.as('m');
    };
    moment.duration.fn.asHours = function () {
        return this.as('h');
    };
    moment.duration.fn.asDays = function () {
        return this.as('d');
    };
    moment.duration.fn.asWeeks = function () {
        return this.as('weeks');
    };
    moment.duration.fn.asMonths = function () {
        return this.as('M');
    };
    moment.duration.fn.asYears = function () {
        return this.as('y');
    };

    /************************************
        Default Locale
    ************************************/


    // Set default locale, other locale will inherit from English.
    moment.locale('en', {
        ordinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (toInt(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        }
    });

    /* EMBED_LOCALES */

    /************************************
        Exposing Moment
    ************************************/

    function makeGlobal(shouldDeprecate) {
        /*global ender:false */
        if (typeof ender !== 'undefined') {
            return;
        }
        oldGlobalMoment = globalScope.moment;
        if (shouldDeprecate) {
            globalScope.moment = deprecate(
                    'Accessing Moment through the global scope is ' +
                    'deprecated, and will be removed in an upcoming ' +
                    'release.',
                    moment);
        } else {
            globalScope.moment = moment;
        }
    }

    // CommonJS module is defined
    if (hasModule) {
        module.exports = moment;
    } else if (typeof define === 'function' && define.amd) {
        define('moment', function (require, exports, module) {
            if (module.config && module.config() && module.config().noGlobal === true) {
                // release the global variable
                globalScope.moment = oldGlobalMoment;
            }

            return moment;
        });
        makeGlobal(true);
    } else {
        makeGlobal();
    }
}).call(this);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],"/Users/jon/jupyter/notebook/notebook/static-src/auth/js/loginmain.js":[function(require,module,exports){
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.

    var IPython = require('base/js/namespace');
    var page = require('base/js/page');

    module.exports = function loginMain() {
        var page_instance = new page.Page();
        $('button#login_submit').addClass("btn btn-default");
        page_instance.show();
        $('input#password_input').focus();

        IPython.page = page_instance;
    };

},{"base/js/namespace":"/Users/jon/jupyter/notebook/notebook/static-src/base/js/namespace.js","base/js/page":"/Users/jon/jupyter/notebook/notebook/static-src/base/js/page.js"}],"/Users/jon/jupyter/notebook/notebook/static-src/auth/js/loginwidget.js":[function(require,module,exports){
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.

    "use strict";

    var utils = require('base/js/utils');

    var LoginWidget = function (selector, options) {
        options = options || {};
        this.base_url = options.base_url || utils.get_body_data("baseUrl");
        this.selector = selector;
        if (this.selector !== undefined) {
            this.element = $(selector);
            this.bind_events();
        }
    };


    LoginWidget.prototype.bind_events = function () {
        var that = this;
        this.element.find("button#logout").click(function () {
            window.location = utils.url_join_encode(
                that.base_url,
                "logout"
            );
        });
        this.element.find("button#login").click(function () {
            window.location = utils.url_join_encode(
                that.base_url,
                "login"
            );
        });
    };

    exports.LoginWidget = LoginWidget;

},{"base/js/utils":"/Users/jon/jupyter/notebook/notebook/static-src/base/js/utils.js"}],"/Users/jon/jupyter/notebook/notebook/static-src/auth/js/logoutmain.js":[function(require,module,exports){
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.

    var IPython = require('base/js/namespace');
    var page = require('base/js/page');

    module.exports = function logoutMain() {
        var page_instance = new page.Page();
        page_instance.show();

        IPython.page = page_instance;
    };

},{"base/js/namespace":"/Users/jon/jupyter/notebook/notebook/static-src/base/js/namespace.js","base/js/page":"/Users/jon/jupyter/notebook/notebook/static-src/base/js/page.js"}],"/Users/jon/jupyter/notebook/notebook/static-src/auth/js/main.js":[function(require,module,exports){
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.

exports.login_main = require('./loginmain');
exports.logout_main = require('./logoutmain');

},{"./loginmain":"/Users/jon/jupyter/notebook/notebook/static-src/auth/js/loginmain.js","./logoutmain":"/Users/jon/jupyter/notebook/notebook/static-src/auth/js/logoutmain.js"}],"/Users/jon/jupyter/notebook/notebook/static-src/base/js/dialog.js":[function(require,module,exports){
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.

    "use strict";
    
    /**
     * A wrapper around bootstrap modal for easier use
     * Pass it an option dictionary with the following properties:
     *
     *    - body : <string> or <DOM node>, main content of the dialog
     *            if pass a <string> it will be wrapped in a p tag and
     *            html element escaped, unless you specify sanitize=false
     *            option.
     *    - title : Dialog title, default to empty string.
     *    - buttons : dict of btn_options who keys are button label.
     *            see btn_options below for description
     *    - open : callback to trigger on dialog open.
     *    - destroy:
     *    - notebook : notebook instance
     *    - keyboard_manager: keyboard manager instance.
     *
     *  Unlike bootstrap modals, the backdrop options is set by default 
     *  to 'static'.
     *
     *  The rest of the options are passed as is to bootstrap modals. 
     *
     *  btn_options: dict with the following property:
     *  
     *    - click : callback to trigger on click
     *    - class : css classes to add to button.
     *
     *
     *
     **/
    var modal = function (options) {
        var modal = $("<div/>")
            .addClass("modal")
            .addClass("fade")
            .attr("role", "dialog");
        var dialog = $("<div/>")
            .addClass("modal-dialog")
            .appendTo(modal);
        var dialog_content = $("<div/>")
            .addClass("modal-content")
            .appendTo(dialog);
        if(typeof(options.body) === 'string' && options.sanitize !== false){
            options.body = $("<p/>").text(options.body);
        }
        dialog_content.append(
            $("<div/>")
                .addClass("modal-header")
                .append($("<button>")
                    .attr("type", "button")
                    .addClass("close")
                    .attr("data-dismiss", "modal")
                    .attr("aria-hidden", "true")
                    .html("&times;")
                ).append(
                    $("<h4/>")
                        .addClass('modal-title')
                        .text(options.title || "")
                )
        ).append(
            $("<div/>").addClass("modal-body").append(
                options.body || $("<p/>")
            )
        );
        
        var footer = $("<div/>").addClass("modal-footer");
        
        for (var label in options.buttons) {
            var btn_opts = options.buttons[label];
            var button = $("<button/>")
                .addClass("btn btn-default btn-sm")
                .attr("data-dismiss", "modal")
                .text(label);
            if (btn_opts.click) {
                button.click($.proxy(btn_opts.click, dialog_content));
            }
            if (btn_opts.class) {
                button.addClass(btn_opts.class);
            }
            footer.append(button);
        }
        dialog_content.append(footer);
        // hook up on-open event
        modal.on("shown.bs.modal", function() {
            setTimeout(function() {
                footer.find("button").last().focus();
                if (options.open) {
                    $.proxy(options.open, modal)();
                }
            }, 0);
        });
        
        // destroy modal on hide, unless explicitly asked not to
        if (options.destroy === undefined || options.destroy) {
            modal.on("hidden.bs.modal", function () {
                modal.remove();
            });
        }
        modal.on("hidden.bs.modal", function () {
            if (options.notebook) {
                var cell = options.notebook.get_selected_cell();
                if (cell) cell.select();
            }
            if (options.keyboard_manager) {
                options.keyboard_manager.enable();
                options.keyboard_manager.command_mode();
            }
        });
        
        if (options.keyboard_manager) {
            options.keyboard_manager.disable();
        }
        
        if(options.backdrop === undefined){
          options.backdrop = 'static';
        }
        
        return modal.modal(options);
    };

    var kernel_modal = function (options) {
        /**
         * only one kernel dialog should be open at a time -- but
         * other modal dialogs can still be open
         */
        $('.kernel-modal').modal('hide');
        var dialog = modal(options);
        dialog.addClass('kernel-modal');
        return dialog;
    };

    var edit_metadata = function (options) {
        options.name = options.name || "Cell";
        var error_div = $('<div/>').css('color', 'red');
        var message = 
            "Manually edit the JSON below to manipulate the metadata for this " + options.name + "." +
            " We recommend putting custom metadata attributes in an appropriately named sub-structure," +
            " so they don't conflict with those of others.";

        var textarea = $('<textarea/>')
            .attr('rows', '13')
            .attr('cols', '80')
            .attr('name', 'metadata')
            .text(JSON.stringify(options.md || {}, null, 2));
        
        var dialogform = $('<div/>').attr('title', 'Edit the metadata')
            .append(
                $('<form/>').append(
                    $('<fieldset/>').append(
                        $('<label/>')
                        .attr('for','metadata')
                        .text(message)
                        )
                        .append(error_div)
                        .append($('<br/>'))
                        .append(textarea)
                    )
            );
        var editor = CodeMirror.fromTextArea(textarea[0], {
            lineNumbers: true,
            matchBrackets: true,
            indentUnit: 2,
            autoIndent: true,
            mode: 'application/json',
        });
        var modal_obj = modal({
            title: "Edit " + options.name + " Metadata",
            body: dialogform,
            buttons: {
                OK: { class : "btn-primary",
                    click: function() {
                        /**
                         * validate json and set it
                         */
                        var new_md;
                        try {
                            new_md = JSON.parse(editor.getValue());
                        } catch(e) {
                            console.log(e);
                            error_div.text('WARNING: Could not save invalid JSON.');
                            return false;
                        }
                        options.callback(new_md);
                    }
                },
                Cancel: {}
            },
            notebook: options.notebook,
            keyboard_manager: options.keyboard_manager,
        });

        modal_obj.on('shown.bs.modal', function(){ editor.refresh(); });
            
    };

    module.exports = {
        modal : modal,
        kernel_modal : kernel_modal,
        edit_metadata : edit_metadata,
    };

},{}],"/Users/jon/jupyter/notebook/notebook/static-src/base/js/events.js":[function(require,module,exports){
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.

// Give us an object to bind all events to. This object should be created
// before all other objects so it exists when others register event handlers.
// To register an event handler:
//
// require(['base/js/events'], function (events) {
//     events.on("event.Namespace", function () { do_stuff(); });
// });
"use strict";

if (!window.jupyterEvents) {
    var Events = function () {};
    window.jupyterEvents = $([new Events()]);
}

module.exports = window.jupyterEvents;

},{}],"/Users/jon/jupyter/notebook/notebook/static-src/base/js/keyboard.js":[function(require,module,exports){
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
/**
 *
 *
 * @module keyboard
 * @namespace keyboard
 * @class ShortcutManager
 */

    "use strict";

    var utils = require('base/js/utils');


    /**
     * Setup global keycodes and inverse keycodes.
     *
     * See http://unixpapa.com/js/key.html for a complete description. The short of
     * it is that there are different keycode sets. Firefox uses the "Mozilla keycodes"
     * and Webkit/IE use the "IE keycodes". These keycode sets are mostly the same
     * but have minor differences.
     **/

     // These apply to Firefox, (Webkit and IE)
     // This does work **only** on US keyboard.
    var _keycodes = {
        'a': 65, 'b': 66, 'c': 67, 'd': 68, 'e': 69, 'f': 70, 'g': 71, 'h': 72, 'i': 73,
        'j': 74, 'k': 75, 'l': 76, 'm': 77, 'n': 78, 'o': 79, 'p': 80, 'q': 81, 'r': 82,
        's': 83, 't': 84, 'u': 85, 'v': 86, 'w': 87, 'x': 88, 'y': 89, 'z': 90,
        '1 !': 49, '2 @': 50, '3 #': 51, '4 $': 52, '5 %': 53, '6 ^': 54,
        '7 &': 55, '8 *': 56, '9 (': 57, '0 )': 48, 
        '[ {': 219, '] }': 221, '` ~': 192,  ', <': 188, '. >': 190, '/ ?': 191,
        '\\ |': 220, '\' "': 222,
        'numpad0': 96, 'numpad1': 97, 'numpad2': 98, 'numpad3': 99, 'numpad4': 100,
        'numpad5': 101, 'numpad6': 102, 'numpad7': 103, 'numpad8': 104, 'numpad9': 105,
        'multiply': 106, 'add': 107, 'subtract': 109, 'decimal': 110, 'divide': 111,
        'f1': 112, 'f2': 113, 'f3': 114, 'f4': 115, 'f5': 116, 'f6': 117, 'f7': 118,
        'f8': 119, 'f9': 120, 'f11': 122, 'f12': 123, 'f13': 124, 'f14': 125, 'f15': 126,
        'backspace': 8, 'tab': 9, 'enter': 13, 'shift': 16, 'ctrl': 17, 'alt': 18,
        'meta': 91, 'capslock': 20, 'esc': 27, 'space': 32, 'pageup': 33, 'pagedown': 34,
        'end': 35, 'home': 36, 'left': 37, 'up': 38, 'right': 39, 'down': 40,
        'insert': 45, 'delete': 46, 'numlock': 144,
    };

    // These apply to Firefox and Opera
    var _mozilla_keycodes = {
        '; :': 59, '= +': 61, '- _': 173, 'meta': 224, 'minus':173
    };

    // This apply to Webkit and IE
    var _ie_keycodes = {
        '; :': 186, '= +': 187, '- _': 189, 'minus':189
    };

    var browser = utils.browser[0];
    var platform = utils.platform;

    if (browser === 'Firefox' || browser === 'Opera' || browser === 'Netscape') {
        $.extend(_keycodes, _mozilla_keycodes);
    } else if (browser === 'Safari' || browser === 'Chrome' || browser === 'MSIE') {
        $.extend(_keycodes, _ie_keycodes);
    }

    var keycodes = {};
    var inv_keycodes = {};
    for (var name in _keycodes) {
        var names = name.split(' ');
        if (names.length === 1) {
            var n = names[0];
            keycodes[n] = _keycodes[n];
            inv_keycodes[_keycodes[n]] = n;
        } else {
            var primary = names[0];
            var secondary = names[1];
            keycodes[primary] = _keycodes[name];
            keycodes[secondary] = _keycodes[name];
            inv_keycodes[_keycodes[name]] = primary;
        }
    }

    var normalize_key = function (key) {
        return inv_keycodes[keycodes[key]];
    };

    var normalize_shortcut = function (shortcut) {
        /**
         * @function _normalize_shortcut
         * @private
         * return a dict containing the normalized shortcut and the number of time it should be pressed:
         *
         * Put a shortcut into normalized form:
         * 1. Make lowercase
         * 2. Replace cmd by meta
         * 3. Sort '-' separated modifiers into the order alt-ctrl-meta-shift
         * 4. Normalize keys
         **/
        if (platform === 'MacOS') {
            shortcut = shortcut.toLowerCase().replace('cmdtrl-', 'cmd-');
        } else {
            shortcut = shortcut.toLowerCase().replace('cmdtrl-', 'ctrl-');
        }

        shortcut = shortcut.toLowerCase().replace('cmd', 'meta');
        shortcut = shortcut.replace(/-$/, 'minus');  // catch shortcuts using '-' key
        shortcut = shortcut.replace(/,$/, 'comma');  // catch shortcuts using '-' key
        if(shortcut.indexOf(',') !== -1){
            var sht = shortcut.split(',');
            sht = _.map(sht, normalize_shortcut);
            return shortcut;
        }
        shortcut = shortcut.replace(/comma/g, ',');  // catch shortcuts using '-' key
        var values = shortcut.split("-");
        if (values.length === 1) {
            return normalize_key(values[0]);
        } else {
            var modifiers = values.slice(0,-1);
            var key = normalize_key(values[values.length-1]);
            modifiers.sort();
            return modifiers.join('-') + '-' + key;
        }
    };

    var shortcut_to_event = function (shortcut, type) {
        /**
         * Convert a shortcut (shift-r) to a jQuery Event object
         **/
        type = type || 'keydown';
        shortcut = normalize_shortcut(shortcut);
        shortcut = shortcut.replace(/-$/, 'minus');  // catch shortcuts using '-' key
        var values = shortcut.split("-");
        var modifiers = values.slice(0,-1);
        var key = values[values.length-1];
        var opts = {which: keycodes[key]};
        if (modifiers.indexOf('alt') !== -1) {opts.altKey = true;}
        if (modifiers.indexOf('ctrl') !== -1) {opts.ctrlKey = true;}
        if (modifiers.indexOf('meta') !== -1) {opts.metaKey = true;}
        if (modifiers.indexOf('shift') !== -1) {opts.shiftKey = true;}
        return $.Event(type, opts);
    };

    var only_modifier_event = function(event){
        /**
         * Return `true` if the event only contains modifiers keys.
         * false otherwise
         **/
        var key = inv_keycodes[event.which];
        return ((event.altKey || event.ctrlKey || event.metaKey || event.shiftKey) &&
         (key === 'alt'|| key === 'ctrl'|| key === 'meta'|| key === 'shift'));

    };

    var event_to_shortcut = function (event) {
        /**
         * Convert a jQuery Event object to a normalized shortcut string (shift-r)
         **/
        var shortcut = '';
        var key = inv_keycodes[event.which];
        if (event.altKey && key !== 'alt') {shortcut += 'alt-';}
        if (event.ctrlKey && key !== 'ctrl') {shortcut += 'ctrl-';}
        if (event.metaKey && key !== 'meta') {shortcut += 'meta-';}
        if (event.shiftKey && key !== 'shift') {shortcut += 'shift-';}
        shortcut += key;
        return shortcut;
    };

    // Shortcut manager class

    var ShortcutManager = function (delay, events, actions, env) {
        /**
         * A class to deal with keyboard event and shortcut
         *
         * @class ShortcutManager
         * @constructor
         */
        this._shortcuts = {};
        this.delay = delay || 800; // delay in milliseconds
        this.events = events;
        this.actions = actions;
        this.actions.extend_env(env);
        this._queue = [];
        this._cleartimeout = null;
        Object.seal(this);
    };

    ShortcutManager.prototype.clearsoon = function(){
        /**
         * Clear the pending shortcut soon, and cancel previous clearing
         * that might be registered.
         **/
         var that = this;
         clearTimeout(this._cleartimeout);
         this._cleartimeout = setTimeout(function(){that.clearqueue();}, this.delay);
    };


    ShortcutManager.prototype.clearqueue = function(){
        /**
         * clear the pending shortcut sequence now. 
         **/
        this._queue = [];
        clearTimeout(this._cleartimeout);
    };


    var flatten_shorttree = function(tree){
        /**
         * Flatten a tree of shortcut sequences. 
         * use full to iterate over all the key/values of available shortcuts.
         **/
        var  dct = {};
        for(var key in tree){
            var value = tree[key];
            if(typeof(value) === 'string'){
                dct[key] = value;
            } else {
                var ftree=flatten_shorttree(value);
                for(var subkey in ftree){
                    dct[key+','+subkey] = ftree[subkey];
                }
            } 
        }
        return dct;
    };
    
    ShortcutManager.prototype.get_action_shortcut = function(name){
      var ftree = flatten_shorttree(this._shortcuts);
      var res = {};
      for (var sht in ftree ){
        if(ftree[sht] === name){
          return sht;
        }
      }
      return undefined;
    };

    ShortcutManager.prototype.help = function () {
        var help = [];
        var ftree = flatten_shorttree(this._shortcuts);
        for (var shortcut in ftree) {
            var action = this.actions.get(ftree[shortcut]);
            var help_string = action.help||'== no help ==';
            var help_index = action.help_index;
            if (help_string) {
                var shortstring = (action.shortstring||shortcut);
                help.push({
                    shortcut: shortstring,
                    help: help_string,
                    help_index: help_index}
                );
            }
        }
        help.sort(function (a, b) {
            if (a.help_index === b.help_index) {
                return 0;
            }
            if (a.help_index === undefined || a.help_index > b.help_index){
                return 1;
            }
            return -1;
        });
        return help;
    };

    ShortcutManager.prototype.clear_shortcuts = function () {
        this._shortcuts = {};
    };

    ShortcutManager.prototype.get_shortcut = function (shortcut){
        /**
         * return a node of the shortcut tree which an action name (string) if leaf,
         * and an object with `object.subtree===true`
         **/
        if(typeof(shortcut) === 'string'){
            shortcut = shortcut.split(',');
        }
        
        return this._get_leaf(shortcut, this._shortcuts);
    };


    ShortcutManager.prototype._get_leaf = function(shortcut_array, tree){
        /**
         * @private
         * find a leaf/node in a subtree of the keyboard shortcut
         *
         **/
        if(shortcut_array.length === 1){
            return tree[shortcut_array[0]];
        } else if(  typeof(tree[shortcut_array[0]]) !== 'string'){
            return this._get_leaf(shortcut_array.slice(1), tree[shortcut_array[0]]);
        }
        return null;
    };

    ShortcutManager.prototype.set_shortcut = function( shortcut, action_name){
        if( typeof(action_name) !== 'string'){throw new Error('action is not a string', action_name);}
        if( typeof(shortcut) === 'string'){
            shortcut = shortcut.split(',');
        }
        return this._set_leaf(shortcut, action_name, this._shortcuts);
    };

    ShortcutManager.prototype._is_leaf = function(shortcut_array, tree){
        if(shortcut_array.length === 1){
           return(typeof(tree[shortcut_array[0]]) === 'string');
        } else {
            var subtree = tree[shortcut_array[0]];
            return this._is_leaf(shortcut_array.slice(1), subtree );
        }
    };

    ShortcutManager.prototype._remove_leaf = function(shortcut_array, tree, allow_node){
        if(shortcut_array.length === 1){
            var current_node = tree[shortcut_array[0]];
            if(typeof(current_node) === 'string'){
                delete tree[shortcut_array[0]];
            } else {
                throw('try to delete non-leaf');
            }
        } else {
            this._remove_leaf(shortcut_array.slice(1),  tree[shortcut_array[0]], allow_node);
            if(_.keys(tree[shortcut_array[0]]).length === 0){
                delete tree[shortcut_array[0]];
            }
        }
    };

    ShortcutManager.prototype._set_leaf = function(shortcut_array, action_name, tree){
        var current_node = tree[shortcut_array[0]];
        if(shortcut_array.length === 1){
            if(current_node !== undefined && typeof(current_node) !== 'string'){
                console.warn('[warning], you are overriting a long shortcut with a shorter one');
            }
            tree[shortcut_array[0]] = action_name;
            return true;
        } else {
            if(typeof(current_node) === 'string'){
                console.warn('you are trying to set a shortcut that will be shadowed'+
                             'by a more specific one. Aborting for :', action_name, 'the follwing '+
                             'will take precedence', current_node);
                return false;
            } else {
                tree[shortcut_array[0]] = tree[shortcut_array[0]]||{};
            }
            this._set_leaf(shortcut_array.slice(1), action_name, tree[shortcut_array[0]]);
            return true;
        }
    };

    ShortcutManager.prototype.add_shortcut = function (shortcut, data, suppress_help_update) {
        /**
         * Add a action to be handled by shortcut manager. 
         * 
         * - `shortcut` should be a `Shortcut Sequence` of the for `Ctrl-Alt-C,Meta-X`...
         * - `data` could be an `action name`, an `action` or a `function`.
         *   if a `function` is passed it will be converted to an anonymous `action`. 
         *
         **/
        var action_name = this.actions.get_name(data);
        if (! action_name){
          throw new Error('does not know how to deal with', data);
        }
        shortcut = normalize_shortcut(shortcut);
        this.set_shortcut(shortcut, action_name);

        if (!suppress_help_update) {
            // update the keyboard shortcuts notebook help
            this.events.trigger('rebuild.QuickHelp');
        }
    };

    ShortcutManager.prototype.add_shortcuts = function (data) {
        /**
         * Convenient methods to call `add_shortcut(key, value)` on several items
         * 
         *  data : Dict of the form {key:value, ...}
         **/
        for (var shortcut in data) {
            this.add_shortcut(shortcut, data[shortcut], true);
        }
        // update the keyboard shortcuts notebook help
        this.events.trigger('rebuild.QuickHelp');
    };

    ShortcutManager.prototype.remove_shortcut = function (shortcut, suppress_help_update) {
        /**
         * Remove the binding of shortcut `sortcut` with its action.
         * throw an error if trying to remove a non-exiting shortcut
         **/
        shortcut = normalize_shortcut(shortcut);
        if( typeof(shortcut) === 'string'){
            shortcut = shortcut.split(',');
        }
        /*
         *  The shortcut error should be explicit here, because it will be
         *  seen by users.
         */
        try
        {
          this._remove_leaf(shortcut, this._shortcuts);
          if (!suppress_help_update) {
            // update the keyboard shortcuts notebook help
            this.events.trigger('rebuild.QuickHelp');
          }
        } catch (ex) {
          throw new Error('trying to remove a non-existent shortcut', shortcut);
        }
    };



    ShortcutManager.prototype.call_handler = function (event) {
        /**
         * Call the corresponding shortcut handler for a keyboard event
         * @method call_handler
         * @return {Boolean} `true|false`, `false` if no handler was found, otherwise the  value return by the handler. 
         * @param event {event}
         *
         * given an event, call the corresponding shortcut. 
         * return false is event wan handled, true otherwise 
         * in any case returning false stop event propagation
         **/


        this.clearsoon();
        if(only_modifier_event(event)){
            return true;
        }
        var shortcut = event_to_shortcut(event);
        this._queue.push(shortcut);
        var action_name = this.get_shortcut(this._queue);

        if (typeof(action_name) === 'undefined'|| action_name === null){
            this.clearqueue();
            return true;
        }
        
        if (this.actions.exists(action_name)) {
            event.preventDefault();
            this.clearqueue();
            return this.actions.call(action_name, event);
        }

        return false;
    };


    ShortcutManager.prototype.handles = function (event) {
        var shortcut = event_to_shortcut(event);
        var action_name = this.get_shortcut(this._queue.concat(shortcut));
        return (typeof(action_name) !== 'undefined');
    };

    module.exports = {
        keycodes : keycodes,
        inv_keycodes : inv_keycodes,
        ShortcutManager : ShortcutManager,
        normalize_key : normalize_key,
        normalize_shortcut : normalize_shortcut,
        shortcut_to_event : shortcut_to_event,
        event_to_shortcut : event_to_shortcut,
    };

},{"base/js/utils":"/Users/jon/jupyter/notebook/notebook/static-src/base/js/utils.js"}],"/Users/jon/jupyter/notebook/notebook/static-src/base/js/namespace.js":[function(require,module,exports){
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.

"use strict";

if (!window.Jupyter) {
    var Jupyter = {};
    Jupyter.version = "4.1.0.dev";
    window.Jupyter = Jupyter;
}

var jprop = function(name, loaded, module_path, global_mod) {
    if (!(window.Jupyter).hasOwnProperty(name)) {
        Object.defineProperty(window.Jupyter, name, {
            get: function() {
                console.warn('accessing `'+name+'` is deprecated. Use `require(\'' + module_path + '\')' + (global_mod ? '[\'' + name + '\']' : '') + '`');
                return global_mod ? loaded[name] : loaded; 
            },
            enumerable: true,
            configurable: false
        });    
    }
};

// expose modules
jprop('events', require('base/js/events'), 'base/js/events');
jprop('utils', require('base/js/utils'), 'base/js/utils');
jprop('security', require('base/js/security'), 'base/js/security');
jprop('keyboard', require('base/js/keyboard'), 'base/js/keyboard');
jprop('dialog', require('base/js/dialog'), 'base/js/dialog');
jprop('mathjaxutils', require('notebook/js/mathjaxutils'), 'notebook/js/mathjaxutils');

//// exposed constructors
jprop('CommManager', require('services/kernels/comm'), 'services/kernels/comm', true);
jprop('Comm', require('services/kernels/comm'), 'services/kernels/comm', true);

jprop('NotificationWidget', require('base/js/notificationwidget'), 'base/js/notificationwidget', true);
jprop('Kernel', require('services/kernels/kernel'), 'services/kernels/kernel', true);
jprop('Session', require('services/sessions/session'), 'services/sessions/session', true);
jprop('LoginWidget', require('auth/js/loginwidget'), 'auth/js/loginwidget', true);
jprop('Page', require('base/js/page'), 'base/js/page', true);

// notebook
jprop('TextCell', require('notebook/js/textcell'), 'notebook/js/textcell', true);
jprop('OutputArea', require('notebook/js/outputarea'), 'notebook/js/outputarea', true);
jprop('KeyboardManager', require('notebook/js/keyboardmanager'), 'notebook/js/keyboardmanager', true);
jprop('Completer', require('notebook/js/completer'), 'notebook/js/completer', true);
jprop('Notebook', require('notebook/js/notebook'), 'notebook/js/notebook', true);
jprop('Tooltip', require('notebook/js/tooltip'), 'notebook/js/tooltip', true);
jprop('ToolBar', require('notebook/js/toolbar'), 'notebook/js/toolbar', true);
jprop('SaveWidget', require('notebook/js/savewidget'), 'notebook/js/savewidget', true);
jprop('Pager', require('notebook/js/pager'), 'notebook/js/pager', true);
jprop('QuickHelp', require('notebook/js/quickhelp'), 'notebook/js/quickhelp', true);
jprop('MarkdownCell', require('notebook/js/textcell'), 'notebook/js/textcell', true);
jprop('RawCell', require('notebook/js/textcell'), 'notebook/js/textcell', true);
jprop('Cell', require('notebook/js/cell'), 'notebook/js/cell', true);
jprop('MainToolBar', require('notebook/js/maintoolbar'), 'notebook/js/maintoolbar', true);
jprop('NotebookNotificationArea', require('notebook/js/notificationarea'), 'notebook/js/notificationarea', true);
jprop('NotebookTour', require( 'notebook/js/tour'),  'notebook/js/tour', true);
jprop('MenuBar', require( 'notebook/js/menubar'),  'notebook/js/menubar', true);

// tree
jprop('SessionList', require('tree/js/sessionlist'), 'tree/js/sessionlist', true);

window.Jupyter._target = '_blank';

// deprecated since 4.0, remove in 5+
window.IPython = window.Jupyter;
    
module.exports = window.Jupyter;

},{"auth/js/loginwidget":"/Users/jon/jupyter/notebook/notebook/static-src/auth/js/loginwidget.js","base/js/dialog":"/Users/jon/jupyter/notebook/notebook/static-src/base/js/dialog.js","base/js/events":"/Users/jon/jupyter/notebook/notebook/static-src/base/js/events.js","base/js/keyboard":"/Users/jon/jupyter/notebook/notebook/static-src/base/js/keyboard.js","base/js/notificationwidget":"/Users/jon/jupyter/notebook/notebook/static-src/base/js/notificationwidget.js","base/js/page":"/Users/jon/jupyter/notebook/notebook/static-src/base/js/page.js","base/js/security":"/Users/jon/jupyter/notebook/notebook/static-src/base/js/security.js","base/js/utils":"/Users/jon/jupyter/notebook/notebook/static-src/base/js/utils.js","notebook/js/cell":"/Users/jon/jupyter/notebook/notebook/static-src/notebook/js/cell.js","notebook/js/completer":"/Users/jon/jupyter/notebook/notebook/static-src/notebook/js/completer.js","notebook/js/keyboardmanager":"/Users/jon/jupyter/notebook/notebook/static-src/notebook/js/keyboardmanager.js","notebook/js/maintoolbar":"/Users/jon/jupyter/notebook/notebook/static-src/notebook/js/maintoolbar.js","notebook/js/mathjaxutils":"/Users/jon/jupyter/notebook/notebook/static-src/notebook/js/mathjaxutils.js","notebook/js/menubar":"/Users/jon/jupyter/notebook/notebook/static-src/notebook/js/menubar.js","notebook/js/notebook":"/Users/jon/jupyter/notebook/notebook/static-src/notebook/js/notebook.js","notebook/js/notificationarea":"/Users/jon/jupyter/notebook/notebook/static-src/notebook/js/notificationarea.js","notebook/js/outputarea":"/Users/jon/jupyter/notebook/notebook/static-src/notebook/js/outputarea.js","notebook/js/pager":"/Users/jon/jupyter/notebook/notebook/static-src/notebook/js/pager.js","notebook/js/quickhelp":"/Users/jon/jupyter/notebook/notebook/static-src/notebook/js/quickhelp.js","notebook/js/savewidget":"/Users/jon/jupyter/notebook/notebook/static-src/notebook/js/savewidget.js","notebook/js/textcell":"/Users/jon/jupyter/notebook/notebook/static-src/notebook/js/textcell.js","notebook/js/toolbar":"/Users/jon/jupyter/notebook/notebook/static-src/notebook/js/toolbar.js","notebook/js/tooltip":"/Users/jon/jupyter/notebook/notebook/static-src/notebook/js/tooltip.js","notebook/js/tour":"/Users/jon/jupyter/notebook/notebook/static-src/notebook/js/tour.js","services/kernels/comm":"/Users/jon/jupyter/notebook/notebook/static-src/services/kernels/comm.js","services/kernels/kernel":"/Users/jon/jupyter/notebook/notebook/static-src/services/kernels/kernel.js","services/sessions/session":"/Users/jon/jupyter/notebook/notebook/static-src/services/sessions/session.js","tree/js/sessionlist":"/Users/jon/jupyter/notebook/notebook/static-src/tree/js/sessionlist.js"}],"/Users/jon/jupyter/notebook/notebook/static-src/base/js/notificationarea.js":[function(require,module,exports){
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.

    "use strict";

    var notificationwidget = require('base/js/notificationwidget');

    // store reference to the NotificationWidget class
    var NotificationWidget = notificationwidget.NotificationWidget;

    /**
     * Construct the NotificationArea object. Options are:
     *     events: $(Events) instance
     *     save_widget: SaveWidget instance
     *     notebook: Notebook instance
     *     keyboard_manager: KeyboardManager instance
     *
     * @constructor
     * @param {string} selector - a jQuery selector string for the
     * notification area element
     * @param {Object} [options] - a dictionary of keyword arguments.
     */
    var NotificationArea = function (selector, options) {
        this.selector = selector;
        this.events = options.events;
        if (this.selector !== undefined) {
            this.element = $(selector);
        }
        this.widget_dict = {};
    };

    /**
     * Get a widget by name, creating it if it doesn't exist.
     *
     * @method widget
     * @param {string} name - the widget name
     */
    NotificationArea.prototype.widget = function (name) {
        if (this.widget_dict[name] === undefined) {
            return this.new_notification_widget(name);
        }
        return this.get_widget(name);
    };

    /**
     * Get a widget by name, throwing an error if it doesn't exist.
     *
     * @method get_widget
     * @param {string} name - the widget name
     */
    NotificationArea.prototype.get_widget = function (name) {
        if(this.widget_dict[name] === undefined) {
            throw('no widgets with this name');
        }
        return this.widget_dict[name];
    };

    /**
     * Create a new notification widget with the given name. The
     * widget must not already exist.
     *
     * @method new_notification_widget
     * @param {string} name - the widget name
     */
    NotificationArea.prototype.new_notification_widget = function (name) {
        if (this.widget_dict[name] !== undefined) {
            throw('widget with that name already exists!');
        }

        // create the element for the notification widget and add it
        // to the notification aread element
        var div = $('<div/>').attr('id', 'notification_' + name);
        $(this.selector).append(div);

        // create the widget object and return it
        this.widget_dict[name] = new NotificationWidget('#notification_' + name);
        return this.widget_dict[name];
    };

    exports.NotificationArea = NotificationArea;

},{"base/js/notificationwidget":"/Users/jon/jupyter/notebook/notebook/static-src/base/js/notificationwidget.js"}],"/Users/jon/jupyter/notebook/notebook/static-src/base/js/notificationwidget.js":[function(require,module,exports){
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.

    "use strict";

    /**
     * Construct a NotificationWidget object.
     *
     * @constructor
     * @param {string} selector - a jQuery selector string for the
     * notification widget element
     */
    var NotificationWidget = function (selector) {
        this.selector = selector;
        this.timeout = null;
        this.busy = false;
        if (this.selector !== undefined) {
            this.element = $(selector);
            this.style();
        }
        this.element.hide();
        this.inner = $('<span/>');
        this.element.append(this.inner);
    };

    /**
     * Add the 'notification_widget' CSS class to the widget element.
     *
     * @method style
     */
    NotificationWidget.prototype.style = function () {
        // use explicit bootstrap classes here,
        // because multiple inheritance in LESS doesn't work
        // for this particular combination
        this.element.addClass('notification_widget btn btn-xs navbar-btn');
    };

    /**
     * hide the widget and empty the text
     **/
    NotificationWidget.prototype.hide = function () {
        var that = this;
        this.element.fadeOut(100, function(){that.inner.text('');});
    };

    /**
     * Set the notification widget message to display for a certain
     * amount of time (timeout).  The widget will be shown forever if
     * timeout is <= 0 or undefined. If the widget is clicked while it
     * is still displayed, execute an optional callback
     * (click_callback). If the callback returns false, it will
     * prevent the notification from being dismissed.
     *
     * Options:
     *    class - CSS class name for styling
     *    icon - CSS class name for the widget icon
     *    title - HTML title attribute for the widget
     *
     * @method set_message
     * @param {string} msg - The notification to display
     * @param {integer} [timeout] - The amount of time in milliseconds to display the widget
     * @param {function} [click_callback] - The function to run when the widget is clicked
     * @param {Object} [options] - Additional options
     */
    NotificationWidget.prototype.set_message = function (msg, timeout, click_callback, options) {
        options = options || {};

        // unbind potential previous callback
        this.element.unbind('click');
        this.inner.attr('class', options.icon);
        this.inner.attr('title', options.title);
        this.inner.text(msg);
        this.element.fadeIn(100);

        // reset previous set style
        this.element.removeClass();
        this.style();
        if (options.class) {
            this.element.addClass(options.class);
        }

        // clear previous timer
        if (this.timeout !== null) {
            clearTimeout(this.timeout);
            this.timeout = null;
        }

        // set the timer if a timeout is given
        var that = this;
        if (timeout !== undefined && timeout >= 0) {
            this.timeout = setTimeout(function () {
                that.element.fadeOut(100, function () {that.inner.text('');});
                that.element.unbind('click');
                that.timeout = null;
            }, timeout);
        }

        // if no click callback assume we will just dismiss the notification
        if (click_callback === undefined) {
            click_callback = function(){return true};
        }
        // on click, remove widget if click callback say so
        // and unbind click event.
        this.element.click(function () {
            if (click_callback() !== false) {
                that.element.fadeOut(100, function () {that.inner.text('');});
                that.element.unbind('click');
            }
            if (that.timeout !== null) {
                clearTimeout(that.timeout);
                that.timeout = null;
            }
        });
    };

    /**
     * Display an information message (styled with the 'info'
     * class). Arguments are the same as in set_message. Default
     * timeout is 3500 milliseconds.
     *
     * @method info
     */
    NotificationWidget.prototype.info = function (msg, timeout, click_callback, options) {
        options = options || {};
        options.class = options.class + ' info';
        timeout = timeout || 3500;
        this.set_message(msg, timeout, click_callback, options);
    };

    /**
     * Display a warning message (styled with the 'warning'
     * class). Arguments are the same as in set_message. Messages are
     * sticky by default.
     *
     * @method warning
     */
    NotificationWidget.prototype.warning = function (msg, timeout, click_callback, options) {
        options = options || {};
        options.class = options.class + ' warning';
        this.set_message(msg, timeout, click_callback, options);
    };

    /**
     * Display a danger message (styled with the 'danger'
     * class). Arguments are the same as in set_message. Messages are
     * sticky by default.
     *
     * @method danger
     */
    NotificationWidget.prototype.danger = function (msg, timeout, click_callback, options) {
        options = options || {};
        options.class = options.class + ' danger';
        this.set_message(msg, timeout, click_callback, options);
    };

    /**
     * Get the text of the widget message.
     *
     * @method get_message
     * @return {string} - the message text
     */
    NotificationWidget.prototype.get_message = function () {
        return this.inner.html();
    };

    exports.NotificationWidget = NotificationWidget;

},{}],"/Users/jon/jupyter/notebook/notebook/static-src/base/js/page.js":[function(require,module,exports){
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.

    "use strict";
        
    var events = require('base/js/events');

    var Page = function () {
        this.bind_events();
    };

    Page.prototype.bind_events = function () {
        // resize site on:
        // - window resize
        // - header change
        // - page load
        var _handle_resize = $.proxy(this._resize_site, this);
        
        $(window).resize(_handle_resize);

        // On document ready, resize codemirror.
        $(document).ready(_handle_resize);
        events.on('resize-header.Page', _handle_resize);
    };

    Page.prototype.show = function () {
        /**
         * The header and site divs start out hidden to prevent FLOUC.
         * Main scripts should call this method after styling everything.
         */
        this.show_header();
        this.show_site();
    };

    Page.prototype.show_header = function () {
        /**
         * The header and site divs start out hidden to prevent FLOUC.
         * Main scripts should call this method after styling everything.
         * TODO: selector are hardcoded, pass as constructor argument
         */
        $('div#header').css('display','block');
    };

    Page.prototype.show_site = function () {
        /**
         * The header and site divs start out hidden to prevent FLOUC.
         * Main scripts should call this method after styling everything.
         * TODO: selector are hardcoded, pass as constructor argument
         */
        $('div#site').css('display', 'block');
        this._resize_site();
    };

    Page.prototype._resize_site = function() {
        // Update the site's size.
        $('div#site').height($(window).height() - $('#header').height());
    };

    exports.Page = Page;

},{"base/js/events":"/Users/jon/jupyter/notebook/notebook/static-src/base/js/events.js"}],"/Users/jon/jupyter/notebook/notebook/static-src/base/js/security.js":[function(require,module,exports){
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.

    "use strict";
        
    var caja = require('google-caja/html-css-sanitizer-minified');

    var noop = function (x) { return x; };

    var caja;
    if (window && window.html) {
        caja = window.html;
        caja.html4 = window.html4;
        caja.sanitizeStylesheet = window.sanitizeStylesheet;
    }

    var sanitizeAttribs = function (tagName, attribs, opt_naiveUriRewriter, opt_nmTokenPolicy, opt_logger) {
        /**
         * add trusting data-attributes to the default sanitizeAttribs from caja
         * this function is mostly copied from the caja source
         */
        var ATTRIBS = caja.html4.ATTRIBS;
        for (var i = 0; i < attribs.length; i += 2) {
            var attribName = attribs[i];
            if (attribName.substr(0,5) == 'data-') {
                var attribKey = '*::' + attribName;
                if (!ATTRIBS.hasOwnProperty(attribKey)) {
                    ATTRIBS[attribKey] = 0;
                }
            }
        }
        return caja.sanitizeAttribs(tagName, attribs, opt_naiveUriRewriter, opt_nmTokenPolicy, opt_logger);
    };

    var sanitize_css = function (css, tagPolicy) {
        /**
         * sanitize CSS
         * like sanitize_html, but for CSS
         * called by sanitize_stylesheets
         */
        return caja.sanitizeStylesheet(
            window.location.pathname,
            css,
            {
                containerClass: null,
                idSuffix: '',
                tagPolicy: tagPolicy,
                virtualizeAttrName: noop
            },
            noop
        );
    };

    var sanitize_stylesheets = function (html, tagPolicy) {
        /**
         * sanitize just the css in style tags in a block of html
         * called by sanitize_html, if allow_css is true
         */
        var h = $("<div/>").append(html);
        var style_tags = h.find("style");
        if (!style_tags.length) {
            // no style tags to sanitize
            return html;
        }
        style_tags.each(function(i, style) {
            style.innerHTML = sanitize_css(style.innerHTML, tagPolicy);
        });
        return h.html();
    };

    var sanitize_html = function (html, allow_css) {
        /**
         * sanitize HTML
         * if allow_css is true (default: false), CSS is sanitized as well.
         * otherwise, CSS elements and attributes are simply removed.
         */
        var html4 = caja.html4;

        if (allow_css) {
            // allow sanitization of style tags,
            // not just scrubbing
            html4.ELEMENTS.style &= ~html4.eflags.UNSAFE;
            html4.ATTRIBS.style = html4.atype.STYLE;
        } else {
            // scrub all CSS
            html4.ELEMENTS.style |= html4.eflags.UNSAFE;
            html4.ATTRIBS.style = html4.atype.SCRIPT;
        }
        
        var record_messages = function (msg, opts) {
            console.log("HTML Sanitizer", msg, opts);
        };
        
        var policy = function (tagName, attribs) {
            if (!(html4.ELEMENTS[tagName] & html4.eflags.UNSAFE)) {
                return {
                    'attribs': sanitizeAttribs(tagName, attribs,
                        noop, noop, record_messages)
                    };
            } else {
                record_messages(tagName + " removed", {
                  change: "removed",
                  tagName: tagName
                });
            }
        };
        
        var sanitized = caja.sanitizeWithPolicy(html, policy);
        
        if (allow_css) {
            // sanitize style tags as stylesheets
            sanitized = sanitize_stylesheets(result.sanitized, policy);
        }
        
        return sanitized;
    };

    module.exports = {
        caja: caja,
        sanitize_html: sanitize_html
    };

},{"google-caja/html-css-sanitizer-minified":"/Users/jon/jupyter/notebook/notebook/static/components/google-caja/html-css-sanitizer-minified.js"}],"/Users/jon/jupyter/notebook/notebook/static-src/base/js/utils.js":[function(require,module,exports){
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.

    "use strict";
        
    var moment = require('moment');

    /**
     * Load a single extension.
     * @param  {string} extension - extension path.
     * @return {Promise} that resolves to an extension module handle
     */
    var load_extension = function (extension) {
        return new Promise(function(resolve, reject) {
            requirejs(["nbextensions/" + extension], function(module) {
                console.log("Loaded extension: " + extension);
                try {
                    module.load_ipython_extension();
                } finally {
                    resolve(module);
                }
            }, function(err) {
                reject(err);
            });
        });
    };

    /**
     * Load multiple extensions.
     * Takes n-args, where each arg is a string path to the extension.
     * @return {Promise} that resolves to a list of loaded module handles.
     */
    var load_extensions = function () {
        return Promise.all(Array.prototype.map.call(arguments, load_extension)).catch(function(err) {
            console.error("Failed to load extension" + (err.requireModules.length>1?'s':'') + ":", err.requireModules, err);
        });
    };

    /**
     * Wait for a config section to load, and then load the extensions specified
     * in a 'load_extensions' key inside it.
     */
    function load_extensions_from_config(section) {
        section.loaded.then(function() {
            if (section.data.load_extensions) {
                var nbextension_paths = Object.getOwnPropertyNames(
                                            section.data.load_extensions);
                load_extensions.apply(this, nbextension_paths);
            }
        });
    }

    //============================================================================
    // Cross-browser RegEx Split
    //============================================================================

    // This code has been MODIFIED from the code licensed below to not replace the
    // default browser split.  The license is reproduced here.

    // see http://blog.stevenlevithan.com/archives/cross-browser-split for more info:
    /*!
     * Cross-Browser Split 1.1.1
     * Copyright 2007-2012 Steven Levithan <stevenlevithan.com>
     * Available under the MIT License
     * ECMAScript compliant, uniform cross-browser split method
     */

    /**
     * Splits a string into an array of strings using a regex or string
     * separator. Matches of the separator are not included in the result array.
     * However, if `separator` is a regex that contains capturing groups,
     * backreferences are spliced into the result each time `separator` is
     * matched. Fixes browser bugs compared to the native
     * `String.prototype.split` and can be used reliably cross-browser.
     * @param {String} str String to split.
     * @param {RegExp} separator Regex to use for separating
     *     the string.
     * @param {Number} [limit] Maximum number of items to include in the result
     *     array.
     * @returns {Array} Array of substrings.
     * @example
     *
     * // Basic use
     * regex_split('a b c d', ' ');
     * // -> ['a', 'b', 'c', 'd']
     *
     * // With limit
     * regex_split('a b c d', ' ', 2);
     * // -> ['a', 'b']
     *
     * // Backreferences in result array
     * regex_split('..word1 word2..', /([a-z]+)(\d+)/i);
     * // -> ['..', 'word', '1', ' ', 'word', '2', '..']
     */
    var regex_split = function (str, separator, limit) {
        var output = [],
            flags = (separator.ignoreCase ? "i" : "") +
                    (separator.multiline  ? "m" : "") +
                    (separator.extended   ? "x" : "") + // Proposed for ES6
                    (separator.sticky     ? "y" : ""), // Firefox 3+
            lastLastIndex = 0,
            separator2, match, lastIndex, lastLength;
        // Make `global` and avoid `lastIndex` issues by working with a copy
        separator = new RegExp(separator.source, flags + "g");

        var compliantExecNpcg = typeof(/()??/.exec("")[1]) === "undefined";
        if (!compliantExecNpcg) {
            // Doesn't need flags gy, but they don't hurt
            separator2 = new RegExp("^" + separator.source + "$(?!\\s)", flags);
        }
        /* Values for `limit`, per the spec:
         * If undefined: 4294967295 // Math.pow(2, 32) - 1
         * If 0, Infinity, or NaN: 0
         * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;
         * If negative number: 4294967296 - Math.floor(Math.abs(limit))
         * If other: Type-convert, then use the above rules
         */
        limit = typeof(limit) === "undefined" ?
            -1 >>> 0 : // Math.pow(2, 32) - 1
            limit >>> 0; // ToUint32(limit)
        for (match = separator.exec(str); match; match = separator.exec(str)) {
            // `separator.lastIndex` is not reliable cross-browser
            lastIndex = match.index + match[0].length;
            if (lastIndex > lastLastIndex) {
                output.push(str.slice(lastLastIndex, match.index));
                // Fix browsers whose `exec` methods don't consistently return `undefined` for
                // nonparticipating capturing groups
                if (!compliantExecNpcg && match.length > 1) {
                    match[0].replace(separator2, function () {
                        for (var i = 1; i < arguments.length - 2; i++) {
                            if (typeof(arguments[i]) === "undefined") {
                                match[i] = undefined;
                            }
                        }
                    });
                }
                if (match.length > 1 && match.index < str.length) {
                    Array.prototype.push.apply(output, match.slice(1));
                }
                lastLength = match[0].length;
                lastLastIndex = lastIndex;
                if (output.length >= limit) {
                    break;
                }
            }
            if (separator.lastIndex === match.index) {
                separator.lastIndex++; // Avoid an infinite loop
            }
        }
        if (lastLastIndex === str.length) {
            if (lastLength || !separator.test("")) {
                output.push("");
            }
        } else {
            output.push(str.slice(lastLastIndex));
        }
        return output.length > limit ? output.slice(0, limit) : output;
    };

    //============================================================================
    // End contributed Cross-browser RegEx Split
    //============================================================================


    var uuid = function () {
        /**
         * http://www.ietf.org/rfc/rfc4122.txt
         */
        var s = [];
        var hexDigits = "0123456789ABCDEF";
        for (var i = 0; i < 32; i++) {
            s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);
        }
        s[12] = "4";  // bits 12-15 of the time_hi_and_version field to 0010
        s[16] = hexDigits.substr((s[16] & 0x3) | 0x8, 1);  // bits 6-7 of the clock_seq_hi_and_reserved to 01

        var uuid = s.join("");
        return uuid;
    };


    //Fix raw text to parse correctly in crazy XML
    function xmlencode(string) {
        return string.replace(/\&/g,'&'+'amp;')
            .replace(/</g,'&'+'lt;')
            .replace(/>/g,'&'+'gt;')
            .replace(/\'/g,'&'+'apos;')
            .replace(/\"/g,'&'+'quot;')
            .replace(/`/g,'&'+'#96;');
    }


    //Map from terminal commands to CSS classes
    var ansi_colormap = {
        "01":"ansibold",
        
        "30":"ansiblack",
        "31":"ansired",
        "32":"ansigreen",
        "33":"ansiyellow",
        "34":"ansiblue",
        "35":"ansipurple",
        "36":"ansicyan",
        "37":"ansigray",
        
        "40":"ansibgblack",
        "41":"ansibgred",
        "42":"ansibggreen",
        "43":"ansibgyellow",
        "44":"ansibgblue",
        "45":"ansibgpurple",
        "46":"ansibgcyan",
        "47":"ansibggray"
    };

    function _process_numbers(attrs, numbers) {
        // process ansi escapes
        var n = numbers.shift();
        if (ansi_colormap[n]) {
            if ( ! attrs["class"] ) {
                attrs["class"] = ansi_colormap[n];
            } else {
                attrs["class"] += " " + ansi_colormap[n];
            }
        } else if (n == "38" || n == "48") {
            // VT100 256 color or 24 bit RGB
            if (numbers.length < 2) {
                console.log("Not enough fields for VT100 color", numbers);
                return;
            }
            
            var index_or_rgb = numbers.shift();
            var r,g,b;
            if (index_or_rgb == "5") {
                // 256 color
                var idx = parseInt(numbers.shift(), 10);
                if (idx < 16) {
                    // indexed ANSI
                    // ignore bright / non-bright distinction
                    idx = idx % 8;
                    var ansiclass = ansi_colormap[n[0] + (idx % 8).toString()];
                    if ( ! attrs["class"] ) {
                        attrs["class"] = ansiclass;
                    } else {
                        attrs["class"] += " " + ansiclass;
                    }
                    return;
                } else if (idx < 232) {
                    // 216 color 6x6x6 RGB
                    idx = idx - 16;
                    b = idx % 6;
                    g = Math.floor(idx / 6) % 6;
                    r = Math.floor(idx / 36) % 6;
                    // convert to rgb
                    r = (r * 51);
                    g = (g * 51);
                    b = (b * 51);
                } else {
                    // grayscale
                    idx = idx - 231;
                    // it's 1-24 and should *not* include black or white,
                    // so a 26 point scale
                    r = g = b = Math.floor(idx * 256 / 26);
                }
            } else if (index_or_rgb == "2") {
                // Simple 24 bit RGB
                if (numbers.length > 3) {
                    console.log("Not enough fields for RGB", numbers);
                    return;
                }
                r = numbers.shift();
                g = numbers.shift();
                b = numbers.shift();
            } else {
                console.log("unrecognized control", numbers);
                return;
            }
            if (r !== undefined) {
                // apply the rgb color
                var line;
                if (n == "38") {
                    line = "color: ";
                } else {
                    line = "background-color: ";
                }
                line = line + "rgb(" + r + "," + g + "," + b + ");";
                if ( !attrs.style ) {
                    attrs.style = line;
                } else {
                    attrs.style += " " + line;
                }
            }
        }
    }

    function ansispan(str) {
        // ansispan function adapted from github.com/mmalecki/ansispan (MIT License)
        // regular ansi escapes (using the table above)
        var is_open = false;
        return str.replace(/\033\[(0?[01]|22|39)?([;\d]+)?m/g, function(match, prefix, pattern) {
            if (!pattern) {
                // [(01|22|39|)m close spans
                if (is_open) {
                    is_open = false;
                    return "</span>";
                } else {
                    return "";
                }
            } else {
                is_open = true;

                // consume sequence of color escapes
                var numbers = pattern.match(/\d+/g);
                var attrs = {};
                while (numbers.length > 0) {
                    _process_numbers(attrs, numbers);
                }

                var span = "<span ";
                Object.keys(attrs).map(function (attr) {
                    span = span + " " + attr + '="' + attrs[attr] + '"';
                });
                return span + ">";
            }
        });
    }

    // Transform ANSI color escape codes into HTML <span> tags with css
    // classes listed in the above ansi_colormap object. The actual color used
    // are set in the css file.
    function fixConsole(txt) {
        txt = xmlencode(txt);

        // Strip all ANSI codes that are not color related.  Matches
        // all ANSI codes that do not end with "m".
        var ignored_re = /(?=(\033\[[\d;=]*[a-ln-zA-Z]{1}))\1(?!m)/g;
        txt = txt.replace(ignored_re, "");
        
        // color ansi codes
        txt = ansispan(txt);
        return txt;
    }

    // Remove chunks that should be overridden by the effect of
    // carriage return characters
    function fixCarriageReturn(txt) {
        var tmp = txt;
        do {
            txt = tmp;
            tmp = txt.replace(/\r+\n/gm, '\n'); // \r followed by \n --> newline
            tmp = tmp.replace(/^.*\r+/gm, '');  // Other \r --> clear line
        } while (tmp.length < txt.length);
        return txt;
    }

    // Locate any URLs and convert them to a anchor tag
    function autoLinkUrls(txt) {
        return txt.replace(/(^|\s)(https?|ftp)(:[^'">\s]+)/gi,
            "$1<a target=\"_blank\" href=\"$2$3\">$2$3</a>");
    }

    var points_to_pixels = function (points) {
        /**
         * A reasonably good way of converting between points and pixels.
         */
        var test = $('<div style="display: none; width: 10000pt; padding:0; border:0;"></div>');
        $('body').append(test);
        var pixel_per_point = test.width()/10000;
        test.remove();
        return Math.floor(points*pixel_per_point);
    };

    var always_new = function (constructor) {
        /**
         * wrapper around contructor to avoid requiring `var a = new constructor()`
         * useful for passing constructors as callbacks,
         * not for programmer laziness.
         * from http://programmers.stackexchange.com/questions/118798
         */
        return function () {
            var obj = Object.create(constructor.prototype);
            constructor.apply(obj, arguments);
            return obj;
        };
    };

    var url_path_join = function () {
        /**
         * join a sequence of url components with '/'
         */
        var url = '';
        for (var i = 0; i < arguments.length; i++) {
            if (arguments[i] === '') {
                continue;
            }
            if (url.length > 0 && url[url.length-1] != '/') {
                url = url + '/' + arguments[i];
            } else {
                url = url + arguments[i];
            }
        }
        url = url.replace(/\/\/+/, '/');
        return url;
    };

    var url_path_split = function (path) {
        /**
         * Like os.path.split for URLs.
         * Always returns two strings, the directory path and the base filename
         */
        
        var idx = path.lastIndexOf('/');
        if (idx === -1) {
            return ['', path];
        } else {
            return [ path.slice(0, idx), path.slice(idx + 1) ];
        }
    };

    var parse_url = function (url) {
        /**
         * an `a` element with an href allows attr-access to the parsed segments of a URL
         * a = parse_url("http://localhost:8888/path/name#hash")
         * a.protocol = "http:"
         * a.host     = "localhost:8888"
         * a.hostname = "localhost"
         * a.port     = 8888
         * a.pathname = "/path/name"
         * a.hash     = "#hash"
         */
        var a = document.createElement("a");
        a.href = url;
        return a;
    };

    var encode_uri_components = function (uri) {
        /**
         * encode just the components of a multi-segment uri,
         * leaving '/' separators
         */
        return uri.split('/').map(encodeURIComponent).join('/');
    };

    var url_join_encode = function () {
        /**
         * join a sequence of url components with '/',
         * encoding each component with encodeURIComponent
         */
        return encode_uri_components(url_path_join.apply(null, arguments));
    };


    var splitext = function (filename) {
        /**
         * mimic Python os.path.splitext
         * Returns ['base', '.ext']
         */
        var idx = filename.lastIndexOf('.');
        if (idx > 0) {
            return [filename.slice(0, idx), filename.slice(idx)];
        } else {
            return [filename, ''];
        }
    };


    var escape_html = function (text) {
        /**
         * escape text to HTML
         */
        return $("<div/>").text(text).html();
    };


    var get_body_data = function(key) {
        /**
         * get a url-encoded item from body.data and decode it
         * we should never have any encoded URLs anywhere else in code
         * until we are building an actual request
         */
        var val = $('body').data(key);
        if (!val)
            return val;
        return decodeURIComponent(val);
    };

    var to_absolute_cursor_pos = function (cm, cursor) {
        /**
         * get the absolute cursor position from CodeMirror's col, ch
         */
        if (!cursor) {
            cursor = cm.getCursor();
        }
        var cursor_pos = cursor.ch;
        for (var i = 0; i < cursor.line; i++) {
            cursor_pos += cm.getLine(i).length + 1;
        }
        return cursor_pos;
    };

    var from_absolute_cursor_pos = function (cm, cursor_pos) {
        /**
         * turn absolute cursor position into CodeMirror col, ch cursor
         */
        var i, line, next_line;
        var offset = 0;
        for (i = 0, next_line=cm.getLine(i); next_line !== undefined; i++, next_line=cm.getLine(i)) {
            line = next_line;
            if (offset + next_line.length < cursor_pos) {
                offset += next_line.length + 1;
            } else {
                return {
                    line : i,
                    ch : cursor_pos - offset,
                };
            }
        }
        // reached end, return endpoint
        return {
            line : i - 1,
            ch : line.length - 1,
        };
    };

    // http://stackoverflow.com/questions/2400935/browser-detection-in-javascript
    var browser = (function() {
        if (typeof navigator === 'undefined') {
            // navigator undefined in node
            return 'None';
        }
        var N= navigator.appName, ua= navigator.userAgent, tem;
        var M= ua.match(/(opera|chrome|safari|firefox|msie)\/?\s*(\.?\d+(\.\d+)*)/i);
        if (M && (tem= ua.match(/version\/([\.\d]+)/i)) !== null) M[2]= tem[1];
        M= M? [M[1], M[2]]: [N, navigator.appVersion,'-?'];
        return M;
    })();

    // http://stackoverflow.com/questions/11219582/how-to-detect-my-browser-version-and-operating-system-using-javascript
    var platform = (function () {
        if (typeof navigator === 'undefined') {
            // navigator undefined in node
            return 'None';
        }
        var OSName="None";
        if (navigator.appVersion.indexOf("Win")!=-1) OSName="Windows";
        if (navigator.appVersion.indexOf("Mac")!=-1) OSName="MacOS";
        if (navigator.appVersion.indexOf("X11")!=-1) OSName="UNIX";
        if (navigator.appVersion.indexOf("Linux")!=-1) OSName="Linux";
        return OSName;
    })();

    var get_url_param = function (name) {
        // get a URL parameter. I cannot believe we actually need this.
        // Based on http://stackoverflow.com/a/25359264/938949
        var match = new RegExp('[?&]' + name + '=([^&]*)').exec(window.location.search);
        if (match){
            return decodeURIComponent(match[1] || '');
        }
    };

    var is_or_has = function (a, b) {
        /**
         * Is b a child of a or a itself?
         */
        return a.has(b).length !==0 || a.is(b);
    };

    var is_focused = function (e) {
        /**
         * Is element e, or one of its children focused?
         */
        e = $(e);
        var target = $(document.activeElement);
        if (target.length > 0) {
            if (is_or_has(e, target)) {
                return true;
            } else {
                return false;
            }
        } else {
            return false;
        }
    };

    var mergeopt = function(_class, options, overwrite){
        options = options || {};
        overwrite = overwrite || {};
        return $.extend(true, {}, _class.options_default, options, overwrite);
    };

    var ajax_error_msg = function (jqXHR) {
        /**
         * Return a JSON error message if there is one,
         * otherwise the basic HTTP status text.
         */
        if (jqXHR.responseJSON && jqXHR.responseJSON.traceback) {
            return jqXHR.responseJSON.traceback;
        } else if (jqXHR.responseJSON && jqXHR.responseJSON.message) {
            return jqXHR.responseJSON.message;
        } else {
            return jqXHR.statusText;
        }
    };
    var log_ajax_error = function (jqXHR, status, error) {
        /**
         * log ajax failures with informative messages
         */
        var msg = "API request failed (" + jqXHR.status + "): ";
        console.log(jqXHR);
        msg += ajax_error_msg(jqXHR);
        console.log(msg);
    };

    var requireCodeMirrorMode = function (mode, callback, errback) {
        /** 
         * find a predefined mode or detect from CM metadata then
         * require and callback with the resolveable mode string: mime or
         * custom name
         */

        var modename = (typeof mode == "string") ? mode :
            mode.mode || mode.name;

            
        // simplest, cheapest check by mode name: mode may also have config
        if (CodeMirror.modes.hasOwnProperty(modename)) {
            // return the full mode object, if it has a name
            callback(mode.name ? mode : modename);
            return;
        }

        // *somehow* get back a CM.modeInfo-like object that has .mode and
        // .mime
        var info = (mode && mode.mode && mode.mime && mode) ||
            CodeMirror.findModeByName(modename) ||
            CodeMirror.findModeByExtension(modename.split(".").slice(-1)) ||
            CodeMirror.findModeByMIME(modename) ||
            {mode: modename, mime: modename};

        requirejs([
                // might want to use CodeMirror.modeURL here
                ['codemirror/mode', info.mode, info.mode].join('/'),
            ], function() {
              // return the original mode, as from a kernelspec on first load
              // or the mimetype, as for most highlighting
              callback(mode.name ? mode : info.mime);
            }, errback
        );
    };

    /** Error type for wrapped XHR errors. */
    var XHR_ERROR = 'XhrError';

    /**
     * Wraps an AJAX error as an Error object.
     */
    var wrap_ajax_error = function (jqXHR, status, error) {
        var wrapped_error = new Error(ajax_error_msg(jqXHR));
        wrapped_error.name =  XHR_ERROR;
        // provide xhr response
        wrapped_error.xhr = jqXHR;
        wrapped_error.xhr_status = status;
        wrapped_error.xhr_error = error;
        return wrapped_error;
    };

    var promising_ajax = function(url, settings) {
        /**
         * Like $.ajax, but returning an ES6 promise. success and error settings
         * will be ignored.
         */
        settings = settings || {};
        return new Promise(function(resolve, reject) {
            settings.success = function(data, status, jqXHR) {
                resolve(data);
            };
            settings.error = function(jqXHR, status, error) {
                log_ajax_error(jqXHR, status, error);
                reject(wrap_ajax_error(jqXHR, status, error));
            };
            $.ajax(url, settings);
        });
    };

    var WrappedError = function(message, error){
        /**
         * Wrappable Error class
         *
         * The Error class doesn't actually act on `this`.  Instead it always
         * returns a new instance of Error.  Here we capture that instance so we
         * can apply it's properties to `this`.
         */
        var tmp = Error.apply(this, [message]);

        // Copy the properties of the error over to this.
        var properties = Object.getOwnPropertyNames(tmp);
        for (var i = 0; i < properties.length; i++) {
            this[properties[i]] = tmp[properties[i]];
        }

        // Keep a stack of the original error messages.
        if (error instanceof WrappedError) {
            this.error_stack = error.error_stack;
        } else {
            this.error_stack = [error];
        }
        this.error_stack.push(tmp);

        return this;
    };

    WrappedError.prototype = Object.create(Error.prototype, {});


    var load_class = function(class_name, module_name, registry) {
        /**
         * Tries to load a class
         *
         * Tries to load a class from a module using require.js, if a module 
         * is specified, otherwise tries to load a class from the global 
         * registry, if the global registry is provided.
         */
        return new Promise(function(resolve, reject) {

            // Try loading the view module using require.js
            if (module_name) {
                requirejs([module_name], function(module) {
                    if (module[class_name] === undefined) {
                        reject(new Error('Class '+class_name+' not found in module '+module_name));
                    } else {
                        resolve(module[class_name]);
                    }
                }, reject);
            } else {
                if (registry && registry[class_name]) {
                    resolve(registry[class_name]);
                } else {
                    reject(new Error('Class '+class_name+' not found in registry '));
                }
            }
        });
    };

    var resolve_promises_dict = function(d) {
        /**
         * Resolve a promiseful dictionary.
         * Returns a single Promise.
         */
        var keys = Object.keys(d);
        var values = [];
        keys.forEach(function(key) {
            values.push(d[key]);
        });
        return Promise.all(values).then(function(v) {
            d = {};
            for(var i=0; i<keys.length; i++) {
                d[keys[i]] = v[i];
            }
            return d;
        });
    };

    var reject = function(message, log) {
        /**
         * Creates a wrappable Promise rejection function.
         * 
         * Creates a function that returns a Promise.reject with a new WrappedError
         * that has the provided message and wraps the original error that 
         * caused the promise to reject.
         */
        return function(error) { 
            var wrapped_error = new WrappedError(message, error);
            if (log) console.error(wrapped_error); 
            return Promise.reject(wrapped_error); 
        };
    };

    var typeset = function(element, text) {
        /**
         * Apply MathJax rendering to an element, and optionally set its text
         *
         * If MathJax is not available, make no changes.
         *
         * Returns the output any number of typeset elements, or undefined if
         * MathJax was not available.
         *
         * Parameters
         * ----------
         * element: Node, NodeList, or jQuery selection
         * text: option string
         */
        var $el = element.jquery ? element : $(element);
        if(arguments.length > 1){
            $el.text(text);
        }
        if(!window.MathJax){
            return;
        }
        return $el.map(function(){
            // MathJax takes a DOM node: $.map makes `this` the context
            return MathJax.Hub.Queue(["Typeset", MathJax.Hub, this]);
        });
    };

    var time = {};
    time.milliseconds = {};
    time.milliseconds.s = 1000;
    time.milliseconds.m = 60 * time.milliseconds.s;
    time.milliseconds.h = 60 * time.milliseconds.m;
    time.milliseconds.d = 24 * time.milliseconds.h;

    time.thresholds = {
        // moment.js thresholds in milliseconds
        s: moment.relativeTimeThreshold('s') * time.milliseconds.s,
        m: moment.relativeTimeThreshold('m') * time.milliseconds.m,
        h: moment.relativeTimeThreshold('h') * time.milliseconds.h,
        d: moment.relativeTimeThreshold('d') * time.milliseconds.d,
    };

    time.timeout_from_dt = function (dt) {
        /** compute a timeout based on dt
        
        input and output both in milliseconds
        
        use moment's relative time thresholds:
        
        - 10 seconds if in 'seconds ago' territory
        - 1 minute if in 'minutes ago'
        - 1 hour otherwise
        */
        if (dt < time.thresholds.s) {
            return 10 * time.milliseconds.s;
        } else if (dt < time.thresholds.m) {
            return time.milliseconds.m;
        } else {
            return time.milliseconds.h;
        }
    };

    module.exports = {
        load_extension: load_extension,
        load_extensions: load_extensions,
        load_extensions_from_config: load_extensions_from_config,
        regex_split : regex_split,
        uuid : uuid,
        fixConsole : fixConsole,
        fixCarriageReturn : fixCarriageReturn,
        autoLinkUrls : autoLinkUrls,
        points_to_pixels : points_to_pixels,
        get_body_data : get_body_data,
        parse_url : parse_url,
        url_path_split : url_path_split,
        url_path_join : url_path_join,
        url_join_encode : url_join_encode,
        encode_uri_components : encode_uri_components,
        splitext : splitext,
        escape_html : escape_html,
        always_new : always_new,
        to_absolute_cursor_pos : to_absolute_cursor_pos,
        from_absolute_cursor_pos : from_absolute_cursor_pos,
        browser : browser,
        platform: platform,
        get_url_param: get_url_param,
        is_or_has : is_or_has,
        is_focused : is_focused,
        mergeopt: mergeopt,
        ajax_error_msg : ajax_error_msg,
        log_ajax_error : log_ajax_error,
        requireCodeMirrorMode : requireCodeMirrorMode,
        XHR_ERROR : XHR_ERROR,
        wrap_ajax_error : wrap_ajax_error,
        promising_ajax : promising_ajax,
        WrappedError: WrappedError,
        load_class: load_class,
        resolve_promises_dict: resolve_promises_dict,
        reject: reject,
        typeset: typeset,
        time: time,
    };

},{"moment":"/Users/jon/jupyter/notebook/node_modules/moment/moment.js"}],"/Users/jon/jupyter/notebook/notebook/static-src/notebook/js/cell.js":[function(require,module,exports){
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.

/**
 *
 *
 * @module cell
 * @namespace cell
 * @class Cell
 */
    "use strict";

    var utils = require('base/js/utils');

    var overlayHack = CodeMirror.scrollbarModel.native.prototype.overlayHack;

    CodeMirror.scrollbarModel.native.prototype.overlayHack = function () {
        overlayHack.apply(this, arguments);
        // Reverse `min-height: 18px` scrollbar hack on OS X
        // which causes a dead area, making it impossible to click on the last line
        // when there is horizontal scrolling to do and the "show scrollbar only when scrolling" behavior
        // is enabled.
        // This, in turn, has the undesirable behavior of never showing the horizontal scrollbar,
        // even when it should, which is less problematic, at least.
        if (/Mac/.test(navigator.platform)) {
            this.horiz.style.minHeight = "";
        }
    };

    var Cell = function (options) {
        /* Constructor
         *
         * The Base `Cell` class from which to inherit.
         * @constructor
         * @param:
         *  options: dictionary
         *      Dictionary of keyword arguments.
         *          events: $(Events) instance
         *          config: dictionary
         *          keyboard_manager: KeyboardManager instance
         */
        options = options || {};
        this.keyboard_manager = options.keyboard_manager;
        this.events = options.events;
        var config = utils.mergeopt(Cell, options.config);
        // superclass default overwrite our default
        
        this.placeholder = config.placeholder || '';
        this.selected = false;
        this.in_selection = false;
        this.selection_anchor = false;
        this.rendered = false;
        this.mode = 'command';

        // Metadata property
        var that = this;
        this._metadata = {};
        Object.defineProperty(this, 'metadata', {
            get: function() { return that._metadata; },
            set: function(value) {
                that._metadata = value;
                if (that.celltoolbar) {
                    that.celltoolbar.rebuild();
                }
            }
        });

        // backward compat.
        Object.defineProperty(this, 'cm_config', {
            get: function() {
                console.warn("Warning: accessing Cell.cm_config directly is deprecate.")
                return that._options.cm_config;
            },
        });

        // load this from metadata later ?
        this.user_highlight = 'auto';


        var _local_cm_config = {};
        if(this.class_config){
            _local_cm_config = this.class_config.get_sync('cm_config');
        }
        config.cm_config = utils.mergeopt({}, config.cm_config, _local_cm_config);
        this.cell_id = utils.uuid();
        this._options = config;

        // For JS VM engines optimization, attributes should be all set (even
        // to null) in the constructor, and if possible, if different subclass
        // have new attributes with same name, they should be created in the
        // same order. Easiest is to create and set to null in parent class.

        this.element = null;
        this.cell_type = this.cell_type || null;
        this.code_mirror = null;

        this.create_element();
        if (this.element !== null) {
            this.element.data("cell", this);
            this.bind_events();
            this.init_classes();
        }
    };

    Cell.options_default = {
        cm_config : {
            indentUnit : 4,
            readOnly: false,
            theme: "default",
            extraKeys: {
                "Cmd-Right":"goLineRight",
                "End":"goLineRight",
                "Cmd-Left":"goLineLeft"
            }
        }
    };

    // FIXME: Workaround CM Bug #332 (Safari segfault on drag)
    // by disabling drag/drop altogether on Safari
    // https://github.com/codemirror/CodeMirror/issues/332    
    if (utils.browser[0] == "Safari") {
        Cell.options_default.cm_config.dragDrop = false;
    }

    /**
     * Empty. Subclasses must implement create_element.
     * This should contain all the code to create the DOM element in notebook
     * and will be called by Base Class constructor.
     * @method create_element
     */
    Cell.prototype.create_element = function () {
    };

    Cell.prototype.init_classes = function () {
        /**
         * Call after this.element exists to initialize the css classes
         * related to selected, rendered and mode.
         */
        if (this.in_selection) {
            this.element.addClass('selected');
        } else {
            this.element.addClass('unselected');
        }
        if (this.rendered) {
            this.element.addClass('rendered');
        } else {
            this.element.addClass('unrendered');
        }
    };

    /**
     * Subclasses can implement override bind_events.
     * Be carefull to call the parent method when overwriting as it fires event.
     * this will be triggerd after create_element in constructor.
     * @method bind_events
     */
    Cell.prototype.bind_events = function () {
        var that = this;
        // We trigger events so that Cell doesn't have to depend on Notebook.
        that.element.click(function (event) {
            if (!that.selected) {
                that.events.trigger('select.Cell', {'cell':that});
            }
        });
        that.element.focusin(function (event) {
            if (!that.selected) {
                that.events.trigger('select.Cell', {'cell':that});
            }
        });
        if (this.code_mirror) {
            this.code_mirror.on("change", function(cm, change) {
                that.events.trigger("set_dirty.Notebook", {value: true});
            });
        }
        if (this.code_mirror) {
            this.code_mirror.on('focus', function(cm, change) {
                that.events.trigger('edit_mode.Cell', {cell: that});
            });
        }
        if (this.code_mirror) {
            this.code_mirror.on('blur', function(cm, change) {
                that.events.trigger('command_mode.Cell', {cell: that});
            });
        }

        this.element.dblclick(function () {
            if (that.selected === false) {
                this.events.trigger('select.Cell', {'cell':that});
            }
            var cont = that.unrender();
            if (cont) {
                that.focus_editor();
            }
        });
    };

    /**
     * This method gets called in CodeMirror's onKeyDown/onKeyPress
     * handlers and is used to provide custom key handling.
     *
     * To have custom handling, subclasses should override this method, but still call it
     * in order to process the Edit mode keyboard shortcuts.
     *
     * @method handle_codemirror_keyevent
     * @param {CodeMirror} editor - The codemirror instance bound to the cell
     * @param {event} event - key press event which either should or should not be handled by CodeMirror
     * @return {Boolean} `true` if CodeMirror should ignore the event, `false` Otherwise
     */
    Cell.prototype.handle_codemirror_keyevent = function (editor, event) {
        var shortcuts = this.keyboard_manager.edit_shortcuts;

        var cur = editor.getCursor();
        if((cur.line !== 0 || cur.ch !==0) && event.keyCode === 38){
            event._ipkmIgnore = true;
        }
        var nLastLine = editor.lastLine();
        if ((event.keyCode === 40) &&
             ((cur.line !== nLastLine) ||
               (cur.ch !== editor.getLineHandle(nLastLine).text.length))
           ) {
            event._ipkmIgnore = true;
        }
        // if this is an edit_shortcuts shortcut, the global keyboard/shortcut
        // manager will handle it
        if (shortcuts.handles(event)) {
            return true;
        }
        
        return false;
    };


    /**
     * Triger typsetting of math by mathjax on current cell element
     * @method typeset
     */
    Cell.prototype.typeset = function () {
        utils.typeset(this.element);
    };

    /**
     * handle cell level logic when a cell is selected
     * @method select
     * @return is the action being taken
     */
    Cell.prototype.select = function () {
        if (!this.selected) {
            this.element.addClass('selected');
            this.element.removeClass('unselected');
            this.selected = true;
            this.in_selection = true;
            return true;
        } else {
            return false;
        }
    };

    /**
     * handle cell level logic when the cursor moves away from a cell
     * @method unselect
     * @param {bool} leave_selected - true to move cursor away and extend selection
     * @return is the action being taken
     */
    Cell.prototype.unselect = function (leave_selected) {
        var was_selected_cell = this.selected;
        this.selected = false;
        if ((!leave_selected) && this.in_selection) {
            this.in_selection = false;
            this.selection_anchor = false;
            this.element.addClass('unselected');
            this.element.removeClass('selected');
        }
        return was_selected_cell;
    };

    /**
     * should be overritten by subclass
     * @method execute
     */
    Cell.prototype.execute = function () {
        return;
    };

    /**
     * handle cell level logic when a cell is rendered
     * @method render
     * @return is the action being taken
     */
    Cell.prototype.render = function () {
        if (!this.rendered) {
            this.element.addClass('rendered');
            this.element.removeClass('unrendered');
            this.rendered = true;
            return true;
        } else {
            return false;
        }
    };

    /**
     * handle cell level logic when a cell is unrendered
     * @method unrender
     * @return is the action being taken
     */
    Cell.prototype.unrender = function () {
        if (this.rendered) {
            this.element.addClass('unrendered');
            this.element.removeClass('rendered');
            this.rendered = false;
            return true;
        } else {
            return false;
        }
    };

    /**
     * Delegates keyboard shortcut handling to either Jupyter keyboard
     * manager when in command mode, or CodeMirror when in edit mode
     *
     * @method handle_keyevent
     * @param {CodeMirror} editor - The codemirror instance bound to the cell
     * @param {event} - key event to be handled
     * @return {Boolean} `true` if CodeMirror should ignore the event, `false` Otherwise
     */
    Cell.prototype.handle_keyevent = function (editor, event) {
        if (this.mode === 'command') {
            return true;
        } else if (this.mode === 'edit') {
            return this.handle_codemirror_keyevent(editor, event);
        }
    };

    /**
     * @method at_top
     * @return {Boolean}
     */
    Cell.prototype.at_top = function () {
        var cm = this.code_mirror;
        var cursor = cm.getCursor();
        if (cursor.line === 0 && cursor.ch === 0) {
            return true;
        }
        return false;
    };

    /**
     * @method at_bottom
     * @return {Boolean}
     * */
    Cell.prototype.at_bottom = function () {
        var cm = this.code_mirror;
        var cursor = cm.getCursor();
        if (cursor.line === (cm.lineCount()-1) && cursor.ch === cm.getLine(cursor.line).length) {
            return true;
        }
        return false;
    };

    /**
     * enter the command mode for the cell
     * @method command_mode
     * @return is the action being taken
     */
    Cell.prototype.command_mode = function () {
        if (this.mode !== 'command') {
            this.mode = 'command';
            return true;
        } else {
            return false;
        }
    };

    /**
     * enter the edit mode for the cell
     * @method command_mode
     * @return is the action being taken
     */
    Cell.prototype.edit_mode = function () {
        if (this.mode !== 'edit') {
            this.mode = 'edit';
            return true;
        } else {
            return false;
        }
    };

    Cell.prototype.ensure_focused = function() {
        if(this.element !== document.activeElement && !this.code_mirror.hasFocus()){
            this.focus_cell();
        }
    }

    /**
     * Focus the cell in the DOM sense
     * @method focus_cell
     */
    Cell.prototype.focus_cell = function () {
        this.element.focus();
    };

    /**
     * Focus the editor area so a user can type
     *
     * NOTE: If codemirror is focused via a mouse click event, you don't want to
     * call this because it will cause a page jump.
     * @method focus_editor
     */
    Cell.prototype.focus_editor = function () {
        this.refresh();
        this.code_mirror.focus();
    };

    /**
     * Refresh codemirror instance
     * @method refresh
     */
    Cell.prototype.refresh = function () {
        if (this.code_mirror) {
            this.code_mirror.refresh();
        }
    };

    /**
     * should be overritten by subclass
     * @method get_text
     */
    Cell.prototype.get_text = function () {
    };

    /**
     * should be overritten by subclass
     * @method set_text
     * @param {string} text
     */
    Cell.prototype.set_text = function (text) {
    };

    /**
     * should be overritten by subclass
     * serialise cell to json.
     * @method toJSON
     **/
    Cell.prototype.toJSON = function () {
        var data = {};
        // deepcopy the metadata so copied cells don't share the same object
        data.metadata = JSON.parse(JSON.stringify(this.metadata));
        data.cell_type = this.cell_type;
        return data;
    };

    /**
     * should be overritten by subclass
     * @method fromJSON
     **/
    Cell.prototype.fromJSON = function (data) {
        if (data.metadata !== undefined) {
            this.metadata = data.metadata;
        }
    };


    /**
     * can the cell be split into two cells (false if not deletable)
     * @method is_splittable
     **/
    Cell.prototype.is_splittable = function () {
        return this.is_deletable();
    };


    /**
     * can the cell be merged with other cells (false if not deletable)
     * @method is_mergeable
     **/
    Cell.prototype.is_mergeable = function () {
        return this.is_deletable();
    };

    /**
     * is the cell deletable? only false (undeletable) if
     * metadata.deletable is explicitly false -- everything else
     * counts as true
     *
     * @method is_deletable
     **/
    Cell.prototype.is_deletable = function () {
        if (this.metadata.deletable === false) {
            return false;
        }
        return true;
    };

    /**
     * @return {String} - the text before the cursor
     * @method get_pre_cursor
     **/
    Cell.prototype.get_pre_cursor = function () {
        var cursor = this.code_mirror.getCursor();
        var text = this.code_mirror.getRange({line:0, ch:0}, cursor);
        text = text.replace(/^\n+/, '').replace(/\n+$/, '');
        return text;
    };


    /**
     * @return {String} - the text after the cursor
     * @method get_post_cursor
     **/
    Cell.prototype.get_post_cursor = function () {
        var cursor = this.code_mirror.getCursor();
        var last_line_num = this.code_mirror.lineCount()-1;
        var last_line_len = this.code_mirror.getLine(last_line_num).length;
        var end = {line:last_line_num, ch:last_line_len};
        var text = this.code_mirror.getRange(cursor, end);
        text = text.replace(/^\n+/, '').replace(/\n+$/, '');
        return text;
    };

    /**
     * Show/Hide CodeMirror LineNumber
     * @method show_line_numbers
     *
     * @param value {Bool}  show (true), or hide (false) the line number in CodeMirror
     **/
    Cell.prototype.show_line_numbers = function (value) {
        this.code_mirror.setOption('lineNumbers', value);
        this.code_mirror.refresh();
    };

    /**
     * Toggle  CodeMirror LineNumber
     * @method toggle_line_numbers
     **/
    Cell.prototype.toggle_line_numbers = function () {
        var val = this.code_mirror.getOption('lineNumbers');
        this.show_line_numbers(!val);
    };

    /**
     * Force codemirror highlight mode
     * @method force_highlight
     * @param {object} - CodeMirror mode
     **/
    Cell.prototype.force_highlight = function(mode) {
        this.user_highlight = mode;
        this.auto_highlight();
    };

    /**
     * Trigger autodetection of highlight scheme for current cell
     * @method auto_highlight
     */
    Cell.prototype.auto_highlight = function () {
        this._auto_highlight(this.class_config.get_sync('highlight_modes'));
    };

    /**
     * Try to autodetect cell highlight mode, or use selected mode
     * @methods _auto_highlight
     * @private
     * @param {String|object|undefined} - CodeMirror mode | 'auto'
     **/
    Cell.prototype._auto_highlight = function (modes) {
        /**
         *Here we handle manually selected modes
         */
        var that = this;
        var mode;
        if( this.user_highlight !== undefined &&  this.user_highlight != 'auto' )
        {
            mode = this.user_highlight;
            CodeMirror.autoLoadMode(this.code_mirror, mode);
            this.code_mirror.setOption('mode', mode);
            return;
        }
        var current_mode = this.code_mirror.getOption('mode', mode);
        var first_line = this.code_mirror.getLine(0);
        // loop on every pairs
        for(mode in modes) {
            var regs = modes[mode].reg;
            // only one key every time but regexp can't be keys...
            for(var i=0; i<regs.length; i++) {
                // here we handle non magic_modes.
                // TODO :
                // On 3.0 and below, these things were regex.
                // But now should be string for json-able config. 
                // We should get rid of assuming they might be already 
                // in a later version of Jupyter.
                var re = regs[i];
                if(typeof(re) === 'string'){
                    re = new RegExp(re) 
                }
                if(first_line.match(re) !== null) {
                    if(current_mode == mode){
                        return;
                    }
                    if (mode.search('magic_') !== 0) {
                        utils.requireCodeMirrorMode(mode, function (spec) {
                            that.code_mirror.setOption('mode', spec);
                        });
                        return;
                    }
                    var open = modes[mode].open || "%%";
                    var close = modes[mode].close || "%%end";
                    var magic_mode = mode;
                    mode = magic_mode.substr(6);
                    if(current_mode == magic_mode){
                        return;
                    }
                    utils.requireCodeMirrorMode(mode, function (spec) {
                        // create on the fly a mode that switch between
                        // plain/text and something else, otherwise `%%` is
                        // source of some highlight issues.
                        CodeMirror.defineMode(magic_mode, function(config) {
                            return CodeMirror.multiplexingMode(
                                CodeMirror.getMode(config, 'text/plain'),
                                // always set something on close
                                {open: open, close: close,
                                 mode: CodeMirror.getMode(config, spec),
                                 delimStyle: "delimit"
                                }
                            );
                        });
                        that.code_mirror.setOption('mode', magic_mode);
                    });
                    return;
                }
            }
        }
        // fallback on default
        var default_mode;
        try {
            default_mode = this._options.cm_config.mode;
        } catch(e) {
            default_mode = 'text/plain';
        }
        if( current_mode === default_mode){
            return;
        }
        this.code_mirror.setOption('mode', default_mode);
    };

    var UnrecognizedCell = function (options) {
        /** Constructor for unrecognized cells */
        Cell.apply(this, arguments);
        this.cell_type = 'unrecognized';
        this.celltoolbar = null;
        this.data = {};
        
        Object.seal(this);
    };

    UnrecognizedCell.prototype = Object.create(Cell.prototype);


    // cannot merge or split unrecognized cells
    UnrecognizedCell.prototype.is_mergeable = function () {
        return false;
    };

    UnrecognizedCell.prototype.is_splittable = function () {
        return false;
    };

    UnrecognizedCell.prototype.toJSON = function () {
        /**
         * deepcopy the metadata so copied cells don't share the same object
         */
        return JSON.parse(JSON.stringify(this.data));
    };

    UnrecognizedCell.prototype.fromJSON = function (data) {
        this.data = data;
        if (data.metadata !== undefined) {
            this.metadata = data.metadata;
        } else {
            data.metadata = this.metadata;
        }
        this.element.find('.inner_cell').find("a").text("Unrecognized cell type: " + data.cell_type);
    };

    UnrecognizedCell.prototype.create_element = function () {
        Cell.prototype.create_element.apply(this, arguments);
        var cell = this.element = $("<div>").addClass('cell unrecognized_cell');
        cell.attr('tabindex','2');

        var prompt = $('<div/>').addClass('prompt input_prompt');
        cell.append(prompt);
        var inner_cell = $('<div/>').addClass('inner_cell');
        inner_cell.append(
            $("<a>")
                .attr("href", "#")
                .text("Unrecognized cell type")
        );
        cell.append(inner_cell);
        this.element = cell;
    };

    UnrecognizedCell.prototype.bind_events = function () {
        Cell.prototype.bind_events.apply(this, arguments);
        var cell = this;
        
        this.element.find('.inner_cell').find("a").click(function () {
            cell.events.trigger('unrecognized_cell.Cell', {cell: cell});
        });
    };

    module.exports = {
        Cell: Cell,
        UnrecognizedCell: UnrecognizedCell
    };

},{"base/js/utils":"/Users/jon/jupyter/notebook/notebook/static-src/base/js/utils.js"}],"/Users/jon/jupyter/notebook/notebook/static-src/notebook/js/celltoolbar.js":[function(require,module,exports){
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
    "use strict";

    var IPython = require('base/js/namespace');
    var events = require('base/js/events');

    var CellToolbar = function (options) {
        /**
         * Constructor
         *
         * Parameters:
         *  options: dictionary
         *      Dictionary of keyword arguments.
         *          events: $(Events) instance 
         *          cell: Cell instance
         *          notebook: Notebook instance 
         *
         *  TODO: This leaks, when cell are deleted
         *  There is still a reference to each celltoolbars.
         */
        CellToolbar._instances.push(this);
        this.notebook = options.notebook;
        this.cell = options.cell;
        this.create_element();
        this.rebuild();
        return this;
    };


    CellToolbar.prototype.create_element = function () {
        this.inner_element = $('<div/>').addClass('celltoolbar');
        this.element = $('<div/>').addClass('ctb_hideshow')
            .append(this.inner_element);
    };


    // The default css style for the outer celltoolbar div
    // (ctb_hideshow) is display: none.
    // To show the cell toolbar, *both* of the following conditions must be met:
    // - A parent container has class `ctb_global_show`
    // - The celltoolbar has the class `ctb_show`
    // This allows global show/hide, as well as per-cell show/hide.

    CellToolbar.global_hide = function () {
        $('body').removeClass('ctb_global_show');
    };


    CellToolbar.global_show = function () {
        $('body').addClass('ctb_global_show');
    };


    CellToolbar.prototype.hide = function () {
        this.element.removeClass('ctb_show');
    };


    CellToolbar.prototype.show = function () {
        this.element.addClass('ctb_show');
    };


    /**
     * Class variable that should contain a dict of all available callback
     * we need to think of wether or not we allow nested namespace
     * @property _callback_dict
     * @private
     * @static
     * @type Dict
     */
    CellToolbar._callback_dict = {};


    /**
     * Class variable that should contain the reverse order list of the button
     * to add to the toolbar of each cell
     * @property _ui_controls_list
     * @private
     * @static
     * @type List
     */
    CellToolbar._ui_controls_list = [];


    /**
     * Class variable that should contain the CellToolbar instances for each
     * cell of the notebook
     *
     * @private
     * @property _instances
     * @static
     * @type List
     */
    CellToolbar._instances = [];


    /**
     * keep a list of all the available presets for the toolbar
     * @private
     * @property _presets
     * @static
     * @type Dict
     */
    CellToolbar._presets = {};


    // this is by design not a prototype.
    /**
     * Register a callback to create an UI element in a cell toolbar.
     * @method register_callback
     * @param name {String} name to use to refer to the callback. It is advised to use a prefix with the name
     * for easier sorting and avoid collision
     * @param callback {function(div, cell)} callback that will be called to generate the ui element
     * @param [cell_types] {List_of_String|undefined} optional list of cell types. If present the UI element
     * will be added only to cells of types in the list.
     *
     *
     * The callback will receive the following element :
     *
     *    * a div in which to add element.
     *    * the cell it is responsible from
     *
     * @example
     *
     * Example that create callback for a button that toggle between `true` and `false` label,
     * with the metadata under the key 'foo' to reflect the status of the button.
     *
     *      // first param reference to a DOM div
     *      // second param reference to the cell.
     *      var toggle =  function(div, cell) {
     *          var button_container = $(div)
     *
     *          // let's create a button that show the  current value of the metadata
     *          var button = $('<div/>').button({label:String(cell.metadata.foo)});
     *
     *          // On click, change the metadata value and update the button label
     *          button.click(function(){
     *                      var v = cell.metadata.foo;
     *                      cell.metadata.foo = !v;
     *                      button.button("option", "label", String(!v));
     *                  })
     *
     *          // add the button to the DOM div.
     *          button_container.append(button);
     *      }
     *
     *      // now we register the callback under the name `foo` to give the
     *      // user the ability to use it later
     *      CellToolbar.register_callback('foo', toggle);
     */
    CellToolbar.register_callback = function(name, callback, cell_types) {
        // Overwrite if it already exists.
        CellToolbar._callback_dict[name] = cell_types ? {callback: callback, cell_types: cell_types} : callback;
    };


    /**
     * Register a preset of UI element in a cell toolbar.
     * Not supported Yet.
     * @method register_preset
     * @param name {String} name to use to refer to the preset. It is advised to use a prefix with the name
     * for easier sorting and avoid collision
     * @param  preset_list {List_of_String} reverse order of the button in the toolbar. Each String of the list
     *          should correspond to a name of a registerd callback.
     *
     * @private
     * @example
     *
     *      CellToolbar.register_callback('foo.c1', function(div, cell){...});
     *      CellToolbar.register_callback('foo.c2', function(div, cell){...});
     *      CellToolbar.register_callback('foo.c3', function(div, cell){...});
     *      CellToolbar.register_callback('foo.c4', function(div, cell){...});
     *      CellToolbar.register_callback('foo.c5', function(div, cell){...});
     *
     *      CellToolbar.register_preset('foo.foo_preset1', ['foo.c1', 'foo.c2', 'foo.c5'])
     *      CellToolbar.register_preset('foo.foo_preset2', ['foo.c4', 'foo.c5'])
     */
    CellToolbar.register_preset = function(name, preset_list, notebook) {
        CellToolbar._presets[name] = preset_list;
        events.trigger('preset_added.CellToolbar', {name: name});
        // When "register_callback" is called by a custom extension, it may be executed after notebook is loaded.
        // In that case, activate the preset if needed.
        if (notebook && notebook.metadata && notebook.metadata.celltoolbar === name){
            CellToolbar.activate_preset(name);
        }
    };

    /**
     * unregister the selected preset, 
     *
     * return true if preset successfully unregistered
     * false otherwise
     *
     **/
    CellToolbar.unregister_preset = function(name){
        if(CellToolbar._presets[name]){
            delete CellToolbar._presets[name];
            events.trigger('unregistered_preset.CellToolbar', {name: name});
            return true
        }
        return false
    }


    /**
     * List the names of the presets that are currently registered.
     *
     * @method list_presets
     * @static
     */
    CellToolbar.list_presets = function() {
        var keys = [];
        for (var k in CellToolbar._presets) {
            keys.push(k);
        }
        return keys;
    };


    /**
     * Activate an UI preset from `register_preset`
     *
     * This does not update the selection UI.
     *
     * @method activate_preset
     * @param preset_name {String} string corresponding to the preset name
     *
     * @static
     * @private
     * @example
     *
     *      CellToolbar.activate_preset('foo.foo_preset1');
     */
    CellToolbar.activate_preset = function(preset_name){
        var preset = CellToolbar._presets[preset_name];

        if(preset !== undefined){
            CellToolbar._ui_controls_list = preset;
            CellToolbar.rebuild_all();
        }

        events.trigger('preset_activated.CellToolbar', {name: preset_name});
    };


    /**
     * This should be called on the class and not on a instance as it will trigger
     * rebuild of all the instances.
     * @method rebuild_all
     * @static
     *
     */
    CellToolbar.rebuild_all = function(){
        for(var i=0; i < CellToolbar._instances.length; i++){
            CellToolbar._instances[i].rebuild();
        }
    };

    /**
     * Rebuild all the button on the toolbar to update its state.
     * @method rebuild
     */
    CellToolbar.prototype.rebuild = function(){
        /**
         * strip evrything from the div
         * which is probably inner_element
         * or this.element.
         */
        this.inner_element.empty();
        this.ui_controls_list = [];

        var callbacks = CellToolbar._callback_dict;
        var preset = CellToolbar._ui_controls_list;
        // Yes we iterate on the class variable, not the instance one.
        for (var i=0; i < preset.length; i++) {
            var key = preset[i];
            var callback = callbacks[key];
            if (!callback) continue;

            if (typeof callback === 'object') {
                if (callback.cell_types.indexOf(this.cell.cell_type) === -1) continue;
                callback = callback.callback;
            }
            
            var local_div = $('<div/>').addClass('button_container');
            try {
                callback(local_div, this.cell, this);
                this.ui_controls_list.push(key);
            } catch (e) {
                console.log("Error in cell toolbar callback " + key, e);
                continue;
            }
            // only append if callback succeeded.
            this.inner_element.append(local_div);
        }

        // If there are no controls or the cell is a rendered TextCell hide the toolbar.
        if (!this.ui_controls_list.length) {
            this.hide();
        } else {
            this.show();
        }
    };


    CellToolbar.utils = {};


    /**
     * A utility function to generate bindings between a checkbox and cell/metadata
     * @method utils.checkbox_ui_generator
     * @static
     *
     * @param name {string} Label in front of the checkbox
     * @param setter {function( cell, newValue )}
     *        A setter method to set the newValue
     * @param getter {function( cell )}
     *        A getter methods which return the current value.
     *
     * @return callback {function( div, cell )} Callback to be passed to `register_callback`
     *
     * @example
     *
     * An exmple that bind the subkey `slideshow.isSectionStart` to a checkbox with a `New Slide` label
     *
     *     var newSlide = CellToolbar.utils.checkbox_ui_generator('New Slide',
     *          // setter
     *          function(cell, value){
     *              // we check that the slideshow namespace exist and create it if needed
     *              if (cell.metadata.slideshow == undefined){cell.metadata.slideshow = {}}
     *              // set the value
     *              cell.metadata.slideshow.isSectionStart = value
     *              },
     *          //geter
     *          function(cell){ var ns = cell.metadata.slideshow;
     *              // if the slideshow namespace does not exist return `undefined`
     *              // (will be interpreted as `false` by checkbox) otherwise
     *              // return the value
     *              return (ns == undefined)? undefined: ns.isSectionStart
     *              }
     *      );
     *
     *      CellToolbar.register_callback('newSlide', newSlide);
     *
     */
    CellToolbar.utils.checkbox_ui_generator = function(name, setter, getter){
        return function(div, cell, celltoolbar) {
            var button_container = $(div);

            var chkb = $('<input/>').attr('type', 'checkbox');
            var lbl = $('<label/>').append($('<span/>').text(name));
            lbl.append(chkb);
            chkb.attr("checked", getter(cell));

            chkb.click(function(){
                        var v = getter(cell);
                        setter(cell, !v);
                        chkb.attr("checked", !v);
            });
            button_container.append($('<span/>').append(lbl));
        };
    };


    /**
     * A utility function to generate bindings between a input field and cell/metadata
     * @method utils.input_ui_generator
     * @static
     *
     * @param name {string} Label in front of the input field
     * @param setter {function( cell, newValue )}
     *        A setter method to set the newValue
     * @param getter {function( cell )}
     *        A getter methods which return the current value.
     *
     * @return callback {function( div, cell )} Callback to be passed to `register_callback`
     *
     */
    CellToolbar.utils.input_ui_generator = function(name, setter, getter){
        return function(div, cell, celltoolbar) {
            var button_container = $(div);

            var text = $('<input/>').attr('type', 'text');
            var lbl = $('<label/>').append($('<span/>').text(name));
            lbl.append(text);
            text.attr("value", getter(cell));

            text.keyup(function(){
                setter(cell, text.val());
            });
            button_container.append($('<span/>').append(lbl));
            IPython.keyboard_manager.register_events(text);
        };
    };

    /**
     * A utility function to generate bindings between a dropdown list cell
     * @method utils.select_ui_generator
     * @static
     *
     * @param list_list {list_of_sublist} List of sublist of metadata value and name in the dropdown list.
     *        subslit shoud contain 2 element each, first a string that woul be displayed in the dropdown list,
     *        and second the corresponding value to  be passed to setter/return by getter. the corresponding value 
     *        should not be "undefined" or behavior can be unexpected.
     * @param setter {function( cell, newValue )}
     *        A setter method to set the newValue
     * @param getter {function( cell )}
     *        A getter methods which return the current value of the metadata.
     * @param [label=""] {String} optionnal label for the dropdown menu
     *
     * @return callback {function( div, cell )} Callback to be passed to `register_callback`
     *
     * @example
     *
     *      var select_type = CellToolbar.utils.select_ui_generator([
     *              ["<None>"       , "None"      ],
     *              ["Header Slide" , "header_slide" ],
     *              ["Slide"        , "slide"        ],
     *              ["Fragment"     , "fragment"     ],
     *              ["Skip"         , "skip"         ],
     *              ],
     *              // setter
     *              function(cell, value){
     *                  // we check that the slideshow namespace exist and create it if needed
     *                  if (cell.metadata.slideshow == undefined){cell.metadata.slideshow = {}}
     *                  // set the value
     *                  cell.metadata.slideshow.slide_type = value
     *                  },
     *              //geter
     *              function(cell){ var ns = cell.metadata.slideshow;
     *                  // if the slideshow namespace does not exist return `undefined`
     *                  // (will be interpreted as `false` by checkbox) otherwise
     *                  // return the value
     *                  return (ns == undefined)? undefined: ns.slide_type
     *                  }
     *      CellToolbar.register_callback('slideshow.select', select_type);
     *
     */
    CellToolbar.utils.select_ui_generator = function(list_list, setter, getter, label) {
        label = label || "";
        return function(div, cell, celltoolbar) {
            var button_container = $(div);
            var lbl = $("<label/>").append($('<span/>').text(label));
            var select = $('<select/>');
            for(var i=0; i < list_list.length; i++){
                var opt = $('<option/>')
                    .attr('value', list_list[i][1])
                    .text(list_list[i][0]);
                select.append(opt);
            }
            select.val(getter(cell));
            select.change(function(){
                        setter(cell, select.val());
                    });
            button_container.append($('<span/>').append(lbl).append(select));
        };
    };

    // Backwards compatability.
    IPython.CellToolbar = CellToolbar;

    exports.CellToolbar = CellToolbar;

},{"base/js/events":"/Users/jon/jupyter/notebook/notebook/static-src/base/js/events.js","base/js/namespace":"/Users/jon/jupyter/notebook/notebook/static-src/base/js/namespace.js"}],"/Users/jon/jupyter/notebook/notebook/static-src/notebook/js/celltoolbarpresets/default.js":[function(require,module,exports){
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
    "use strict";

    var celltoolbar = require('notebook/js/celltoolbar');
    var dialog = require('base/js/dialog');

    var CellToolbar = celltoolbar.CellToolbar;

    var raw_edit = function (cell) {
        dialog.edit_metadata({
            md: cell.metadata,
            callback: function (md) {
                cell.metadata = md;
            },
            name: 'Cell',
            notebook: this.notebook,
            keyboard_manager: this.keyboard_manager
        });
    };

    var add_raw_edit_button = function(div, cell) {
        var button_container = $(div);
        var button = $('<button/>')
            .addClass("btn btn-default btn-xs")
            .text("Edit Metadata")
            .click( function () {
                raw_edit(cell);
                return false;
            });
        button_container.append(button);
    };

    var register = function (notebook) {
        CellToolbar.register_callback('default.rawedit', add_raw_edit_button);
        raw_edit = $.proxy(raw_edit, {
            notebook: notebook,
            keyboard_manager: notebook.keyboard_manager
        });

        var example_preset = [];
        example_preset.push('default.rawedit');

        CellToolbar.register_preset('Edit Metadata', example_preset, notebook);
        console.log('Default extension for cell metadata editing loaded.');
    };
    exports.register = register;

},{"base/js/dialog":"/Users/jon/jupyter/notebook/notebook/static-src/base/js/dialog.js","notebook/js/celltoolbar":"/Users/jon/jupyter/notebook/notebook/static-src/notebook/js/celltoolbar.js"}],"/Users/jon/jupyter/notebook/notebook/static-src/notebook/js/celltoolbarpresets/rawcell.js":[function(require,module,exports){
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
    "use strict";

    var celltoolbar = require('notebook/js/celltoolbar');
    var dialog = require('base/js/dialog');
    var keyboard = require('base/js/keyboard');

    var CellToolbar = celltoolbar.CellToolbar;
    var raw_cell_preset = [];

    var select_type = CellToolbar.utils.select_ui_generator([
    ["None", "-"],
    ["LaTeX", "text/latex"],
    ["reST", "text/restructuredtext"],
    ["HTML", "text/html"],
    ["Markdown", "text/markdown"],
    ["Python", "text/x-python"],
    ["Custom", "dialog"],

    ],
      // setter
      function(cell, value) {
        if (value === "-") {
          delete cell.metadata.raw_mimetype;
        } else if (value === 'dialog'){
            var dialog = $('<div/>').append(
                $("<p/>")
                    .text("Set the MIME type of the raw cell:")
            ).append(
                $("<br/>")
            ).append(
                $('<input/>').attr('type','text').attr('size','25')
                .val(cell.metadata.raw_mimetype || "-")
            );
            dialog.modal({
                title: "Raw Cell MIME Type",
                body: dialog,
                buttons : {
                    "Cancel": {},
                    "OK": {
                        class: "btn-primary",
                        click: function () {
                            console.log(cell);
                            cell.metadata.raw_mimetype = $(this).find('input').val();
                            console.log(cell.metadata);
                        }
                    }
                },
                open : function (event, ui) {
                    var that = $(this);
                    // Upon ENTER, click the OK button.
                    that.find('input[type="text"]').keydown(function (event, ui) {
                        if (event.which === keyboard.keycodes.enter) {
                            that.find('.btn-primary').first().click();
                            return false;
                        }
                    });
                    that.find('input[type="text"]').focus().select();
                }
            });
        } else {
          cell.metadata.raw_mimetype = value;
        }
      },
      //getter
      function(cell) {
        return cell.metadata.raw_mimetype || "";
      },
      // name
      "Raw NBConvert Format"
    );

    var register = function (notebook) {
    CellToolbar.register_callback('raw_cell.select', select_type, ['raw']);
    raw_cell_preset.push('raw_cell.select');

    CellToolbar.register_preset('Raw Cell Format', raw_cell_preset, notebook);
    console.log('Raw Cell Format toolbar preset loaded.');
    };
    exports.register = register;

},{"base/js/dialog":"/Users/jon/jupyter/notebook/notebook/static-src/base/js/dialog.js","base/js/keyboard":"/Users/jon/jupyter/notebook/notebook/static-src/base/js/keyboard.js","notebook/js/celltoolbar":"/Users/jon/jupyter/notebook/notebook/static-src/notebook/js/celltoolbar.js"}],"/Users/jon/jupyter/notebook/notebook/static-src/notebook/js/celltoolbarpresets/slideshow.js":[function(require,module,exports){
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
    "use strict";

    var celltoolbar = require('notebook/js/celltoolbar');

    var CellToolbar = celltoolbar.CellToolbar;
    var slideshow_preset = [];

    var select_type = CellToolbar.utils.select_ui_generator([
            ["-"            ,"-"            ],
            ["Slide"        ,"slide"        ],
            ["Sub-Slide"    ,"subslide"     ],
            ["Fragment"     ,"fragment"     ],
            ["Skip"         ,"skip"         ],
            ["Notes"        ,"notes"        ],
            ],
            // setter
            function(cell, value){
                // we check that the slideshow namespace exist and create it if needed
                if (cell.metadata.slideshow === undefined){cell.metadata.slideshow = {};}
                // set the value
                cell.metadata.slideshow.slide_type = value;
                },
            //geter
            function(cell){ var ns = cell.metadata.slideshow;
                // if the slideshow namespace does not exist return `undefined`
                // (will be interpreted as `false` by checkbox) otherwise
                // return the value
                return (ns === undefined)? undefined: ns.slide_type;
                },
            "Slide Type");

    var register = function (notebook) {
        CellToolbar.register_callback('slideshow.select',select_type);
        slideshow_preset.push('slideshow.select');

        CellToolbar.register_preset('Slideshow',slideshow_preset, notebook);
        console.log('Slideshow extension for metadata editing loaded.');
    };
    exports.register = register;

},{"notebook/js/celltoolbar":"/Users/jon/jupyter/notebook/notebook/static-src/notebook/js/celltoolbar.js"}],"/Users/jon/jupyter/notebook/notebook/static-src/notebook/js/codecell.js":[function(require,module,exports){
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
/**
 *
 *
 * @module codecell
 * @namespace codecell
 * @class CodeCell
 */
    "use strict";

    var IPython = require('base/js/namespace');
    var utils = require('base/js/utils');
    var keyboard = require('base/js/keyboard');
    var configmod = require('services/config');
    var cell = require('notebook/js/cell');
    var outputarea = require('notebook/js/outputarea');
    var completer = require('notebook/js/completer');
    var celltoolbar = require('notebook/js/celltoolbar');

    var Cell = cell.Cell;

    /* local util for codemirror */
    var posEq = function(a, b) {return a.line === b.line && a.ch === b.ch;};

    /**
     *
     * function to delete until previous non blanking space character
     * or first multiple of 4 tabstop.
     * @private
     */
    CodeMirror.commands.delSpaceToPrevTabStop = function(cm){
        var from = cm.getCursor(true), to = cm.getCursor(false), sel = !posEq(from, to);
        if (!posEq(from, to)) { cm.replaceRange("", from, to); return; }
        var cur = cm.getCursor(), line = cm.getLine(cur.line);
        var tabsize = cm.getOption('tabSize');
        var chToPrevTabStop = cur.ch-(Math.ceil(cur.ch/tabsize)-1)*tabsize;
        from = {ch:cur.ch-chToPrevTabStop,line:cur.line};
        var select = cm.getRange(from,cur);
        if( select.match(/^\ +$/) !== null){
            cm.replaceRange("",from,cur);
        } else {
            cm.deleteH(-1,"char");
        }
    };

    var keycodes = keyboard.keycodes;

    var CodeCell = function (kernel, options) {
        /**
         * Constructor
         *
         * A Cell conceived to write code.
         *
         * Parameters:
         *  kernel: Kernel instance
         *      The kernel doesn't have to be set at creation time, in that case
         *      it will be null and set_kernel has to be called later.
         *  options: dictionary
         *      Dictionary of keyword arguments.
         *          events: $(Events) instance 
         *          config: dictionary
         *          keyboard_manager: KeyboardManager instance 
         *          notebook: Notebook instance
         *          tooltip: Tooltip instance
         */
        this.kernel = kernel || null;
        this.notebook = options.notebook;
        this.collapsed = false;
        this.events = options.events;
        this.tooltip = options.tooltip;
        this.config = options.config;
        this.class_config = new configmod.ConfigWithDefaults(this.config,
                                        CodeCell.config_defaults, 'CodeCell');

        // create all attributed in constructor function
        // even if null for V8 VM optimisation
        this.input_prompt_number = null;
        this.celltoolbar = null;
        this.output_area = null;

        this.last_msg_id = null;
        this.completer = null;

        Cell.apply(this,[{
            config: $.extend({}, CodeCell.options_default), 
            keyboard_manager: options.keyboard_manager, 
            events: this.events}]);

        // Attributes we want to override in this subclass.
        this.cell_type = "code";
        var that  = this;
        this.element.focusout(
            function() { that.auto_highlight(); }
        );
    };

    CodeCell.options_default = {
        cm_config : {
            extraKeys: {
                "Tab" :  "indentMore",
                "Shift-Tab" : "indentLess",
                "Backspace" : "delSpaceToPrevTabStop",
                "Cmd-/" : "toggleComment",
                "Ctrl-/" : "toggleComment"
            },
            mode: 'text',
            theme: 'ipython',
            matchBrackets: true,
            autoCloseBrackets: true
        },
        highlight_modes : {
            'magic_javascript'    :{'reg':['^%%javascript']},
            'magic_perl'          :{'reg':['^%%perl']},
            'magic_ruby'          :{'reg':['^%%ruby']},
            'magic_python'        :{'reg':['^%%python3?']},
            'magic_shell'         :{'reg':['^%%bash']},
            'magic_r'             :{'reg':['^%%R']},
            'magic_text/x-cython' :{'reg':['^%%cython']},
        },
    };

    CodeCell.config_defaults = CodeCell.options_default;

    CodeCell.msg_cells = {};

    CodeCell.prototype = Object.create(Cell.prototype);

    /** @method create_element */
    CodeCell.prototype.create_element = function () {
        Cell.prototype.create_element.apply(this, arguments);
        var that = this;

        var cell =  $('<div></div>').addClass('cell code_cell');
        cell.attr('tabindex','2');

        var input = $('<div></div>').addClass('input');
        this.input = input;
        var prompt = $('<div/>').addClass('prompt input_prompt');
        var inner_cell = $('<div/>').addClass('inner_cell');
        this.celltoolbar = new celltoolbar.CellToolbar({
            cell: this, 
            notebook: this.notebook});
        inner_cell.append(this.celltoolbar.element);
        var input_area = $('<div/>').addClass('input_area');
        this.code_mirror = new CodeMirror(input_area.get(0), this._options.cm_config);
        // In case of bugs that put the keyboard manager into an inconsistent state,
        // ensure KM is enabled when CodeMirror is focused:
        this.code_mirror.on('focus', function () {
            if (that.keyboard_manager) {
                that.keyboard_manager.enable();
            }
        });
        this.code_mirror.on('keydown', $.proxy(this.handle_keyevent,this));
        $(this.code_mirror.getInputField()).attr("spellcheck", "false");
        inner_cell.append(input_area);
        input.append(prompt).append(inner_cell);

        var output = $('<div></div>');
        cell.append(input).append(output);
        this.element = cell;
        this.output_area = new outputarea.OutputArea({
            selector: output, 
            prompt_area: true, 
            events: this.events, 
            keyboard_manager: this.keyboard_manager});
        this.completer = new completer.Completer(this, this.events);
    };

    /** @method bind_events */
    CodeCell.prototype.bind_events = function () {
        Cell.prototype.bind_events.apply(this);
        var that = this;

        this.element.focusout(
            function() { that.auto_highlight(); }
        );
    };


    /**
     *  This method gets called in CodeMirror's onKeyDown/onKeyPress
     *  handlers and is used to provide custom key handling. Its return
     *  value is used to determine if CodeMirror should ignore the event:
     *  true = ignore, false = don't ignore.
     *  @method handle_codemirror_keyevent
     */

    CodeCell.prototype.handle_codemirror_keyevent = function (editor, event) {

        var that = this;
        // whatever key is pressed, first, cancel the tooltip request before
        // they are sent, and remove tooltip if any, except for tab again
        var tooltip_closed = null;
        if (event.type === 'keydown' && event.which !== keycodes.tab ) {
            tooltip_closed = this.tooltip.remove_and_cancel_tooltip();
        }

        var cur = editor.getCursor();
        if (event.keyCode === keycodes.enter){
            this.auto_highlight();
        }

        if (event.which === keycodes.down && event.type === 'keypress' && this.tooltip.time_before_tooltip >= 0) {
            // triger on keypress (!) otherwise inconsistent event.which depending on plateform
            // browser and keyboard layout !
            // Pressing '(' , request tooltip, don't forget to reappend it
            // The second argument says to hide the tooltip if the docstring
            // is actually empty
            this.tooltip.pending(that, true);
        } else if ( tooltip_closed && event.which === keycodes.esc && event.type === 'keydown') {
            // If tooltip is active, cancel it.  The call to
            // remove_and_cancel_tooltip above doesn't pass, force=true.
            // Because of this it won't actually close the tooltip
            // if it is in sticky mode. Thus, we have to check again if it is open
            // and close it with force=true.
            if (!this.tooltip._hidden) {
                this.tooltip.remove_and_cancel_tooltip(true);
            }
            // If we closed the tooltip, don't let CM or the global handlers
            // handle this event.
            event.codemirrorIgnore = true;
            event._ipkmIgnore = true;
            event.preventDefault();
            return true;
        } else if (event.keyCode === keycodes.tab && event.type === 'keydown' && event.shiftKey) {
                if (editor.somethingSelected() || editor.getSelections().length !== 1){
                    var anchor = editor.getCursor("anchor");
                    var head = editor.getCursor("head");
                    if( anchor.line !== head.line){
                        return false;
                    }
                }
                var pre_cursor = editor.getRange({line:cur.line,ch:0},cur);
                if (pre_cursor.trim() === "") {
                    // Don't show tooltip if the part of the line before the cursor
                    // is empty.  In this case, let CodeMirror handle indentation.
                    return false;
                } 
                this.tooltip.request(that);
                event.codemirrorIgnore = true;
                event.preventDefault();
                return true;
        } else if (event.keyCode === keycodes.tab && event.type === 'keydown') {
            // Tab completion.
            this.tooltip.remove_and_cancel_tooltip();

            // completion does not work on multicursor, it might be possible though in some cases
            if (editor.somethingSelected() || editor.getSelections().length > 1) {
                return false;
            }
            var pre_cursor = editor.getRange({line:cur.line,ch:0},cur);
            if (pre_cursor.trim() === "") {
                // Don't autocomplete if the part of the line before the cursor
                // is empty.  In this case, let CodeMirror handle indentation.
                return false;
            } else {
                event.codemirrorIgnore = true;
                event.preventDefault();
                this.completer.startCompletion();
                return true;
            }
        } 
        
        // keyboard event wasn't one of those unique to code cells, let's see
        // if it's one of the generic ones (i.e. check edit mode shortcuts)
        return Cell.prototype.handle_codemirror_keyevent.apply(this, [editor, event]);
    };

    // Kernel related calls.

    CodeCell.prototype.set_kernel = function (kernel) {
        this.kernel = kernel;
    };

    /**
     * Execute current code cell to the kernel
     * @method execute
     */
    CodeCell.prototype.execute = function (stop_on_error) {
        if (!this.kernel || !this.kernel.is_connected()) {
            console.log("Can't execute, kernel is not connected.");
            return;
        }

        this.output_area.clear_output(false, true);

        if (stop_on_error === undefined) {
            stop_on_error = true;
        }

        var old_msg_id = this.last_msg_id;

        if (old_msg_id) {
            this.kernel.clear_callbacks_for_msg(old_msg_id);
            if (old_msg_id) {
                delete CodeCell.msg_cells[old_msg_id];
            }
        }
        if (this.get_text().trim().length === 0) {
            // nothing to do
            this.set_input_prompt(null);
            return;
        }
        this.set_input_prompt('*');
        this.element.addClass("running");
        var callbacks = this.get_callbacks();
        
        this.last_msg_id = this.kernel.execute(this.get_text(), callbacks, {silent: false, store_history: true,
            stop_on_error : stop_on_error});
        CodeCell.msg_cells[this.last_msg_id] = this;
        this.render();
        this.events.trigger('execute.CodeCell', {cell: this});
    };

    /**
     * Construct the default callbacks for
     * @method get_callbacks
     */
    CodeCell.prototype.get_callbacks = function () {
        var that = this;
        return {
            shell : {
                reply : $.proxy(this._handle_execute_reply, this),
                payload : {
                    set_next_input : $.proxy(this._handle_set_next_input, this),
                    page : $.proxy(this._open_with_pager, this)
                }
            },
            iopub : {
                output : function() { 
                    that.output_area.handle_output.apply(that.output_area, arguments);
                }, 
                clear_output : function() { 
                    that.output_area.handle_clear_output.apply(that.output_area, arguments);
                }, 
            },
            input : $.proxy(this._handle_input_request, this)
        };
    };

    CodeCell.prototype._open_with_pager = function (payload) {
        this.events.trigger('open_with_text.Pager', payload);
    };

    /**
     * @method _handle_execute_reply
     * @private
     */
    CodeCell.prototype._handle_execute_reply = function (msg) {
        this.set_input_prompt(msg.content.execution_count);
        this.element.removeClass("running");
        this.events.trigger('set_dirty.Notebook', {value: true});
    };

    /**
     * @method _handle_set_next_input
     * @private
     */
    CodeCell.prototype._handle_set_next_input = function (payload) {
        var data = {'cell': this, 'text': payload.text, replace: payload.replace};
        this.events.trigger('set_next_input.Notebook', data);
    };

    /**
     * @method _handle_input_request
     * @private
     */
    CodeCell.prototype._handle_input_request = function (msg) {
        this.output_area.append_raw_input(msg);
    };


    // Basic cell manipulation.

    CodeCell.prototype.select = function () {
        var cont = Cell.prototype.select.apply(this);
        if (cont) {
            this.code_mirror.refresh();
            this.auto_highlight();
        }
        return cont;
    };

    CodeCell.prototype.render = function () {
        var cont = Cell.prototype.render.apply(this);
        // Always execute, even if we are already in the rendered state
        return cont;
    };

    CodeCell.prototype.select_all = function () {
        var start = {line: 0, ch: 0};
        var nlines = this.code_mirror.lineCount();
        var last_line = this.code_mirror.getLine(nlines-1);
        var end = {line: nlines-1, ch: last_line.length};
        this.code_mirror.setSelection(start, end);
    };


    CodeCell.prototype.collapse_output = function () {
        this.output_area.collapse();
    };


    CodeCell.prototype.expand_output = function () {
        this.output_area.expand();
        this.output_area.unscroll_area();
    };

    CodeCell.prototype.scroll_output = function () {
        this.output_area.expand();
        this.output_area.scroll_if_long();
    };

    CodeCell.prototype.toggle_output = function () {
        this.output_area.toggle_output();
    };

    CodeCell.prototype.toggle_output_scroll = function () {
        this.output_area.toggle_scroll();
    };


    CodeCell.input_prompt_classical = function (prompt_value, lines_number) {
        var ns;
        if (prompt_value === undefined || prompt_value === null) {
            ns = "&nbsp;";
        } else {
            ns = encodeURIComponent(prompt_value);
        }
        return 'In&nbsp;[' + ns + ']:';
    };

    CodeCell.input_prompt_continuation = function (prompt_value, lines_number) {
        var html = [CodeCell.input_prompt_classical(prompt_value, lines_number)];
        for(var i=1; i < lines_number; i++) {
            html.push(['...:']);
        }
        return html.join('<br/>');
    };

    CodeCell.input_prompt_function = CodeCell.input_prompt_classical;


    CodeCell.prototype.set_input_prompt = function (number) {
        var nline = 1;
        if (this.code_mirror !== undefined) {
           nline = this.code_mirror.lineCount();
        }
        this.input_prompt_number = number;
        var prompt_html = CodeCell.input_prompt_function(this.input_prompt_number, nline);
        // This HTML call is okay because the user contents are escaped.
        this.element.find('div.input_prompt').html(prompt_html);
    };


    CodeCell.prototype.clear_input = function () {
        this.code_mirror.setValue('');
    };


    CodeCell.prototype.get_text = function () {
        return this.code_mirror.getValue();
    };


    CodeCell.prototype.set_text = function (code) {
        return this.code_mirror.setValue(code);
    };


    CodeCell.prototype.clear_output = function (wait) {
        this.output_area.clear_output(wait);
        this.set_input_prompt();
    };


    // JSON serialization

    CodeCell.prototype.fromJSON = function (data) {
        Cell.prototype.fromJSON.apply(this, arguments);
        if (data.cell_type === 'code') {
            if (data.source !== undefined) {
                this.set_text(data.source);
                // make this value the starting point, so that we can only undo
                // to this state, instead of a blank cell
                this.code_mirror.clearHistory();
                this.auto_highlight();
            }
            this.set_input_prompt(data.execution_count);
            this.output_area.trusted = data.metadata.trusted || false;
            this.output_area.fromJSON(data.outputs, data.metadata);
        }
    };


    CodeCell.prototype.toJSON = function () {
        var data = Cell.prototype.toJSON.apply(this);
        data.source = this.get_text();
        // is finite protect against undefined and '*' value
        if (isFinite(this.input_prompt_number)) {
            data.execution_count = this.input_prompt_number;
        } else {
            data.execution_count = null;
        }
        var outputs = this.output_area.toJSON();
        data.outputs = outputs;
        data.metadata.trusted = this.output_area.trusted;
        data.metadata.collapsed = this.output_area.collapsed;
        if (this.output_area.scroll_state === 'auto') {
            delete data.metadata.scrolled;
        } else {
            data.metadata.scrolled = this.output_area.scroll_state;
        }
        return data;
    };

    /**
     * handle cell level logic when the cursor moves away from a cell
     * @method unselect
     * @return is the action being taken
     */
    CodeCell.prototype.unselect = function (leave_selected) {
        var cont = Cell.prototype.unselect.apply(this, [leave_selected]);
        if (cont) {
            // When a code cell is unselected, make sure that the corresponding
            // tooltip and completer to that cell is closed.
            this.tooltip.remove_and_cancel_tooltip(true);
            if (this.completer !== null) {
                this.completer.close();
            }
        }
        return cont;
    };

    // Backwards compatability.
    IPython.CodeCell = CodeCell;

    exports.CodeCell = CodeCell;

},{"base/js/keyboard":"/Users/jon/jupyter/notebook/notebook/static-src/base/js/keyboard.js","base/js/namespace":"/Users/jon/jupyter/notebook/notebook/static-src/base/js/namespace.js","base/js/utils":"/Users/jon/jupyter/notebook/notebook/static-src/base/js/utils.js","notebook/js/cell":"/Users/jon/jupyter/notebook/notebook/static-src/notebook/js/cell.js","notebook/js/celltoolbar":"/Users/jon/jupyter/notebook/notebook/static-src/notebook/js/celltoolbar.js","notebook/js/completer":"/Users/jon/jupyter/notebook/notebook/static-src/notebook/js/completer.js","notebook/js/outputarea":"/Users/jon/jupyter/notebook/notebook/static-src/notebook/js/outputarea.js","services/config":"/Users/jon/jupyter/notebook/notebook/static-src/services/config.js"}],"/Users/jon/jupyter/notebook/notebook/static-src/notebook/js/commandpalette.js":[function(require,module,exports){
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.

    "use strict";

    var QH = require("notebook/js/quickhelp");
    
    /**
     * Humanize the action name to be consumed by user.
     * internaly the actions anem are of the form
     * <namespace>.<description-with-dashes>
     * we drop <namesapce> and replace dashes for space.
     */
    var humanize_action_id = function(str) {
      return str.split('.')[1].replace(/-/g, ' ').replace(/_/g, '-');
    };

    /**
     * given an action id return 'command-shortcut', 'edit-shortcut' or 'no-shortcut'
     * for the action. This allows us to tag UI in order to visually distinguish
     * wether an action have a keybinding or not.
     **/
    var get_mode_for_action_id = function(name, notebook) {
      var shortcut = notebook.keyboard_manager.command_shortcuts.get_action_shortcut(name);
      if (shortcut) {
        return 'command-shortcut';
      }
      shortcut = notebook.keyboard_manager.edit_shortcuts.get_action_shortcut(name);
      if (shortcut) {
        return 'edit-shortcut';
      }
      return 'no-shortcut';
    };

    var CommandPalette = function(notebook) {
        if(!notebook){
          throw new Error("CommandPalette takes a notebook non-null mandatory arguement");
        }

        // typeahead lib need a specific layout with specific class names.
        // the following just does that
        var form = $('<form/>');
        var container = $('<div/>').addClass('typeahead-container');
        var field = $('<div/>').addClass('typeahead-field');
        var input = $('<input/>').attr('type', 'search');

        field
          .append(
            $('<span>').addClass('typeahead-query').append(
              input
            )
          )
          .append(
            $('<span/>').addClass('typeahead-button').append(
              $('<button/>').attr('type', 'submit').append(
                $('<span/>').addClass('typeahead-search-icon')
              )
            )
          );

        container.append(field);
        form.append(container);


        var mod = $('<div/>').addClass('modal cmd-palette').append(
          $('<div/>').addClass('modal-dialog')
          .append(
            $('<div/>').addClass('modal-content').append(
              $('<div/>').addClass('modal-body')
              .append(
                form
              )
            )
          )
        )
        // end setting up right layout
        .modal({show: false, backdrop:true})
        .on('shown.bs.modal', function () {
              // click on button trigger de-focus on mouse up.
              // or somethign like that.
              setTimeout(function(){input.focus();}, 100);
        });

        notebook.keyboard_manager.disable();

        var before_close = function() {
          // little trick to trigger early in onsubmit
          // when the action called pop-up a dialog
          // insure this function is only called once
          if (before_close.ok) {
            return;
          }
          var cell = notebook.get_selected_cell();
          if (cell) {
            cell.select();
          }
          if (notebook.keyboard_manager) {
            notebook.keyboard_manager.enable();
            notebook.keyboard_manager.command_mode();
          }
          before_close.ok = true; // avoid double call.
        };
        
        mod.on("hide.bs.modal", before_close);
        

        // will be trigger when user select action
        var onSubmit = function(node, query, result, resultCount) {
          if (actions.indexOf(result.key) >= 0) {
            before_close();
            notebook.keyboard_manager.actions.call(result.key);
          } else {
            console.warning("No command " + result.key);
          }
          mod.modal('hide');
        };

        // generate structure needed for typeahead layout and ability to search
        var src = {};

        var actions = Object.keys(notebook.keyboard_manager.actions._actions);

        for (var i = 0; i < actions.length; i++) {
          var action_id = actions[i];
          var action = notebook.keyboard_manager.actions.get(action_id);
          var group = action_id.split('.')[0];
          if (group === 'ipython') {
            group = 'built-in';
          }

          src[group] = src[group] || {
            data: [],
            display: 'display'
          };

          var short = notebook.keyboard_manager.command_shortcuts.get_action_shortcut(action_id) ||
            notebook.keyboard_manager.edit_shortcuts.get_action_shortcut(action_id);
          if (short) {
            short = QH.humanize_sequence(short);
          }

          src[group].data.push({
            display: humanize_action_id(action_id),
            shortcut: short,
            mode_shortcut: get_mode_for_action_id(action_id, notebook),
            group: group,
            icon: action.icon,
            help: action.help,
            key: action_id,
          });
        }

        // now src is the right structure for typeahead

        input.typeahead({
          emptyTemplate: "No results found for <pre>{{query}}</pre>",
          maxItem: 1e3,
          minLength: 0,
          hint: true,
          group: ["group", "{{group}} extension"],
          searchOnFocus: true,
          mustSelectItem: true,
          template: '<i class="fa fa-icon {{icon}}"></i>{{display}}  <div class="pull-right {{mode_shortcut}}">{{shortcut}}</div>',
          order: "asc",
          source: src,
          callback: {
            onSubmit: onSubmit,
            onClickAfter: onSubmit
          },
          debug: false,
        });

        mod.modal('show');
    };
    module.exports = {'CommandPalette': CommandPalette}; 

},{"notebook/js/quickhelp":"/Users/jon/jupyter/notebook/notebook/static-src/notebook/js/quickhelp.js"}],"/Users/jon/jupyter/notebook/notebook/static-src/notebook/js/completer.js":[function(require,module,exports){
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
    "use strict";

    var utils = require('base/js/utils');
    var keyboard = require('base/js/keyboard');
    require('notebook/js/contexthint');

    // easier key mapping
    var keycodes = keyboard.keycodes;

    var prepend_n_prc = function(str, n) {
        for( var i =0 ; i< n ; i++){
            str = '%'+str ;
        }
        return str;
    };

    var _existing_completion = function(item, completion_array){
        for( var i=0; i < completion_array.length; i++) {
            if (completion_array[i].trim().substr(-item.length) == item) {
                return true;
            }
        }
        return false;
    };

    // what is the common start of all completions
    function shared_start(B, drop_prct) {
        if (B.length == 1) {
            return B[0];
        }
        var A = [];
        var common;
        var min_lead_prct = 10;
        for (var i = 0; i < B.length; i++) {
            var str = B[i].str;
            var localmin = 0;
            if(drop_prct === true){
                while ( str.substr(0, 1) == '%') {
                    localmin = localmin+1;
                    str = str.substring(1);
                }
            }
            min_lead_prct = Math.min(min_lead_prct, localmin);
            A.push(str);
        }

        if (A.length > 1) {
            var tem1, tem2, s;
            A = A.slice(0).sort();
            tem1 = A[0];
            s = tem1.length;
            tem2 = A.pop();
            while (s && tem2.indexOf(tem1) == -1) {
                tem1 = tem1.substring(0, --s);
            }
            if (tem1 === "" || tem2.indexOf(tem1) !== 0) {
                return {
                    str:prepend_n_prc('', min_lead_prct),
                    type: "computed",
                    from: B[0].from,
                    to: B[0].to
                    };
            }
            return {
                str: prepend_n_prc(tem1, min_lead_prct),
                type: "computed",
                from: B[0].from,
                to: B[0].to
            };
        }
        return null;
    }


    var Completer = function (cell, events) {
        this.cell = cell;
        this.editor = cell.code_mirror;
        var that = this;
        events.on('kernel_busy.Kernel', function () {
            that.skip_kernel_completion = true;
        });
        events.on('kernel_idle.Kernel', function () {
            that.skip_kernel_completion = false;
        });
    };

    Completer.prototype.startCompletion = function () {
        /**
         * call for a 'first' completion, that will set the editor and do some
         * special behavior like autopicking if only one completion available.
         */
        if (this.editor.somethingSelected()|| this.editor.getSelections().length > 1) return;
        this.done = false;
        // use to get focus back on opera
        this.carry_on_completion(true);
    };


    // easy access for julia to monkeypatch
    //
    Completer.reinvoke_re = /[%0-9a-z._/\\:~-]/i;

    Completer.prototype.reinvoke= function(pre_cursor, block, cursor){
        return Completer.reinvoke_re.test(pre_cursor);
    };

    /**
     *
     * pass true as parameter if this is the first invocation of the completer
     * this will prevent the completer to dissmiss itself if it is not on a
     * word boundary like pressing tab after a space, and make it autopick the
     * only choice if there is only one which prevent from popping the UI.  as
     * well as fast-forwarding the typing if all completion have a common
     * shared start
     **/
    Completer.prototype.carry_on_completion = function (first_invocation) {
        /**
         * Pass true as parameter if you want the completer to autopick when
         * only one completion. This function is automatically reinvoked at
         * each keystroke with first_invocation = false
         */
        var cur = this.editor.getCursor();
        var line = this.editor.getLine(cur.line);
        var pre_cursor = this.editor.getRange({
            line: cur.line,
            ch: cur.ch - 1
        }, cur);

        // we need to check that we are still on a word boundary
        // because while typing the completer is still reinvoking itself
        // so dismiss if we are on a "bad" caracter
        if (!this.reinvoke(pre_cursor) && !first_invocation) {
            this.close();
            return;
        }

        this.autopick = false;
        if (first_invocation) {
            this.autopick = true;
        }

        // We want a single cursor position.
        if (this.editor.somethingSelected()|| this.editor.getSelections().length > 1) {
            return;
        }

        // one kernel completion came back, finish_completing will be called with the results
        // we fork here and directly call finish completing if kernel is busy
        var cursor_pos = utils.to_absolute_cursor_pos(this.editor, cur);
        if (this.skip_kernel_completion) {
            this.finish_completing({ content: {
                matches: [],
                cursor_start: cursor_pos,
                cursor_end: cursor_pos,
            }});
        } else {
            this.cell.kernel.complete(this.editor.getValue(), cursor_pos,
                $.proxy(this.finish_completing, this)
            );
        }
    };

    Completer.prototype.finish_completing = function (msg) {
        /**
         * let's build a function that wrap all that stuff into what is needed
         * for the new completer:
         */
        var content = msg.content;
        var start = content.cursor_start;
        var end = content.cursor_end;
        var matches = content.matches;

        var cur = this.editor.getCursor();
        if (end === null) {
            // adapted message spec replies don't have cursor position info,
            // interpret end=null as current position,
            // and negative start relative to that
            end = utils.to_absolute_cursor_pos(this.editor, cur);
            if (start === null) {
                start = end;
            } else if (start < 0) {
                start = end + start;
            }
        }
        var results = CodeMirror.contextHint(this.editor);
        var filtered_results = [];
        //remove results from context completion
        //that are already in kernel completion
        var i;
        for (i=0; i < results.length; i++) {
            if (!_existing_completion(results[i].str, matches)) {
                filtered_results.push(results[i]);
            }
        }

        // append the introspection result, in order, at at the beginning of
        // the table and compute the replacement range from current cursor
        // positon and matched_text length.
        var from = utils.from_absolute_cursor_pos(this.editor, start);
        var to = utils.from_absolute_cursor_pos(this.editor, end);
        for (i = matches.length - 1; i >= 0; --i) {
            filtered_results.unshift({
                str: matches[i],
                type: "introspection",
                from: from,
                to: to
            });
        }

        // one the 2 sources results have been merge, deal with it
        this.raw_result = filtered_results;

        // if empty result return
        if (!this.raw_result || !this.raw_result.length) return;

        // When there is only one completion, use it directly.
        if (this.autopick && this.raw_result.length == 1) {
            this.insert(this.raw_result[0]);
            return;
        }

        if (this.raw_result.length == 1) {
            // test if first and only completion totally matches
            // what is typed, in this case dismiss
            var str = this.raw_result[0].str;
            var pre_cursor = this.editor.getRange({
                line: cur.line,
                ch: cur.ch - str.length
            }, cur);
            if (pre_cursor == str) {
                this.close();
                return;
            }
        }

        if (!this.visible) {
            this.complete = $('<div/>').addClass('completions');
            this.complete.attr('id', 'complete');

            // Currently webkit doesn't use the size attr correctly. See:
            // https://code.google.com/p/chromium/issues/detail?id=4579
            this.sel = $('<select/>')
                .attr('tabindex', -1)
                .attr('multiple', 'true');
            this.complete.append(this.sel);
            this.visible = true;
            $('body').append(this.complete);

            //build the container
            var that = this;
            this.sel.dblclick(function () {
                that.pick();
            });
            this.sel.focus(function () {
                that.editor.focus();
            });
            this._handle_keydown = function (cm, event) {
                that.keydown(event);
            };
            this.editor.on('keydown', this._handle_keydown);
            this._handle_keypress = function (cm, event) {
                that.keypress(event);
            };
            this.editor.on('keypress', this._handle_keypress);
        }
        this.sel.attr('size', Math.min(10, this.raw_result.length));

        // After everything is on the page, compute the postion.
        // We put it above the code if it is too close to the bottom of the page.
        var pos = this.editor.cursorCoords(
            utils.from_absolute_cursor_pos(this.editor, start)
        );
        var left = pos.left-3;
        var top;
        var cheight = this.complete.height();
        var wheight = $(window).height();
        if (pos.bottom+cheight+5 > wheight) {
            top = pos.top-cheight-4;
        } else {
            top = pos.bottom+1;
        }
        this.complete.css('left', left + 'px');
        this.complete.css('top', top + 'px');

        // Clear and fill the list.
        this.sel.text('');
        this.build_gui_list(this.raw_result);
        return true;
    };

    Completer.prototype.insert = function (completion) {
        this.editor.replaceRange(completion.str, completion.from, completion.to);
    };

    Completer.prototype.build_gui_list = function (completions) {
        for (var i = 0; i < completions.length; ++i) {
            var opt = $('<option/>').text(completions[i].str).addClass(completions[i].type);
            this.sel.append(opt);
        }
        this.sel.children().first().attr('selected', 'true');
        this.sel.scrollTop(0);
    };

    Completer.prototype.close = function () {
        this.done = true;
        $('#complete').remove();
        this.editor.off('keydown', this._handle_keydown);
        this.editor.off('keypress', this._handle_keypress);
        this.visible = false;
    };

    Completer.prototype.pick = function () {
        this.insert(this.raw_result[this.sel[0].selectedIndex]);
        this.close();
    };

    Completer.prototype.keydown = function (event) {
        var code = event.keyCode;

        // Enter
        var options;
        var index;
        if (code == keycodes.enter) {
            event.codemirrorIgnore = true;
            event._ipkmIgnore = true;
            event.preventDefault();
            this.pick();
        // Escape or backspace
        } else if (code == keycodes.esc || code == keycodes.backspace) {
            event.codemirrorIgnore = true;
            event._ipkmIgnore = true;
            event.preventDefault();
            this.close();
        } else if (code == keycodes.tab) {
            //all the fastforwarding operation,
            //Check that shared start is not null which can append with prefixed completion
            // like %pylab , pylab have no shred start, and ff will result in py<tab><tab>
            // to erase py
            var sh = shared_start(this.raw_result, true);
            if (sh.str !== '') {
                this.insert(sh);
            }
            this.close();
            this.carry_on_completion();
        } else if (code == keycodes.up || code == keycodes.down) {
            // need to do that to be able to move the arrow
            // when on the first or last line ofo a code cell
            event.codemirrorIgnore = true;
            event._ipkmIgnore = true;
            event.preventDefault();

            options = this.sel.find('option');
            index = this.sel[0].selectedIndex;
            if (code == keycodes.up) {
                index--;
            }
            if (code == keycodes.down) {
                index++;
            }
            index = Math.min(Math.max(index, 0), options.length-1);
            this.sel[0].selectedIndex = index;
        } else if (code == keycodes.pageup || code == keycodes.pagedown) {
            event._ipkmIgnore = true;

            options = this.sel.find('option');
            index = this.sel[0].selectedIndex;
            if (code == keycodes.pageup) {
                index -= 10; // As 10 is the hard coded size of the drop down menu
            } else {
                index += 10;
            }
            index = Math.min(Math.max(index, 0), options.length-1);
            this.sel[0].selectedIndex = index;
        } else if (code == keycodes.left || code == keycodes.right) {
            this.close();
        }
    };

    Completer.prototype.keypress = function (event) {
        /**
         * FIXME: This is a band-aid.
         * on keypress, trigger insertion of a single character.
         * This simulates the old behavior of completion as you type,
         * before events were disconnected and CodeMirror stopped
         * receiving events while the completer is focused.
         */
        
        var that = this;
        var code = event.keyCode;
        
        // don't handle keypress if it's not a character (arrows on FF)
        // or ENTER/TAB
        if (event.charCode === 0 ||
            code == keycodes.tab ||
            code == keycodes.enter
        ) return;
        
        this.close();
        this.editor.focus();
        setTimeout(function () {
            that.carry_on_completion();
        }, 50);
    };

    exports.Completer = Completer;

},{"base/js/keyboard":"/Users/jon/jupyter/notebook/notebook/static-src/base/js/keyboard.js","base/js/utils":"/Users/jon/jupyter/notebook/notebook/static-src/base/js/utils.js","notebook/js/contexthint":"/Users/jon/jupyter/notebook/notebook/static-src/notebook/js/contexthint.js"}],"/Users/jon/jupyter/notebook/notebook/static-src/notebook/js/contexthint.js":[function(require,module,exports){
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.

// highly adapted for codemiror jshint
    "use strict";

    var forEach = function(arr, f) {
        for (var i = 0, e = arr.length; i < e; ++i) f(arr[i]);
    };

    var arrayContains = function(arr, item) {
        if (!Array.prototype.indexOf) {
            var i = arr.length;
            while (i--) {
                if (arr[i] === item) {
                    return true;
                }
            }
            return false;
        }
        return arr.indexOf(item) != -1;
    };

    CodeMirror.contextHint = function (editor) {
        // Find the token at the cursor
        var cur = editor.getCursor(),
            token = editor.getTokenAt(cur),
            tprop = token;
        // If it's not a 'word-style' token, ignore the token.
        // If it is a property, find out what it is a property of.
        var list = [];
        var clist = getCompletions(token, editor);
        for (var i = 0; i < clist.length; i++) {
            list.push({
                str: clist[i],
                type: "context",
                from: {
                    line: cur.line,
                    ch: token.start
                },
                to: {
                    line: cur.line,
                    ch: token.end
                }
            });
        }
        return list;
    };

    // find all 'words' of current cell
    var getAllTokens = function (editor) {
        var found = [];

        // add to found if not already in it


        function maybeAdd(str) {
            if (!arrayContains(found, str)) found.push(str);
        }

        // loop through all token on all lines
        var lineCount = editor.lineCount();
        // loop on line
        for (var l = 0; l < lineCount; l++) {
            var line = editor.getLine(l);
            //loop on char
            for (var c = 1; c < line.length; c++) {
                var tk = editor.getTokenAt({
                    line: l,
                    ch: c
                });
                // if token has a class, it has geat chances of beeing
                // of interest. Add it to the list of possible completions.
                // we could skip token of ClassName 'comment'
                // or 'number' and 'operator'
                if (tk.className !== null) {
                    maybeAdd(tk.string);
                }
                // jump to char after end of current token
                c = tk.end;
            }
        }
        return found;
    };

    var getCompletions = function(token, editor) {
        var candidates = getAllTokens(editor);
        // filter all token that have a common start (but nox exactly) the lenght of the current token
        var lambda = function (x) {
                return (x.indexOf(token.string) === 0 && x != token.string);
            };
        var filterd = candidates.filter(lambda);
        return filterd;
    };

    exports.contextHint = CodeMirror.contextHint;

},{}],"/Users/jon/jupyter/notebook/notebook/static-src/notebook/js/keyboardmanager.js":[function(require,module,exports){
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
/**
 *
 *
 * @module keyboardmanager
 * @namespace keyboardmanager
 * @class KeyboardManager
 */
    "use strict";
    var utils = require('base/js/utils');
    var keyboard = require('base/js/keyboard');

    // Main keyboard manager for the notebook
    var keycodes = keyboard.keycodes;

    var KeyboardManager = function (options) {
        /**
         * A class to deal with keyboard event and shortcut
         *
         * @class KeyboardManager
         * @constructor
         * @param options {dict} Dictionary of keyword arguments :
         *    @param options.events {$(Events)} instance 
         *    @param options.pager: {Pager}  pager instance
         */
        this.mode = 'command';
        this.enabled = true;
        this.pager = options.pager;
        this.quick_help = undefined;
        this.notebook = undefined;
        this.last_mode = undefined;
        this.bind_events();
        this.env = {pager:this.pager};
        this.actions = options.actions;
        this.command_shortcuts = new keyboard.ShortcutManager(undefined, options.events, this.actions, this.env );
        this.command_shortcuts.add_shortcuts(this.get_default_common_shortcuts());
        this.command_shortcuts.add_shortcuts(this.get_default_command_shortcuts());
        this.edit_shortcuts = new keyboard.ShortcutManager(undefined, options.events, this.actions, this.env);
        this.edit_shortcuts.add_shortcuts(this.get_default_common_shortcuts());
        this.edit_shortcuts.add_shortcuts(this.get_default_edit_shortcuts());
        Object.seal(this);
    };




    /**
     * Return a dict of common shortcut
     * @method get_default_common_shortcuts
     *
     * @example Example of returned shortcut
     * ```
     * 'shortcut-key': 'action-name'
     * // a string representing the shortcut as dash separated value.
     * // e.g. 'shift' , 'shift-enter', 'cmd-t'
     *```
     */
    KeyboardManager.prototype.get_default_common_shortcuts = function() {
        return {
            'shift'       : 'ipython.ignore',
            'shift-enter' : 'ipython.run-select-next',
            'ctrl-enter'  : 'ipython.execute-in-place',
            'alt-enter'   : 'ipython.execute-and-insert-after',
            // cmd on mac, ctrl otherwise
            'cmdtrl-s'    : 'ipython.save-notebook',
        };
    };

    KeyboardManager.prototype.get_default_edit_shortcuts = function() {
        return {
            'cmdtrl-shift-p'      : 'ipython.command-palette',
            'esc'                 : 'ipython.go-to-command-mode',
            'ctrl-m'              : 'ipython.go-to-command-mode',
            'up'                  : 'ipython.move-cursor-up-or-previous-cell',
            'down'                : 'ipython.move-cursor-down-or-next-cell',
            'ctrl-shift--'        : 'ipython.split-cell-at-cursor',
            'ctrl-shift-subtract' : 'ipython.split-cell-at-cursor',
        };
    };

    KeyboardManager.prototype.get_default_command_shortcuts = function() {
        return {
            'cmdtrl-shift-p': 'ipython.command-palette',
            'shift-space': 'ipython.scroll-up',
            'shift-v' : 'ipython.paste-cell-before',
            'shift-m' : 'ipython.merge-selected-cells',
            'shift-o' : 'ipython.toggle-output-scrolling-selected-cell',
            'enter' : 'ipython.enter-edit-mode',
            'space' : 'ipython.scroll-down',
            'down' : 'ipython.select-next-cell',
            'i,i' : 'ipython.interrupt-kernel',
            '0,0' : 'ipython.restart-kernel',
            'd,d' : 'ipython.delete-cell',
            'esc': 'ipython.close-pager',
            'up' : 'ipython.select-previous-cell',
            'k' : 'ipython.select-previous-cell',
            'j' : 'ipython.select-next-cell',
            'shift-k': 'ipython.extend-selection-previous',
            'shift-j': 'ipython.extend-selection-next',
            'x' : 'ipython.cut-selected-cell',
            'c' : 'ipython.copy-selected-cell',
            'v' : 'ipython.paste-cell-after',
            'a' : 'ipython.insert-cell-before',
            'b' : 'ipython.insert-cell-after',
            'y' : 'ipython.change-selected-cell-to-code-cell',
            'm' : 'ipython.change-selected-cell-to-markdown-cell',
            'r' : 'ipython.change-selected-cell-to-raw-cell',
            '1' : 'ipython.change-selected-cell-to-heading-1',
            '2' : 'ipython.change-selected-cell-to-heading-2',
            '3' : 'ipython.change-selected-cell-to-heading-3',
            '4' : 'ipython.change-selected-cell-to-heading-4',
            '5' : 'ipython.change-selected-cell-to-heading-5',
            '6' : 'ipython.change-selected-cell-to-heading-6',
            'o' : 'ipython.toggle-output-visibility-selected-cell',
            's' : 'ipython.save-notebook',
            'l' : 'ipython.toggle-line-number-selected-cell',
            'h' : 'ipython.show-keyboard-shortcut-help-dialog',
            'z' : 'ipython.undo-last-cell-deletion',
            'q' : 'ipython.close-pager',
        };
    };

    KeyboardManager.prototype.bind_events = function () {
        var that = this;
        $(document).keydown(function (event) {
            if(event._ipkmIgnore===true||(event.originalEvent||{})._ipkmIgnore===true){
                return false;
            }
            return that.handle_keydown(event);
        });
    };

    KeyboardManager.prototype.set_notebook = function (notebook) {
        this.notebook = notebook;
        this.actions.extend_env({notebook:notebook});
    };

    KeyboardManager.prototype.set_quickhelp = function (notebook) {
        this.actions.extend_env({quick_help:notebook});
    };


    KeyboardManager.prototype.handle_keydown = function (event) {
        /**
         *  returning false from this will stop event propagation
         **/

        if (event.which === keycodes.esc) {
            // Intercept escape at highest level to avoid closing
            // websocket connection with firefox
            event.preventDefault();
        }
        
        if (!this.enabled) {
            if (event.which === keycodes.esc) {
                this.notebook.command_mode();
                return false;
            }
            return true;
        }
        
        if (this.mode === 'edit') {
            return this.edit_shortcuts.call_handler(event);
        } else if (this.mode === 'command') {
            return this.command_shortcuts.call_handler(event);
        }
        return true;
    };

    KeyboardManager.prototype.edit_mode = function () {
        this.last_mode = this.mode;
        this.mode = 'edit';
    };

    KeyboardManager.prototype.command_mode = function () {
        this.last_mode = this.mode;
        this.mode = 'command';
    };

    KeyboardManager.prototype.enable = function () {
        this.enabled = true;
    };

    KeyboardManager.prototype.disable = function () {
        this.enabled = false;
    };

    KeyboardManager.prototype.register_events = function (e) {
        e = $(e);
        var that = this;
        var handle_focus = function () {
            that.disable();
        };
        var handle_blur = function () {
            that.enable();
        };
        e.on('focusin', handle_focus);
        e.on('focusout', handle_blur);
        // TODO: Very strange. The focusout event does not seem fire for the 
        // bootstrap textboxes on FF25&26...  This works around that by 
        // registering focus and blur events recursively on all inputs within
        // registered element.
        e.find('input').blur(handle_blur);
        e.on('DOMNodeInserted', function (event) {
            var target = $(event.target);
            if (target.is('input')) {
                target.blur(handle_blur);
            } else {
                target.find('input').blur(handle_blur);    
            }
          });
        // There are times (raw_input) where we remove the element from the DOM before
        // focusout is called. In this case we bind to the remove event of jQueryUI,
        // which gets triggered upon removal, iff it is focused at the time.
        // is_focused must be used to check for the case where an element within
        // the element being removed is focused.
        e.on('remove', function () {
            if (utils.is_focused(e[0])) {
                that.enable();
            }
        });
    };

    exports.KeyboardManager = KeyboardManager;

},{"base/js/keyboard":"/Users/jon/jupyter/notebook/notebook/static-src/base/js/keyboard.js","base/js/utils":"/Users/jon/jupyter/notebook/notebook/static-src/base/js/utils.js"}],"/Users/jon/jupyter/notebook/notebook/static-src/notebook/js/maintoolbar.js":[function(require,module,exports){
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
    "use strict";

    var toolbar = require('./toolbar');
    var celltoolbar = require('./celltoolbar');
    var MainToolBar = function (selector, options) {
        /**
         * Constructor
         *
         * Parameters:
         *  selector: string
         *  options: dictionary
         *      Dictionary of keyword arguments.
         *          events: $(Events) instance
         *          notebook: Notebook instance
         **/
        toolbar.ToolBar.apply(this, [selector, options] );
        this.events = options.events;
        this.notebook = options.notebook;
        this._make();
        Object.seal(this);
    };

    MainToolBar.prototype = Object.create(toolbar.ToolBar.prototype);

    MainToolBar.prototype._make = function () {
        var grps = [
          [
            ['ipython.save-notebook'],
            'save-notbook'
          ],
          [
            ['ipython.insert-cell-after'],
            'insert_above_below'],
          [
            ['ipython.cut-selected-cell',
             'ipython.copy-selected-cell',
             'ipython.paste-cell-after'
            ] ,
            'cut_copy_paste'],
          [
            ['ipython.move-selected-cell-up',
             'ipython.move-selected-cell-down'
            ],
            'move_up_down'],
          [ ['ipython.run-select-next',
             'ipython.interrupt-kernel',
             'ipython.restart-kernel'
            ],
            'run_int'],
         ['<add_celltype_list>'],
         ['<add_celltoolbar_list>'],
         [['ipython.command-palette']]
        ];
        this.construct(grps);
    };

    // add a cell type drop down to the maintoolbar.
    // triggered when the pseudo action `<add_celltype_list>` is
    // encountered when building a toolbar.
    MainToolBar.prototype._pseudo_actions.add_celltype_list = function () {
        var that = this;
        var sel = $('<select/>')
            .attr('id','cell_type')
            .addClass('form-control select-xs')
            .append($('<option/>').attr('value','code').text('Code'))
            .append($('<option/>').attr('value','markdown').text('Markdown'))
            .append($('<option/>').attr('value','raw').text('Raw NBConvert'))
            .append($('<option/>').attr('value','heading').text('Heading'));
        this.notebook.keyboard_manager.register_events(sel);
        this.events.on('selected_cell_type_changed.Notebook', function (event, data) {
            if (data.cell_type === 'heading') {
                sel.val('Markdown');
            } else {
                sel.val(data.cell_type);
            }
        });
        sel.change(function () {
            var cell_type = $(this).val();
            switch (cell_type) {
            case 'code':
                that.notebook.to_code();
                break;
            case 'markdown':
                that.notebook.to_markdown();
                break;
            case 'raw':
                that.notebook.to_raw();
                break;
            case 'heading':
                that.notebook._warn_heading();
                that.notebook.to_heading();
                sel.val('markdown');
                break;
            default:
                console.log("unrecognized cell type:", cell_type);
            }
            that.notebook.focus_cell();
        });
        return sel;

    };

    MainToolBar.prototype._pseudo_actions.add_celltoolbar_list = function () {
        var label = $('<span/>').addClass("navbar-text").text('Cell Toolbar:');
        var select = $('<select/>')
            .attr('id', 'ctb_select')
            .addClass('form-control select-xs')
            .append($('<option/>').attr('value', '').text('None'));
        var that = this;
        select.change(function() {
                var val = $(this).val();
                if (val ==='') {
                    celltoolbar.CellToolbar.global_hide();
                    delete that.notebook.metadata.celltoolbar;
                } else {
                    celltoolbar.CellToolbar.global_show();
                    celltoolbar.CellToolbar.activate_preset(val, that.events);
                    that.notebook.metadata.celltoolbar = val;
                }
                that.notebook.focus_cell();
            });
        this.notebook.keyboard_manager.register_events(select);
        // Setup the currently registered presets.
        var presets = celltoolbar.CellToolbar.list_presets();
        for (var i=0; i<presets.length; i++) {
            var name = presets[i];
            select.append($('<option/>').attr('value', name).text(name));
        }
        // Setup future preset registrations.
        this.events.on('preset_added.CellToolbar', function (event, data) {
            var name = data.name;
            select.append($('<option/>').attr('value', name).text(name));
        });
        this.events.on('unregistered_preset.CellToolbar', function (event, data) {
            if (select.val() === data.name){
                select.val('');
                celltoolbar.CellToolbar.global_hide();
                delete that.notebook.metadata.celltoolbar;
            }
            select.find("option[value='"+name+"']" ).remove();
        });
        // Update select value when a preset is activated.
        this.events.on('preset_activated.CellToolbar', function (event, data) {
            if (select.val() !== data.name){
                select.val(data.name);
            }
        });

        var wrapper = $('<div/>').addClass('btn-group');
        wrapper.append(label).append(select);
        return wrapper;
    };

    exports.MainToolBar = MainToolBar;

},{"./celltoolbar":"/Users/jon/jupyter/notebook/notebook/static-src/notebook/js/celltoolbar.js","./toolbar":"/Users/jon/jupyter/notebook/notebook/static-src/notebook/js/toolbar.js"}],"/Users/jon/jupyter/notebook/notebook/static-src/notebook/js/mathjaxutils.js":[function(require,module,exports){
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
    "use strict";

    var utils = require('base/js/utils');
    var dialog = require('base/js/dialog');

    var init = function () {
        if (window.MathJax) {
            // MathJax loaded
            MathJax.Hub.Config({
                tex2jax: {
                    inlineMath: [ ['$','$'], ["\\(","\\)"] ],
                    displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
                    processEscapes: true,
                    processEnvironments: true
                },
                // Center justify equations in code and markdown cells. Elsewhere
                // we use CSS to left justify single line equations in code cells.
                displayAlign: 'center',
                "HTML-CSS": {
                    availableFonts: [],
                    imageFont: null,
                    preferredFont: null,
                    webFont: "STIX-Web",
                    styles: {'.MathJax_Display': {"margin": 0}},
                    linebreaks: { automatic: true }
                }
            });
            MathJax.Hub.Configured();
        } else if (window.mathjax_url !== "") {
            // Don't have MathJax, but should. Show dialog.
            dialog.modal({
                title : "Failed to retrieve MathJax from '" + window.mathjax_url + "'",
                body : $("<p/>").addClass('dialog').text(
                        "Math/LaTeX rendering will be disabled."
                    ),
                buttons : {
                    OK : {class: "btn-danger"}
                }
            });
        }
    };

    // Some magic for deferring mathematical expressions to MathJax
    // by hiding them from the Markdown parser.
    // Some of the code here is adapted with permission from Davide Cervone
    // under the terms of the Apache2 license governing the MathJax project.
    // Other minor modifications are also due to StackExchange and are used with
    // permission.

    var inline = "$"; // the inline math delimiter

    // MATHSPLIT contains the pattern for math delimiters and special symbols
    // needed for searching for math in the text input.
    var MATHSPLIT = /(\$\$?|\\(?:begin|end)\{[a-z]*\*?\}|\\[\\{}$]|[{}]|(?:\n\s*)+|@@\d+@@)/i;

    //  The math is in blocks i through j, so
    //    collect it into one block and clear the others.
    //  Replace &, <, and > by named entities.
    //  For IE, put <br> at the ends of comments since IE removes \n.
    //  Clear the current math positions and store the index of the
    //    math, then push the math string onto the storage array.
    //  The preProcess function is called on all blocks if it has been passed in
    var process_math = function (i, j, pre_process, math, blocks) {
        var block = blocks.slice(i, j + 1).join("").replace(/&/g, "&amp;") // use HTML entity for &
        .replace(/</g, "&lt;") // use HTML entity for <
        .replace(/>/g, "&gt;") // use HTML entity for >
        ;
        if (utils.browser === 'msie') {
            block = block.replace(/(%[^\n]*)\n/g, "$1<br/>\n");
        }
        while (j > i) {
            blocks[j] = "";
            j--;
        }
        blocks[i] = "@@" + math.length + "@@"; // replace the current block text with a unique tag to find later
        if (pre_process){
            block = pre_process(block);
        }
        math.push(block);
        return blocks;
    };

    //  Break up the text into its component parts and search
    //    through them for math delimiters, braces, linebreaks, etc.
    //  Math delimiters must match and braces must balance.
    //  Don't allow math to pass through a double linebreak
    //    (which will be a paragraph).
    //
    var remove_math = function (text) {
        var math = []; // stores math strings for later
        var start;
        var end;
        var last;
        var braces;

        // Except for extreme edge cases, this should catch precisely those pieces of the markdown
        // source that will later be turned into code spans. While MathJax will not TeXify code spans,
        // we still have to consider them at this point; the following issue has happened several times:
        //
        //     `$foo` and `$bar` are varibales.  -->  <code>$foo ` and `$bar</code> are variables.

        var hasCodeSpans = /`/.test(text),
            de_tilde;
        if (hasCodeSpans) {
            text = text.replace(/~/g, "~T").replace(/(^|[^\\])(`+)([^\n]*?[^`\n])\2(?!`)/gm, function (wholematch) {
                return wholematch.replace(/\$/g, "~D");
            });
            de_tilde = function (text) {
                return text.replace(/~([TD])/g, function (wholematch, character) {
                                                    return { T: "~", D: "$" }[character];
                                                });
            };
        } else {
            de_tilde = function (text) { return text; };
        }

        var blocks = utils.regex_split(text.replace(/\r\n?/g, "\n"),MATHSPLIT);

        for (var i = 1, m = blocks.length; i < m; i += 2) {
            var block = blocks[i];
            if (block.charAt(0) === "@") {
                //
                //  Things that look like our math markers will get
                //  stored and then retrieved along with the math.
                //
                blocks[i] = "@@" + math.length + "@@";
                math.push(block);
            }
            else if (start) {
                //
                //  If we are in math, look for the end delimiter,
                //    but don't go past double line breaks, and
                //    and balance braces within the math.
                //
                if (block === end) {
                    if (braces) {
                        last = i;
                    }
                    else {
                        blocks = process_math(start, i, de_tilde, math, blocks);
                        start  = null;
                        end    = null;
                        last   = null;
                    }
                }
                else if (block.match(/\n.*\n/)) {
                    if (last) {
                        i = last;
                        blocks = process_math(start, i, de_tilde, math, blocks);
                    }
                    start = null;
                    end = null;
                    last = null;
                    braces = 0;
                }
                else if (block === "{") {
                    braces++;
                }
                else if (block === "}" && braces) {
                    braces--;
                }
            }
            else {
                //
                //  Look for math start delimiters and when
                //    found, set up the end delimiter.
                //
                if (block === inline || block === "$$") {
                    start = i;
                    end = block;
                    braces = 0;
                }
                else if (block.substr(1, 5) === "begin") {
                    start = i;
                    end = "\\end" + block.substr(6);
                    braces = 0;
                }
            }
        }
        if (last) {
            blocks = process_math(start, last, de_tilde, math, blocks);
            start  = null;
            end    = null;
            last   = null;
        }
        return [de_tilde(blocks.join("")), math];
    };

    //
    //  Put back the math strings that were saved,
    //    and clear the math array (no need to keep it around).
    //
    var replace_math = function (text, math) {
        text = text.replace(/@@(\d+)@@/g, function (match, n) {
            return math[n];
        });
        return text;
    };

    module.exports = {
        init : init,
        remove_math : remove_math,
        replace_math : replace_math
    };

},{"base/js/dialog":"/Users/jon/jupyter/notebook/notebook/static-src/base/js/dialog.js","base/js/utils":"/Users/jon/jupyter/notebook/notebook/static-src/base/js/utils.js"}],"/Users/jon/jupyter/notebook/notebook/static-src/notebook/js/menubar.js":[function(require,module,exports){
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
    "use strict";

    var IPython = require('base/js/namespace');
    var dialog = require('base/js/dialog');
    var utils = require('base/js/utils');
    var tour = require('notebook/js/tour');
    var moment = require('moment');

    var MenuBar = function (selector, options) {
        /**
         * Constructor
         *
         * A MenuBar Class to generate the menubar of Jupyter notebook
         *
         * Parameters:
         *  selector: string
         *  options: dictionary
         *      Dictionary of keyword arguments.
         *          notebook: Notebook instance
         *          contents: ContentManager instance
         *          events: $(Events) instance
         *          save_widget: SaveWidget instance
         *          quick_help: QuickHelp instance
         *          base_url : string
         *          notebook_path : string
         *          notebook_name : string
         */
        options = options || {};
        this.base_url = options.base_url || utils.get_body_data("baseUrl");
        this.selector = selector;
        this.notebook = options.notebook;
        this.contents = options.contents;
        this.events = options.events;
        this.save_widget = options.save_widget;
        this.quick_help = options.quick_help;

        try {
            this.tour = new tour.NotebookTour(this.notebook, this.events);
        } catch (e) {
            this.tour = undefined;
            console.log("Failed to instantiate Notebook Tour", e);
        }

        if (this.selector !== undefined) {
            this.element = $(selector);
            this.style();
            this.bind_events();
        }
    };

    // TODO: This has definitively nothing to do with style ...
    MenuBar.prototype.style = function () {
        var that = this;
        this.element.find("li").click(function (event, ui) {
                // The selected cell loses focus when the menu is entered, so we
                // re-select it upon selection.
                var i = that.notebook.get_selected_index();
                that.notebook.select(i);
            }
        );
    };

    MenuBar.prototype._nbconvert = function (format, download) {
        download = download || false;
        var notebook_path = this.notebook.notebook_path;
        var url = utils.url_join_encode(
            this.base_url,
            'nbconvert',
            format,
            notebook_path
        ) + "?download=" + download.toString();
        
        var w = window.open('', IPython._target);
        if (this.notebook.dirty) {
            this.notebook.save_notebook().then(function() {
                w.location = url;
            });
        } else {
            w.location = url;
        }
    };

    MenuBar.prototype._size_header = function() {
        /** 
         * Update header spacer size.
         */
        this.events.trigger('resize-header.Page');
    };

    MenuBar.prototype.bind_events = function () {
        /**
         *  File
         */
        var that = this;
        
        this.element.find('#open_notebook').click(function () {
            var parent = utils.url_path_split(that.notebook.notebook_path)[0];
            window.open(utils.url_join_encode(that.base_url, 'tree', parent), IPython._target);
        });
        this.element.find('#copy_notebook').click(function () {
            if (that.notebook.dirty) {
                that.notebook.save_notebook({async : false});
            }
            that.notebook.copy_notebook();
            return false;
        });
        this.element.find('#download_ipynb').click(function () {
            var base_url = that.notebook.base_url;
            var notebook_path = that.notebook.notebook_path;
            var w = window.open('');
            var url = utils.url_join_encode(base_url, 'files', notebook_path)
                                + '?download=1';
            if (that.notebook.dirty) {
                that.notebook.save_notebook().then(function() {
                    w.location = url;
                });
            } else {
                w.location = url;
            }
        });
        
        this.element.find('#print_preview').click(function () {
            that._nbconvert('html', false);
        });

        this.element.find('#download_html').click(function () {
            that._nbconvert('html', true);
        });

        this.element.find('#download_markdown').click(function () {
            that._nbconvert('markdown', true);
        });

        this.element.find('#download_rst').click(function () {
            that._nbconvert('rst', true);
        });

        this.element.find('#download_pdf').click(function () {
            that._nbconvert('pdf', true);
        });

        this.element.find('#download_script').click(function () {
            that._nbconvert('script', true);
        });

        this.element.find('#rename_notebook').click(function () {
            that.save_widget.rename_notebook({notebook: that.notebook});
        });

        this.element.find('#save_checkpoint').click(function () {
            that.notebook.save_checkpoint();
        });

        this.element.find('#restore_checkpoint').click(function () {
        });

        this.element.find('#trust_notebook').click(function () {
            that.notebook.trust_notebook();
        });
        this.events.on('trust_changed.Notebook', function (event, trusted) {
            if (trusted) {
                that.element.find('#trust_notebook')
                    .addClass("disabled").off('click')
                    .find("a").text("Trusted Notebook");
            } else {
                that.element.find('#trust_notebook')
                    .removeClass("disabled").on('click', function () {
                        that.notebook.trust_notebook();
                    })
                    .find("a").text("Trust Notebook");
            }
        });

        this.element.find('#kill_and_exit').click(function () {
            var close_window = function () {
                /**
                 * allow closing of new tabs in Chromium, impossible in FF
                 */
                window.open('', '_self', '');
                window.close();
            };
            // finish with close on success or failure
            that.notebook.session.delete(close_window, close_window);
        });

        // Edit
        this.element.find('#cut_cell').click(function () {
            that.notebook.cut_cell();
        });
        this.element.find('#copy_cell').click(function () {
            that.notebook.copy_cell();
        });
        this.element.find('#delete_cell').click(function () {
            that.notebook.delete_cell();
        });
        this.element.find('#undelete_cell').click(function () {
            that.notebook.undelete_cell();
        });
        this.element.find('#split_cell').click(function () {
            that.notebook.split_cell();
        });
        this.element.find('#merge_cell_above').click(function () {
            that.notebook.merge_cell_above();
        });
        this.element.find('#merge_cell_below').click(function () {
            that.notebook.merge_cell_below();
        });
        this.element.find('#move_cell_up').click(function () {
            that.notebook.move_cell_up();
        });
        this.element.find('#move_cell_down').click(function () {
            that.notebook.move_cell_down();
        });
        this.element.find('#edit_nb_metadata').click(function () {
            that.notebook.edit_metadata({
                notebook: that.notebook,
                keyboard_manager: that.notebook.keyboard_manager});
        });
        
        // View
        this.element.find('#toggle_header').click(function () {
            $('#header-container').toggle();
            $('.header-bar').toggle();
            that._size_header();
        });
        this.element.find('#toggle_toolbar').click(function () {
            $('div#maintoolbar').toggle();
            that._size_header();
        });
        // Insert
        this.element.find('#insert_cell_above').click(function () {
            that.notebook.insert_cell_above('code');
            that.notebook.select_prev();
        });
        this.element.find('#insert_cell_below').click(function () {
            that.notebook.insert_cell_below('code');
            that.notebook.select_next();
        });
        // Cell
        this.element.find('#run_cell').click(function () {
            that.notebook.execute_cell();
        });
        this.element.find('#run_cell_select_below').click(function () {
            that.notebook.execute_cell_and_select_below();
        });
        this.element.find('#run_cell_insert_below').click(function () {
            that.notebook.execute_cell_and_insert_below();
        });
        this.element.find('#run_all_cells').click(function () {
            that.notebook.execute_all_cells();
        });
        this.element.find('#run_all_cells_above').click(function () {
            that.notebook.execute_cells_above();
        });
        this.element.find('#run_all_cells_below').click(function () {
            that.notebook.execute_cells_below();
        });
        this.element.find('#to_code').click(function () {
            that.notebook.to_code();
        });
        this.element.find('#to_markdown').click(function () {
            that.notebook.to_markdown();
        });
        this.element.find('#to_raw').click(function () {
            that.notebook.to_raw();
        });
        
        this.element.find('#toggle_current_output').click(function () {
            that.notebook.toggle_output();
        });
        this.element.find('#toggle_current_output_scroll').click(function () {
            that.notebook.toggle_output_scroll();
        });
        this.element.find('#clear_current_output').click(function () {
            that.notebook.clear_output();
        });
        
        this.element.find('#toggle_all_output').click(function () {
            that.notebook.toggle_all_output();
        });
        this.element.find('#toggle_all_output_scroll').click(function () {
            that.notebook.toggle_all_output_scroll();
        });
        this.element.find('#clear_all_output').click(function () {
            that.notebook.clear_all_output();
        });
        
        // Kernel
        this.element.find('#int_kernel').click(function () {
            that.notebook.kernel.interrupt();
        });
        this.element.find('#restart_kernel').click(function () {
            that.notebook.restart_kernel();
        });
        this.element.find('#reconnect_kernel').click(function () {
            that.notebook.kernel.reconnect();
        });
        // Help
        if (this.tour) {
            this.element.find('#notebook_tour').click(function () {
                that.tour.start();
            });
        } else {
            this.element.find('#notebook_tour').addClass("disabled");
        }
        this.element.find('#keyboard_shortcuts').click(function () {
            that.quick_help.show_keyboard_shortcuts();
        });
        
        this.update_restore_checkpoint(null);
        
        this.events.on('checkpoints_listed.Notebook', function (event, data) {
            that.update_restore_checkpoint(that.notebook.checkpoints);
        });
        
        this.events.on('checkpoint_created.Notebook', function (event, data) {
            that.update_restore_checkpoint(that.notebook.checkpoints);
        });
        
        this.events.on('notebook_loaded.Notebook', function() {
            var langinfo = that.notebook.metadata.language_info || {};
            that.update_nbconvert_script(langinfo);
        });
        
        this.events.on('kernel_ready.Kernel', function(event, data) {
            var langinfo = data.kernel.info_reply.language_info || {};
            that.update_nbconvert_script(langinfo);
            that.add_kernel_help_links(data.kernel.info_reply.help_links || []);
        });
    };

    MenuBar.prototype.update_restore_checkpoint = function(checkpoints) {
        var ul = this.element.find("#restore_checkpoint").find("ul");
        ul.empty();
        if (!checkpoints || checkpoints.length === 0) {
            ul.append(
                $("<li/>")
                .addClass("disabled")
                .append(
                    $("<a/>")
                    .text("No checkpoints")
                )
            );
            return;
        }
        
        var that = this;
        checkpoints.map(function (checkpoint) {
            var d = new Date(checkpoint.last_modified);
            ul.append(
                $("<li/>").append(
                    $("<a/>")
                    .attr("href", "#")
                    .text(moment(d).format("LLLL"))
                    .click(function () {
                        that.notebook.restore_checkpoint_dialog(checkpoint);
                    })
                )
            );
        });
    };

    MenuBar.prototype.update_nbconvert_script = function(langinfo) {
        /**
         * Set the 'Download as foo' menu option for the relevant language.
         */
        var el = this.element.find('#download_script');
        
        // Set menu entry text to e.g. "Python (.py)"
        var langname = (langinfo.name || 'Script');
        langname = langname.charAt(0).toUpperCase()+langname.substr(1); // Capitalise
        el.find('a').text(langname + ' ('+(langinfo.file_extension || 'txt')+')');
    };

    MenuBar.prototype.add_kernel_help_links = function(help_links) {
        /** add links from kernel_info to the help menu */
        var divider = $("#kernel-help-links");
        if (divider.length === 0) {
            // insert kernel help section above about link
            var about = $("#notebook_about").parent();
            divider = $("<li>")
                .attr('id', "kernel-help-links")
                .addClass('divider');
            about.prev().before(divider);
        }
        // remove previous entries
        while (!divider.next().hasClass('divider')) {
            divider.next().remove();
        }
        if (help_links.length === 0) {
            // no help links, remove the divider
            divider.remove();
            return;
        }
        var cursor = divider;
        help_links.map(function (link) {
            cursor.after($("<li>")
                .append($("<a>")
                    .attr('target', '_blank')
                    .attr('title', 'Opens in a new window')
                    .attr('href', link.url)
                    .append($("<i>")
                        .addClass("fa fa-external-link menu-icon pull-right")
                    )
                    .append($("<span>")
                        .text(link.text)
                    )
                )
            );
            cursor = cursor.next();
        });
        
    };

    exports.MenuBar = MenuBar;

},{"base/js/dialog":"/Users/jon/jupyter/notebook/notebook/static-src/base/js/dialog.js","base/js/namespace":"/Users/jon/jupyter/notebook/notebook/static-src/base/js/namespace.js","base/js/utils":"/Users/jon/jupyter/notebook/notebook/static-src/base/js/utils.js","moment":"/Users/jon/jupyter/notebook/node_modules/moment/moment.js","notebook/js/tour":"/Users/jon/jupyter/notebook/notebook/static-src/notebook/js/tour.js"}],"/Users/jon/jupyter/notebook/notebook/static-src/notebook/js/notebook.js":[function(require,module,exports){
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.

/**
 * @module notebook
 */
    "use strict";

    var IPython = require('base/js/namespace');
    var utils = require('base/js/utils');
    var dialog = require('base/js/dialog');
    var cellmod = require('notebook/js/cell');
    var textcell = require('notebook/js/textcell');
    var codecell = require('notebook/js/codecell');
    var moment = require('moment');
    var configmod = require('services/config');
    var session = require('services/sessions/session');
    var celltoolbar = require('notebook/js/celltoolbar');
    var marked = require('marked');
    var mathjaxutils = require('notebook/js/mathjaxutils');
    var keyboard = require('base/js/keyboard');
    var tooltip = require('notebook/js/tooltip');
    var default_celltoolbar = require('notebook/js/celltoolbarpresets/default');
    var rawcell_celltoolbar = require('notebook/js/celltoolbarpresets/rawcell');
    var slideshow_celltoolbar = require('notebook/js/celltoolbarpresets/slideshow');
    var scrollmanager = require('notebook/js/scrollmanager');
    var commandpalette = require('notebook/js/commandpalette');

    /**
     * Contains and manages cells.
     * @class Notebook
     * @param {string}          selector
     * @param {object}          options - Dictionary of keyword arguments.  
     * @param {jQuery}          options.events - selector of Events
     * @param {KeyboardManager} options.keyboard_manager
     * @param {Contents}        options.contents
     * @param {SaveWidget}      options.save_widget
     * @param {object}          options.config
     * @param {string}          options.base_url
     * @param {string}          options.notebook_path
     * @param {string}          options.notebook_name
     */
    var Notebook = function (selector, options) {
        this.config = options.config;
        this.class_config = new configmod.ConfigWithDefaults(this.config, 
                                        Notebook.options_default, 'Notebook');
        this.base_url = options.base_url;
        this.notebook_path = options.notebook_path;
        this.notebook_name = options.notebook_name;
        this.events = options.events;
        this.keyboard_manager = options.keyboard_manager;
        this.contents = options.contents;
        this.save_widget = options.save_widget;
        this.tooltip = new tooltip.Tooltip(this.events);
        this.ws_url = options.ws_url;
        this._session_starting = false;
        this.last_modified = null;

        //  Create default scroll manager.
        this.scroll_manager = new scrollmanager.ScrollManager(this);

        // TODO: This code smells (and the other `= this` line a couple lines down)
        // We need a better way to deal with circular instance references.
        this.keyboard_manager.notebook = this;
        this.save_widget.notebook = this;
        
        mathjaxutils.init();

        if (marked) {
            marked.setOptions({
                gfm : true,
                tables: true,
                // FIXME: probably want central config for CodeMirror theme when we have js config
                langPrefix: "cm-s-ipython language-",
                highlight: function(code, lang, callback) {
                    if (!lang) {
                        // no language, no highlight
                        if (callback) {
                            callback(null, code);
                            return;
                        } else {
                            return code;
                        }
                    }
                    utils.requireCodeMirrorMode(lang, function (spec) {
                        var el = document.createElement("div");
                        var mode = CodeMirror.getMode({}, spec);
                        if (!mode) {
                            console.log("No CodeMirror mode: " + lang);
                            callback(null, code);
                            return;
                        }
                        try {
                            CodeMirror.runMode(code, spec, el);
                            callback(null, el.innerHTML);
                        } catch (err) {
                            console.log("Failed to highlight " + lang + " code", err);
                            callback(err, code);
                        }
                    }, function (err) {
                        console.log("No CodeMirror mode: " + lang);
                        callback(err, code);
                    });
                }
            });
        }

        this.element = $(selector);
        this.element.scroll();
        this.element.data("notebook", this);
        this.next_prompt_number = 1;
        this.session = null;
        this.kernel = null;
        this.kernel_busy = false;
        this.clipboard = null;
        this.undelete_backup = null;
        this.undelete_index = null;
        this.undelete_below = false;
        this.paste_enabled = false;
        this.writable = false;
        // It is important to start out in command mode to match the intial mode
        // of the KeyboardManager.
        this.mode = 'command';
        this.set_dirty(false);
        this.metadata = {};
        this._checkpoint_after_save = false;
        this.last_checkpoint = null;
        this.checkpoints = [];
        this.autosave_interval = 0;
        this.autosave_timer = null;
        // autosave *at most* every two minutes
        this.minimum_autosave_interval = 120000;
        this.notebook_name_blacklist_re = /[\/\\:]/;
        this.nbformat = 4; // Increment this when changing the nbformat
        this.nbformat_minor = this.current_nbformat_minor = 0; // Increment this when changing the nbformat
        this.codemirror_mode = 'text';
        this.create_elements();
        this.bind_events();
        this.kernel_selector = null;
        this.dirty = null;
        this.trusted = null;
        this._fully_loaded = false;

        // Trigger cell toolbar registration.
        default_celltoolbar.register(this);
        rawcell_celltoolbar.register(this);
        slideshow_celltoolbar.register(this);

        // prevent assign to miss-typed properties.
        Object.seal(this);
    };

    Notebook.options_default = {
        // can be any cell type, or the special values of
        // 'above', 'below', or 'selected' to get the value from another cell.
        default_cell_type: 'code'
    };

    /**
     * Create an HTML and CSS representation of the notebook.
     */
    Notebook.prototype.create_elements = function () {
        var that = this;
        this.element.attr('tabindex','-1');
        this.container = $("<div/>").addClass("container").attr("id", "notebook-container");
        // We add this end_space div to the end of the notebook div to:
        // i) provide a margin between the last cell and the end of the notebook
        // ii) to prevent the div from scrolling up when the last cell is being
        // edited, but is too low on the page, which browsers will do automatically.
        var end_space = $('<div/>')
            .addClass('end_space');
        end_space.dblclick(function (e) {
            var ncells = that.ncells();
            that.insert_cell_below('code',ncells-1);
        });
        this.element.append(this.container);
        this.container.after(end_space);
    };

    /**
     * Bind JavaScript events: key presses and custom Jupyter events.
     */
    Notebook.prototype.bind_events = function () {
        var that = this;

        this.events.on('set_next_input.Notebook', function (event, data) {
            if (data.replace) {
                data.cell.set_text(data.text);
                data.cell.clear_output();
            } else {
                var index = that.find_cell_index(data.cell);
                var new_cell = that.insert_cell_below('code',index);
                new_cell.set_text(data.text);
            }
            that.dirty = true;
        });

        this.events.on('unrecognized_cell.Cell', function () {
            that.warn_nbformat_minor();
        });

        this.events.on('unrecognized_output.OutputArea', function () {
            that.warn_nbformat_minor();
        });

        this.events.on('set_dirty.Notebook', function (event, data) {
            that.dirty = data.value;
        });

        this.events.on('trust_changed.Notebook', function (event, trusted) {
            that.trusted = trusted;
        });

        this.events.on('select.Cell', function (event, data) {
            var index = that.find_cell_index(data.cell);
            that.select(index);
        });

        this.events.on('edit_mode.Cell', function (event, data) {
            that.handle_edit_mode(data.cell);
        });

        this.events.on('command_mode.Cell', function (event, data) {
            that.handle_command_mode(data.cell);
        });
        
        this.events.on('spec_changed.Kernel', function(event, data) {
            that.metadata.kernelspec = {
                name: data.name,
                display_name: data.spec.display_name,
                language: data.spec.language,
            };
            // start session if the current session isn't already correct
            if (!(that.session && that.session.kernel && that.session.kernel.name === data.name)) {
                that.start_session(data.name);
            }
        });

        this.events.on('kernel_ready.Kernel', function(event, data) {
            var kinfo = data.kernel.info_reply;
            if (!kinfo.language_info) {
                delete that.metadata.language_info;
                return;
            }
            var langinfo = kinfo.language_info;
            that.metadata.language_info = langinfo;
            // Mode 'null' should be plain, unhighlighted text.
            var cm_mode = langinfo.codemirror_mode || langinfo.name || 'null';
            that.set_codemirror_mode(cm_mode);
        });
        
        this.events.on('kernel_idle.Kernel', function () {
            that.kernel_busy = false;
        });
        
        this.events.on('kernel_busy.Kernel', function () {
            that.kernel_busy = true;
        });

        var collapse_time = function (time) {
            var app_height = $('#ipython-main-app').height(); // content height
            var splitter_height = $('div#pager_splitter').outerHeight(true);
            var new_height = app_height - splitter_height;
            that.element.animate({height : new_height + 'px'}, time);
        };

        this.element.bind('collapse_pager', function (event, extrap) {
            var time = (extrap !== undefined) ? ((extrap.duration !== undefined ) ? extrap.duration : 'fast') : 'fast';
            collapse_time(time);
        });

        var expand_time = function (time) {
            var app_height = $('#ipython-main-app').height(); // content height
            var splitter_height = $('div#pager_splitter').outerHeight(true);
            var pager_height = $('div#pager').outerHeight(true);
            var new_height = app_height - pager_height - splitter_height;
            that.element.animate({height : new_height + 'px'}, time);
        };

        this.element.bind('expand_pager', function (event, extrap) {
            var time = (extrap !== undefined) ? ((extrap.duration !== undefined ) ? extrap.duration : 'fast') : 'fast';
            expand_time(time);
        });

        // Firefox 22 broke $(window).on("beforeunload")
        // I'm not sure why or how.
        window.onbeforeunload = function (e) {
            // TODO: Make killing the kernel configurable.
            var kill_kernel = false;
            if (kill_kernel) {
                that.session.delete();
            }
            // if we are autosaving, trigger an autosave on nav-away.
            // still warn, because if we don't the autosave may fail.
            if (that.dirty) {
                if ( that.autosave_interval ) {
                    // schedule autosave in a timeout
                    // this gives you a chance to forcefully discard changes
                    // by reloading the page if you *really* want to.
                    // the timer doesn't start until you *dismiss* the dialog.
                    setTimeout(function () {
                        if (that.dirty) {
                            that.save_notebook();
                        }
                    }, 1000);
                    return "Autosave in progress, latest changes may be lost.";
                } else {
                    return "Unsaved changes will be lost.";
                }
            }
            // if the kernel is busy, prompt the user if he’s sure
            if (that.kernel_busy) {
                return "The Kernel is busy, outputs may be lost.";
            }
            // IE treats null as a string.  Instead just return which will avoid the dialog.
            return;
        };
    };

    Notebook.prototype.show_command_palette = function() {
        var x = new commandpalette.CommandPalette(this);
    }

    /**
     * Trigger a warning dialog about missing functionality from newer minor versions
     */
    Notebook.prototype.warn_nbformat_minor = function (event) {
        var v = 'v' + this.nbformat + '.';
        var orig_vs = v + this.nbformat_minor;
        var this_vs = v + this.current_nbformat_minor;
        var msg = "This notebook is version " + orig_vs + ", but we only fully support up to " +
        this_vs + ".  You can still work with this notebook, but cell and output types " +
        "introduced in later notebook versions will not be available.";

        dialog.modal({
            notebook: this,
            keyboard_manager: this.keyboard_manager,
            title : "Newer Notebook",
            body : msg,
            buttons : {
                OK : {
                    "class" : "btn-danger"
                }
            }
        });
    };

    /**
     * Set the dirty flag, and trigger the set_dirty.Notebook event
     */
    Notebook.prototype.set_dirty = function (value) {
        if (value === undefined) {
            value = true;
        }
        if (this.dirty === value) {
            return;
        }
        this.events.trigger('set_dirty.Notebook', {value: value});
    };

    /**
     * Scroll the top of the page to a given cell.
     * 
     * @param {integer}  index - An index of the cell to view
     * @param {integer}  time - Animation time in milliseconds
     * @return {integer} Pixel offset from the top of the container
     */
    Notebook.prototype.scroll_to_cell = function (index, time) {
        return this.scroll_cell_percent(index, 0, time);
    };

    /**
     * Scroll the middle of the page to a given cell.
     *
     * @param {integer}  index - An index of the cell to view
     * @param {integer}  percent - 0-100, the location on the screen to scroll.
     *                   0 is the top, 100 is the bottom.
     * @param {integer}  time - Animation time in milliseconds
     * @return {integer} Pixel offset from the top of the container
     */
    Notebook.prototype.scroll_cell_percent = function (index, percent, time) {
        var cells = this.get_cells();
        time = time || 0;
        percent = percent || 0;
        index = Math.min(cells.length-1,index);
        index = Math.max(0             ,index);
        var sme = this.scroll_manager.element;
        var h = sme.height();
        var st = sme.scrollTop();
        var t = sme.offset().top;
        var ct = cells[index].element.offset().top;
        var scroll_value =  st + ct - (t + .01 * percent * h);
        this.scroll_manager.element.animate({scrollTop:scroll_value}, time);
        return scroll_value;
    };

    /**
     * Scroll to the bottom of the page.
     */
    Notebook.prototype.scroll_to_bottom = function () {
        this.scroll_manager.element.animate({scrollTop:this.element.get(0).scrollHeight}, 0);
    };

    /**
     * Scroll to the top of the page.
     */
    Notebook.prototype.scroll_to_top = function () {
        this.scroll_manager.element.animate({scrollTop:0}, 0);
    };

    // Edit Notebook metadata

    /**
     * Display a dialog that allows the user to edit the Notebook's metadata.
     */
    Notebook.prototype.edit_metadata = function () {
        var that = this;
        dialog.edit_metadata({
            md: this.metadata, 
            callback: function (md) {
                that.metadata = md;
            },
            name: 'Notebook',
            notebook: this,
            keyboard_manager: this.keyboard_manager});
    };

    // Cell indexing, retrieval, etc.

    /**
     * Get all cell elements in the notebook.
     * 
     * @return {jQuery} A selector of all cell elements
     */
    Notebook.prototype.get_cell_elements = function () {
        return this.container.find(".cell").not('.cell .cell');
    };

    /**
     * Get a particular cell element.
     * 
     * @param {integer} index An index of a cell to select
     * @return {jQuery} A selector of the given cell.
     */
    Notebook.prototype.get_cell_element = function (index) {
        var result = null;
        var e = this.get_cell_elements().eq(index);
        if (e.length !== 0) {
            result = e;
        }
        return result;
    };

    /**
     * Try to get a particular cell by msg_id.
     * 
     * @param {string} msg_id A message UUID
     * @return {Cell} Cell or null if no cell was found.
     */
    Notebook.prototype.get_msg_cell = function (msg_id) {
        return codecell.CodeCell.msg_cells[msg_id] || null;
    };

    /**
     * Count the cells in this notebook.
     * 
     * @return {integer} The number of cells in this notebook
     */
    Notebook.prototype.ncells = function () {
        return this.get_cell_elements().length;
    };

    /**
     * Get all Cell objects in this notebook.
     * 
     * @return {Array} This notebook's Cell objects
     */
    Notebook.prototype.get_cells = function () {
        // TODO: we are often calling cells as cells()[i], which we should optimize
        // to cells(i) or a new method.
        return this.get_cell_elements().toArray().map(function (e) {
            return $(e).data("cell");
        });
    };

    /**
     * Get a Cell objects from this notebook.
     * 
     * @param {integer} index - An index of a cell to retrieve
     * @return {Cell} Cell or null if no cell was found.
     */
    Notebook.prototype.get_cell = function (index) {
        var result = null;
        var ce = this.get_cell_element(index);
        if (ce !== null) {
            result = ce.data('cell');
        }
        return result;
    };

    /**
     * Get the cell below a given cell.
     * 
     * @param {Cell} cell
     * @return {Cell} the next cell or null if no cell was found.
     */
    Notebook.prototype.get_next_cell = function (cell) {
        var result = null;
        var index = this.find_cell_index(cell);
        if (this.is_valid_cell_index(index+1)) {
            result = this.get_cell(index+1);
        }
        return result;
    };

    /**
     * Get the cell above a given cell.
     * 
     * @param {Cell} cell
     * @return {Cell} The previous cell or null if no cell was found.
     */
    Notebook.prototype.get_prev_cell = function (cell) {
        var result = null;
        var index = this.find_cell_index(cell);
        if (index !== null && index > 0) {
            result = this.get_cell(index-1);
        }
        return result;
    };

    /**
     * Get the numeric index of a given cell.
     * 
     * @param {Cell} cell
     * @return {integer} The cell's numeric index or null if no cell was found.
     */
    Notebook.prototype.find_cell_index = function (cell) {
        var result = null;
        this.get_cell_elements().filter(function (index) {
            if ($(this).data("cell") === cell) {
                result = index;
            }
        });
        return result;
    };

    /**
     * Return given index if defined, or the selected index if not.
     * 
     * @param {integer} [index] - A cell's index
     * @return {integer} cell index
     */
    Notebook.prototype.index_or_selected = function (index) {
        var i;
        if (index === undefined || index === null) {
            i = this.get_selected_index();
            if (i === null) {
                i = 0;
            }
        } else {
            i = index;
        }
        return i;
    };

    /**
     * Get the currently selected cell.
     * 
     * @return {Cell} The selected cell
     */
    Notebook.prototype.get_selected_cell = function () {
        var index = this.get_selected_index();
        return this.get_cell(index);
    };

    /**
     * Check whether a cell index is valid.
     * 
     * @param {integer} index - A cell index
     * @return True if the index is valid, false otherwise
     */
    Notebook.prototype.is_valid_cell_index = function (index) {
        if (index !== null && index >= 0 && index < this.ncells()) {
            return true;
        } else {
            return false;
        }
    };

    /**
     * Get the index of the currently selected cell.
     *
     * @return {integer} The selected cell's numeric index
     */
    Notebook.prototype.get_selected_index = function () {
        var result = null;
        this.get_cell_elements().filter(function (index) {
            if ($(this).data("cell").selected === true) {
                result = index;
            }
        });
        return result;
    };

    /**
     * Get the index of the anchor cell for range selection
     *
     * @return {integer} The anchor cell's numeric index
     */
    Notebook.prototype.get_selection_anchor = function() {
        var result = null;
        this.get_cell_elements().filter(function (index) {
            if ($(this).data("cell").selection_anchor === true) {
                result = index;
            }
        });
        return result;
    };

    /**
     * Get an array of the cells in the currently selected range
     *
     * @return {Array} The selected cells
     */
    Notebook.prototype.get_selected_cells = function () {
        return this.get_cells().filter(function(cell) {
            return cell.in_selection;
        });
    };

    /**
     * Get the indices of the currently selected range of cells.
     *
     * @return {Array} The selected cells' numeric indices
     */
    Notebook.prototype.get_selected_indices = function () {
        var result = [];
        this.get_cell_elements().filter(function (index) {
            if ($(this).data("cell").in_selection === true) {
                result.push(index);
            }
        });
        return result;
    };

    // Cell selection.

    /**
     * Programmatically select a cell.
     * 
     * @param {integer} index - A cell's index
     * @return {Notebook} This notebook
     */
    Notebook.prototype.select = function (index) {
        if (this.is_valid_cell_index(index)) {
            var sindex = this.get_selected_index();
            if (sindex !== null && index !== sindex) {
                // If we are about to select a different cell, make sure we are
                // first in command mode.
                if (this.mode !== 'command') {
                    this.command_mode();
                }
            }
            var current_selection = this.get_selected_cells();
            for (var i=0; i<current_selection.length; i++) {
                current_selection[i].unselect()
            }

            var cell = this._select(index);
            cell.selection_anchor = true
        }
        return this;
    };

    Notebook.prototype._select = function(index) {
        var cell = this.get_cell(index);
        cell.select();
        this.events.trigger('selected_cell_type_changed.Notebook',
            {'cell_type':cell.cell_type}
        );
        return cell;
    };

    /**
     * Programmatically select the next cell.
     *
     * @return {Notebook} This notebook
     */
    Notebook.prototype.select_next = function () {
        var index = this.get_selected_index();
        this.select(index+1);
        return this;
    };

    /**
     * Programmatically select the previous cell.
     *
     * @return {Notebook} This notebook
     */
    Notebook.prototype.select_prev = function () {
        var index = this.get_selected_index();
        this.select(index-1);
        return this;
    };

    /**
     * Extend the selected range
     *
     * @param {string} direction - 'up' or 'down
     */
    Notebook.prototype.extend_selection = function(direction) {
        var anchor_ix = this.get_selection_anchor();
        var cursor_ix = this.get_selected_index();
        var range_direction = (cursor_ix > anchor_ix) ? 'down' : 'up';
        var contracting = (cursor_ix !== anchor_ix) &&
                            (direction !== range_direction);
        var ix_delta = (direction === 'up') ? -1 : 1;
        var new_ix = cursor_ix + ix_delta;
        if (new_ix < 0 || new_ix >= this.ncells()) {
            return false;
        }
        if (this.mode !== 'command') {
            this.command_mode();
        }
        this.get_cell(cursor_ix).unselect(!contracting);
        this._select(new_ix);
        return true;
    };

    /**
     * Clear selection of multiple cells (except the cell at the cursor)
     */
    Notebook.prototype.reset_selection = function() {
        var current_selection = this.get_selected_cells();
        for (var i=0; i<current_selection.length; i++) {
            if (!current_selection[i].selected) {
                current_selection[i].unselect()
            }
        }
    };


    // Edit/Command mode

    /**
     * Gets the index of the cell that is in edit mode.
     *
     * @return {integer} index
     */
    Notebook.prototype.get_edit_index = function () {
        var result = null;
        this.get_cell_elements().filter(function (index) {
            if ($(this).data("cell").mode === 'edit') {
                result = index;
            }
        });
        return result;
    };

    /**
     * Handle when a a cell blurs and the notebook should enter command mode.
     *
     * @param {Cell} [cell] - Cell to enter command mode on.
     */
    Notebook.prototype.handle_command_mode = function (cell) {
        if (this.mode !== 'command') {
            cell.command_mode();
            this.mode = 'command';
            this.events.trigger('command_mode.Notebook');
            this.keyboard_manager.command_mode();
        }
    };

    /**
     * Make the notebook enter command mode.
     */
    Notebook.prototype.command_mode = function () {
        var cell = this.get_cell(this.get_edit_index());
        if (cell && this.mode !== 'command') {
            // We don't call cell.command_mode, but rather blur the CM editor
            // which will trigger the call to handle_command_mode.
            cell.code_mirror.getInputField().blur();
        }
    };

    /**
     * Handle when a cell fires it's edit_mode event.
     *
     * @param {Cell} [cell] Cell to enter edit mode on.
     */
    Notebook.prototype.handle_edit_mode = function (cell) {
        if (cell && this.mode !== 'edit') {
            cell.edit_mode();
            this.mode = 'edit';
            this.reset_selection();
            this.events.trigger('edit_mode.Notebook');
            this.keyboard_manager.edit_mode();
        }
    };

    /**
     * Make a cell enter edit mode.
     */
    Notebook.prototype.edit_mode = function () {
        var cell = this.get_selected_cell();
        if (cell && this.mode !== 'edit') {
            cell.unrender();
            cell.focus_editor();
        }
    };

    /**
     * Ensure either cell, or codemirror is focused. Is none 
     * is focused, focus the cell.
     */
    Notebook.prototype.ensure_focused = function(){
        var cell = this.get_selected_cell();
        if (cell === null) {return;}  // No cell is selected
        cell.ensure_focused();
    }

    /**
     * Focus the currently selected cell.
     */
    Notebook.prototype.focus_cell = function () {
        var cell = this.get_selected_cell();
        if (cell === null) {return;}  // No cell is selected
        cell.focus_cell();
    };

    // Cell movement

    /**
     * Move given (or selected) cell up and select it.
     * 
     * @param {integer} [index] - cell index
     * @return {Notebook} This notebook
     */
    Notebook.prototype.move_cell_up = function (index) {
        var i = this.index_or_selected(index);
        if (this.is_valid_cell_index(i) && i > 0) {
            var pivot = this.get_cell_element(i-1);
            var tomove = this.get_cell_element(i);
            if (pivot !== null && tomove !== null) {
                tomove.detach();
                pivot.before(tomove);
                this.select(i-1);
                var cell = this.get_selected_cell();
                cell.focus_cell();
            }
            this.set_dirty(true);
        }
        return this;
    };


    /**
     * Move given (or selected) cell down and select it.
     * 
     * @param {integer} [index] - cell index
     * @return {Notebook} This notebook
     */
    Notebook.prototype.move_cell_down = function (index) {
        var i = this.index_or_selected(index);
        if (this.is_valid_cell_index(i) && this.is_valid_cell_index(i+1)) {
            var pivot = this.get_cell_element(i+1);
            var tomove = this.get_cell_element(i);
            if (pivot !== null && tomove !== null) {
                tomove.detach();
                pivot.after(tomove);
                this.select(i+1);
                var cell = this.get_selected_cell();
                cell.focus_cell();
            }
        }
        this.set_dirty();
        return this;
    };


    // Insertion, deletion.

    /**
     * Delete a cell from the notebook without any precautions
     * Needed to reload checkpoints and other things like that.
     * 
     * @param {integer} [index] - cell's numeric index
     * @return {Notebook} This notebook
     */
    Notebook.prototype._unsafe_delete_cell = function (index) {
        var i = this.index_or_selected(index);
        var cell = this.get_cell(i);

        $('#undelete_cell').addClass('disabled');
        if (this.is_valid_cell_index(i)) {
            var old_ncells = this.ncells();
            var ce = this.get_cell_element(i);
            ce.remove();
            this.set_dirty(true);
        }
        return this;
    };


    /**
     * Delete cells from the notebook
     *
     * @param {Array} [indices] - the numeric indices of cells to delete.
     * @return {Notebook} This notebook
     */
    Notebook.prototype.delete_cells = function(indices) {
        if (indices === undefined) {
            indices = this.get_selected_indices();
        }

        this.undelete_backup = [];

        var cursor_ix_before = this.get_selected_index();
        var deleting_before_cursor = 0;
        for (var i=0; i < indices.length; i++) {
            if (!this.get_cell(indices[i]).is_deletable()) {
                // If any cell is marked undeletable, cancel
                return this;
            }

            if (indices[i] < cursor_ix_before) {
                deleting_before_cursor++;
            }
        }

        // If we started deleting cells from the top, the later indices would
        // get offset. We sort them into descending order to avoid that.
        indices.sort(function(a, b) {return b-a;});
        for (i=0; i < indices.length; i++) {
            var cell = this.get_cell(indices[i]);
            this.undelete_backup.push(cell.toJSON());
            this.get_cell_element(indices[i]).remove();
            this.events.trigger('delete.Cell', {'cell': cell, 'index': indices[i]});
        }

        // Flip the backup copy of cells back to first-to-last order
        this.undelete_backup.reverse();

        var new_ncells = this.ncells();
        // Always make sure we have at least one cell.
        if (new_ncells === 0) {
            this.insert_cell_below('code');
            new_ncells = 1;
        }

        this.undelete_below = false;
        var cursor_ix_after = this.get_selected_index();
        if (cursor_ix_after === null) {
            // Selected cell was deleted
            cursor_ix_after = cursor_ix_before - deleting_before_cursor;
            if (cursor_ix_after >= new_ncells) {
                cursor_ix_after = new_ncells - 1;
                this.undelete_below = true;
            }
            this.select(cursor_ix_after);
        }

        // This will put all the deleted cells back in one location, rather than
        // where they came from. It will do until we have proper undo support.
        this.undelete_index = cursor_ix_after;
        $('#undelete_cell').removeClass('disabled');

        this.set_dirty(true);

        return this;
    };

    /**
     * Delete a cell from the notebook.
     * 
     * @param {integer} [index] - cell's numeric index
     * @return {Notebook} This notebook
     */
    Notebook.prototype.delete_cell = function (index) {
        if (index === undefined) {
            return this.delete_cells();
        } else {
            return this.delete_cells([index]);
        }
    };

    /**
     * Restore the most recently deleted cells.
     */
    Notebook.prototype.undelete_cell = function() {
        if (this.undelete_backup !== null && this.undelete_index !== null) {
            var i, cell_data, new_cell;
            if (this.undelete_below) {
                for (i = this.undelete_backup.length-1; i >= 0; i--) {
                    cell_data = this.undelete_backup[i];
                    new_cell = this.insert_cell_below(cell_data.cell_type,
                        this.undelete_index);
                    new_cell.fromJSON(cell_data);
                }
            } else {
                for (i=0; i < this.undelete_backup.length; i++) {
                    cell_data = this.undelete_backup[i];
                    new_cell = this.insert_cell_above(cell_data.cell_type,
                        this.undelete_index);
                    new_cell.fromJSON(cell_data);
                }
            }

            this.set_dirty(true);
            this.undelete_backup = null;
            this.undelete_index = null;
        }
        $('#undelete_cell').addClass('disabled');
    };

    /**
     * Insert a cell so that after insertion the cell is at given index.
     *
     * If cell type is not provided, it will default to the type of the
     * currently active cell.
     *
     * Similar to insert_above, but index parameter is mandatory.
     *
     * Index will be brought back into the accessible range [0,n].
     *
     * @param {string} [type] - in ['code','markdown', 'raw'], defaults to 'code'
     * @param {integer} [index] - a valid index where to insert cell
     * @return {Cell|null} created cell or null
     */
    Notebook.prototype.insert_cell_at_index = function(type, index){

        var ncells = this.ncells();
        index = Math.min(index, ncells);
        index = Math.max(index, 0);
        var cell = null;
        type = type || this.class_config.get_sync('default_cell_type');
        if (type === 'above') {
            if (index > 0) {
                type = this.get_cell(index-1).cell_type;
            } else {
                type = 'code';
            }
        } else if (type === 'below') {
            if (index < ncells) {
                type = this.get_cell(index).cell_type;
            } else {
                type = 'code';
            }
        } else if (type === 'selected') {
            type = this.get_selected_cell().cell_type;
        }

        if (ncells === 0 || this.is_valid_cell_index(index) || index === ncells) {
            var cell_options = {
                events: this.events, 
                config: this.config, 
                keyboard_manager: this.keyboard_manager, 
                notebook: this,
                tooltip: this.tooltip
            };
            switch(type) {
            case 'code':
                cell = new codecell.CodeCell(this.kernel, cell_options);
                cell.set_input_prompt();
                break;
            case 'markdown':
                cell = new textcell.MarkdownCell(cell_options);
                break;
            case 'raw':
                cell = new textcell.RawCell(cell_options);
                break;
            default:
                console.log("Unrecognized cell type: ", type, cellmod);
                cell = new cellmod.UnrecognizedCell(cell_options);
            }

            if(this._insert_element_at_index(cell.element,index)) {
                cell.render();
                this.events.trigger('create.Cell', {'cell': cell, 'index': index});
                cell.refresh();
                // We used to select the cell after we refresh it, but there
                // are now cases were this method is called where select is
                // not appropriate. The selection logic should be handled by the
                // caller of the the top level insert_cell methods.
                this.set_dirty(true);
            }
        }
        return cell;

    };

    /**
     * Insert an element at given cell index.
     *
     * @param {HTMLElement} element - a cell element
     * @param {integer}     [index] - a valid index where to inser cell
     * @returns {boolean}   success
     */
    Notebook.prototype._insert_element_at_index = function(element, index){
        if (element === undefined){
            return false;
        }

        var ncells = this.ncells();

        if (ncells === 0) {
            // special case append if empty
            this.container.append(element);
        } else if ( ncells === index ) {
            // special case append it the end, but not empty
            this.get_cell_element(index-1).after(element);
        } else if (this.is_valid_cell_index(index)) {
            // otherwise always somewhere to append to
            this.get_cell_element(index).before(element);
        } else {
            return false;
        }

        if (this.undelete_index !== null && index <= this.undelete_index) {
            this.undelete_index = this.undelete_index + 1;
            this.set_dirty(true);
        }
        return true;
    };

    /**
     * Insert a cell of given type above given index, or at top
     * of notebook if index smaller than 0.
     *
     * @param {string}     [type] - cell type
     * @param {integer}    [index] - defaults to the currently selected cell
     * @return {Cell|null} handle to created cell or null
     */
    Notebook.prototype.insert_cell_above = function (type, index) {
        index = this.index_or_selected(index);
        return this.insert_cell_at_index(type, index);
    };

    /**
     * Insert a cell of given type below given index, or at bottom
     * of notebook if index greater than number of cells
     *
     * @param {string}     [type] - cell type
     * @param {integer}    [index] - defaults to the currently selected cell
     * @return {Cell|null} handle to created cell or null
     */
    Notebook.prototype.insert_cell_below = function (type, index) {
        index = this.index_or_selected(index);
        return this.insert_cell_at_index(type, index+1);
    };


    /**
     * Insert cell at end of notebook
     *
     * @param {string} type - cell type
     * @return {Cell|null} handle to created cell or null
     */
    Notebook.prototype.insert_cell_at_bottom = function (type){
        var len = this.ncells();
        return this.insert_cell_below(type,len-1);
    };

    /**
     * Turn a cell into a code cell.
     * 
     * @param {integer} [index] - cell index
     */
    Notebook.prototype.to_code = function (index) {
        var i = this.index_or_selected(index);
        if (this.is_valid_cell_index(i)) {
            var source_cell = this.get_cell(i);
            if (!(source_cell instanceof codecell.CodeCell)) {
                var target_cell = this.insert_cell_below('code',i);
                var text = source_cell.get_text();
                if (text === source_cell.placeholder) {
                    text = '';
                }
                //metadata
                target_cell.metadata = source_cell.metadata;

                target_cell.set_text(text);
                // make this value the starting point, so that we can only undo
                // to this state, instead of a blank cell
                target_cell.code_mirror.clearHistory();
                source_cell.element.remove();
                this.select(i);
                var cursor = source_cell.code_mirror.getCursor();
                target_cell.code_mirror.setCursor(cursor);
                this.set_dirty(true);
            }
        }
    };

    /**
     * Turn a cell into a Markdown cell.
     * 
     * @param {integer} [index] - cell index
     */
    Notebook.prototype.to_markdown = function (index) {
        var i = this.index_or_selected(index);
        if (this.is_valid_cell_index(i)) {
            var source_cell = this.get_cell(i);

            if (!(source_cell instanceof textcell.MarkdownCell)) {
                var target_cell = this.insert_cell_below('markdown',i);
                var text = source_cell.get_text();

                if (text === source_cell.placeholder) {
                    text = '';
                }
                // metadata
                target_cell.metadata = source_cell.metadata;
                // We must show the editor before setting its contents
                target_cell.unrender();
                target_cell.set_text(text);
                // make this value the starting point, so that we can only undo
                // to this state, instead of a blank cell
                target_cell.code_mirror.clearHistory();
                source_cell.element.remove();
                this.select(i);
                if ((source_cell instanceof textcell.TextCell) && source_cell.rendered) {
                    target_cell.render();
                }
                var cursor = source_cell.code_mirror.getCursor();
                target_cell.code_mirror.setCursor(cursor);
                this.set_dirty(true);
            }
        }
    };

    /**
     * Turn a cell into a raw text cell.
     * 
     * @param {integer} [index] - cell index
     */
    Notebook.prototype.to_raw = function (index) {
        var i = this.index_or_selected(index);
        if (this.is_valid_cell_index(i)) {
            var target_cell = null;
            var source_cell = this.get_cell(i);

            if (!(source_cell instanceof textcell.RawCell)) {
                target_cell = this.insert_cell_below('raw',i);
                var text = source_cell.get_text();
                if (text === source_cell.placeholder) {
                    text = '';
                }
                //metadata
                target_cell.metadata = source_cell.metadata;
                // We must show the editor before setting its contents
                target_cell.unrender();
                target_cell.set_text(text);
                // make this value the starting point, so that we can only undo
                // to this state, instead of a blank cell
                target_cell.code_mirror.clearHistory();
                source_cell.element.remove();
                this.select(i);
                var cursor = source_cell.code_mirror.getCursor();
                target_cell.code_mirror.setCursor(cursor);
                this.set_dirty(true);
            }
        }
    };

    /**
     * Warn about heading cell support removal.
     */
    Notebook.prototype._warn_heading = function () {
        dialog.modal({
            notebook: this,
            keyboard_manager: this.keyboard_manager,
            title : "Use markdown headings",
            body : $("<p/>").text(
                'Jupyter no longer uses special heading cells. ' + 
                'Instead, write your headings in Markdown cells using # characters:'
            ).append($('<pre/>').text(
                '## This is a level 2 heading'
            )),
            buttons : {
                "OK" : {}
            }
        });
    };

    /**
     * Turn a cell into a heading containing markdown cell.
     * 
     * @param {integer} [index] - cell index
     * @param {integer} [level] - heading level (e.g., 1 for h1)
     */
    Notebook.prototype.to_heading = function (index, level) {
        this.to_markdown(index);
        level = level || 1;
        var i = this.index_or_selected(index);
        if (this.is_valid_cell_index(i)) {
            var cell = this.get_cell(i);
            cell.set_heading_level(level);
            this.set_dirty(true);
        }
    };


    // Cut/Copy/Paste

    /**
     * Enable the UI elements for pasting cells.
     */
    Notebook.prototype.enable_paste = function () {
        var that = this;
        if (!this.paste_enabled) {
            $('#paste_cell_replace').removeClass('disabled')
                .on('click', function () {that.paste_cell_replace();});
            $('#paste_cell_above').removeClass('disabled')
                .on('click', function () {that.paste_cell_above();});
            $('#paste_cell_below').removeClass('disabled')
                .on('click', function () {that.paste_cell_below();});
            this.paste_enabled = true;
        }
    };

    /**
     * Disable the UI elements for pasting cells.
     */
    Notebook.prototype.disable_paste = function () {
        if (this.paste_enabled) {
            $('#paste_cell_replace').addClass('disabled').off('click');
            $('#paste_cell_above').addClass('disabled').off('click');
            $('#paste_cell_below').addClass('disabled').off('click');
            this.paste_enabled = false;
        }
    };

    /**
     * Cut a cell.
     */
    Notebook.prototype.cut_cell = function () {
        this.copy_cell();
        this.delete_cell();
    };

    /**
     * Copy cells.
     */
    Notebook.prototype.copy_cell = function () {
        var cells = this.get_selected_cells();
        this.clipboard = [];
        var cell_json;
        for (var i=0; i < cells.length; i++) {
            cell_json = cells[i].toJSON();
            if (cell_json.metadata.deletable !== undefined) {
                delete cell_json.metadata.deletable;
            }
            this.clipboard.push(cell_json);
        }
        this.enable_paste();
    };

    /**
     * Replace the selected cell with the cells in the clipboard.
     */
    Notebook.prototype.paste_cell_replace = function () {
        if (this.clipboard !== null && this.paste_enabled) {
            var first_inserted = null;
            for (var i=0; i < this.clipboard.length; i++) {
                var cell_data = this.clipboard;
                var new_cell = this.insert_cell_above(cell_data.cell_type);
                new_cell.fromJSON(cell_data);
                if (first_inserted === null) {
                    first_inserted = new_cell;
                }
            }
            var old_selected = this.get_selected_index();
            this.select(this.find_cell_index(first_inserted));
            this.delete_cell(old_selected);
        }
    };

    /**
     * Paste cells from the clipboard above the selected cell.
     */
    Notebook.prototype.paste_cell_above = function () {
        if (this.clipboard !== null && this.paste_enabled) {
            var first_inserted = null;
            for (var i=0; i < this.clipboard.length; i++) {
                var cell_data = this.clipboard[i];
                var new_cell = this.insert_cell_above(cell_data.cell_type);
                new_cell.fromJSON(cell_data);
                if (first_inserted === null) {
                    first_inserted = new_cell;
                }

            }
            first_inserted.focus_cell();
        }
    };

    /**
     * Paste cells from the clipboard below the selected cell.
     */
    Notebook.prototype.paste_cell_below = function () {
        if (this.clipboard !== null && this.paste_enabled) {
            var first_inserted = null;
            for (var i = this.clipboard.length-1; i >= 0; i--) {
                var cell_data = this.clipboard[i];
                var new_cell = this.insert_cell_below(cell_data.cell_type);
                new_cell.fromJSON(cell_data);
                if (first_inserted === null) {
                    first_inserted = new_cell;
                }
            }
            first_inserted.focus_cell();
        }
    };

    // Split/merge

    /**
     * Split the selected cell into two cells.
     */
    Notebook.prototype.split_cell = function () {
        var cell = this.get_selected_cell();
        if (cell.is_splittable()) {
            var texta = cell.get_pre_cursor();
            var textb = cell.get_post_cursor();
            cell.set_text(textb);
            var new_cell = this.insert_cell_above(cell.cell_type);
            // Unrender the new cell so we can call set_text.
            new_cell.unrender();
            new_cell.set_text(texta);
        }
    };

    /**
     * Merge a series of cells into one
     *
     * @param {Array} indices - the numeric indices of the cells to be merged
     * @param {bool} into_last - merge into the last cell instead of the first
     */
    Notebook.prototype.merge_cells = function(indices, into_last) {
        if (indices.length <= 1) {
            return;
        }
        for (var i=0; i < indices.length; i++) {
            if (!this.get_cell(indices[i]).is_mergeable()) {
                return;
            }
        }
        var target = this.get_cell(into_last ? indices.pop() : indices.shift());

        // Get all the cells' contents
        var contents = [];
        for (i=0; i < indices.length; i++) {
            contents.push(this.get_cell(indices[i]).get_text());
        }
        if (into_last) {
            contents.push(target.get_text())
        } else {
            contents.unshift(target.get_text())
        }

        // Update the contents of the target cell
        if (target instanceof codecell.CodeCell) {
            target.set_text(contents.join('\n\n'))
        } else {
            var was_rendered = target.rendered;
            target.unrender(); // Must unrender before we set_text.
            target.set_text(contents.join('\n\n'));
            if (was_rendered) {
                // The rendered state of the final cell should match
                // that of the original selected cell;
                target.render();
            }
        }

        // Delete the other cells
        this.delete_cells(indices);

        this.select(this.find_cell_index(target));
    };

    /**
     * Merge the selected range of cells
     */
    Notebook.prototype.merge_selected_cells = function() {
        this.merge_cells(this.get_selected_indices());
    };

    /**
     * Merge the selected cell into the cell above it.
     */
    Notebook.prototype.merge_cell_above = function () {
        var index = this.get_selected_index();
        this.merge_cells([index-1, index], true)
    };

    /**
     * Merge the selected cell into the cell below it.
     */
    Notebook.prototype.merge_cell_below = function () {
        var index = this.get_selected_index();
        this.merge_cells([index, index+1], false)
    };


    // Cell collapsing and output clearing

    /**
     * Hide a cell's output.
     * 
     * @param {integer} index - cell index
     */
    Notebook.prototype.collapse_output = function (index) {
        var i = this.index_or_selected(index);
        var cell = this.get_cell(i);
        if (cell !== null && (cell instanceof codecell.CodeCell)) {
            cell.collapse_output();
            this.set_dirty(true);
        }
    };

    /**
     * Hide each code cell's output area.
     */
    Notebook.prototype.collapse_all_output = function () {
        this.get_cells().map(function (cell, i) {
            if (cell instanceof codecell.CodeCell) {
                cell.collapse_output();
            }
        });
        // this should not be set if the `collapse` key is removed from nbformat
        this.set_dirty(true);
    };

    /**
     * Show a cell's output.
     * 
     * @param {integer} index - cell index
     */
    Notebook.prototype.expand_output = function (index) {
        var i = this.index_or_selected(index);
        var cell = this.get_cell(i);
        if (cell !== null && (cell instanceof codecell.CodeCell)) {
            cell.expand_output();
            this.set_dirty(true);
        }
    };

    /**
     * Expand each code cell's output area, and remove scrollbars.
     */
    Notebook.prototype.expand_all_output = function () {
        this.get_cells().map(function (cell, i) {
            if (cell instanceof codecell.CodeCell) {
                cell.expand_output();
            }
        });
        // this should not be set if the `collapse` key is removed from nbformat
        this.set_dirty(true);
    };

    /**
     * Clear the selected CodeCell's output area.
     * 
     * @param {integer} index - cell index
     */
    Notebook.prototype.clear_output = function (index) {
        var i = this.index_or_selected(index);
        var cell = this.get_cell(i);
        if (cell !== null && (cell instanceof codecell.CodeCell)) {
            cell.clear_output();
            this.set_dirty(true);
        }
    };

    /**
     * Clear each code cell's output area.
     */
    Notebook.prototype.clear_all_output = function () {
        this.get_cells().map(function (cell, i) {
            if (cell instanceof codecell.CodeCell) {
                cell.clear_output();
            }
        });
        this.set_dirty(true);
    };

    /**
     * Scroll the selected CodeCell's output area.
     * 
     * @param {integer} index - cell index
     */
    Notebook.prototype.scroll_output = function (index) {
        var i = this.index_or_selected(index);
        var cell = this.get_cell(i);
        if (cell !== null && (cell instanceof codecell.CodeCell)) {
            cell.scroll_output();
            this.set_dirty(true);
        }
    };

    /**
     * Expand each code cell's output area and add a scrollbar for long output.
     */
    Notebook.prototype.scroll_all_output = function () {
        this.get_cells().map(function (cell, i) {
            if (cell instanceof codecell.CodeCell) {
                cell.scroll_output();
            }
        });
        // this should not be set if the `collapse` key is removed from nbformat
        this.set_dirty(true);
    };

    /** 
     * Toggle whether a cell's output is collapsed or expanded.
     * 
     * @param {integer} index - cell index
     */
    Notebook.prototype.toggle_output = function (index) {
        var i = this.index_or_selected(index);
        var cell = this.get_cell(i);
        if (cell !== null && (cell instanceof codecell.CodeCell)) {
            cell.toggle_output();
            this.set_dirty(true);
        }
    };

    /**
     * Toggle the output of all cells.
     */
    Notebook.prototype.toggle_all_output = function () {
        this.get_cells().map(function (cell, i) {
            if (cell instanceof codecell.CodeCell) {
                cell.toggle_output();
            }
        });
        // this should not be set if the `collapse` key is removed from nbformat
        this.set_dirty(true);
    };

    /**
     * Toggle a scrollbar for long cell outputs.
     * 
     * @param {integer} index - cell index
     */
    Notebook.prototype.toggle_output_scroll = function (index) {
        var i = this.index_or_selected(index);
        var cell = this.get_cell(i);
        if (cell !== null && (cell instanceof codecell.CodeCell)) {
            cell.toggle_output_scroll();
            this.set_dirty(true);
        }
    };

    /**
     * Toggle the scrolling of long output on all cells.
     */
    Notebook.prototype.toggle_all_output_scroll = function () {
        this.get_cells().map(function (cell, i) {
            if (cell instanceof codecell.CodeCell) {
                cell.toggle_output_scroll();
            }
        });
        // this should not be set if the `collapse` key is removed from nbformat
        this.set_dirty(true);
    };

    // Other cell functions: line numbers, ...

    /**
     * Toggle line numbers in the selected cell's input area.
     */
    Notebook.prototype.cell_toggle_line_numbers = function() {
        this.get_selected_cell().toggle_line_numbers();
    };


    //dispatch codemirror mode to all cells.
    Notebook.prototype._dispatch_mode = function(spec, newmode){
        this.codemirror_mode = newmode;
        codecell.CodeCell.options_default.cm_config.mode = newmode;
        this.get_cells().map(function(cell, i) {
            if (cell.cell_type === 'code'){
                cell.code_mirror.setOption('mode', spec);
                // This is currently redundant, because cm_config ends up as
                // codemirror's own .options object, but I don't want to
                // rely on that.
                cell._options.cm_config.mode = spec;
            }
        });

    };

    // roughly try to check mode equality
    var _mode_equal = function(mode1, mode2){
        return ((mode1||{}).name||mode1)===((mode2||{}).name||mode2);
    };

    /**
     * Set the codemirror mode for all code cells, including the default for
     * new code cells.
     * Set the mode to 'null' (no highlighting) if it can't be found.
     */
    Notebook.prototype.set_codemirror_mode = function(newmode){
        // if mode is the same don't reset,
        // to avoid n-time re-highlighting.
        if (_mode_equal(newmode, this.codemirror_mode)) {
            return;
        }
        
        var that = this;
        utils.requireCodeMirrorMode(newmode, function (spec) {
            that._dispatch_mode(spec, newmode);
        }, function(){
            // on error don't dispatch the new mode as re-setting it later will not work.
            // don't either set to null mode if it has been changed in the meantime
            if( _mode_equal(newmode, this.codemirror_mode) ){
                that._dispatch_mode('null','null');
            }
        });
    };

    // Session related things

    /**
     * Start a new session and set it on each code cell.
     */
    Notebook.prototype.start_session = function (kernel_name) {
        if (this._session_starting) {
            throw new session.SessionAlreadyStarting();
        }
        this._session_starting = true;

        var options = {
            base_url: this.base_url,
            ws_url: this.ws_url,
            notebook_path: this.notebook_path,
            notebook_name: this.notebook_name,
            kernel_name: kernel_name,
            notebook: this
        };

        var success = $.proxy(this._session_started, this);
        var failure = $.proxy(this._session_start_failed, this);

        if (this.session !== null) {
            this.session.restart(options, success, failure);
        } else {
            this.session = new session.Session(options);
            this.session.start(success, failure);
        }
    };


    /**
     * Once a session is started, link the code cells to the kernel and pass the 
     * comm manager to the widget manager.
     */
    Notebook.prototype._session_started = function (){
        this._session_starting = false;
        this.kernel = this.session.kernel;
        var ncells = this.ncells();
        for (var i=0; i<ncells; i++) {
            var cell = this.get_cell(i);
            if (cell instanceof codecell.CodeCell) {
                cell.set_kernel(this.session.kernel);
            }
        }
    };

    /**
     * Called when the session fails to start.
     */
    Notebook.prototype._session_start_failed = function(jqxhr, status, error){
        this._session_starting = false;
        utils.log_ajax_error(jqxhr, status, error);
    };

    /**
     * Prompt the user to restart the Jupyter kernel.
     */
    Notebook.prototype.restart_kernel = function () {
        var that = this;
        dialog.modal({
            notebook: this,
            keyboard_manager: this.keyboard_manager,
            title : "Restart kernel or continue running?",
            body : $("<p/>").text(
                'Do you want to restart the current kernel?  You will lose all variables defined in it.'
            ),
            buttons : {
                "Continue running" : {},
                "Clear all outputs & restart" : {
                    "class" : "btn-danger",
                    "click" : function(){
                        that.clear_all_output();
                        that.kernel.restart();
                    },
                },
                "Restart" : {
                    "class" : "btn-warning",
                    "click" : function() {
                        that.kernel.restart();
                    }
                },
            }
        });
    };

    /**
     * Execute or render cell outputs and go into command mode.
     */
    Notebook.prototype.execute_cell = function () {
        // mode = shift, ctrl, alt
        var cell = this.get_selected_cell();
        
        cell.execute();
        this.command_mode();
        this.set_dirty(true);
    };

    /**
     * Execute or render cell outputs and insert a new cell below.
     */
    Notebook.prototype.execute_cell_and_insert_below = function () {
        var cell = this.get_selected_cell();
        var cell_index = this.find_cell_index(cell);
        
        cell.execute();

        // If we are at the end always insert a new cell and return
        if (cell_index === (this.ncells()-1)) {
            this.command_mode();
            this.insert_cell_below();
            this.select(cell_index+1);
            this.edit_mode();
            this.scroll_to_bottom();
            this.set_dirty(true);
            return;
        }

        this.command_mode();
        this.insert_cell_below();
        this.select(cell_index+1);
        this.edit_mode();
        this.set_dirty(true);
    };

    /**
     * Execute or render cell outputs and select the next cell.
     */
    Notebook.prototype.execute_cell_and_select_below = function () {

        var cell = this.get_selected_cell();
        var cell_index = this.find_cell_index(cell);
        
        cell.execute();

        // If we are at the end always insert a new cell and return
        if (cell_index === (this.ncells()-1)) {
            this.command_mode();
            this.insert_cell_below();
            this.select(cell_index+1);
            this.edit_mode();
            this.scroll_to_bottom();
            this.set_dirty(true);
            return;
        }

        this.command_mode();
        this.select(cell_index+1);
        this.focus_cell();
        this.set_dirty(true);
    };

    /**
     * Execute all cells below the selected cell.
     */
    Notebook.prototype.execute_cells_below = function () {
        this.execute_cell_range(this.get_selected_index(), this.ncells());
        this.scroll_to_bottom();
    };

    /**
     * Execute all cells above the selected cell.
     */
    Notebook.prototype.execute_cells_above = function () {
        this.execute_cell_range(0, this.get_selected_index());
    };

    /**
     * Execute all cells.
     */
    Notebook.prototype.execute_all_cells = function () {
        this.execute_cell_range(0, this.ncells());
        this.scroll_to_bottom();
    };

    /**
     * Execute a contiguous range of cells.
     * 
     * @param {integer} start - index of the first cell to execute (inclusive)
     * @param {integer} end - index of the last cell to execute (exclusive)
     */
    Notebook.prototype.execute_cell_range = function (start, end) {
        this.command_mode();
        for (var i=start; i<end; i++) {
            this.select(i);
            this.execute_cell();
        }
    };

    // Persistance and loading

    /**
     * Getter method for this notebook's name.
     * 
     * @return {string} This notebook's name (excluding file extension)
     */
    Notebook.prototype.get_notebook_name = function () {
        var nbname = utils.splitext(this.notebook_name)[0];
        return nbname;
    };

    /**
     * Setter method for this notebook's name.
     *
     * @param {string} name
     */
    Notebook.prototype.set_notebook_name = function (name) {
        var parent = utils.url_path_split(this.notebook_path)[0];
        this.notebook_name = name;
        this.notebook_path = utils.url_path_join(parent, name);
    };

    /**
     * Check that a notebook's name is valid.
     * 
     * @param {string} nbname - A name for this notebook
     * @return {boolean} True if the name is valid, false if invalid
     */
    Notebook.prototype.test_notebook_name = function (nbname) {
        nbname = nbname || '';
        if (nbname.length>0 && !this.notebook_name_blacklist_re.test(nbname)) {
            return true;
        } else {
            return false;
        }
    };

    /**
     * Load a notebook from JSON (.ipynb).
     * 
     * @param {object} data - JSON representation of a notebook
     */
    Notebook.prototype.fromJSON = function (data) {

        var content = data.content;
        var ncells = this.ncells();
        var i;
        for (i=0; i<ncells; i++) {
            // Always delete cell 0 as they get renumbered as they are deleted.
            this._unsafe_delete_cell(0);
        }
        // Save the metadata and name.
        this.metadata = content.metadata;
        this.notebook_name = data.name;
        this.notebook_path = data.path;
        var trusted = true;
        
        // Set the codemirror mode from language_info metadata
        if (this.metadata.language_info !== undefined) {
            var langinfo = this.metadata.language_info;
            // Mode 'null' should be plain, unhighlighted text.
            var cm_mode = langinfo.codemirror_mode || langinfo.name || 'null';
            this.set_codemirror_mode(cm_mode);
        }
        
        var new_cells = content.cells;
        ncells = new_cells.length;
        var cell_data = null;
        var new_cell = null;
        for (i=0; i<ncells; i++) {
            cell_data = new_cells[i];
            new_cell = this.insert_cell_at_index(cell_data.cell_type, i);
            new_cell.fromJSON(cell_data);
            if (new_cell.cell_type === 'code' && !new_cell.output_area.trusted) {
                trusted = false;
            }
        }
        if (trusted !== this.trusted) {
            this.trusted = trusted;
            this.events.trigger("trust_changed.Notebook", trusted);
        }
    };

    /**
     * Dump this notebook into a JSON-friendly object.
     * 
     * @return {object} A JSON-friendly representation of this notebook.
     */
    Notebook.prototype.toJSON = function () {
        // remove the conversion indicator, which only belongs in-memory
        delete this.metadata.orig_nbformat;
        delete this.metadata.orig_nbformat_minor;

        var cells = this.get_cells();
        var ncells = cells.length;
        var cell_array = new Array(ncells);
        var trusted = true;
        for (var i=0; i<ncells; i++) {
            var cell = cells[i];
            if (cell.cell_type === 'code' && !cell.output_area.trusted) {
                trusted = false;
            }
            cell_array[i] = cell.toJSON();
        }
        var data = {
            cells: cell_array,
            metadata: this.metadata,
            nbformat: this.nbformat,
            nbformat_minor: this.nbformat_minor
        };
        if (trusted !== this.trusted) {
            this.trusted = trusted;
            this.events.trigger("trust_changed.Notebook", trusted);
        }
        return data;
    };

    /**
     * Start an autosave timer which periodically saves the notebook.
     * 
     * @param {integer} interval - the autosave interval in milliseconds
     */
    Notebook.prototype.set_autosave_interval = function (interval) {
        var that = this;
        // clear previous interval, so we don't get simultaneous timers
        if (this.autosave_timer) {
            clearInterval(this.autosave_timer);
        }
        if (!this.writable) {
            // disable autosave if not writable
            interval = 0;
        }
        
        this.autosave_interval = this.minimum_autosave_interval = interval;
        if (interval) {
            this.autosave_timer = setInterval(function() {
                if (that.dirty) {
                    that.save_notebook();
                }
            }, interval);
            this.events.trigger("autosave_enabled.Notebook", interval);
        } else {
            this.autosave_timer = null;
            this.events.trigger("autosave_disabled.Notebook");
        }
    };

    /**
     * Save this notebook on the server. This becomes a notebook instance's
     * .save_notebook method *after* the entire notebook has been loaded.
     */
    Notebook.prototype.save_notebook = function (check_last_modified) {
        if (check_last_modified === undefined) {
            check_last_modified = true;
        }
        if (!this._fully_loaded) {
            this.events.trigger('notebook_save_failed.Notebook',
                new Error("Load failed, save is disabled")
            );
            return;
        } else if (!this.writable) {
            this.events.trigger('notebook_save_failed.Notebook',
                new Error("Notebook is read-only")
            );
            return;
        }

        // Trigger an event before save, which allows listeners to modify
        // the notebook as needed.
        this.events.trigger('before_save.Notebook');

        // Create a JSON model to be sent to the server.
        var model = {
            type : "notebook",
            content : this.toJSON()
        };
        // time the ajax call for autosave tuning purposes.
        var start =  new Date().getTime();

        var that = this;
        var _save = function () {
            return that.contents.save(that.notebook_path, model).then(
                $.proxy(that.save_notebook_success, that, start),
                function (error) {
                    that.events.trigger('notebook_save_failed.Notebook', error);
                }
            );
        };

        if (check_last_modified) {
            return this.contents.get(this.notebook_path, {content: false}).then(
                function (data) {
                    var last_modified = new Date(data.last_modified);
                    if (last_modified > that.last_modified) {
                        dialog.modal({
                            notebook: that,
                            keyboard_manager: that.keyboard_manager,
                            title: "Notebook changed",
                            body: "The notebook file has changed on disk since the last time we opened or saved it. "+
                                  "Do you want to overwrite the file on disk with the version open here, or load "+
                                  "the version on disk (reload the page) ?",
                            buttons: {
                                Reload: {
                                    class: 'btn-warning',
                                    click: function() {
                                        window.location.reload();
                                    }
                                },
                                Cancel: {},
                                Overwrite: {
                                    class: 'btn-danger',
                                    click: function () {
                                        _save();
                                    }
                                },
                            }
                        });
                    } else {
                        return _save();
                    }
                }, function (error) {
                    // maybe it has been deleted or renamed? Go ahead and save.
                    return _save();
                }
            );
        } else {
            return _save();
        }
    };

    /**
     * Success callback for saving a notebook.
     * 
     * @param {integer} start - Time when the save request start
     * @param {object}  data - JSON representation of a notebook
     */
    Notebook.prototype.save_notebook_success = function (start, data) {
        this.set_dirty(false);
        this.last_modified = new Date(data.last_modified);
        if (data.message) {
            // save succeeded, but validation failed.
            var body = $("<div>");
            var title = "Notebook validation failed";

            body.append($("<p>").text(
                "The save operation succeeded," +
                " but the notebook does not appear to be valid." +
                " The validation error was:"
            )).append($("<div>").addClass("validation-error").append(
                $("<pre>").text(data.message)
            ));
            dialog.modal({
                notebook: this,
                keyboard_manager: this.keyboard_manager,
                title: title,
                body: body,
                buttons : {
                    OK : {
                        "class" : "btn-primary"
                    }
                }
            });
        }
        this.events.trigger('notebook_saved.Notebook');
        this._update_autosave_interval(start);
        if (this._checkpoint_after_save) {
            this.create_checkpoint();
            this._checkpoint_after_save = false;
        }
    };

    /**
     * Update the autosave interval based on the duration of the last save.
     * 
     * @param {integer} timestamp - when the save request started
     */
    Notebook.prototype._update_autosave_interval = function (start) {
        var duration = (new Date().getTime() - start);
        if (this.autosave_interval) {
            // new save interval: higher of 10x save duration or parameter (default 30 seconds)
            var interval = Math.max(10 * duration, this.minimum_autosave_interval);
            // round to 10 seconds, otherwise we will be setting a new interval too often
            interval = 10000 * Math.round(interval / 10000);
            // set new interval, if it's changed
            if (interval !== this.autosave_interval) {
                this.set_autosave_interval(interval);
            }
        }
    };

    /**
     * Explicitly trust the output of this notebook.
     */
    Notebook.prototype.trust_notebook = function () {
        var body = $("<div>").append($("<p>")
            .text("A trusted Jupyter notebook may execute hidden malicious code ")
            .append($("<strong>")
                .append(
                    $("<em>").text("when you open it")
                )
            ).append(".").append(
                " Selecting trust will immediately reload this notebook in a trusted state."
            ).append(
                " For more information, see the "
            ).append($("<a>").attr("href", "http://ipython.org/ipython-doc/2/notebook/security.html")
                .text("Jupyter security documentation")
            ).append(".")
        );

        var nb = this;
        dialog.modal({
            notebook: this,
            keyboard_manager: this.keyboard_manager,
            title: "Trust this notebook?",
            body: body,

            buttons: {
                Cancel : {},
                Trust : {
                    class : "btn-danger",
                    click : function () {
                        var cells = nb.get_cells();
                        for (var i = 0; i < cells.length; i++) {
                            var cell = cells[i];
                            if (cell.cell_type === 'code') {
                                cell.output_area.trusted = true;
                            }
                        }
                        nb.events.on('notebook_saved.Notebook', function () {
                            window.location.reload();
                        });
                        nb.save_notebook();
                    }
                }
            }
        });
    };

    /**
     * Make a copy of the current notebook.
     */
    Notebook.prototype.copy_notebook = function () {
        var that = this;
        var base_url = this.base_url;
        var w = window.open('', IPython._target);
        var parent = utils.url_path_split(this.notebook_path)[0];
        this.contents.copy(this.notebook_path, parent).then(
            function (data) {
                w.location = utils.url_join_encode(
                    base_url, 'notebooks', data.path
                );
            },
            function(error) {
                w.close();
                that.events.trigger('notebook_copy_failed', error);
            }
        );
    };

    /**
     * Ensure a filename has the right extension
     * Returns the filename with the appropriate extension, appending if necessary.
     */
    Notebook.prototype.ensure_extension = function (name) {
        var ext = utils.splitext(this.notebook_path)[1];
        if (ext.length && name.slice(-ext.length) !== ext) {
            name = name + ext;
        }
        return name;
    };

    /**
     * Rename the notebook.
     * @param  {string} new_name
     * @return {Promise} promise that resolves when the notebook is renamed.
     */
    Notebook.prototype.rename = function (new_name) {
        new_name = this.ensure_extension(new_name);

        var that = this;
        var parent = utils.url_path_split(this.notebook_path)[0];
        var new_path = utils.url_path_join(parent, new_name);
        return this.contents.rename(this.notebook_path, new_path).then(
            function (json) {
                that.notebook_name = json.name;
                that.notebook_path = json.path;
                that.last_modified = new Date(json.last_modified);
                that.session.rename_notebook(json.path);
                that.events.trigger('notebook_renamed.Notebook', json);
            }
        );
    };

    /**
     * Delete this notebook
     */
    Notebook.prototype.delete = function () {
        this.contents.delete(this.notebook_path);
    };

    /**
     * Request a notebook's data from the server.
     * 
     * @param {string} notebook_path - A notebook to load
     */
    Notebook.prototype.load_notebook = function (notebook_path) {
        this.notebook_path = notebook_path;
        this.notebook_name = utils.url_path_split(this.notebook_path)[1];
        this.events.trigger('notebook_loading.Notebook');
        this.contents.get(notebook_path, {type: 'notebook'}).then(
            $.proxy(this.load_notebook_success, this),
            $.proxy(this.load_notebook_error, this)
        );
    };

    /**
     * Success callback for loading a notebook from the server.
     * 
     * Load notebook data from the JSON response.
     * 
     * @param {object} data JSON representation of a notebook
     */
    Notebook.prototype.load_notebook_success = function (data) {
        var failed, msg;
        try {
            this.fromJSON(data);
        } catch (e) {
            failed = e;
            console.log("Notebook failed to load from JSON:", e);
        }
        if (failed || data.message) {
            // *either* fromJSON failed or validation failed
            var body = $("<div>");
            var title;
            if (failed) {
                title = "Notebook failed to load";
                body.append($("<p>").text(
                    "The error was: "
                )).append($("<div>").addClass("js-error").text(
                    failed.toString()
                )).append($("<p>").text(
                    "See the error console for details."
                ));
            } else {
                title = "Notebook validation failed";
            }

            if (data.message) {
                if (failed) {
                    msg = "The notebook also failed validation:";
                } else {
                    msg = "An invalid notebook may not function properly." +
                    " The validation error was:";
                }
                body.append($("<p>").text(
                    msg
                )).append($("<div>").addClass("validation-error").append(
                    $("<pre>").text(data.message)
                ));
            }

            dialog.modal({
                notebook: this,
                keyboard_manager: this.keyboard_manager,
                title: title,
                body: body,
                buttons : {
                    OK : {
                        "class" : "btn-primary"
                    }
                }
            });
        }
        if (this.ncells() === 0) {
            this.insert_cell_below('code');
            this.edit_mode(0);
        } else {
            this.select(0);
            this.handle_command_mode(this.get_cell(0));
        }
        this.set_dirty(false);
        this.scroll_to_top();
        this.writable = data.writable || false;
        this.last_modified = new Date(data.last_modified);
        var nbmodel = data.content;
        var orig_nbformat = nbmodel.metadata.orig_nbformat;
        var orig_nbformat_minor = nbmodel.metadata.orig_nbformat_minor;
        if (orig_nbformat !== undefined && nbmodel.nbformat !== orig_nbformat) {
            var src;
            if (nbmodel.nbformat > orig_nbformat) {
                src = " an older notebook format ";
            } else {
                src = " a newer notebook format ";
            }
            
            msg = "This notebook has been converted from" + src +
            "(v"+orig_nbformat+") to the current notebook " +
            "format (v"+nbmodel.nbformat+"). The next time you save this notebook, the " +
            "current notebook format will be used.";
            
            if (nbmodel.nbformat > orig_nbformat) {
                msg += " Older versions of Jupyter may not be able to read the new format.";
            } else {
                msg += " Some features of the original notebook may not be available.";
            }
            msg += " To preserve the original version, close the " +
                "notebook without saving it.";
            dialog.modal({
                notebook: this,
                keyboard_manager: this.keyboard_manager,
                title : "Notebook converted",
                body : msg,
                buttons : {
                    OK : {
                        class : "btn-primary"
                    }
                }
            });
        } else if (this.nbformat_minor < nbmodel.nbformat_minor) {
            this.nbformat_minor = nbmodel.nbformat_minor;
        }

        if (this.session === null) {
            var kernel_name = utils.get_url_param('kernel_name');
            if (kernel_name) {
                this.kernel_selector.set_kernel(kernel_name);
            } else if (this.metadata.kernelspec) {
                this.kernel_selector.set_kernel(this.metadata.kernelspec);
            } else if (this.metadata.language) {
                // compat with IJulia, IHaskell, and other early kernels
                // adopters that where setting a language metadata.
                this.kernel_selector.set_kernel({
                    name: "(No name)",
                    language: this.metadata.language
                  });
                // this should be stored in kspec now, delete it.
                // remove once we do not support notebook v3 anymore.
                delete this.metadata.language;
            } else {
                // setting kernel via set_kernel above triggers start_session,
                // otherwise start a new session with the server's default kernel
                // spec_changed events will fire after kernel is loaded
                this.start_session();
            }
        }
        // load our checkpoint list
        this.list_checkpoints();
        
        // load toolbar state
        if (this.metadata.celltoolbar) {
            celltoolbar.CellToolbar.global_show();
            celltoolbar.CellToolbar.activate_preset(this.metadata.celltoolbar);
        } else {
            celltoolbar.CellToolbar.global_hide();
        }
        
        if (!this.writable) {
            this.set_autosave_interval(0);
            this.events.trigger('notebook_read_only.Notebook');
        }
        
        // now that we're fully loaded, it is safe to restore save functionality
        this._fully_loaded = true;
        this.events.trigger('notebook_loaded.Notebook');
    };

    Notebook.prototype.set_kernelselector = function(k_selector){
        this.kernel_selector = k_selector;
    };

    /**
     * Failure callback for loading a notebook from the server.
     * 
     * @param {Error} error
     */
    Notebook.prototype.load_notebook_error = function (error) {
        this.events.trigger('notebook_load_failed.Notebook', error);
        var msg;
        if (error.name === utils.XHR_ERROR && error.xhr.status === 500) {
            utils.log_ajax_error(error.xhr, error.xhr_status, error.xhr_error);
            msg = "An unknown error occurred while loading this notebook. " +
            "This version can load notebook formats " +
            "v" + this.nbformat + " or earlier. See the server log for details.";
        } else {
            msg = error.message;
            console.warn('Error stack trace while loading notebook was:');
            console.warn(error.stack);
        }
        dialog.modal({
            notebook: this,
            keyboard_manager: this.keyboard_manager,
            title: "Error loading notebook",
            body : msg,
            buttons : {
                "OK": {}
            }
        });
    };

    /*********************  checkpoint-related  ********************/

    /**
     * Save the notebook then immediately create a checkpoint.
     */
    Notebook.prototype.save_checkpoint = function () {
        this._checkpoint_after_save = true;
        this.save_notebook();
    };

    /**
     * Add a checkpoint for this notebook.
     */
    Notebook.prototype.add_checkpoint = function (checkpoint) {
        var found = false;
        for (var i = 0; i < this.checkpoints.length; i++) {
            var existing = this.checkpoints[i];
            if (existing.id === checkpoint.id) {
                found = true;
                this.checkpoints[i] = checkpoint;
                break;
            }
        }
        if (!found) {
            this.checkpoints.push(checkpoint);
        }
        this.last_checkpoint = this.checkpoints[this.checkpoints.length - 1];
    };

    /**
     * List checkpoints for this notebook.
     */
    Notebook.prototype.list_checkpoints = function () {
        var that = this;
        this.contents.list_checkpoints(this.notebook_path).then(
            $.proxy(this.list_checkpoints_success, this),
            function(error) {
                that.events.trigger('list_checkpoints_failed.Notebook', error);
            }
        );
    };

    /**
     * Success callback for listing checkpoints.
     * 
     * @param {object} data - JSON representation of a checkpoint
     */
    Notebook.prototype.list_checkpoints_success = function (data) {
        this.checkpoints = data;
        if (data.length) {
            this.last_checkpoint = data[data.length - 1];
        } else {
            this.last_checkpoint = null;
        }
        this.events.trigger('checkpoints_listed.Notebook', [data]);
    };

    /**
     * Create a checkpoint of this notebook on the server from the most recent save.
     */
    Notebook.prototype.create_checkpoint = function () {
        var that = this;
        this.contents.create_checkpoint(this.notebook_path).then(
            $.proxy(this.create_checkpoint_success, this),
            function (error) {
                that.events.trigger('checkpoint_failed.Notebook', error);
            }
        );
    };

    /**
     * Success callback for creating a checkpoint.
     * 
     * @param {object} data - JSON representation of a checkpoint
     */
    Notebook.prototype.create_checkpoint_success = function (data) {
        this.add_checkpoint(data);
        this.events.trigger('checkpoint_created.Notebook', data);
    };

    /**
     * Display the restore checkpoint dialog
     * @param  {string} checkpoint ID
     */
    Notebook.prototype.restore_checkpoint_dialog = function (checkpoint) {
        var that = this;
        checkpoint = checkpoint || this.last_checkpoint;
        if ( ! checkpoint ) {
            console.log("restore dialog, but no checkpoint to restore to!");
            return;
        }
        var body = $('<div/>').append(
            $('<p/>').addClass("p-space").text(
                "Are you sure you want to revert the notebook to " +
                "the latest checkpoint?"
            ).append(
                $("<strong/>").text(
                    " This cannot be undone."
                )
            )
        ).append(
            $('<p/>').addClass("p-space").text("The checkpoint was last updated at:")
        ).append(
            $('<p/>').addClass("p-space").text(
                moment(checkpoint.last_modified).format('LLLL') +
                ' ('+moment(checkpoint.last_modified).fromNow()+')'// Long form:  Tuesday, January 27, 2015 12:15 PM
            ).css("text-align", "center")
        );
        
        dialog.modal({
            notebook: this,
            keyboard_manager: this.keyboard_manager,
            title : "Revert notebook to checkpoint",
            body : body,
            buttons : {
                Revert : {
                    class : "btn-danger",
                    click : function () {
                        that.restore_checkpoint(checkpoint.id);
                    }
                },
                Cancel : {}
                }
        });
    };

    /**
     * Restore the notebook to a checkpoint state.
     * 
     * @param {string} checkpoint ID
     */
    Notebook.prototype.restore_checkpoint = function (checkpoint) {
        this.events.trigger('notebook_restoring.Notebook', checkpoint);
        var that = this;
        this.contents.restore_checkpoint(this.notebook_path, checkpoint).then(
            $.proxy(this.restore_checkpoint_success, this),
            function (error) {
                that.events.trigger('checkpoint_restore_failed.Notebook', error);
            }
        );
    };

    /**
     * Success callback for restoring a notebook to a checkpoint.
     */
    Notebook.prototype.restore_checkpoint_success = function () {
        this.events.trigger('checkpoint_restored.Notebook');
        this.load_notebook(this.notebook_path);
    };

    /**
     * Delete a notebook checkpoint.
     * 
     * @param {string} checkpoint ID
     */
    Notebook.prototype.delete_checkpoint = function (checkpoint) {
        this.events.trigger('notebook_restoring.Notebook', checkpoint);
        var that = this;
        this.contents.delete_checkpoint(this.notebook_path, checkpoint).then(
            $.proxy(this.delete_checkpoint_success, this),
            function (error) {
                that.events.trigger('checkpoint_delete_failed.Notebook', error);
            }
        );
    };

    /**
     * Success callback for deleting a notebook checkpoint.
     */
    Notebook.prototype.delete_checkpoint_success = function () {
        this.events.trigger('checkpoint_deleted.Notebook');
        this.load_notebook(this.notebook_path);
    };

    exports.Notebook = Notebook;

},{"base/js/dialog":"/Users/jon/jupyter/notebook/notebook/static-src/base/js/dialog.js","base/js/keyboard":"/Users/jon/jupyter/notebook/notebook/static-src/base/js/keyboard.js","base/js/namespace":"/Users/jon/jupyter/notebook/notebook/static-src/base/js/namespace.js","base/js/utils":"/Users/jon/jupyter/notebook/notebook/static-src/base/js/utils.js","marked":"/Users/jon/jupyter/notebook/node_modules/marked/lib/marked.js","moment":"/Users/jon/jupyter/notebook/node_modules/moment/moment.js","notebook/js/cell":"/Users/jon/jupyter/notebook/notebook/static-src/notebook/js/cell.js","notebook/js/celltoolbar":"/Users/jon/jupyter/notebook/notebook/static-src/notebook/js/celltoolbar.js","notebook/js/celltoolbarpresets/default":"/Users/jon/jupyter/notebook/notebook/static-src/notebook/js/celltoolbarpresets/default.js","notebook/js/celltoolbarpresets/rawcell":"/Users/jon/jupyter/notebook/notebook/static-src/notebook/js/celltoolbarpresets/rawcell.js","notebook/js/celltoolbarpresets/slideshow":"/Users/jon/jupyter/notebook/notebook/static-src/notebook/js/celltoolbarpresets/slideshow.js","notebook/js/codecell":"/Users/jon/jupyter/notebook/notebook/static-src/notebook/js/codecell.js","notebook/js/commandpalette":"/Users/jon/jupyter/notebook/notebook/static-src/notebook/js/commandpalette.js","notebook/js/mathjaxutils":"/Users/jon/jupyter/notebook/notebook/static-src/notebook/js/mathjaxutils.js","notebook/js/scrollmanager":"/Users/jon/jupyter/notebook/notebook/static-src/notebook/js/scrollmanager.js","notebook/js/textcell":"/Users/jon/jupyter/notebook/notebook/static-src/notebook/js/textcell.js","notebook/js/tooltip":"/Users/jon/jupyter/notebook/notebook/static-src/notebook/js/tooltip.js","services/config":"/Users/jon/jupyter/notebook/notebook/static-src/services/config.js","services/sessions/session":"/Users/jon/jupyter/notebook/notebook/static-src/services/sessions/session.js"}],"/Users/jon/jupyter/notebook/notebook/static-src/notebook/js/notificationarea.js":[function(require,module,exports){
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
    "use strict";

    var utils = require('base/js/utils');
    var dialog = require('base/js/dialog');
    var notificationarea = require('base/js/notificationarea');
    var moment = require('moment');

    var NotificationArea = notificationarea.NotificationArea;

    var NotebookNotificationArea = function(selector, options) {
        NotificationArea.apply(this, [selector, options]);
        this.save_widget = options.save_widget;
        this.notebook = options.notebook;
        this.keyboard_manager = options.keyboard_manager;
    };

    NotebookNotificationArea.prototype = Object.create(NotificationArea.prototype);

    /**
     * Initialize the default set of notification widgets.
     *
     * @method init_notification_widgets
     */
    NotebookNotificationArea.prototype.init_notification_widgets = function () {
        this.init_kernel_notification_widget();
        this.init_notebook_notification_widget();
    };

    /**
     * Initialize the notification widget for kernel status messages.
     *
     * @method init_kernel_notification_widget
     */
    NotebookNotificationArea.prototype.init_kernel_notification_widget = function () {
        var that = this;
        var knw = this.new_notification_widget('kernel');
        var $kernel_ind_icon = $("#kernel_indicator_icon");
        var $modal_ind_icon = $("#modal_indicator");
        var $readonly_ind_icon = $('#readonly-indicator');
        var $body = $('body');

        // Listen for the notebook loaded event.  Set readonly indicator.
        this.events.on('notebook_loaded.Notebook', function() {
            if (that.notebook.writable) {
                $readonly_ind_icon.hide();
            } else {
                $readonly_ind_icon.show();
            }
        });

        // Command/Edit mode
        this.events.on('edit_mode.Notebook', function () {
            that.save_widget.update_document_title();
            $body.addClass('edit_mode');
            $body.removeClass('command_mode');
            $modal_ind_icon.attr('title','Edit Mode');
        });

        this.events.on('command_mode.Notebook', function () {
            that.save_widget.update_document_title();
            $body.removeClass('edit_mode');
            $body.addClass('command_mode');
            $modal_ind_icon.attr('title','Command Mode');
        });

        // Implicitly start off in Command mode, switching to Edit mode will trigger event
        $modal_ind_icon.addClass('modal_indicator').attr('title','Command Mode');
        $body.addClass('command_mode');

        // Kernel events

        // this can be either kernel_created.Kernel or kernel_created.Session
        this.events.on('kernel_created.Kernel kernel_created.Session', function () {
            knw.info("Kernel Created", 500);
        });

        this.events.on('kernel_reconnecting.Kernel', function () {
            knw.warning("Connecting to kernel");
        });

        this.events.on('kernel_connection_dead.Kernel', function (evt, info) {
            knw.danger("Not Connected", undefined, function () {
                // schedule reconnect a short time in the future, don't reconnect immediately
                setTimeout($.proxy(info.kernel.reconnect, info.kernel), 500);
            }, {title: 'click to reconnect'});
        });

        this.events.on('kernel_connected.Kernel', function () {
            knw.info("Connected", 500);
        });

        this.events.on('kernel_restarting.Kernel', function () {
            that.save_widget.update_document_title();
            knw.set_message("Restarting kernel", 2000);
        });

        this.events.on('kernel_autorestarting.Kernel', function (evt, info) {
            // Only show the dialog on the first restart attempt. This
            // number gets tracked by the `Kernel` object and passed
            // along here, because we don't want to show the user 5
            // dialogs saying the same thing (which is the number of
            // times it tries restarting).
            if (info.attempt === 1) {

                dialog.kernel_modal({
                    notebook: that.notebook,
                    keyboard_manager: that.keyboard_manager,
                    title: "Kernel Restarting",
                    body: "The kernel appears to have died. It will restart automatically.",
                    buttons: {
                        OK : {
                            class : "btn-primary"
                        }
                    }
                });
            }

            that.save_widget.update_document_title();
            knw.danger("Dead kernel");
            $kernel_ind_icon.attr('class','kernel_dead_icon').attr('title','Kernel Dead');
        });

        this.events.on('kernel_interrupting.Kernel', function () {
            knw.set_message("Interrupting kernel", 2000);
        });

        this.events.on('kernel_disconnected.Kernel', function () {
            $kernel_ind_icon
                .attr('class', 'kernel_disconnected_icon')
                .attr('title', 'No Connection to Kernel');
        });

        this.events.on('kernel_connection_failed.Kernel', function (evt, info) {
            // only show the dialog if this is the first failed
            // connect attempt, because the kernel will continue
            // trying to reconnect and we don't want to spam the user
            // with messages
            if (info.attempt === 1) {

                var msg = "A connection to the notebook server could not be established." +
                        " The notebook will continue trying to reconnect, but" +
                        " until it does, you will NOT be able to run code. Check your" +
                        " network connection or notebook server configuration.";

                dialog.kernel_modal({
                    title: "Connection failed",
                    body: msg,
                    keyboard_manager: that.keyboard_manager,
                    notebook: that.notebook,
                    buttons : {
                        "OK": {}
                    }
                });
            }
        });

        this.events.on('kernel_killed.Kernel kernel_killed.Session', function () {
            that.save_widget.update_document_title();
            knw.warning("No kernel");
            $kernel_ind_icon.attr('class','kernel_busy_icon').attr('title','Kernel is not running');
        });

        this.events.on('kernel_dead.Kernel', function () {

            var showMsg = function () {

                var msg = 'The kernel has died, and the automatic restart has failed.' +
                        ' It is possible the kernel cannot be restarted.' +
                        ' If you are not able to restart the kernel, you will still be able to save' +
                        ' the notebook, but running code will no longer work until the notebook' +
                        ' is reopened.';

                dialog.kernel_modal({
                    title: "Dead kernel",
                    body : msg,
                    keyboard_manager: that.keyboard_manager,
                    notebook: that.notebook,
                    buttons : {
                        "Try restarting now": {
                            class: "btn-danger",
                            click: function () {
                                that.notebook.start_session();
                            }
                        },
                    "Don't restart": {}
                    }
                });

                return false;
            };

            that.save_widget.update_document_title();
            knw.danger("Dead kernel", undefined, showMsg);
            $kernel_ind_icon.attr('class','kernel_dead_icon').attr('title','Kernel Dead');

            showMsg();
        });
        
        this.events.on("no_kernel.Kernel", function (evt, data) {
            $("#kernel_indicator").find('.kernel_indicator_name').text("No Kernel");
        });

        this.events.on('kernel_dead.Session', function (evt, info) {
            var full = info.xhr.responseJSON.message;
            var short = info.xhr.responseJSON.short_message || 'Kernel error';
            var traceback = info.xhr.responseJSON.traceback;

            var showMsg = function () {
                var msg = $('<div/>').append($('<p/>').text(full));
                var cm, cm_elem, cm_open;

                if (traceback) {
                    cm_elem = $('<div/>')
                        .css('margin-top', '1em')
                        .css('padding', '1em')
                        .addClass('output_scroll');
                    msg.append(cm_elem);
                    cm = CodeMirror(cm_elem.get(0), {
                        mode:  "python",
                        readOnly : true
                    });
                    cm.setValue(traceback);
                    cm_open = $.proxy(cm.refresh, cm);
                }

                dialog.kernel_modal({
                    title: "Failed to start the kernel",
                    body : msg,
                    keyboard_manager: that.keyboard_manager,
                    notebook: that.notebook,
                    open: cm_open,
                    buttons : {
                        "Ok": { class: 'btn-primary' }
                    }
                });

                return false;
            };

            that.save_widget.update_document_title();
            $kernel_ind_icon.attr('class','kernel_dead_icon').attr('title','Kernel Dead');
            knw.danger(short, undefined, showMsg);
        });

        this.events.on('kernel_starting.Kernel kernel_created.Session', function () {
            window.document.title='(Starting) '+window.document.title;
            $kernel_ind_icon.attr('class','kernel_busy_icon').attr('title','Kernel Busy');
            knw.set_message("Kernel starting, please wait...");
        });

        this.events.on('kernel_ready.Kernel', function () {
            that.save_widget.update_document_title();
            $kernel_ind_icon.attr('class','kernel_idle_icon').attr('title','Kernel Idle');
            knw.info("Kernel ready", 500);
        });

        this.events.on('kernel_idle.Kernel', function () {
            that.save_widget.update_document_title();
            $kernel_ind_icon.attr('class','kernel_idle_icon').attr('title','Kernel Idle');
        });

        this.events.on('kernel_busy.Kernel', function () {
            window.document.title='(Busy) '+window.document.title;
            $kernel_ind_icon.attr('class','kernel_busy_icon').attr('title','Kernel Busy');
        });

        this.events.on('spec_match_found.Kernel', function (evt, data) {
            that.widget('kernelspec').info("Using kernel: " + data.found.spec.display_name, 3000, undefined, {
                title: "Only candidate for language: " + data.selected.language + " was " + data.found.spec.display_name
            });
        });

        
        // Start the kernel indicator in the busy state, and send a kernel_info request.
        // When the kernel_info reply arrives, the kernel is idle.
        $kernel_ind_icon.attr('class','kernel_busy_icon').attr('title','Kernel Busy');
    };

    /**
     * Initialize the notification widget for notebook status messages.
     *
     * @method init_notebook_notification_widget
     */
    NotebookNotificationArea.prototype.init_notebook_notification_widget = function () {
        var nnw = this.new_notification_widget('notebook');

        // Notebook events
        this.events.on('notebook_loading.Notebook', function () {
            nnw.set_message("Loading notebook",500);
        });
        this.events.on('notebook_loaded.Notebook', function () {
            nnw.set_message("Notebook loaded",500);
        });
        this.events.on('notebook_saving.Notebook', function () {
            nnw.set_message("Saving notebook",500);
        });
        this.events.on('notebook_saved.Notebook', function () {
            nnw.set_message("Notebook saved",2000);
        });
        this.events.on('notebook_save_failed.Notebook', function (evt, error) {
            nnw.warning(error.message || "Notebook save failed");
        });
        this.events.on('notebook_copy_failed.Notebook', function (evt, error) {
            nnw.warning(error.message || "Notebook copy failed");
        });
        
        // Checkpoint events
        this.events.on('checkpoint_created.Notebook', function (evt, data) {
            var msg = "Checkpoint created";
            if (data.last_modified) {
                var d = new Date(data.last_modified);
                msg = msg + ": " + moment(d).format("HH:mm:ss");
            }
            nnw.set_message(msg, 2000);
        });
        this.events.on('checkpoint_failed.Notebook', function () {
            nnw.warning("Checkpoint failed");
        });
        this.events.on('checkpoint_deleted.Notebook', function () {
            nnw.set_message("Checkpoint deleted", 500);
        });
        this.events.on('checkpoint_delete_failed.Notebook', function () {
            nnw.warning("Checkpoint delete failed");
        });
        this.events.on('checkpoint_restoring.Notebook', function () {
            nnw.set_message("Restoring to checkpoint...", 500);
        });
        this.events.on('checkpoint_restore_failed.Notebook', function () {
            nnw.warning("Checkpoint restore failed");
        });

        // Autosave events
        this.events.on('autosave_disabled.Notebook', function () {
            nnw.set_message("Autosave disabled", 2000);
        });
        this.events.on('autosave_enabled.Notebook', function (evt, interval) {
            nnw.set_message("Saving every " + interval / 1000 + "s", 1000);
        });
    };

    exports.NotebookNotificationArea = NotebookNotificationArea;

},{"base/js/dialog":"/Users/jon/jupyter/notebook/notebook/static-src/base/js/dialog.js","base/js/notificationarea":"/Users/jon/jupyter/notebook/notebook/static-src/base/js/notificationarea.js","base/js/utils":"/Users/jon/jupyter/notebook/notebook/static-src/base/js/utils.js","moment":"/Users/jon/jupyter/notebook/node_modules/moment/moment.js"}],"/Users/jon/jupyter/notebook/notebook/static-src/notebook/js/outputarea.js":[function(require,module,exports){
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
    "use strict";

    var utils = require('base/js/utils');
    var security = require('base/js/security');
    var keyboard = require('base/js/keyboard');
    var mathjaxutils = require('notebook/js/mathjaxutils');
    var marked = require('marked');

    /**
     * @class OutputArea
     *
     * @constructor
     */

    var OutputArea = function (options) {
        this.selector = options.selector;
        this.events = options.events;
        this.keyboard_manager = options.keyboard_manager;
        this.wrapper = $(options.selector);
        this.outputs = [];
        this.collapsed = false;
        this.scrolled = false;
        this.scroll_state = 'auto';
        this.trusted = true;
        this.clear_queued = null;
        if (options.prompt_area === undefined) {
            this.prompt_area = true;
        } else {
            this.prompt_area = options.prompt_area;
        }
        this.create_elements();
        this.style();
        this.bind_events();
    };


    /**
     * Class prototypes
     **/

    OutputArea.prototype.create_elements = function () {
        this.element = $("<div/>");
        this.collapse_button = $("<div/>");
        this.prompt_overlay = $("<div/>");
        this.wrapper.append(this.prompt_overlay);
        this.wrapper.append(this.element);
        this.wrapper.append(this.collapse_button);
    };


    OutputArea.prototype.style = function () {
        this.collapse_button.hide();
        this.prompt_overlay.hide();
        
        this.wrapper.addClass('output_wrapper');
        this.element.addClass('output');
        
        this.collapse_button.addClass("btn btn-default output_collapsed");
        this.collapse_button.attr('title', 'click to expand output');
        this.collapse_button.text('. . .');
        
        this.prompt_overlay.addClass('out_prompt_overlay prompt');
        this.prompt_overlay.attr('title', 'click to expand output; double click to hide output');
        
        this.collapse();
    };

    /**
     * Should the OutputArea scroll?
     * Returns whether the height (in lines) exceeds the current threshold.
     * Threshold will be OutputArea.minimum_scroll_threshold if scroll_state=true (manually requested)
     * or OutputArea.auto_scroll_threshold if scroll_state='auto'.
     * This will always return false if scroll_state=false (scroll disabled).
     *
     */
    OutputArea.prototype._should_scroll = function () {
        var threshold;
        if (this.scroll_state === false) {
            return false;
        } else if (this.scroll_state === true) {
            threshold = OutputArea.minimum_scroll_threshold;
        } else {
            threshold = OutputArea.auto_scroll_threshold;
        }
        if (threshold <=0) {
            return false;
        }
        // line-height from http://stackoverflow.com/questions/1185151
        var fontSize = this.element.css('font-size');
        var lineHeight = Math.floor(parseInt(fontSize.replace('px','')) * 1.5);
        return (this.element.height() > threshold * lineHeight);
    };


    OutputArea.prototype.bind_events = function () {
        var that = this;
        this.prompt_overlay.dblclick(function () { that.toggle_output(); });
        this.prompt_overlay.click(function () { that.toggle_scroll(); });

        this.element.resize(function () {
            // FIXME: Firefox on Linux misbehaves, so automatic scrolling is disabled
            if ( utils.browser[0] === "Firefox" ) {
                return;
            }
            // maybe scroll output,
            // if it's grown large enough and hasn't already been scrolled.
            if (!that.scrolled && that._should_scroll()) {
                that.scroll_area();
            }
        });
        this.collapse_button.click(function () {
            that.expand();
        });
    };


    OutputArea.prototype.collapse = function () {
        if (!this.collapsed) {
            this.element.hide();
            this.prompt_overlay.hide();
            if (this.element.html()){
                this.collapse_button.show();
            }
            this.collapsed = true;
            // collapsing output clears scroll state
            this.scroll_state = 'auto';
        }
    };


    OutputArea.prototype.expand = function () {
        if (this.collapsed) {
            this.collapse_button.hide();
            this.element.show();
            if (this.prompt_area) {
                this.prompt_overlay.show();
            }
            this.collapsed = false;
            this.scroll_if_long();
        }
    };


    OutputArea.prototype.toggle_output = function () {
        if (this.collapsed) {
            this.expand();
        } else {
            this.collapse();
        }
    };


    OutputArea.prototype.scroll_area = function () {
        this.element.addClass('output_scroll');
        this.prompt_overlay.attr('title', 'click to unscroll output; double click to hide');
        this.scrolled = true;
    };


    OutputArea.prototype.unscroll_area = function () {
        this.element.removeClass('output_scroll');
        this.prompt_overlay.attr('title', 'click to scroll output; double click to hide');
        this.scrolled = false;
    };

    /**
     * Scroll OutputArea if height exceeds a threshold.
     *
     * Threshold is OutputArea.minimum_scroll_threshold if scroll_state = true,
     * OutputArea.auto_scroll_threshold if scroll_state='auto'.
     *
     **/
    OutputArea.prototype.scroll_if_long = function () {
        var should_scroll = this._should_scroll();
        if (!this.scrolled && should_scroll) {
            // only allow scrolling long-enough output
            this.scroll_area();
        } else if (this.scrolled && !should_scroll) {
            // scrolled and shouldn't be
            this.unscroll_area();
        }
    };


    OutputArea.prototype.toggle_scroll = function () {
        if (this.scroll_state == 'auto') {
            this.scroll_state = !this.scrolled;
        } else {
            this.scroll_state = !this.scroll_state;
        }
        if (this.scrolled) {
            this.unscroll_area();
        } else {
            // only allow scrolling long-enough output
            this.scroll_if_long();
        }
    };


    // typeset with MathJax if MathJax is available
    OutputArea.prototype.typeset = function () {
        utils.typeset(this.element);
    };


    OutputArea.prototype.handle_output = function (msg) {
        var json = {};
        var msg_type = json.output_type = msg.header.msg_type;
        var content = msg.content;
        if (msg_type === "stream") {
            json.text = content.text;
            json.name = content.name;
        } else if (msg_type === "display_data") {
            json.data = content.data;
            json.metadata = content.metadata;
        } else if (msg_type === "execute_result") {
            json.data = content.data;
            json.metadata = content.metadata;
            json.execution_count = content.execution_count;
        } else if (msg_type === "error") {
            json.ename = content.ename;
            json.evalue = content.evalue;
            json.traceback = content.traceback;
        } else {
            console.log("unhandled output message", msg);
            return;
        }
        this.append_output(json);
    };


    OutputArea.output_types = [
        'application/javascript',
        'text/html',
        'text/markdown',
        'text/latex',
        'image/svg+xml',
        'image/png',
        'image/jpeg',
        'application/pdf',
        'text/plain'
    ];

    OutputArea.prototype.validate_mimebundle = function (bundle) {
        /** scrub invalid outputs */
        if (typeof bundle.data !== 'object') {
            console.warn("mimebundle missing data", bundle);
            bundle.data = {};
        }
        if (typeof bundle.metadata !== 'object') {
            console.warn("mimebundle missing metadata", bundle);
            bundle.metadata = {};
        }
        var data = bundle.data;
        $.map(OutputArea.output_types, function(key){
            if (key !== 'application/json' &&
                data[key] !== undefined &&
                typeof data[key] !== 'string'
            ) {
                console.log("Invalid type for " + key, data[key]);
                delete data[key];
            }
        });
        return bundle;
    };

    OutputArea.prototype.append_output = function (json) {
        this.expand();
        
        // Clear the output if clear is queued.
        var needs_height_reset = false;
        if (this.clear_queued) {
            this.clear_output(false);
            needs_height_reset = true;
        }

        var record_output = true;
        switch(json.output_type) {
            case 'execute_result':
                json = this.validate_mimebundle(json);
                this.append_execute_result(json);
                break;
            case 'stream':
                // append_stream might have merged the output with earlier stream output
                record_output = this.append_stream(json);
                break;
            case 'error':
                this.append_error(json);
                break;
            case 'display_data':
                // append handled below
                json = this.validate_mimebundle(json);
                break;
            default:
                console.log("unrecognized output type: " + json.output_type);
                this.append_unrecognized(json);
        }

        // We must release the animation fixed height in a callback since Gecko
        // (FireFox) doesn't render the image immediately as the data is 
        // available.
        var that = this;
        var handle_appended = function ($el) {
            /**
             * Only reset the height to automatic if the height is currently
             * fixed (done by wait=True flag on clear_output).
             */
            if (needs_height_reset) {
                that.element.height('');
            }
            that.element.trigger('resize');
        };
        if (json.output_type === 'display_data') {
            this.append_display_data(json, handle_appended);
        } else {
            handle_appended();
        }
        
        if (record_output) {
            this.outputs.push(json);
        }
    };


    OutputArea.prototype.create_output_area = function () {
        var oa = $("<div/>").addClass("output_area");
        if (this.prompt_area) {
            oa.append($('<div/>').addClass('prompt'));
        }
        return oa;
    };


    function _get_metadata_key(metadata, key, mime) {
        var mime_md = metadata[mime];
        // mime-specific higher priority
        if (mime_md && mime_md[key] !== undefined) {
            return mime_md[key];
        }
        // fallback on global
        return metadata[key];
    }

    OutputArea.prototype.create_output_subarea = function(md, classes, mime) {
        var subarea = $('<div/>').addClass('output_subarea').addClass(classes);
        if (_get_metadata_key(md, 'isolated', mime)) {
            // Create an iframe to isolate the subarea from the rest of the
            // document
            var iframe = $('<iframe/>').addClass('box-flex1');
            iframe.css({'height':1, 'width':'100%', 'display':'block'});
            iframe.attr('frameborder', 0);
            iframe.attr('scrolling', 'auto');

            // Once the iframe is loaded, the subarea is dynamically inserted
            iframe.on('load', function() {
                // Workaround needed by Firefox, to properly render svg inside
                // iframes, see http://stackoverflow.com/questions/10177190/
                // svg-dynamically-added-to-iframe-does-not-render-correctly
                this.contentDocument.open();

                // Insert the subarea into the iframe
                // We must directly write the html. When using Jquery's append
                // method, javascript is evaluated in the parent document and
                // not in the iframe document.  At this point, subarea doesn't
                // contain any user content.
                this.contentDocument.write(subarea.html());

                this.contentDocument.close();

                var body = this.contentDocument.body;
                // Adjust the iframe height automatically
                iframe.height(body.scrollHeight + 'px');
            });

            // Elements should be appended to the inner subarea and not to the
            // iframe
            iframe.append = function(that) {
                subarea.append(that);
            };

            return iframe;
        } else {
            return subarea;
        }
    };


    OutputArea.prototype._append_javascript_error = function (err, element) {
        /**
         * display a message when a javascript error occurs in display output
         */
        var msg = "Javascript error adding output!";
        if ( element === undefined ) return;
        element
            .append($('<div/>').text(msg).addClass('js-error'))
            .append($('<div/>').text(err.toString()).addClass('js-error'))
            .append($('<div/>').text('See your browser Javascript console for more details.').addClass('js-error'));
    };

    OutputArea.prototype._safe_append = function (toinsert) {
        /**
         * safely append an item to the document
         * this is an object created by user code,
         * and may have errors, which should not be raised
         * under any circumstances.
         */
        try {
            this.element.append(toinsert);
        } catch(err) {
            console.log(err);
            // Create an actual output_area and output_subarea, which creates
            // the prompt area and the proper indentation.
            var toinsert = this.create_output_area();
            var subarea = $('<div/>').addClass('output_subarea');
            toinsert.append(subarea);
            this._append_javascript_error(err, subarea);
            this.element.append(toinsert);
        }

        // Notify others of changes.
        this.element.trigger('changed');
    };


    OutputArea.prototype.append_execute_result = function (json) {
        var n = json.execution_count || ' ';
        var toinsert = this.create_output_area();
        if (this.prompt_area) {
            toinsert.find('div.prompt').addClass('output_prompt').text('Out[' + n + ']:');
        }
        var inserted = this.append_mime_type(json, toinsert);
        if (inserted) {
            inserted.addClass('output_result');
        }
        this._safe_append(toinsert);
        // If we just output latex, typeset it.
        if ((json.data['text/latex'] !== undefined) ||
            (json.data['text/html'] !== undefined) ||
            (json.data['text/markdown'] !== undefined)) {
            this.typeset();
        }
    };


    OutputArea.prototype.append_error = function (json) {
        var tb = json.traceback;
        if (tb !== undefined && tb.length > 0) {
            var s = '';
            var len = tb.length;
            for (var i=0; i<len; i++) {
                s = s + tb[i] + '\n';
            }
            s = s + '\n';
            var toinsert = this.create_output_area();
            var append_text = OutputArea.append_map['text/plain'];
            if (append_text) {
                append_text.apply(this, [s, {}, toinsert]).addClass('output_error');
            }
            this._safe_append(toinsert);
        }
    };


    OutputArea.prototype.append_stream = function (json) {
        var text = json.text;
        if (typeof text !== 'string') {
            console.error("Stream output is invalid (missing text)", json);
            return false;
        }
        var subclass = "output_"+json.name;
        if (this.outputs.length > 0){
            // have at least one output to consider
            var last = this.outputs[this.outputs.length-1];
            if (last.output_type == 'stream' && json.name == last.name){
                // latest output was in the same stream,
                // so append directly into its pre tag
                // escape ANSI & HTML specials:
                last.text = utils.fixCarriageReturn(last.text + json.text);
                var pre = this.element.find('div.'+subclass).last().find('pre');
                var html = utils.fixConsole(last.text);
                html = utils.autoLinkUrls(html);
                // The only user content injected with this HTML call is
                // escaped by the fixConsole() method.
                pre.html(html);
                // return false signals that we merged this output with the previous one,
                // and the new output shouldn't be recorded.
                return false;
            }
        }

        if (!text.replace("\r", "")) {
            // text is nothing (empty string, \r, etc.)
            // so don't append any elements, which might add undesirable space
            // return true to indicate the output should be recorded.
            return true;
        }

        // If we got here, attach a new div
        var toinsert = this.create_output_area();
        var append_text = OutputArea.append_map['text/plain'];
        if (append_text) {
            append_text.apply(this, [text, {}, toinsert]).addClass("output_stream " + subclass);
        }
        this._safe_append(toinsert);
        return true;
    };


    OutputArea.prototype.append_unrecognized = function (json) {
        var that = this;
        var toinsert = this.create_output_area();
        var subarea = $('<div/>').addClass('output_subarea output_unrecognized');
        toinsert.append(subarea);
        subarea.append(
            $("<a>")
                .attr("href", "#")
                .text("Unrecognized output: " + json.output_type)
                .click(function () {
                    that.events.trigger('unrecognized_output.OutputArea', {output: json});
                })
        );
        this._safe_append(toinsert);
    };


    OutputArea.prototype.append_display_data = function (json, handle_inserted) {
        var toinsert = this.create_output_area();
        if (this.append_mime_type(json, toinsert, handle_inserted)) {
            this._safe_append(toinsert);
            // If we just output latex, typeset it.
            if ((json.data['text/latex'] !== undefined) ||
                (json.data['text/html'] !== undefined) ||
                (json.data['text/markdown'] !== undefined)) {
                this.typeset();
            }
        }
    };


    OutputArea.safe_outputs = {
        'text/plain' : true,
        'text/latex' : true,
        'image/png' : true,
        'image/jpeg' : true
    };

    OutputArea.prototype.append_mime_type = function (json, element, handle_inserted) {
        for (var i=0; i < OutputArea.display_order.length; i++) {
            var type = OutputArea.display_order[i];
            var append = OutputArea.append_map[type];
            if ((json.data[type] !== undefined) && append) {
                var value = json.data[type];
                if (!this.trusted && !OutputArea.safe_outputs[type]) {
                    // not trusted, sanitize HTML
                    if (type==='text/html' || type==='text/svg') {
                        value = security.sanitize_html(value);
                    } else {
                        // don't display if we don't know how to sanitize it
                        console.log("Ignoring untrusted " + type + " output.");
                        continue;
                    }
                }
                var md = json.metadata || {};
                var toinsert = append.apply(this, [value, md, element, handle_inserted]);
                // Since only the png and jpeg mime types call the inserted
                // callback, if the mime type is something other we must call the 
                // inserted callback only when the element is actually inserted
                // into the DOM.  Use a timeout of 0 to do this.
                if (['image/png', 'image/jpeg'].indexOf(type) < 0 && handle_inserted !== undefined) {
                    setTimeout(handle_inserted, 0);
                }
                this.events.trigger('output_appended.OutputArea', [type, value, md, toinsert]);
                return toinsert;
            }
        }
        return null;
    };


    var append_html = function (html, md, element) {
        var type = 'text/html';
        var toinsert = this.create_output_subarea(md, "output_html rendered_html", type);
        this.keyboard_manager.register_events(toinsert);
        toinsert.append(html);
        dblclick_to_reset_size(toinsert.find('img'));
        element.append(toinsert);
        return toinsert;
    };


    var append_markdown = function(markdown, md, element) {
        var type = 'text/markdown';
        var toinsert = this.create_output_subarea(md, "output_markdown rendered_html", type);
        var text_and_math = mathjaxutils.remove_math(markdown);
        var text = text_and_math[0];
        var math = text_and_math[1];
        marked(text, function (err, html) {
            html = mathjaxutils.replace_math(html, math);
            toinsert.append(html);
        });
        dblclick_to_reset_size(toinsert.find('img'));
        element.append(toinsert);
        return toinsert;
    };


    var append_javascript = function (js, md, element) {
        /**
         * We just eval the JS code, element appears in the local scope.
         */
        var type = 'application/javascript';
        var toinsert = this.create_output_subarea(md, "output_javascript rendered_html", type);
        this.keyboard_manager.register_events(toinsert);
        element.append(toinsert);

        // Fix for ipython/issues/5293, make sure `element` is the area which
        // output can be inserted into at the time of JS execution.
        element = toinsert;
        try {
            eval(js);
        } catch(err) {
            console.log(err);
            this._append_javascript_error(err, toinsert);
        }
        return toinsert;
    };


    var append_text = function (data, md, element) {
        var type = 'text/plain';
        var toinsert = this.create_output_subarea(md, "output_text", type);
        // escape ANSI & HTML specials in plaintext:
        data = utils.fixConsole(data);
        data = utils.fixCarriageReturn(data);
        data = utils.autoLinkUrls(data);
        // The only user content injected with this HTML call is
        // escaped by the fixConsole() method.
        toinsert.append($("<pre/>").html(data));
        element.append(toinsert);
        return toinsert;
    };


    var append_svg = function (svg_html, md, element) {
        var type = 'image/svg+xml';
        var toinsert = this.create_output_subarea(md, "output_svg", type);

        // Get the svg element from within the HTML.
        var svg = $('<div />').html(svg_html).find('svg');
        var svg_area = $('<div />');
        var width = svg.attr('width');
        var height = svg.attr('height');
        svg
            .width('100%')
            .height('100%');
        svg_area
            .width(width)
            .height(height);

        svg_area.append(svg);
        toinsert.append(svg_area);
        element.append(toinsert);

        return toinsert;
    };

    function dblclick_to_reset_size (img) {
        /**
         * Double-click on an image toggles confinement to notebook width
         *
         * img: jQuery element
         */

        img.dblclick(function () {
            // dblclick toggles *raw* size, disabling max-width confinement.
            if (img.hasClass('unconfined')) {
                img.removeClass('unconfined');
            } else {
                img.addClass('unconfined');
            }
        });
    };

    var set_width_height = function (img, md, mime) {
        /**
         * set width and height of an img element from metadata
         */
        var height = _get_metadata_key(md, 'height', mime);
        if (height !== undefined) img.attr('height', height);
        var width = _get_metadata_key(md, 'width', mime);
        if (width !== undefined) img.attr('width', width);
        if (_get_metadata_key(md, 'unconfined', mime)) {
            img.addClass('unconfined');
        }
    };

    var append_png = function (png, md, element, handle_inserted) {
        var type = 'image/png';
        var toinsert = this.create_output_subarea(md, "output_png", type);
        var img = $("<img/>");
        if (handle_inserted !== undefined) {
            img.on('load', function(){
                handle_inserted(img);
            });
        }
        img[0].src = 'data:image/png;base64,'+ png;
        set_width_height(img, md, 'image/png');
        dblclick_to_reset_size(img);
        toinsert.append(img);
        element.append(toinsert);
        return toinsert;
    };


    var append_jpeg = function (jpeg, md, element, handle_inserted) {
        var type = 'image/jpeg';
        var toinsert = this.create_output_subarea(md, "output_jpeg", type);
        var img = $("<img/>");
        if (handle_inserted !== undefined) {
            img.on('load', function(){
                handle_inserted(img);
            });
        }
        img[0].src = 'data:image/jpeg;base64,'+ jpeg;
        set_width_height(img, md, 'image/jpeg');
        dblclick_to_reset_size(img);
        toinsert.append(img);
        element.append(toinsert);
        return toinsert;
    };


    var append_pdf = function (pdf, md, element) {
        var type = 'application/pdf';
        var toinsert = this.create_output_subarea(md, "output_pdf", type);
        var a = $('<a/>').attr('href', 'data:application/pdf;base64,'+pdf);
        a.attr('target', '_blank');
        a.text('View PDF');
        toinsert.append(a);
        element.append(toinsert);
        return toinsert;
     };

    var append_latex = function (latex, md, element) {
        /**
         * This method cannot do the typesetting because the latex first has to
         * be on the page.
         */
        var type = 'text/latex';
        var toinsert = this.create_output_subarea(md, "output_latex", type);
        toinsert.append(latex);
        element.append(toinsert);
        return toinsert;
    };


    OutputArea.prototype.append_raw_input = function (msg) {
        var that = this;
        this.expand();
        var content = msg.content;
        var area = this.create_output_area();
        
        // disable any other raw_inputs, if they are left around
        $("div.output_subarea.raw_input_container").remove();
        
        var input_type = content.password ? 'password' : 'text';
        
        area.append(
            $("<div/>")
            .addClass("box-flex1 output_subarea raw_input_container")
            .append(
                $("<pre/>")
                .addClass("raw_input_prompt")
                .text(content.prompt)
                .append(
                    $("<input/>")
                    .addClass("raw_input")
                    .attr('type', input_type)
                    .attr("size", 47)
                    .keydown(function (event, ui) {
                        // make sure we submit on enter,
                        // and don't re-execute the *cell* on shift-enter
                        if (event.which === keyboard.keycodes.enter) {
                            that._submit_raw_input();
                            return false;
                        }
                    })
                )
            )
        );
        
        this.element.append(area);
        var raw_input = area.find('input.raw_input');
        // Register events that enable/disable the keyboard manager while raw
        // input is focused.
        this.keyboard_manager.register_events(raw_input);
        // Note, the following line used to read raw_input.focus().focus().
        // This seemed to be needed otherwise only the cell would be focused.
        // But with the modal UI, this seems to work fine with one call to focus().
        raw_input.focus();
    };

    OutputArea.prototype._submit_raw_input = function (evt) {
        var container = this.element.find("div.raw_input_container");
        var theprompt = container.find("pre.raw_input_prompt");
        var theinput = container.find("input.raw_input");
        var value = theinput.val();
        var echo  = value;
        // don't echo if it's a password
        if (theinput.attr('type') == 'password') {
            echo = '········';
        }
        var content = {
            output_type : 'stream',
            name : 'stdout',
            text : theprompt.text() + echo + '\n'
        };
        // remove form container
        container.parent().remove();
        // replace with plaintext version in stdout
        this.append_output(content, false);
        this.events.trigger('send_input_reply.Kernel', value);
    };


    OutputArea.prototype.handle_clear_output = function (msg) {
        /**
         * msg spec v4 had stdout, stderr, display keys
         * v4.1 replaced these with just wait
         * The default behavior is the same (stdout=stderr=display=True, wait=False),
         * so v4 messages will still be properly handled,
         * except for the rarely used clearing less than all output.
         */
        this.clear_output(msg.content.wait || false);
    };


    OutputArea.prototype.clear_output = function(wait, ignore_que) {
        if (wait) {

            // If a clear is queued, clear before adding another to the queue.
            if (this.clear_queued) {
                this.clear_output(false);
            }

            this.clear_queued = true;
        } else {

            // Fix the output div's height if the clear_output is waiting for
            // new output (it is being used in an animation).
            if (!ignore_que && this.clear_queued) {
                var height = this.element.height();
                this.element.height(height);
                this.clear_queued = false;
            }
            
            // Clear all
            // Remove load event handlers from img tags because we don't want
            // them to fire if the image is never added to the page.
            this.element.find('img').off('load');
            this.element.html("");

            // Notify others of changes.
            this.element.trigger('changed');
            
            this.outputs = [];
            this.trusted = true;
            this.unscroll_area();
            return;
        }
    };


    // JSON serialization

    OutputArea.prototype.fromJSON = function (outputs, metadata) {
        var len = outputs.length;
        metadata = metadata || {};

        for (var i=0; i<len; i++) {
            this.append_output(outputs[i]);
        }
        if (metadata.collapsed !== undefined) {
            if (metadata.collapsed) {
                this.collapse();
            } else {
                this.expand();
            }
        }
        if (metadata.scrolled !== undefined) {
            this.scroll_state = metadata.scrolled;
            if (metadata.scrolled) {
                this.scroll_if_long();
            } else {
                this.unscroll_area();
            }
        }
    };


    OutputArea.prototype.toJSON = function () {
        return this.outputs;
    };

    /**
     * Class properties
     **/

    /**
     * Threshold to trigger autoscroll when the OutputArea is resized,
     * typically when new outputs are added.
     *
     * Behavior is undefined if autoscroll is lower than minimum_scroll_threshold,
     * unless it is < 0, in which case autoscroll will never be triggered
     *
     * @property auto_scroll_threshold
     * @type Number
     * @default 100
     *
     **/
    OutputArea.auto_scroll_threshold = 100;

    /**
     * Lower limit (in lines) for OutputArea to be made scrollable. OutputAreas
     * shorter than this are never scrolled.
     *
     * @property minimum_scroll_threshold
     * @type Number
     * @default 20
     *
     **/
    OutputArea.minimum_scroll_threshold = 20;


    OutputArea.display_order = [
        'application/javascript',
        'text/html',
        'text/markdown',
        'text/latex',
        'image/svg+xml',
        'image/png',
        'image/jpeg',
        'application/pdf',
        'text/plain'
    ];

    OutputArea.append_map = {
        "text/plain" : append_text,
        "text/html" : append_html,
        "text/markdown": append_markdown,
        "image/svg+xml" : append_svg,
        "image/png" : append_png,
        "image/jpeg" : append_jpeg,
        "text/latex" : append_latex,
        "application/javascript" : append_javascript,
        "application/pdf" : append_pdf
    };

    exports.OutputArea = OutputArea;

},{"base/js/keyboard":"/Users/jon/jupyter/notebook/notebook/static-src/base/js/keyboard.js","base/js/security":"/Users/jon/jupyter/notebook/notebook/static-src/base/js/security.js","base/js/utils":"/Users/jon/jupyter/notebook/notebook/static-src/base/js/utils.js","marked":"/Users/jon/jupyter/notebook/node_modules/marked/lib/marked.js","notebook/js/mathjaxutils":"/Users/jon/jupyter/notebook/notebook/static-src/notebook/js/mathjaxutils.js"}],"/Users/jon/jupyter/notebook/notebook/static-src/notebook/js/pager.js":[function(require,module,exports){
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
    "use strict";

    var utils = require('base/js/utils');

    var Pager = function (pager_selector, options) {
        /**
         * Constructor
         *
         * Parameters:
         *  pager_selector: string
         *  options: dictionary
         *      Dictionary of keyword arguments.
         *          events: $(Events) instance
         */
        this.events = options.events;
        this.pager_element = $(pager_selector);
        this.pager_button_area = $('#pager-button-area');
        this._default_end_space = 100;
        this.pager_element.resizable({handles: 'n', resize: $.proxy(this._resize, this)});
        this.expanded = false;
        this.create_button_area();
        this.bind_events();
    };

    Pager.prototype.create_button_area = function(){
        var that = this;
        this.pager_button_area.append(
            $('<a>').attr('role', "button")
                    .attr('title',"Open the pager in an external window")
                    .addClass('ui-button')
                    .click(function(){that.detach();})
                    .append(
                        $('<span>').addClass("ui-icon ui-icon-extlink")
                    )
        );
        this.pager_button_area.append(
            $('<a>').attr('role', "button")
                    .attr('title',"Close the pager")
                    .addClass('ui-button')
                    .click(function(){that.collapse();})
                    .append(
                        $('<span>').addClass("ui-icon ui-icon-close")
                    )
        );
    };


    Pager.prototype.bind_events = function () {
        var that = this;

        this.pager_element.bind('collapse_pager', function (event, extrap) {
            // Animate hiding of the pager.
            var time = (extrap && extrap.duration) ? extrap.duration : 'fast';
            that.pager_element.animate({
                height: 'toggle'
            }, {
                duration: time,
                done: function() {
                    $('.end_space').css('height', that._default_end_space);
                }
            });
        });

        this.pager_element.bind('expand_pager', function (event, extrap) {
            // Clear the pager's height attr if it's set.  This allows the
            // pager to size itself according to its contents.
            that.pager_element.height('initial');

            // Animate the showing of the pager
            var time = (extrap && extrap.duration) ? extrap.duration : 'fast';
            that.pager_element.show(time, function() {
                // Explicitly set pager height once the pager has shown itself.
                // This allows the pager-contents div to use percentage sizing.
                that.pager_element.height(that.pager_element.height());
                that._resize();
            });
        });

        this.events.on('open_with_text.Pager', function (event, payload) {
            // FIXME: support other mime types with generic mimebundle display
            // mechanism
            if (payload.data['text/html'] && payload.data['text/html'] !== "") {
                that.clear();
                that.expand();
                that.append(payload.data['text/html']);
            } else if (payload.data['text/plain'] && payload.data['text/plain'] !== "") {
                that.clear();
                that.expand();
                that.append_text(payload.data['text/plain']);
            }
        });
    };


    Pager.prototype.collapse = function (extrap) {
        if (this.expanded === true) {
            this.expanded = false;
            this.pager_element.trigger('collapse_pager', extrap);
        }
    };


    Pager.prototype.expand = function (extrap) {
        if (this.expanded !== true) {
            this.expanded = true;
            this.pager_element.trigger('expand_pager', extrap);
        }
    };


    Pager.prototype.toggle = function () {
        if (this.expanded === true) {
            this.collapse();
        } else {
            this.expand();
        }
    };


    Pager.prototype.clear = function (text) {
        this.pager_element.find(".container").empty();
    };

    Pager.prototype.detach = function(){
        var w = window.open("","_blank");
        $(w.document.head)
        .append(
                $('<link>')
                .attr('rel',"stylesheet")
                .attr('href',"/static/css/notebook.css")
                .attr('type',"text/css")
        )
        .append(
                $('<title>').text("Jupyter Pager")
        );
        var pager_body = $(w.document.body);
        pager_body.css('overflow','scroll');

        pager_body.append(this.pager_element.clone().children());
        w.document.close();
        this.collapse();
    };

    Pager.prototype.append_text = function (text) {
        /**
         * The only user content injected with this HTML call is escaped by
         * the fixConsole() method.
         */
        this.pager_element.find(".container").append($('<pre/>').html(utils.fixCarriageReturn(utils.fixConsole(text))));
    };


    Pager.prototype._resize = function() {
        /**
         * Update document based on pager size.
         */
        
        // Make sure the padding at the end of the notebook is large
        // enough that the user can scroll to the bottom of the 
        // notebook.
        $('.end_space').css('height', Math.max(this.pager_element.height(), this._default_end_space));
    };

    exports.Pager = Pager;

},{"base/js/utils":"/Users/jon/jupyter/notebook/notebook/static-src/base/js/utils.js"}],"/Users/jon/jupyter/notebook/notebook/static-src/notebook/js/quickhelp.js":[function(require,module,exports){
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
    "use strict";

    var utils = require('base/js/utils');
    var dialog = require('base/js/dialog');

    var platform = utils.platform;

    var QuickHelp = function (options) {
        /**
         * Constructor
         *
         * Parameters:
         *  options: dictionary
         *      Dictionary of keyword arguments.
         *          events: $(Events) instance
         *          keyboard_manager: KeyboardManager instance
         *          notebook: Notebook instance
         */
        this.keyboard_manager = options.keyboard_manager;
        this.notebook = options.notebook;
        this.keyboard_manager.quick_help = this;
        this.events = options.events;
    };

    var cmd_ctrl = 'Ctrl-';
    var platform_specific;

    if (platform === 'MacOS') {
        // Mac OS X specific
        cmd_ctrl = 'Cmd-';
        platform_specific = [
            { shortcut: "Cmd-Up",     help:"go to cell start"  },
            { shortcut: "Cmd-Down",   help:"go to cell end"  },
            { shortcut: "Alt-Left",   help:"go one word left"  },
            { shortcut: "Alt-Right",  help:"go one word right"  },
            { shortcut: "Alt-Backspace",      help:"delete word before"  },
            { shortcut: "Alt-Delete",         help:"delete word after"  },
        ];
    } else {
        // PC specific
        platform_specific = [
            { shortcut: "Ctrl-Home",  help:"go to cell start"  },
            { shortcut: "Ctrl-Up",     help:"go to cell start"  },
            { shortcut: "Ctrl-End",   help:"go to cell end"  },
            { shortcut: "Ctrl-Down",  help:"go to cell end"  },
            { shortcut: "Ctrl-Left",  help:"go one word left"  },
            { shortcut: "Ctrl-Right", help:"go one word right"  },
            { shortcut: "Ctrl-Backspace", help:"delete word before"  },
            { shortcut: "Ctrl-Delete",    help:"delete word after"  },
        ];
    }

    var cm_shortcuts = [
        { shortcut:"Tab",   help:"code completion or indent" },
        { shortcut:"Shift-Tab",   help:"tooltip" },
        { shortcut: cmd_ctrl + "]",   help:"indent"  },
        { shortcut: cmd_ctrl + "[",   help:"dedent"  },
        { shortcut: cmd_ctrl + "a",   help:"select all"  },
        { shortcut: cmd_ctrl + "z",   help:"undo"  },
        { shortcut: cmd_ctrl + "Shift-z",   help:"redo"  },
        { shortcut: cmd_ctrl + "y",   help:"redo"  },
    ].concat( platform_specific );

    var mac_humanize_map = {
        // all these are unicode, will probably display badly on anything except macs.
        // these are the standard symbol that are used in MacOS native menus
        // cf http://apple.stackexchange.com/questions/55727/
        // for htmlentities and/or unicode value
        'cmd':'⌘',
        'shift':'⇧',
        'alt':'⌥',
        'up':'↑',
        'down':'↓',
        'left':'←',
        'right':'→',
        'eject':'⏏',
        'tab':'⇥',
        'backtab':'⇤',
        'capslock':'⇪',
        'esc':'esc',
        'ctrl':'⌃',
        'enter':'↩',
        'pageup':'⇞',
        'pagedown':'⇟',
        'home':'↖',
        'end':'↘',
        'altenter':'⌤',
        'space':'␣',
        'delete':'⌦',
        'backspace':'⌫',
        'apple':'',
    };

    var default_humanize_map = {
        'shift':'Shift',
        'alt':'Alt',
        'up':'Up',
        'down':'Down',
        'left':'Left',
        'right':'Right',
        'tab':'Tab',
        'capslock':'Caps Lock',
        'esc':'Esc',
        'ctrl':'Ctrl',
        'enter':'Enter',
        'pageup':'Page Up',
        'pagedown':'Page Down',
        'home':'Home',
        'end':'End',
        'space':'Space',
        'backspace':'Backspace',
        };

    var humanize_map;

    if (platform === 'MacOS'){
        humanize_map = mac_humanize_map;
    } else {
        humanize_map = default_humanize_map;
    }

    var special_case = { pageup: "PageUp", pagedown: "Page Down", 'minus': '-' };
    
    function humanize_key(key){
        if (key.length === 1){
            return key.toUpperCase();
        }

        key = humanize_map[key.toLowerCase()]||key;
        
        if (key.indexOf(',') === -1){
            return  ( special_case[key] ? special_case[key] : key.charAt(0).toUpperCase() + key.slice(1) );
        }
    }

    // return an **html** string of the keyboard shortcut
    // for human eyes consumption.
    // the sequence is a string, comma sepparated linkt of shortcut,
    // where the shortcut is a list of dash-joined keys.
    // Each shortcut will be wrapped in <kbd> tag, and joined by comma is in a
    // sequence.
    //
    // Depending on the platform each shortcut will be normalized, with or without dashes.
    // and replace with the corresponding unicode symbol for modifier if necessary.
    function humanize_sequence(sequence){
        var joinchar = ',';
        var hum = _.map(sequence.replace(/meta/g, 'cmd').split(','), humanize_shortcut).join(joinchar);
        return hum;
    }

    function humanize_shortcut(shortcut){
        var joinchar = '-';
        if (platform === 'MacOS'){
            joinchar = '';
        }
        var sh = _.map(shortcut.split('-'), humanize_key ).join(joinchar);
        return '<kbd>'+sh+'</kbd>';
    }
    

    QuickHelp.prototype.show_keyboard_shortcuts = function () {
        /**
         * toggles display of keyboard shortcut dialog
         */
        var that = this;
        if ( this.force_rebuild ) {
            this.shortcut_dialog.remove();
            delete(this.shortcut_dialog);
            this.force_rebuild = false;
        }
        if ( this.shortcut_dialog ){
            // if dialog is already shown, close it
            $(this.shortcut_dialog).modal("toggle");
            return;
        }
        var command_shortcuts = this.keyboard_manager.command_shortcuts.help();
        var edit_shortcuts = this.keyboard_manager.edit_shortcuts.help();
        var help, shortcut;
        var i, half, n;
        var element = $('<div/>');

        // The documentation
        var doc = $('<div/>').addClass('alert alert-info');
        doc.append(
            'The Jupyter Notebook has two different keyboard input modes. <b>Edit mode</b> '+
            'allows you to type code/text into a cell and is indicated by a green cell '+
            'border. <b>Command mode</b> binds the keyboard to notebook level actions '+
            'and is indicated by a grey cell border.'
        );
        if (platform === 'MacOS') {
            var key_div = this.build_key_names();
            doc.append(key_div);
        }
        element.append(doc);

        // Command mode
        var cmd_div = this.build_command_help();
        element.append(cmd_div);

        // Edit mode
        var edit_div = this.build_edit_help(cm_shortcuts);
        element.append(edit_div);

        this.shortcut_dialog = dialog.modal({
            title : "Keyboard shortcuts",
            body : element,
            destroy : false,
            buttons : {
                Close : {}
            },
            notebook: this.notebook,
            keyboard_manager: this.keyboard_manager,
        });
        this.shortcut_dialog.addClass("modal_stretch");
        
        this.events.on('rebuild.QuickHelp', function() { that.force_rebuild = true;});
    };

    QuickHelp.prototype.build_key_names = function () {
       var key_names_mac =  [{ shortcut:"⌘", help:"Command" },
                    { shortcut:"⌃", help:"Control" },
                    { shortcut:"⌥", help:"Option" },
                    { shortcut:"⇧", help:"Shift" },
                    { shortcut:"↩", help:"Return" },
                    { shortcut:"␣", help:"Space" },
                    { shortcut:"⇥", help:"Tab" }];
        var i, half, n;
        var div = $('<div/>').append('MacOS modifier keys:');
        var sub_div = $('<div/>').addClass('container-fluid');
        var col1 = $('<div/>').addClass('col-md-6');
        var col2 = $('<div/>').addClass('col-md-6');
        n = key_names_mac.length;
        half = ~~(n/2);
        for (i=0; i<half; i++) { col1.append(
                build_one(key_names_mac[i])
                ); }
        for (i=half; i<n; i++) { col2.append(
                build_one(key_names_mac[i])
                ); }
        sub_div.append(col1).append(col2);
        div.append(sub_div);
        return div;
    };


    QuickHelp.prototype.build_command_help = function () {
        var command_shortcuts = this.keyboard_manager.command_shortcuts.help();
        return build_div('<h4>Command Mode (press <kbd>Esc</kbd> to enable)</h4>', command_shortcuts);
    };

    
    QuickHelp.prototype.build_edit_help = function (cm_shortcuts) {
        var edit_shortcuts = this.keyboard_manager.edit_shortcuts.help();
        jQuery.merge(cm_shortcuts, edit_shortcuts);
        return build_div('<h4>Edit Mode (press <kbd>Enter</kbd> to enable)</h4>', cm_shortcuts);
    };

    var build_one = function (s) {
        var help = s.help;
        var shortcut = '';
        if(s.shortcut){
            shortcut = humanize_sequence(s.shortcut);
        }
        return $('<div>').addClass('quickhelp').
            append($('<span/>').addClass('shortcut_key').append($(shortcut))).
            append($('<span/>').addClass('shortcut_descr').text(' : ' + help));

    };

    var build_div = function (title, shortcuts) {
        var i, half, n;
        var div = $('<div/>').append($(title));
        var sub_div = $('<div/>').addClass('container-fluid');
        var col1 = $('<div/>').addClass('col-md-6');
        var col2 = $('<div/>').addClass('col-md-6');
        n = shortcuts.length;
        half = ~~(n/2);  // Truncate :)
        for (i=0; i<half; i++) { col1.append( build_one(shortcuts[i]) ); }
        for (i=half; i<n; i++) { col2.append( build_one(shortcuts[i]) ); }
        sub_div.append(col1).append(col2);
        div.append(sub_div);
        return div;
    };

    module.exports = {'QuickHelp': QuickHelp,
      humanize_shortcut: humanize_shortcut,
      humanize_sequence: humanize_sequence
  };

},{"base/js/dialog":"/Users/jon/jupyter/notebook/notebook/static-src/base/js/dialog.js","base/js/utils":"/Users/jon/jupyter/notebook/notebook/static-src/base/js/utils.js"}],"/Users/jon/jupyter/notebook/notebook/static-src/notebook/js/savewidget.js":[function(require,module,exports){
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
    "use strict";

    var utils = require('base/js/utils');
    var dialog = require('base/js/dialog');
    var keyboard = require('base/js/keyboard');
    var moment = require('moment');

    var SaveWidget = function (selector, options) {
        /**
         * TODO: Remove circular ref.
         */
        this.notebook = undefined;
        this.selector = selector;
        this.events = options.events;
        this._checkpoint_date = undefined;
        this.keyboard_manager = options.keyboard_manager;
        if (this.selector !== undefined) {
            this.element = $(selector);
            this.bind_events();
        }
    };


    SaveWidget.prototype.bind_events = function () {
        var that = this;
        this.element.find('span.filename').click(function () {
            that.rename_notebook({notebook: that.notebook});
        });
        this.events.on('notebook_loaded.Notebook', function () {
            that.update_notebook_name();
            that.update_document_title();
        });
        this.events.on('notebook_saved.Notebook', function () {
            that.update_notebook_name();
            that.update_document_title();
        });
        this.events.on('notebook_renamed.Notebook', function () {
            that.update_notebook_name();
            that.update_document_title();
            that.update_address_bar();
        });
        this.events.on('notebook_save_failed.Notebook', function () {
            that.set_save_status('Autosave Failed!');
        });
        this.events.on('notebook_read_only.Notebook', function () {
            that.set_save_status('(read only)');
            // disable future set_save_status
            that.set_save_status = function () {};
        });
        this.events.on('checkpoints_listed.Notebook', function (event, data) {
            that._set_last_checkpoint(data[0]);
        });

        this.events.on('checkpoint_created.Notebook', function (event, data) {
            that._set_last_checkpoint(data);
        });
        this.events.on('set_dirty.Notebook', function (event, data) {
            that.set_autosaved(data.value);
        });
    };


    SaveWidget.prototype.rename_notebook = function (options) {
        options = options || {};
        var that = this;
        var dialog_body = $('<div/>').append(
            $("<p/>").addClass("rename-message")
                .text('Enter a new notebook name:')
        ).append(
            $("<br/>")
        ).append(
            $('<input/>').attr('type','text').attr('size','25').addClass('form-control')
            .val(options.notebook.get_notebook_name())
        );
        var d = dialog.modal({
            title: "Rename Notebook",
            body: dialog_body,
            notebook: options.notebook,
            keyboard_manager: this.keyboard_manager,
            buttons : {
                "OK": {
                    class: "btn-primary",
                    click: function () {
                        var new_name = d.find('input').val();
                        if (!options.notebook.test_notebook_name(new_name)) {
                            d.find('.rename-message').text(
                                "Invalid notebook name. Notebook names must "+
                                "have 1 or more characters and can contain any characters " +
                                "except :/\\. Please enter a new notebook name:"
                            );
                            return false;
                        } else {
                            d.find('.rename-message').text("Renaming...");
                            d.find('input[type="text"]').prop('disabled', true);
                            that.notebook.rename(new_name).then(
                                function () {
                                    d.modal('hide');
                                }, function (error) {
                                    d.find('.rename-message').text(error.message || 'Unknown error');
                                    d.find('input[type="text"]').prop('disabled', false).focus().select();
                                }
                            );
                            return false;
                        }
                    }
                },
                "Cancel": {}
                },
            open : function () {
                /**
                 * Upon ENTER, click the OK button.
                 */
                d.find('input[type="text"]').keydown(function (event) {
                    if (event.which === keyboard.keycodes.enter) {
                        d.find('.btn-primary').first().click();
                        return false;
                    }
                });
                d.find('input[type="text"]').focus().select();
            }
        });
    };


    SaveWidget.prototype.update_notebook_name = function () {
        var nbname = this.notebook.get_notebook_name();
        this.element.find('span.filename').text(nbname);
    };


    SaveWidget.prototype.update_document_title = function () {
        var nbname = this.notebook.get_notebook_name();
        document.title = nbname;
    };

    SaveWidget.prototype.update_address_bar = function(){
        var base_url = this.notebook.base_url;
        var path = this.notebook.notebook_path;
        var state = {path : path};
        window.history.replaceState(state, "", utils.url_join_encode(
            base_url,
            "notebooks",
            path)
        );
    };


    SaveWidget.prototype.set_save_status = function (msg) {
        this.element.find('span.autosave_status').text(msg);
    };

    SaveWidget.prototype._set_last_checkpoint = function (checkpoint) {
        if (checkpoint) {
            this._checkpoint_date = new Date(checkpoint.last_modified);
        } else {
            this._checkpoint_date = null;
        }
        this._render_checkpoint();
    };

    SaveWidget.prototype._render_checkpoint = function () {
        /** actually set the text in the element, from our _checkpoint value
        
        called directly, and periodically in timeouts.
        */
        this._schedule_render_checkpoint();
        var el = this.element.find('span.checkpoint_status');
        if (!this._checkpoint_date) {
            el.text('').attr('title', 'no checkpoint');
            return;
        }
        var chkd = moment(this._checkpoint_date);
        var long_date = chkd.format('llll');
        var human_date;
        var tdelta = Math.ceil(new Date() - this._checkpoint_date);
        if (tdelta < utils.time.milliseconds.d){
            // less than 24 hours old, use relative date
            human_date = chkd.fromNow();
        } else {
            // otherwise show calendar 
            // <Today | yesterday|...> at hh,mm,ss
            human_date = chkd.calendar();
        }
        el.text('Last Checkpoint: ' + human_date).attr('title', long_date);
    };


    SaveWidget.prototype._schedule_render_checkpoint = function () {
        /** schedule the next update to relative date
        
        periodically updated, so short values like 'a few seconds ago' don't get stale.
        */
        if (!this._checkpoint_date) {
            return;
        }
        if ((this._checkpoint_timeout)) {
            clearTimeout(this._checkpoint_timeout);
        }
        var dt = Math.ceil(new Date() - this._checkpoint_date);
        this._checkpoint_timeout = setTimeout(
            $.proxy(this._render_checkpoint, this),
            utils.time.timeout_from_dt(dt)
        );
    };

    SaveWidget.prototype.set_autosaved = function (dirty) {
        if (dirty) {
            this.set_save_status("(unsaved changes)");
        } else {
            this.set_save_status("(autosaved)");
        }
    };

    exports.SaveWidget = SaveWidget;

},{"base/js/dialog":"/Users/jon/jupyter/notebook/notebook/static-src/base/js/dialog.js","base/js/keyboard":"/Users/jon/jupyter/notebook/notebook/static-src/base/js/keyboard.js","base/js/utils":"/Users/jon/jupyter/notebook/notebook/static-src/base/js/utils.js","moment":"/Users/jon/jupyter/notebook/node_modules/moment/moment.js"}],"/Users/jon/jupyter/notebook/notebook/static-src/notebook/js/scrollmanager.js":[function(require,module,exports){
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
    "use strict";

    var ScrollManager = function(notebook, options) {
        /**
         * Public constructor.
         */
        this.notebook = notebook;
        this.element = $('#site');
        options = options || {};
        this.animation_speed = options.animation_speed || 250; //ms
    };

    ScrollManager.prototype.scroll = function (delta) {
        /**
         * Scroll the document.
         *
         * Parameters
         * ----------
         * delta: integer
         *  direction to scroll the document.  Positive is downwards. 
         *  Unit is one page length.
         */
        this.scroll_some(delta);
        return false;
    };

    ScrollManager.prototype.scroll_to = function(selector) {
        /**
         * Scroll to an element in the notebook.
         */
        this.element.animate({'scrollTop': $(selector).offset().top + this.element.scrollTop() - this.element.offset().top}, this.animation_speed);
    };

    ScrollManager.prototype.scroll_some = function(pages) {
        /**
         * Scroll up or down a given number of pages.
         *
         * Parameters
         * ----------
         * pages: integer
         *  number of pages to scroll the document, may be positive or negative.
         */
        this.element.animate({'scrollTop': this.element.scrollTop() + pages * this.element.height()}, this.animation_speed);
    };

    ScrollManager.prototype.get_first_visible_cell = function() {
        /**
         * Gets the index of the first visible cell in the document.
         *
         * First, attempt to be smart by guessing the index of the cell we are
         * scrolled to.  Then, walk from there up or down until the right cell 
         * is found.  To guess the index, get the top of the last cell, and
         * divide that by the number of cells to get an average cell height.  
         * Then divide the scroll height by the average cell height.
         */
        var cell_count = this.notebook.ncells();
        var first_cell_top = this.notebook.get_cell(0).element.offset().top;
        var last_cell_top = this.notebook.get_cell(cell_count-1).element.offset().top;
        var avg_cell_height = (last_cell_top - first_cell_top) / cell_count;
        var i = Math.ceil(this.element.scrollTop() / avg_cell_height);
        i = Math.min(Math.max(i , 0), cell_count - 1);

        while (this.notebook.get_cell(i).element.offset().top - first_cell_top < this.element.scrollTop() && i < cell_count - 1) {
            i += 1;
        } 

        while (this.notebook.get_cell(i).element.offset().top - first_cell_top > this.element.scrollTop() - 50 && i >= 0) {
            i -= 1;
        } 
        return Math.min(i + 1, cell_count - 1);
    };


    var TargetScrollManager = function(notebook, options) {
        /**
         * Public constructor.
         */
        ScrollManager.apply(this, [notebook, options]);
    };
    TargetScrollManager.prototype = Object.create(ScrollManager.prototype);

    TargetScrollManager.prototype.is_target = function (index) {
        /**
         * Check if a cell should be a scroll stop.
         *
         * Returns `true` if the cell is a cell that the scroll manager
         * should scroll to.  Otherwise, false is returned. 
         *
         * Parameters
         * ----------
         * index: integer
         *  index of the cell to test.
         */
        return false;
    };

    TargetScrollManager.prototype.scroll = function (delta) {
        /**
         * Scroll the document.
         *
         * Parameters
         * ----------
         * delta: integer
         *  direction to scroll the document.  Positive is downwards.
         *  Units are targets.
         *
         * Try to scroll to the next slide.
         */
        var cell_count = this.notebook.ncells();
        var selected_index = this.get_first_visible_cell() + delta;
        while (0 <= selected_index && selected_index < cell_count && !this.is_target(selected_index)) {
            selected_index += delta;
        }

        if (selected_index < 0 || cell_count <= selected_index) {
            return ScrollManager.prototype.scroll.apply(this, [delta]);
        } else {
            this.scroll_to(this.notebook.get_cell(selected_index).element);
            
            // Cancel browser keyboard scroll.
            return false;
        }
    };


    var SlideScrollManager = function(notebook, options) {
        /**
         * Public constructor.
         */
        TargetScrollManager.apply(this, [notebook, options]);
    };
    SlideScrollManager.prototype = Object.create(TargetScrollManager.prototype);

    SlideScrollManager.prototype.is_target = function (index) {
        var cell = this.notebook.get_cell(index);
        return cell.metadata && cell.metadata.slideshow && 
            cell.metadata.slideshow.slide_type && 
            (cell.metadata.slideshow.slide_type === "slide" ||
            cell.metadata.slideshow.slide_type === "subslide");
    };


    var HeadingScrollManager = function(notebook, options) {
        /**
         * Public constructor.
         */
        ScrollManager.apply(this, [notebook, options]);
        options = options || {};
        this._level = options.heading_level || 1;
    };
    HeadingScrollManager.prototype = Object.create(ScrollManager.prototype);

    HeadingScrollManager.prototype.scroll = function (delta) {
        /**
         * Scroll the document.
         *
         * Parameters
         * ----------
         * delta: integer
         *  direction to scroll the document.  Positive is downwards.
         *  Units are headers.
         *
         * Get all of the header elements that match the heading level or are of
         * greater magnitude (a smaller header number).
         */
        var headers = $();
        var i;
        for (i = 1; i <= this._level; i++) {
            headers = headers.add('#notebook-container h' + i);
        }

        // Find the header the user is on or below.
        var first_cell_top = this.notebook.get_cell(0).element.offset().top;
        var current_scroll = this.element.scrollTop();
        var header_scroll = 0;
        i = -1;
        while (current_scroll >= header_scroll && i < headers.length) {
            if (++i < headers.length) {
                header_scroll = $(headers[i]).offset().top - first_cell_top;
            }
        }
        i--;

        // Check if the user is below the header.
        if (i < 0 || current_scroll > $(headers[i]).offset().top - first_cell_top + 30) {
            // Below the header, count the header as a target.
            if (delta < 0) {
                delta += 1;
            }
        }
        i += delta;

        // Scroll!
        if (0 <= i && i < headers.length) {
            this.scroll_to(headers[i]);
            return false;
        } else {
            // Default to the base's scroll behavior when target header doesn't
            // exist.
            return ScrollManager.prototype.scroll.apply(this, [delta]);
        }
    };

    // Return naemspace for require.js loads
    module.exports = {
        'ScrollManager': ScrollManager,
        'SlideScrollManager': SlideScrollManager,
        'HeadingScrollManager': HeadingScrollManager,
        'TargetScrollManager': TargetScrollManager
    };

},{}],"/Users/jon/jupyter/notebook/notebook/static-src/notebook/js/textcell.js":[function(require,module,exports){
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
    "use strict";

    var utils = require('base/js/utils');
    var cell = require('notebook/js/cell');
    var security = require('base/js/security');
    var configmod = require('services/config');
    var mathjaxutils = require('notebook/js/mathjaxutils');
    var celltoolbar = require('notebook/js/celltoolbar');
    var marked = require('marked');

    var Cell = cell.Cell;

    var TextCell = function (options) {
        /**
         * Constructor
         *
         * Construct a new TextCell, codemirror mode is by default 'htmlmixed', 
         * and cell type is 'text' cell start as not redered.
         *
         * Parameters:
         *  options: dictionary
         *      Dictionary of keyword arguments.
         *          events: $(Events) instance 
         *          config: dictionary
         *          keyboard_manager: KeyboardManager instance 
         *          notebook: Notebook instance
         */
        options = options || {};

        // in all TextCell/Cell subclasses
        // do not assign most of members here, just pass it down
        // in the options dict potentially overwriting what you wish.
        // they will be assigned in the base class.
        this.notebook = options.notebook;
        this.events = options.events;
        this.config = options.config;
        
        // we cannot put this as a class key as it has handle to "this".
        var config = utils.mergeopt(TextCell, this.config);
        Cell.apply(this, [{
                    config: config, 
                    keyboard_manager: options.keyboard_manager, 
                    events: this.events}]);

        this.cell_type = this.cell_type || 'text';
        mathjaxutils = mathjaxutils;
        this.rendered = false;
    };

    TextCell.prototype = Object.create(Cell.prototype);

    TextCell.options_default = {
        cm_config : {
            extraKeys: {"Tab": "indentMore","Shift-Tab" : "indentLess"},
            mode: 'htmlmixed',
            lineWrapping : true,
        }
    };


    /**
     * Create the DOM element of the TextCell
     * @method create_element
     * @private
     */
    TextCell.prototype.create_element = function () {
        Cell.prototype.create_element.apply(this, arguments);
        var that = this;

        var cell = $("<div>").addClass('cell text_cell');
        cell.attr('tabindex','2');

        var prompt = $('<div/>').addClass('prompt input_prompt');
        cell.append(prompt);
        var inner_cell = $('<div/>').addClass('inner_cell');
        this.celltoolbar = new celltoolbar.CellToolbar({
            cell: this, 
            notebook: this.notebook});
        inner_cell.append(this.celltoolbar.element);
        var input_area = $('<div/>').addClass('input_area');
        this.code_mirror = new CodeMirror(input_area.get(0), this._options.cm_config);
        // In case of bugs that put the keyboard manager into an inconsistent state,
        // ensure KM is enabled when CodeMirror is focused:
        this.code_mirror.on('focus', function () {
            if (that.keyboard_manager) {
                that.keyboard_manager.enable();
            }
        });
        this.code_mirror.on('keydown', $.proxy(this.handle_keyevent,this))
        // The tabindex=-1 makes this div focusable.
        var render_area = $('<div/>').addClass('text_cell_render rendered_html')
            .attr('tabindex','-1');
        inner_cell.append(input_area).append(render_area);
        cell.append(inner_cell);
        this.element = cell;
    };


    // Cell level actions

    TextCell.prototype.select = function () {
        var cont = Cell.prototype.select.apply(this);
        if (cont) {
            if (this.mode === 'edit') {
                this.code_mirror.refresh();
            }
        }
        return cont;
    };

    TextCell.prototype.unrender = function () {
        var cont = Cell.prototype.unrender.apply(this);
        if (cont) {
            var text_cell = this.element;
            if (this.get_text() === this.placeholder) {
                this.set_text('');
            }
            this.refresh();
        }
        return cont;
    };

    TextCell.prototype.execute = function () {
        this.render();
    };

    /**
     * setter: {{#crossLink "TextCell/set_text"}}{{/crossLink}}
     * @method get_text
     * @retrun {string} CodeMirror current text value
     */
    TextCell.prototype.get_text = function() {
        return this.code_mirror.getValue();
    };

    /**
     * @param {string} text - Codemiror text value
     * @see TextCell#get_text
     * @method set_text
     * */
    TextCell.prototype.set_text = function(text) {
        this.code_mirror.setValue(text);
        this.unrender();
        this.code_mirror.refresh();
    };

    /**
     * setter :{{#crossLink "TextCell/set_rendered"}}{{/crossLink}}
     * @method get_rendered
     * */
    TextCell.prototype.get_rendered = function() {
        return this.element.find('div.text_cell_render').html();
    };

    /**
     * @method set_rendered
     */
    TextCell.prototype.set_rendered = function(text) {
        this.element.find('div.text_cell_render').html(text);
    };


    /**
     * Create Text cell from JSON
     * @param {json} data - JSON serialized text-cell
     * @method fromJSON
     */
    TextCell.prototype.fromJSON = function (data) {
        Cell.prototype.fromJSON.apply(this, arguments);
        if (data.cell_type === this.cell_type) {
            if (data.source !== undefined) {
                this.set_text(data.source);
                // make this value the starting point, so that we can only undo
                // to this state, instead of a blank cell
                this.code_mirror.clearHistory();
                // TODO: This HTML needs to be treated as potentially dangerous
                // user input and should be handled before set_rendered.         
                this.set_rendered(data.rendered || '');
                this.rendered = false;
                this.render();
            }
        }
    };

    /** Generate JSON from cell
     * @return {object} cell data serialised to json
     */
    TextCell.prototype.toJSON = function () {
        var data = Cell.prototype.toJSON.apply(this);
        data.source = this.get_text();
        if (data.source == this.placeholder) {
            data.source = "";
        }
        return data;
    };


    var MarkdownCell = function (options) {
        /**
         * Constructor
         *
         * Parameters:
         *  options: dictionary
         *      Dictionary of keyword arguments.
         *          events: $(Events) instance 
         *          config: ConfigSection instance
         *          keyboard_manager: KeyboardManager instance 
         *          notebook: Notebook instance
         */
        options = options || {};
        var config = utils.mergeopt(MarkdownCell, {});
        this.class_config = new configmod.ConfigWithDefaults(options.config,
                                            {}, 'MarkdownCell');
        TextCell.apply(this, [$.extend({}, options, {config: config})]);

        this.cell_type = 'markdown';
    };

    MarkdownCell.options_default = {
        cm_config: {
            mode: 'ipythongfm'
        },
        placeholder: "Type *Markdown* and LaTeX: $\\alpha^2$"
    };

    MarkdownCell.prototype = Object.create(TextCell.prototype);

    MarkdownCell.prototype.set_heading_level = function (level) {
        /**
         * make a markdown cell a heading
         */
        level = level || 1;
        var source = this.get_text();
        source = source.replace(/^(#*)\s?/,
            new Array(level + 1).join('#') + ' ');
        this.set_text(source);
        this.refresh();
        if (this.rendered) {
            this.render();
        }
    };

    /**
     * @method render
     */
    MarkdownCell.prototype.render = function () {
        var cont = TextCell.prototype.render.apply(this);
        if (cont) {
            var that = this;
            var text = this.get_text();
            var math = null;
            if (text === "") { text = this.placeholder; }
            var text_and_math = mathjaxutils.remove_math(text);
            text = text_and_math[0];
            math = text_and_math[1];
            marked(text, function (err, html) {
                html = mathjaxutils.replace_math(html, math);
                html = security.sanitize_html(html);
                html = $($.parseHTML(html));
                // add anchors to headings
                html.find(":header").addBack(":header").each(function (i, h) {
                    h = $(h);
                    var hash = h.text().replace(/ /g, '-');
                    h.attr('id', hash);
                    h.append(
                        $('<a/>')
                            .addClass('anchor-link')
                            .attr('href', '#' + hash)
                            .text('¶')
                    );
                });
                // links in markdown cells should open in new tabs
                html.find("a[href]").not('[href^="#"]').attr("target", "_blank");
                that.set_rendered(html);
                that.typeset();
                that.events.trigger("rendered.MarkdownCell", {cell: that});
            });
        }
        return cont;
    };


    var RawCell = function (options) {
        /**
         * Constructor
         *
         * Parameters:
         *  options: dictionary
         *      Dictionary of keyword arguments.
         *          events: $(Events) instance 
         *          config: ConfigSection instance
         *          keyboard_manager: KeyboardManager instance 
         *          notebook: Notebook instance
         */
        options = options || {};
        var config = utils.mergeopt(RawCell, {});
        TextCell.apply(this, [$.extend({}, options, {config: config})]);

        this.class_config = new configmod.ConfigWithDefaults(options.config,
                                            RawCell.config_defaults, 'RawCell');
        this.cell_type = 'raw';
    };

    RawCell.options_default = {
        placeholder : "Write raw LaTeX or other formats here, for use with nbconvert. " +
            "It will not be rendered in the notebook. " + 
            "When passing through nbconvert, a Raw Cell's content is added to the output unmodified."
    };

    RawCell.config_defaults =  {
        highlight_modes : {
            'diff'         :{'reg':[/^diff/]}
        },
    };

    RawCell.prototype = Object.create(TextCell.prototype);

    /** @method bind_events **/
    RawCell.prototype.bind_events = function () {
        TextCell.prototype.bind_events.apply(this);
        var that = this;
        this.element.focusout(function() {
            that.auto_highlight();
            that.render();
        });

        this.code_mirror.on('focus', function() { that.unrender(); });
    };

    /** @method render **/
    RawCell.prototype.render = function () {
        var cont = TextCell.prototype.render.apply(this);
        if (cont){
            var text = this.get_text();
            if (text === "") { text = this.placeholder; }
            this.set_text(text);
            this.element.removeClass('rendered');
            this.auto_highlight();
        }
        return cont;
    };

    module.exports = {
        TextCell: TextCell,
        MarkdownCell: MarkdownCell,
        RawCell: RawCell
    };

},{"base/js/security":"/Users/jon/jupyter/notebook/notebook/static-src/base/js/security.js","base/js/utils":"/Users/jon/jupyter/notebook/notebook/static-src/base/js/utils.js","marked":"/Users/jon/jupyter/notebook/node_modules/marked/lib/marked.js","notebook/js/cell":"/Users/jon/jupyter/notebook/notebook/static-src/notebook/js/cell.js","notebook/js/celltoolbar":"/Users/jon/jupyter/notebook/notebook/static-src/notebook/js/celltoolbar.js","notebook/js/mathjaxutils":"/Users/jon/jupyter/notebook/notebook/static-src/notebook/js/mathjaxutils.js","services/config":"/Users/jon/jupyter/notebook/notebook/static-src/services/config.js"}],"/Users/jon/jupyter/notebook/notebook/static-src/notebook/js/toolbar.js":[function(require,module,exports){
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.

    "use strict";

    /**
     * A generic toolbar on which one can add button
     * @class ToolBar
     * @constructor
     * @param {Dom_object} selector
     */
    var ToolBar = function (selector, options) {
        this.selector = selector;
        this.actions = (options||{}).actions;
        if (this.selector !== undefined) {
            this.element = $(selector);
            this.style();
        }
    };

    ToolBar.prototype._pseudo_actions={};


    ToolBar.prototype.construct = function (config) {
        for(var k=0; k<config.length; k++) {
            this.add_buttons_group(config[k][0],config[k][1]);
        }
    };

    /**
     *  Add a group of button into the current toolbar.
     *
     *  Use a [dict of [list of action name]] to trigger
     *  on click to the button
     *
     *  @example
     *
     *      ... todo, maybe use a list of  list to keep ordering.
     *
     *      [
     *          [
     *            [
     *              action_name_1,
     *              action_name_2,
     *              action_name_3,
     *            ],
     *            optional_group_name
     *          ],
     *          ...
     *      ]
     *
     *  @param list {List}
     *      List of button of the group, with the following paramter for each :
     *      @param list.label {string} text to show on button hover
     *      @param list.icon {string} icon to choose from [Font Awesome](http://fortawesome.github.io/Font-Awesome)
     *      @param list.callback {function} function to be called on button click
     *      @param [list.id] {String} id to give to the button
     *  @param [group_id] {String} optionnal id to give to the group
     *
     *
     *  for private usage, the key can also be strings starting with '<' and ending with '>' to inject custom element that cannot
     *  be bound to an action.
     *
     */
    // TODO JUPYTER:
    // get rid of legacy code that handle things that are not actions.
    ToolBar.prototype.add_buttons_group = function (list, group_id) {
        // handle custom call of pseudoaction binding.
        if(typeof(list) === 'string' && list.slice(0,1) === '<' && list.slice(-1) === '>'){
            var _pseudo_action;
            try{
                _pseudo_action = list.slice(1,-1);
                this.element.append(this._pseudo_actions[_pseudo_action].call(this));
            } catch (e) {
                console.warn('ouch, calling ', _pseudo_action, 'does not seem to work...:', e);
            }
            return ;
        }
        var that = this;
        var btn_group = $('<div/>').addClass("btn-group");
        if( group_id !== undefined ) {
            btn_group.attr('id',group_id);
        }
        for(var i=0; i < list.length; i++) {

            // IIFE because javascript don't have loop scope so
            // action_name would otherwise be the same on all iteration
            // of the loop
            (function(i,list){
                var el = list[i];
                var action_name;
                var action;
                if(typeof(el) === 'string'){
                    action = that.actions.get(el);
                    action_name = el;

                }
                var button  = $('<button/>')
                    .addClass('btn btn-default')
                    .attr("title", el.label||action.help)
                    .append(
                        $("<i/>").addClass(el.icon||(action||{icon:'fa-exclamation-triangle'}).icon).addClass('fa')
                    );
                var id = el.id;
                if( id !== undefined ){
                    button.attr('id',id);
                }
                button.attr('data-jupyter-action', action_name);
                var fun = el.callback|| function(){
                    that.actions.call(action_name);
                };
                button.click(fun);
                btn_group.append(button);
            })(i,list);
            // END IIFE
        }
        $(this.selector).append(btn_group);
    };

    ToolBar.prototype.style = function () {
        this.element.addClass('toolbar');
    };

    /**
     * Show and hide toolbar
     * @method toggle
     */
    ToolBar.prototype.toggle = function () {
        this.element.toggle();
    };

    exports.ToolBar = ToolBar;

},{}],"/Users/jon/jupyter/notebook/notebook/static-src/notebook/js/tooltip.js":[function(require,module,exports){
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
    "use strict";

    var utils = require('base/js/utils');

    // tooltip constructor
    var Tooltip = function (events) {
        var that = this;
        this.events = events;
        this.time_before_tooltip = 1200;

        // handle to html
        this.tooltip = $('#tooltip');
        this._hidden = true;

        // variable for consecutive call
        this._old_cell = null;
        this._old_request = null;
        this._consecutive_counter = 0;

        // 'sticky ?'
        this._sticky = false;

        // display tooltip if the docstring is empty?
        this._hide_if_no_docstring = false;

        // contain the button in the upper right corner
        this.buttons = $('<div/>').addClass('tooltipbuttons');

        // will contain the docstring
        this.text = $('<div/>').addClass('tooltiptext').addClass('smalltooltip');

        // build the buttons menu on the upper right
        // expand the tooltip to see more
        var expandlink = $('<a/>').attr('href', "#").addClass("ui-corner-all") //rounded corner
        .attr('role', "button").attr('id', 'expanbutton').attr('title', 'Grow the tooltip vertically (press shift-tab twice)').click(function () {
            that.expand();
            event.preventDefault();
        }).append(
        $('<span/>').text('Expand').addClass('ui-icon').addClass('ui-icon-plus'));

        // open in pager
        var morelink = $('<a/>').attr('href', "#").attr('role', "button").addClass('ui-button').attr('title', 'show the current docstring in pager (press shift-tab 4 times)');
        var morespan = $('<span/>').text('Open in Pager').addClass('ui-icon').addClass('ui-icon-arrowstop-l-n');
        morelink.append(morespan);
        morelink.click(function () {
            that.showInPager(that._old_cell);
            event.preventDefault();
        });

        // close the tooltip
        var closelink = $('<a/>').attr('href', "#").attr('role', "button").addClass('ui-button');
        var closespan = $('<span/>').text('Close').addClass('ui-icon').addClass('ui-icon-close');
        closelink.append(closespan);
        closelink.click(function () {
            that.remove_and_cancel_tooltip(true);
            event.preventDefault();
        });

        this._clocklink = $('<a/>').attr('href', "#");
        this._clocklink.attr('role', "button");
        this._clocklink.addClass('ui-button');
        this._clocklink.attr('title', 'Tooltip will linger for 10 seconds while you type');
        var clockspan = $('<span/>').text('Close');
        clockspan.addClass('ui-icon');
        clockspan.addClass('ui-icon-clock');
        this._clocklink.append(clockspan);
        this._clocklink.click(function () {
            that.cancel_stick();
            event.preventDefault();
        });




        //construct the tooltip
        // add in the reverse order you want them to appear
        this.buttons.append(closelink);
        this.buttons.append(expandlink);
        this.buttons.append(morelink);
        this.buttons.append(this._clocklink);
        this._clocklink.hide();


        // we need a phony element to make the small arrow
        // of the tooltip in css
        // we will move the arrow later
        this.arrow = $('<div/>').addClass('pretooltiparrow');
        this.tooltip.append(this.buttons);
        this.tooltip.append(this.arrow);
        this.tooltip.append(this.text);

        // function that will be called if you press tab 1, 2, 3... times in a row
        this.tabs_functions = [function (cell, text, cursor) {
            that._request_tooltip(cell, text, cursor);
        }, function () {
            that.expand();
        }, function () {
            that.stick();
        }, function (cell) {
            that.cancel_stick();
            that.showInPager(cell);
        }];
        // call after all the tabs function above have bee call to clean their effects
        // if necessary
        this.reset_tabs_function = function (cell, text) {
            this._old_cell = (cell) ? cell : null;
            this._old_request = (text) ? text : null;
            this._consecutive_counter = 0;
        };
    };

    Tooltip.prototype.is_visible = function () {
        return !this._hidden;
    };

    Tooltip.prototype.showInPager = function (cell) {
        /**
         * reexecute last call in pager by appending ? to show back in pager
         */
        this.events.trigger('open_with_text.Pager', this._reply.content);
        this.remove_and_cancel_tooltip();
    };

    // grow the tooltip verticaly
    Tooltip.prototype.expand = function () {
        this.text.removeClass('smalltooltip');
        this.text.addClass('bigtooltip');
        $('#expanbutton').hide('slow');
    };

    // deal with all the logic of hiding the tooltip
    // and reset it's status
    Tooltip.prototype._hide = function () {
        this._hidden = true;
        this.tooltip.fadeOut('fast');
        $('#expanbutton').show('slow');
        this.text.removeClass('bigtooltip');
        this.text.addClass('smalltooltip');
        // keep scroll top to be sure to always see the first line
        this.text.scrollTop(0);
        this.code_mirror = null;
    };

    // return true on successfully removing a visible tooltip; otherwise return
    // false.
    Tooltip.prototype.remove_and_cancel_tooltip = function (force) {
        /**
         * note that we don't handle closing directly inside the calltip
         * as in the completer, because it is not focusable, so won't
         * get the event.
         */
        this.cancel_pending();
        if (!this._hidden) {
          if (force || !this._sticky) {
              this.cancel_stick();
              this._hide();
          }
          this.reset_tabs_function();
          return true;
        } else {
          return false;
        }
    };

    // cancel autocall done after '(' for example.
    Tooltip.prototype.cancel_pending = function () {
        if (this._tooltip_timeout !== null) {
            clearTimeout(this._tooltip_timeout);
            this._tooltip_timeout = null;
        }
    };

    // will trigger tooltip after timeout
    Tooltip.prototype.pending = function (cell, hide_if_no_docstring) {
        var that = this;
        this._tooltip_timeout = setTimeout(function () {
            that.request(cell, hide_if_no_docstring);
        }, that.time_before_tooltip);
    };

    // easy access for julia monkey patching.
    Tooltip.last_token_re = /[a-z_][0-9a-z._]*$/gi;

    Tooltip.prototype._request_tooltip = function (cell, text, cursor_pos) {
        var callbacks = $.proxy(this._show, this);
        var msg_id = cell.kernel.inspect(text, cursor_pos, callbacks);
    };

    // make an immediate completion request
    Tooltip.prototype.request = function (cell, hide_if_no_docstring) {
        /**
         * request(codecell)
         * Deal with extracting the text from the cell and counting
         * call in a row
         */
        this.cancel_pending();
        var editor = cell.code_mirror;
        var cursor = editor.getCursor();
        var cursor_pos = utils.to_absolute_cursor_pos(editor, cursor);
        var text = cell.get_text();

        this._hide_if_no_docstring = hide_if_no_docstring;

        if(editor.somethingSelected()){
            // get only the most recent selection.
            text = editor.getSelection();
        }

        // need a permanent handle to code_mirror for future auto recall
        this.code_mirror = editor;

        // now we treat the different number of keypress
        // first if same cell, same text, increment counter by 1
        if (this._old_cell == cell && this._old_request == text && this._hidden === false) {
            this._consecutive_counter++;
        } else {
            // else reset
            this.cancel_stick();
            this.reset_tabs_function (cell, text);
        }

        this.tabs_functions[this._consecutive_counter](cell, text, cursor_pos);

        // then if we are at the end of list function, reset
        if (this._consecutive_counter == this.tabs_functions.length) {
            this.reset_tabs_function (cell, text, cursor);
        }

        return;
    };

    // cancel the option of having the tooltip to stick
    Tooltip.prototype.cancel_stick = function () {
        clearTimeout(this._stick_timeout);
        this._stick_timeout = null;
        this._clocklink.hide('slow');
        this._sticky = false;
    };

    // put the tooltip in a sicky state for 10 seconds
    // it won't be removed by remove_and_cancell() unless you called with
    // the first parameter set to true.
    // remove_and_cancell_tooltip(true)
    Tooltip.prototype.stick = function (time) {
        time = (time !== undefined) ? time : 10;
        var that = this;
        this._sticky = true;
        this._clocklink.show('slow');
        this._stick_timeout = setTimeout(function () {
            that._sticky = false;
            that._clocklink.hide('slow');
        }, time * 1000);
    };

    // should be called with the kernel reply to actually show the tooltip
    Tooltip.prototype._show = function (reply) {
        /**
         * move the bubble if it is not hidden
         * otherwise fade it
         */
        this._reply = reply;
        var content = reply.content;
        if (!content.found) {
            // object not found, nothing to show
            return;
        }
        this.name = content.name;

        // do some math to have the tooltip arrow on more or less on left or right
        // position of the editor
        var cm_pos = $(this.code_mirror.getWrapperElement()).position();

        // anchor and head positions are local within CodeMirror element
        var anchor = this.code_mirror.cursorCoords(false, 'local');
        var head = this.code_mirror.cursorCoords(true, 'local');
        // locate the target at the center of anchor, head
        var center_left = (head.left + anchor.left) / 2;
        // locate the left edge of the tooltip, at most 450 px left of the arrow
        var edge_left = Math.max(center_left - 450, 0);
        // locate the arrow at the cursor. A 24 px offset seems necessary.
        var arrow_left = center_left - edge_left - 24;
        
        // locate left, top within container element
        var left = (cm_pos.left + edge_left) + 'px';
        var top = (cm_pos.top + head.bottom + 10) + 'px';

        if (this._hidden === false) {
            this.tooltip.animate({
                left: left,
                top: top
            });
        } else {
            this.tooltip.css({
                left: left
            });
            this.tooltip.css({
                top: top
            });
        }
        this.arrow.animate({
            'left': arrow_left + 'px'
        });
        
        this._hidden = false;
        this.tooltip.fadeIn('fast');
        this.text.children().remove();
        
        // This should support rich data types, but only text/plain for now
        // Any HTML within the docstring is escaped by the fixConsole() method.
        var pre = $('<pre/>').html(utils.fixConsole(content.data['text/plain']));
        this.text.append(pre);
        // keep scroll top to be sure to always see the first line
        this.text.scrollTop(0);
    };

    exports.Tooltip = Tooltip;

},{"base/js/utils":"/Users/jon/jupyter/notebook/notebook/static-src/base/js/utils.js"}],"/Users/jon/jupyter/notebook/notebook/static-src/notebook/js/tour.js":[function(require,module,exports){
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
    "use strict";

    var tour_style = "<div class='popover tour'>\n" +
        "<div class='arrow'></div>\n" +
        "<div style='position:absolute; top:7px; right:7px'>\n" +
            "<button class='btn btn-default btn-sm fa fa-times' data-role='end'></button>\n" +
        "</div><h3 class='popover-title'></h3>\n" +
        "<div class='popover-content'></div>\n" +
        "<div class='popover-navigation'>\n" +
            "<button class='btn btn-default fa fa-step-backward' data-role='prev'></button>\n" +
            "<button class='btn btn-default fa fa-step-forward pull-right' data-role='next'></button>\n" +
            "<button id='tour-pause' class='btn btn-sm btn-default fa fa-pause' data-resume-text='' data-pause-text='' data-role='pause-resume'></button>\n" +
        "</div>\n" +
    "</div>";

    var NotebookTour = function (notebook, events) {
        var that = this;
        this.notebook = notebook;
        this.step_duration = 0;
        this.events = events;
        this.tour_steps = [
            { 
                title: "Welcome to the Notebook Tour",
                placement: 'bottom',
                orphan: true,
                content: "You can use the left and right arrow keys to go backwards and forwards."
            }, {
                element: "#notebook_name",
                title: "Filename",
                placement: 'bottom',
                content: "Click here to change the filename for this notebook."
            }, {
                element: $("#menus").parent(),
                placement: 'bottom',
                title: "Notebook Menubar",
                content: "The menubar has menus for actions on the notebook, its cells, and the kernel it communicates with."
            }, {
                element: "#maintoolbar",
                placement: 'bottom',
                title: "Notebook Toolbar",
                content: "The toolbar has buttons for the most common actions. Hover your mouse over each button for more information."
            }, {
                element: "#modal_indicator",
                title: "Mode Indicator",
                placement: 'bottom',
                content: "The Notebook has two modes: Edit Mode and Command Mode. In this area, an indicator can appear to tell you which mode you are in.",
                onShow: function(tour) { that.command_icon_hack(); }
            }, {
                element: "#modal_indicator",
                title: "Command Mode",
                placement: 'bottom',
                onShow: function(tour) { notebook.command_mode(); that.command_icon_hack(); },
                onNext: function(tour) { that.edit_mode(); },
                content: "Right now you are in Command Mode, and many keyboard shortcuts are available. In this mode, no icon is displayed in the indicator area."
            }, {
                element: "#modal_indicator",
                title: "Edit Mode",
                placement: 'bottom',
                onShow: function(tour) { that.edit_mode(); },
                content: "Pressing <code>Enter</code> or clicking in the input text area of the cell switches to Edit Mode."
            }, {
                element: '.selected',
                title: "Edit Mode",
                placement: 'bottom',
                onShow: function(tour) { that.edit_mode(); },
                content: "Notice that the border around the currently active cell changed color. Typing will insert text into the currently active cell."
            }, {
                element: '.selected',
                title: "Back to Command Mode",
                placement: 'bottom',
                onShow: function(tour) { notebook.command_mode(); },
                onHide: function(tour) { $('#help_menu').parent().children('a').click(); },
                content: "Pressing <code>Esc</code> or clicking outside of the input text area takes you back to Command Mode."
            }, {
                element: '#keyboard_shortcuts',
                title: "Keyboard Shortcuts",
                placement: 'bottom',
                onHide: function(tour) { $('#help_menu').parent().children('a').click(); },
                content: "You can click here to get a list of all of the keyboard shortcuts."
            }, {
                element: "#kernel_indicator_icon",
                title: "Kernel Indicator",
                placement: 'bottom',
                onShow: function(tour) { events.trigger('kernel_idle.Kernel');},
                content: "This is the Kernel indicator. It looks like this when the Kernel is idle."
            }, {
                element: "#kernel_indicator_icon",
                title: "Kernel Indicator",
                placement: 'bottom',
                onShow: function(tour) { events.trigger('kernel_busy.Kernel'); },
                content: "The Kernel indicator looks like this when the Kernel is busy."
            }, {
                element: ".fa-stop",
                placement: 'bottom',
                title: "Interrupting the Kernel",
                onHide: function(tour) { events.trigger('kernel_idle.Kernel'); },
                content: "To cancel a computation in progress, you can click here."
            }, {
                element: "#notification_kernel",
                placement: 'bottom',
                onShow: function(tour) { $('.fa-stop').click(); },
                title: "Notification Area",
                content: "Messages in response to user actions (Save, Interrupt, etc) appear here."
            }, {
                title: "Fin.",
                placement: 'bottom',
                orphan: true,
                content: "This concludes the Jupyter Notebook User Interface Tour. Happy hacking!"
            }
        ];

        requirejs(['bootstraptour'], function assignTour(Tour) {
            that.tour = new Tour({
                storage: false, // start tour from beginning every time
                debug: true,
                reflex: true, // click on element to continue tour
                animation: false,
                duration: that.step_duration,
                onStart: function() { console.log('tour started'); },
                // TODO: remove the onPause/onResume logic once pi's patch has been
                // merged upstream to make this work via data-resume-class and 
                // data-resume-text attributes.
                onPause: that.toggle_pause_play,
                onResume: that.toggle_pause_play,
                steps: that.tour_steps,
                template: tour_style,
                orphan: true
            });
        });
    };

    NotebookTour.prototype.start = function () {
        console.log("let's start the tour");
        this.tour.init();
        this.tour.start();
        if (this.tour.ended())
        {
            this.tour.restart();
        }
    };

    NotebookTour.prototype.command_icon_hack =  function() {
        $('#modal_indicator').css('min-height', 20);
    };

    NotebookTour.prototype.toggle_pause_play = function () { 
        $('#tour-pause').toggleClass('fa-pause fa-play'); 
    };

    NotebookTour.prototype.edit_mode = function() { 
        this.notebook.focus_cell(); 
        this.notebook.edit_mode();
    };

    exports.NotebookTour = NotebookTour;
    
},{}],"/Users/jon/jupyter/notebook/notebook/static-src/services/config.js":[function(require,module,exports){
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
    "use strict";

    var utils = require('base/js/utils');

    var ConfigSection = function(section_name, options) {
        this.section_name = section_name;
        this.base_url = options.base_url;
        this.data = {};
        
        var that = this;
        
        /* .loaded is a promise, fulfilled the first time the config is loaded
         * from the server. Code can do:
         *      conf.loaded.then(function() { ... using conf.data ... });
         */
        this._one_load_finished = false;
        this.loaded = new Promise(function(resolve, reject) {
            that._finish_firstload = resolve;
        });
    };

    ConfigSection.prototype.api_url = function() {
        return utils.url_join_encode(this.base_url, 'api/config', this.section_name);
    };

    ConfigSection.prototype._load_done = function() {
        if (!this._one_load_finished) {
            this._one_load_finished = true;
            this._finish_firstload();
        }
    };

    ConfigSection.prototype.load = function() {
        var that = this;
        return utils.promising_ajax(this.api_url(), {
            cache: false,
            type: "GET",
            dataType: "json",
        }).then(function(data) {
            that.data = data;
            that._load_done();
            return data;
        });
    };

    /**
     * Modify the config values stored. Update the local data immediately,
     * send the change to the server, and use the updated data from the server
     * when the reply comes.
     */
    ConfigSection.prototype.update = function(newdata) {
        $.extend(true, this.data, newdata);  // true -> recursive update
        
        var that = this;
        return utils.promising_ajax(this.api_url(), {
            processData: false,
            type : "PATCH",
            data: JSON.stringify(newdata),
            dataType : "json",
            contentType: 'application/json',
        }).then(function(data) {
            that.data = data;
            that._load_done();
            return data;
        });
    };


    var ConfigWithDefaults = function(section, defaults, classname) {
        this.section = section;
        this.defaults = defaults;
        this.classname = classname;
    };

    ConfigWithDefaults.prototype._class_data = function() {
        if (this.classname) {
            return this.section.data[this.classname] || {};
        } else {
            return this.section.data
        }
    };

    /**
     * Wait for config to have loaded, then get a value or the default.
     * Returns a promise.
     */
    ConfigWithDefaults.prototype.get = function(key) {
        var that = this;
        return this.section.loaded.then(function() {
            return this._class_data()[key] || this.defaults[key]
        });
    };

    /**
     * Return a config value. If config is not yet loaded, return the default
     * instead of waiting for it to load.
     */
    ConfigWithDefaults.prototype.get_sync = function(key) {
        return this._class_data()[key] || this.defaults[key];
    };

    /**
     * Set a config value. Send the update to the server, and change our
     * local copy of the data immediately.
     * Returns a promise which is fulfilled when the server replies to the
     * change.
     */
     ConfigWithDefaults.prototype.set = function(key, value) {
         var d = {};
         d[key] = value;
         if (this.classname) {
            var d2 = {};
            d2[this.classname] = d;
            return this.section.update(d2);
        } else {
            return this.section.update(d);
        }
    };

    module.exports = {
        ConfigSection: ConfigSection,
        ConfigWithDefaults: ConfigWithDefaults,
    };

},{"base/js/utils":"/Users/jon/jupyter/notebook/notebook/static-src/base/js/utils.js"}],"/Users/jon/jupyter/notebook/notebook/static-src/services/kernels/comm.js":[function(require,module,exports){
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.

    "use strict";

    var utils = require('base/js/utils');

    //-----------------------------------------------------------------------
    // CommManager class
    //-----------------------------------------------------------------------

    var CommManager = function (kernel) {
        this.comms = {};
        this.targets = {};
        if (kernel !== undefined) {
            this.init_kernel(kernel);
        }
    };

    CommManager.prototype.init_kernel = function (kernel) {
        /**
         * connect the kernel, and register message handlers
         */
        this.kernel = kernel;
        var msg_types = ['comm_open', 'comm_msg', 'comm_close'];
        for (var i = 0; i < msg_types.length; i++) {
            var msg_type = msg_types[i];
            kernel.register_iopub_handler(msg_type, $.proxy(this[msg_type], this));
        }
    };

    CommManager.prototype.new_comm = function (target_name, data, callbacks, metadata, comm_id) {
        /**
         * Create a new Comm, register it, and open its Kernel-side counterpart
         * Mimics the auto-registration in `Comm.__init__` in the Jupyter Comm.
         *
         * argument comm_id is optional
         */
        var comm = new Comm(target_name, comm_id);
        this.register_comm(comm);
        comm.open(data, callbacks, metadata);
        return comm;
    };

    CommManager.prototype.register_target = function (target_name, f) {
        /**
         * Register a target function for a given target name
         */
        this.targets[target_name] = f;
    };

    CommManager.prototype.unregister_target = function (target_name, f) {
        /**
         * Unregister a target function for a given target name
         */
        delete this.targets[target_name];
    };

    CommManager.prototype.register_comm = function (comm) {
        /**
         * Register a comm in the mapping
         */
        this.comms[comm.comm_id] = Promise.resolve(comm);
        comm.kernel = this.kernel;
        return comm.comm_id;
    };

    CommManager.prototype.unregister_comm = function (comm) {
        /**
         * Remove a comm from the mapping
         */
        delete this.comms[comm.comm_id];
    };

    // comm message handlers

    CommManager.prototype.comm_open = function (msg) {
        var content = msg.content;
        var that = this;
        var comm_id = content.comm_id;

        this.comms[comm_id] = utils.load_class(content.target_name, content.target_module, 
            this.targets).then(function(target) {
                var comm = new Comm(content.target_name, comm_id);
                comm.kernel = that.kernel;
                try {
                    var response = target(comm, msg);
                } catch (e) {
                    comm.close();
                    that.unregister_comm(comm);
                    var wrapped_error = new utils.WrappedError("Exception opening new comm", e);
                    console.error(wrapped_error);
                    return Promise.reject(wrapped_error);
                }
                // Regardless of the target return value, we need to
                // then return the comm
                return Promise.resolve(response).then(function() {return comm;});
            }, utils.reject('Could not open comm', true));
        return this.comms[comm_id];
    };

    CommManager.prototype.comm_close = function(msg) {
        var content = msg.content;
        if (this.comms[content.comm_id] === undefined) {
            console.error('Comm promise not found for comm id ' + content.comm_id);
            return;
        }
        var that = this;
        this.comms[content.comm_id] = this.comms[content.comm_id].then(function(comm) {
            that.unregister_comm(comm);
            try {
                comm.handle_close(msg);
            } catch (e) {
                console.log("Exception closing comm: ", e, e.stack, msg);
            }
            // don't return a comm, so that further .then() functions
            // get an undefined comm input
        });
        return this.comms[content.comm_id];
    };

    CommManager.prototype.comm_msg = function(msg) {
        var content = msg.content;
        if (this.comms[content.comm_id] === undefined) {
            console.error('Comm promise not found for comm id ' + content.comm_id);
            return;
        }

        this.comms[content.comm_id] = this.comms[content.comm_id].then(function(comm) {
            try {
                comm.handle_msg(msg);
            } catch (e) {
                console.log("Exception handling comm msg: ", e, e.stack, msg);
            }
            return comm;
        });
        return this.comms[content.comm_id];
    };

    //-----------------------------------------------------------------------
    // Comm base class
    //-----------------------------------------------------------------------

    var Comm = function (target_name, comm_id) {
        this.target_name = target_name;
        this.comm_id = comm_id || utils.uuid();
        this._msg_callback = this._close_callback = null;
    };

    // methods for sending messages
    Comm.prototype.open = function (data, callbacks, metadata) {
        var content = {
            comm_id : this.comm_id,
            target_name : this.target_name,
            data : data || {},
        };
        return this.kernel.send_shell_message("comm_open", content, callbacks, metadata);
    };

    Comm.prototype.send = function (data, callbacks, metadata, buffers) {
        var content = {
            comm_id : this.comm_id,
            data : data || {},
        };
        return this.kernel.send_shell_message("comm_msg", content, callbacks, metadata, buffers);
    };

    Comm.prototype.close = function (data, callbacks, metadata) {
        var content = {
            comm_id : this.comm_id,
            data : data || {},
        };
        return this.kernel.send_shell_message("comm_close", content, callbacks, metadata);
    };

    // methods for registering callbacks for incoming messages
    Comm.prototype._register_callback = function (key, callback) {
        this['_' + key + '_callback'] = callback;
    };

    Comm.prototype.on_msg = function (callback) {
        this._register_callback('msg', callback);
    };

    Comm.prototype.on_close = function (callback) {
        this._register_callback('close', callback);
    };

    // methods for handling incoming messages

    Comm.prototype._callback = function (key, msg) {
        var callback = this['_' + key + '_callback'];
        if (callback) {
            try {
                callback(msg);
            } catch (e) {
                console.log("Exception in Comm callback", e, e.stack, msg);
            }
        }
    };

    Comm.prototype.handle_msg = function (msg) {
        this._callback('msg', msg);
    };

    Comm.prototype.handle_close = function (msg) {
        this._callback('close', msg);
    };

    module.exports = {
        'CommManager': CommManager,
        'Comm': Comm
    };

},{"base/js/utils":"/Users/jon/jupyter/notebook/notebook/static-src/base/js/utils.js"}],"/Users/jon/jupyter/notebook/notebook/static-src/services/kernels/kernel.js":[function(require,module,exports){
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
    "use strict";

    var utils = require('base/js/utils');
    var comm = require('./comm');
    var serialize = require('./serialize');
    var events = require('base/js/events');

    /**
     * A Kernel class to communicate with the Python kernel. This
     * should generally not be constructed directly, but be created
     * by.  the `Session` object. Once created, this object should be
     * used to communicate with the kernel.
     * 
     * Preliminary documentation for the REST API is at
     * https://github.com/ipython/ipython/wiki/IPEP-16%3A-Notebook-multi-directory-dashboard-and-URL-mapping#kernels-api
     * 
     * @class Kernel
     * @param {string} kernel_service_url - the URL to access the kernel REST api
     * @param {string} ws_url - the websockets URL
     * @param {string} name - the kernel type (e.g. python3)
     */
    var Kernel = function (kernel_service_url, ws_url, name) {
        this.events = events;

        this.id = null;
        this.name = name;
        this.ws = null;

        this.kernel_service_url = kernel_service_url;
        this.kernel_url = null;
        this.ws_url = ws_url || utils.get_body_data("wsUrl");
        if (!this.ws_url) {
            // trailing 's' in https will become wss for secure web sockets
            this.ws_url = location.protocol.replace('http', 'ws') + "//" + location.host;
        }

        this.username = "username";
        this.session_id = utils.uuid();
        this._msg_callbacks = {};
        this._msg_queue = Promise.resolve();
        this.info_reply = {}; // kernel_info_reply stored here after starting

        if (typeof(WebSocket) !== 'undefined') {
            this.WebSocket = WebSocket;
        } else if (typeof(MozWebSocket) !== 'undefined') {
            this.WebSocket = MozWebSocket;
        } else {
            alert('Your browser does not have WebSocket support, please try Chrome, Safari or Firefox ≥ 6. Firefox 4 and 5 are also supported by you have to enable WebSockets in about:config.');
        }
        
        this.bind_events();
        this.init_iopub_handlers();
        this.comm_manager = new comm.CommManager(this);
        
        this.last_msg_id = null;
        this.last_msg_callbacks = {};

        this._autorestart_attempt = 0;
        this._reconnect_attempt = 0;
        this.reconnect_limit = 7;
    };

    /**
     * @function _get_msg
     */
    Kernel.prototype._get_msg = function (msg_type, content, metadata, buffers) {
        var msg = {
            header : {
                msg_id : utils.uuid(),
                username : this.username,
                session : this.session_id,
                msg_type : msg_type,
                version : "5.0"
            },
            metadata : metadata || {},
            content : content,
            buffers : buffers || [],
            parent_header : {}
        };
        return msg;
    };

    /**
     * @function bind_events
     */
    Kernel.prototype.bind_events = function () {
        var that = this;
        this.events.on('send_input_reply.Kernel', function(evt, data) { 
            that.send_input_reply(data);
        });

        var record_status = function (evt, info) {
            console.log('Kernel: ' + evt.type + ' (' + info.kernel.id + ')');
        };

        this.events.on('kernel_created.Kernel', record_status);
        this.events.on('kernel_reconnecting.Kernel', record_status);
        this.events.on('kernel_connected.Kernel', record_status);
        this.events.on('kernel_starting.Kernel', record_status);
        this.events.on('kernel_restarting.Kernel', record_status);
        this.events.on('kernel_autorestarting.Kernel', record_status);
        this.events.on('kernel_interrupting.Kernel', record_status);
        this.events.on('kernel_disconnected.Kernel', record_status);
        // these are commented out because they are triggered a lot, but can
        // be uncommented for debugging purposes
        //this.events.on('kernel_idle.Kernel', record_status);
        //this.events.on('kernel_busy.Kernel', record_status);
        this.events.on('kernel_ready.Kernel', record_status);
        this.events.on('kernel_killed.Kernel', record_status);
        this.events.on('kernel_dead.Kernel', record_status);

        this.events.on('kernel_ready.Kernel', function () {
            that._autorestart_attempt = 0;
        });
        this.events.on('kernel_connected.Kernel', function () {
            that._reconnect_attempt = 0;
        });
    };

    /**
     * Initialize the iopub handlers.
     *
     * @function init_iopub_handlers
     */
    Kernel.prototype.init_iopub_handlers = function () {
        var output_msg_types = ['stream', 'display_data', 'execute_result', 'error'];
        this._iopub_handlers = {};
        this.register_iopub_handler('status', $.proxy(this._handle_status_message, this));
        this.register_iopub_handler('clear_output', $.proxy(this._handle_clear_output, this));
        this.register_iopub_handler('execute_input', $.proxy(this._handle_input_message, this));
        
        for (var i=0; i < output_msg_types.length; i++) {
            this.register_iopub_handler(output_msg_types[i], $.proxy(this._handle_output_message, this));
        }
    };

    /**
     * GET /api/kernels
     *
     * Get the list of running kernels.
     *
     * @function list
     * @param {function} [success] - function executed on ajax success
     * @param {function} [error] - functon executed on ajax error
     */
    Kernel.prototype.list = function (success, error) {
        $.ajax(this.kernel_service_url, {
            processData: false,
            cache: false,
            type: "GET",
            dataType: "json",
            success: success,
            error: this._on_error(error)
        });
    };

    /**
     * POST /api/kernels
     *
     * Start a new kernel.
     *
     * In general this shouldn't be used -- the kernel should be
     * started through the session API. If you use this function and
     * are also using the session API then your session and kernel
     * WILL be out of sync!
     *
     * @function start
     * @param {params} [Object] - parameters to include in the query string
     * @param {function} [success] - function executed on ajax success
     * @param {function} [error] - functon executed on ajax error
     */
    Kernel.prototype.start = function (params, success, error) {
        var url = this.kernel_service_url;
        var qs = $.param(params || {}); // query string for sage math stuff
        if (qs !== "") {
            url = url + "?" + qs;
        }

        this.events.trigger('kernel_starting.Kernel', {kernel: this});
        var that = this;
        var on_success = function (data, status, xhr) {
            that.events.trigger('kernel_created.Kernel', {kernel: that});
            that._kernel_created(data);
            if (success) {
                success(data, status, xhr);
            }
        };

        $.ajax(url, {
            processData: false,
            cache: false,
            type: "POST",
            data: JSON.stringify({name: this.name}),
            contentType: 'application/json',
            dataType: "json",
            success: this._on_success(on_success),
            error: this._on_error(error)
        });

        return url;
    };

    /**
     * GET /api/kernels/[:kernel_id]
     *
     * Get information about the kernel.
     *
     * @function get_info
     * @param {function} [success] - function executed on ajax success
     * @param {function} [error] - functon executed on ajax error
     */
    Kernel.prototype.get_info = function (success, error) {
        $.ajax(this.kernel_url, {
            processData: false,
            cache: false,
            type: "GET",
            dataType: "json",
            success: this._on_success(success),
            error: this._on_error(error)
        });
    };

    /**
     * DELETE /api/kernels/[:kernel_id]
     *
     * Shutdown the kernel.
     *
     * If you are also using sessions, then this function shoul NOT be
     * used. Instead, use Session.delete. Otherwise, the session and
     * kernel WILL be out of sync.
     *
     * @function kill
     * @param {function} [success] - function executed on ajax success
     * @param {function} [error] - functon executed on ajax error
     */
    Kernel.prototype.kill = function (success, error) {
        this.events.trigger('kernel_killed.Kernel', {kernel: this});
        this._kernel_dead();
        $.ajax(this.kernel_url, {
            processData: false,
            cache: false,
            type: "DELETE",
            dataType: "json",
            success: this._on_success(success),
            error: this._on_error(error)
        });
    };

    /**
     * POST /api/kernels/[:kernel_id]/interrupt
     *
     * Interrupt the kernel.
     *
     * @function interrupt
     * @param {function} [success] - function executed on ajax success
     * @param {function} [error] - functon executed on ajax error
     */
    Kernel.prototype.interrupt = function (success, error) {
        this.events.trigger('kernel_interrupting.Kernel', {kernel: this});

        var that = this;
        var on_success = function (data, status, xhr) {
            /**
             * get kernel info so we know what state the kernel is in
             */
            that.kernel_info();
            if (success) {
                success(data, status, xhr);
            }
        };

        var url = utils.url_join_encode(this.kernel_url, 'interrupt');
        $.ajax(url, {
            processData: false,
            cache: false,
            type: "POST",
            contentType: false,  // there's no data with this
            dataType: "json",
            success: this._on_success(on_success),
            error: this._on_error(error)
        });
    };

    Kernel.prototype.restart = function (success, error) {
        /**
         * POST /api/kernels/[:kernel_id]/restart
         *
         * Restart the kernel.
         *
         * @function interrupt
         * @param {function} [success] - function executed on ajax success
         * @param {function} [error] - functon executed on ajax error
         */
        this.events.trigger('kernel_restarting.Kernel', {kernel: this});
        this.stop_channels();

        var that = this;
        var on_success = function (data, status, xhr) {
            that.events.trigger('kernel_created.Kernel', {kernel: that});
            that._kernel_created(data);
            if (success) {
                success(data, status, xhr);
            }
        };

        var on_error = function (xhr, status, err) {
            that.events.trigger('kernel_dead.Kernel', {kernel: that});
            that._kernel_dead();
            if (error) {
                error(xhr, status, err);
            }
        };

        var url = utils.url_join_encode(this.kernel_url, 'restart');
        $.ajax(url, {
            processData: false,
            cache: false,
            type: "POST",
            contentType: false,  // there's no data with this
            dataType: "json",
            success: this._on_success(on_success),
            error: this._on_error(on_error)
        });
    };

    Kernel.prototype.reconnect = function () {
        /**
         * Reconnect to a disconnected kernel. This is not actually a
         * standard HTTP request, but useful function nonetheless for
         * reconnecting to the kernel if the connection is somehow lost.
         *
         * @function reconnect
         */
        if (this.is_connected()) {
            return;
        }
        this._reconnect_attempt = this._reconnect_attempt + 1;
        this.events.trigger('kernel_reconnecting.Kernel', {
            kernel: this,
            attempt: this._reconnect_attempt,
        });
        this.start_channels();
    };

    Kernel.prototype._on_success = function (success) {
        /**
         * Handle a successful AJAX request by updating the kernel id and
         * name from the response, and then optionally calling a provided
         * callback.
         *
         * @function _on_success
         * @param {function} success - callback
         */
        var that = this;
        return function (data, status, xhr) {
            if (data) {
                that.id = data.id;
                that.name = data.name;
            }
            that.kernel_url = utils.url_join_encode(that.kernel_service_url, that.id);
            if (success) {
                success(data, status, xhr);
            }
        };
    };

    Kernel.prototype._on_error = function (error) {
        /**
         * Handle a failed AJAX request by logging the error message, and
         * then optionally calling a provided callback.
         *
         * @function _on_error
         * @param {function} error - callback
         */
        return function (xhr, status, err) {
            utils.log_ajax_error(xhr, status, err);
            if (error) {
                error(xhr, status, err);
            }
        };
    };

    Kernel.prototype._kernel_created = function (data) {
        /**
         * Perform necessary tasks once the kernel has been started,
         * including actually connecting to the kernel.
         *
         * @function _kernel_created
         * @param {Object} data - information about the kernel including id
         */
        this.id = data.id;
        this.kernel_url = utils.url_join_encode(this.kernel_service_url, this.id);
        this.start_channels();
    };

    Kernel.prototype._kernel_connected = function () {
        /**
         * Perform necessary tasks once the connection to the kernel has
         * been established. This includes requesting information about
         * the kernel.
         *
         * @function _kernel_connected
         */
        this.events.trigger('kernel_connected.Kernel', {kernel: this});
        // get kernel info so we know what state the kernel is in
        var that = this;
        this.kernel_info(function (reply) {
            that.info_reply = reply.content;
            that.events.trigger('kernel_ready.Kernel', {kernel: that});
        });
    };

    Kernel.prototype._kernel_dead = function () {
        /**
         * Perform necessary tasks after the kernel has died. This closing
         * communication channels to the kernel if they are still somehow
         * open.
         *
         * @function _kernel_dead
         */
        this.stop_channels();
    };

    Kernel.prototype.start_channels = function () {
        /**
         * Start the websocket channels.
         * Will stop and restart them if they already exist.
         *
         * @function start_channels
         */
        var that = this;
        this.stop_channels();
        var ws_host_url = this.ws_url + this.kernel_url;

        console.log("Starting WebSockets:", ws_host_url);
        
        this.ws = new this.WebSocket([
                that.ws_url,
                utils.url_join_encode(that.kernel_url, 'channels'),
                "?session_id=" + that.session_id
            ].join('')
        );
        
        var already_called_onclose = false; // only alert once
        var ws_closed_early = function(evt){
            if (already_called_onclose){
                return;
            }
            already_called_onclose = true;
            if ( ! evt.wasClean ){
                // If the websocket was closed early, that could mean
                // that the kernel is actually dead. Try getting
                // information about the kernel from the API call --
                // if that fails, then assume the kernel is dead,
                // otherwise just follow the typical websocket closed
                // protocol.
                that.get_info(function () {
                    that._ws_closed(ws_host_url, false);
                }, function () {
                    that.events.trigger('kernel_dead.Kernel', {kernel: that});
                    that._kernel_dead();
                });
            }
        };
        var ws_closed_late = function(evt){
            if (already_called_onclose){
                return;
            }
            already_called_onclose = true;
            if ( ! evt.wasClean ){
                that._ws_closed(ws_host_url, false);
            }
        };
        var ws_error = function(evt){
            if (already_called_onclose){
                return;
            }
            already_called_onclose = true;
            that._ws_closed(ws_host_url, true);
        };

        this.ws.onopen = $.proxy(this._ws_opened, this);
        this.ws.onclose = ws_closed_early;
        this.ws.onerror = ws_error;
        // switch from early-close to late-close message after 1s
        setTimeout(function() {
            if (that.ws !== null) {
                that.ws.onclose = ws_closed_late;
            }
        }, 1000);
        this.ws.onmessage = $.proxy(this._handle_ws_message, this);
    };

    Kernel.prototype._ws_opened = function (evt) {
        /**
         * Handle a websocket entering the open state,
         * signaling that the kernel is connected when websocket is open.
         *
         * @function _ws_opened
         */
        if (this.is_connected()) {
            // all events ready, trigger started event.
            this._kernel_connected();
        }
    };

    Kernel.prototype._ws_closed = function(ws_url, error) {
        /**
         * Handle a websocket entering the closed state.  If the websocket
         * was not closed due to an error, try to reconnect to the kernel.
         *
         * @function _ws_closed
         * @param {string} ws_url - the websocket url
         * @param {bool} error - whether the connection was closed due to an error
         */
        this.stop_channels();

        this.events.trigger('kernel_disconnected.Kernel', {kernel: this});
        if (error) {
            console.log('WebSocket connection failed: ', ws_url);
            this.events.trigger('kernel_connection_failed.Kernel', {kernel: this, ws_url: ws_url, attempt: this._reconnect_attempt});
        }
        this._schedule_reconnect();
    };

    Kernel.prototype._schedule_reconnect = function () {
        /**
         * function to call when kernel connection is lost
         * schedules reconnect, or fires 'connection_dead' if reconnect limit is hit
         */
        if (this._reconnect_attempt < this.reconnect_limit) {
            var timeout = Math.pow(2, this._reconnect_attempt);
            console.log("Connection lost, reconnecting in " + timeout + " seconds.");
            setTimeout($.proxy(this.reconnect, this), 1e3 * timeout);
        } else {
            this.events.trigger('kernel_connection_dead.Kernel', {
                kernel: this,
                reconnect_attempt: this._reconnect_attempt,
            });
            console.log("Failed to reconnect, giving up.");
        }
    };

    Kernel.prototype.stop_channels = function () {
        /**
         * Close the websocket. After successful close, the value
         * in `this.ws` will be null.
         *
         * @function stop_channels
         */
        var that = this;
        var close = function () {
            if (that.ws && that.ws.readyState === WebSocket.CLOSED) {
                that.ws = null;
            }
        };
        if (this.ws !== null) {
            if (this.ws.readyState === WebSocket.OPEN) {
                this.ws.onclose = close;
                this.ws.close();
            } else {
                close();
            }
        }
    };

    Kernel.prototype.is_connected = function () {
        /**
         * Check whether there is a connection to the kernel. This
         * function only returns true if websocket has been
         * created and has a state of WebSocket.OPEN.
         *
         * @function is_connected
         * @returns {bool} - whether there is a connection
         */
        // if any channel is not ready, then we're not connected
        if (this.ws === null) {
            return false;
        }
        if (this.ws.readyState !== WebSocket.OPEN) {
            return false;
        }
        return true;
    };

    Kernel.prototype.is_fully_disconnected = function () {
        /**
         * Check whether the connection to the kernel has been completely
         * severed. This function only returns true if all channel objects
         * are null.
         *
         * @function is_fully_disconnected
         * @returns {bool} - whether the kernel is fully disconnected
         */
        return (this.ws === null);
    };

    Kernel.prototype.send_shell_message = function (msg_type, content, callbacks, metadata, buffers) {
        /**
         * Send a message on the Kernel's shell channel
         *
         * @function send_shell_message
         */
        if (!this.is_connected()) {
            throw new Error("kernel is not connected");
        }
        var msg = this._get_msg(msg_type, content, metadata, buffers);
        msg.channel = 'shell';
        this.ws.send(serialize.serialize(msg));
        this.set_callbacks_for_msg(msg.header.msg_id, callbacks);
        return msg.header.msg_id;
    };

    Kernel.prototype.kernel_info = function (callback) {
        /**
         * Get kernel info
         *
         * @function kernel_info
         * @param callback {function}
         *
         * When calling this method, pass a callback function that expects one argument.
         * The callback will be passed the complete `kernel_info_reply` message documented
         * [here](http://ipython.org/ipython-doc/dev/development/messaging.html#kernel-info)
         */
        var callbacks;
        if (callback) {
            callbacks = { shell : { reply : callback } };
        }
        return this.send_shell_message("kernel_info_request", {}, callbacks);
    };

    Kernel.prototype.inspect = function (code, cursor_pos, callback) {
        /**
         * Get info on an object
         *
         * When calling this method, pass a callback function that expects one argument.
         * The callback will be passed the complete `inspect_reply` message documented
         * [here](http://ipython.org/ipython-doc/dev/development/messaging.html#object-information)
         *
         * @function inspect
         * @param code {string}
         * @param cursor_pos {integer}
         * @param callback {function}
         */
        var callbacks;
        if (callback) {
            callbacks = { shell : { reply : callback } };
        }
        
        var content = {
            code : code,
            cursor_pos : cursor_pos,
            detail_level : 0
        };
        return this.send_shell_message("inspect_request", content, callbacks);
    };

    Kernel.prototype.execute = function (code, callbacks, options) {
        /**
         * Execute given code into kernel, and pass result to callback.
         *
         * @async
         * @function execute
         * @param {string} code
         * @param [callbacks] {Object} With the following keys (all optional)
         *      @param callbacks.shell.reply {function}
         *      @param callbacks.shell.payload.[payload_name] {function}
         *      @param callbacks.iopub.output {function}
         *      @param callbacks.iopub.clear_output {function}
         *      @param callbacks.input {function}
         * @param {object} [options]
         *      @param [options.silent=false] {Boolean}
         *      @param [options.user_expressions=empty_dict] {Dict}
         *      @param [options.allow_stdin=false] {Boolean} true|false
         *
         * @example
         *
         * The options object should contain the options for the execute
         * call. Its default values are:
         *
         *      options = {
         *        silent : true,
         *        user_expressions : {},
         *        allow_stdin : false
         *      }
         *
         * When calling this method pass a callbacks structure of the
         * form:
         *
         *      callbacks = {
         *       shell : {
         *         reply : execute_reply_callback,
         *         payload : {
         *           set_next_input : set_next_input_callback,
         *         }
         *       },
         *       iopub : {
         *         output : output_callback,
         *         clear_output : clear_output_callback,
         *       },
         *       input : raw_input_callback
         *      }
         *
         * Each callback will be passed the entire message as a single
         * arugment.  Payload handlers will be passed the corresponding
         * payload and the execute_reply message.
         */
        var content = {
            code : code,
            silent : true,
            store_history : false,
            user_expressions : {},
            allow_stdin : false
        };
        callbacks = callbacks || {};
        if (callbacks.input !== undefined) {
            content.allow_stdin = true;
        }
        $.extend(true, content, options);
        this.events.trigger('execution_request.Kernel', {kernel: this, content: content});
        return this.send_shell_message("execute_request", content, callbacks);
    };

    /**
     * When calling this method, pass a function to be called with the
     * `complete_reply` message as its only argument when it arrives.
     *
     * `complete_reply` is documented
     * [here](http://ipython.org/ipython-doc/dev/development/messaging.html#complete)
     *
     * @function complete
     * @param code {string}
     * @param cursor_pos {integer}
     * @param callback {function}
     */
    Kernel.prototype.complete = function (code, cursor_pos, callback) {
        var callbacks;
        if (callback) {
            callbacks = { shell : { reply : callback } };
        }
        var content = {
            code : code,
            cursor_pos : cursor_pos
        };
        return this.send_shell_message("complete_request", content, callbacks);
    };

    /**
     * @function send_input_reply
     */
    Kernel.prototype.send_input_reply = function (input) {
        if (!this.is_connected()) {
            throw new Error("kernel is not connected");
        }
        var content = {
            value : input
        };
        this.events.trigger('input_reply.Kernel', {kernel: this, content: content});
        var msg = this._get_msg("input_reply", content);
        msg.channel = 'stdin';
        this.ws.send(serialize.serialize(msg));
        return msg.header.msg_id;
    };

    /**
     * @function register_iopub_handler
     */
    Kernel.prototype.register_iopub_handler = function (msg_type, callback) {
        this._iopub_handlers[msg_type] = callback;
    };

    /**
     * Get the iopub handler for a specific message type.
     *
     * @function get_iopub_handler
     */
    Kernel.prototype.get_iopub_handler = function (msg_type) {
        return this._iopub_handlers[msg_type];
    };

    /**
     * Get callbacks for a specific message.
     *
     * @function get_callbacks_for_msg
     */
    Kernel.prototype.get_callbacks_for_msg = function (msg_id) {
        if (msg_id == this.last_msg_id) {
            return this.last_msg_callbacks;
        } else {
            return this._msg_callbacks[msg_id];
        }
    };

    /**
     * Clear callbacks for a specific message.
     *
     * @function clear_callbacks_for_msg
     */
    Kernel.prototype.clear_callbacks_for_msg = function (msg_id) {
        if (this._msg_callbacks[msg_id] !== undefined ) {
            delete this._msg_callbacks[msg_id];
        }
    };

    /**
     * @function _finish_shell
     */
    Kernel.prototype._finish_shell = function (msg_id) {
        var callbacks = this._msg_callbacks[msg_id];
        if (callbacks !== undefined) {
            callbacks.shell_done = true;
            if (callbacks.iopub_done) {
                this.clear_callbacks_for_msg(msg_id);
            }
        }
    };

    /**
     * @function _finish_iopub
     */
    Kernel.prototype._finish_iopub = function (msg_id) {
        var callbacks = this._msg_callbacks[msg_id];
        if (callbacks !== undefined) {
            callbacks.iopub_done = true;
            if (callbacks.shell_done) {
                this.clear_callbacks_for_msg(msg_id);
            }
        }
    };

    /**
     * Set callbacks for a particular message.
     * Callbacks should be a struct of the following form:
     * shell : {
     * 
     * }
     *
     * @function set_callbacks_for_msg
     */
    Kernel.prototype.set_callbacks_for_msg = function (msg_id, callbacks) {
        this.last_msg_id = msg_id;
        if (callbacks) {
            // shallow-copy mapping, because we will modify it at the top level
            var cbcopy = this._msg_callbacks[msg_id] = this.last_msg_callbacks = {};
            cbcopy.shell = callbacks.shell;
            cbcopy.iopub = callbacks.iopub;
            cbcopy.input = callbacks.input;
            cbcopy.shell_done = (!callbacks.shell);
            cbcopy.iopub_done = (!callbacks.iopub);
        } else {
            this.last_msg_callbacks = {};
        }
    };

    Kernel.prototype._handle_ws_message = function (e) {
        var that = this;
        this._msg_queue = this._msg_queue.then(function() {
            return serialize.deserialize(e.data);
        }).then(function(msg) {return that._finish_ws_message(msg);})
        .catch(utils.reject("Couldn't process kernel message", true));
    };

    Kernel.prototype._finish_ws_message = function (msg) {
        switch (msg.channel) {
            case 'shell':
                return this._handle_shell_reply(msg);
                break;
            case 'iopub':
                return this._handle_iopub_message(msg);
                break;
            case 'stdin':
                return this._handle_input_request(msg);
                break;
            default:
                console.error("unrecognized message channel", msg.channel, msg);
        }
    };

    Kernel.prototype._handle_shell_reply = function (reply) {
        this.events.trigger('shell_reply.Kernel', {kernel: this, reply:reply});
        var that = this;
        var content = reply.content;
        var metadata = reply.metadata;
        var parent_id = reply.parent_header.msg_id;
        var callbacks = this.get_callbacks_for_msg(parent_id);
        var promise = Promise.resolve();
        if (!callbacks || !callbacks.shell) {
            return;
        }
        var shell_callbacks = callbacks.shell;
        
        // signal that shell callbacks are done
        this._finish_shell(parent_id);
        
        if (shell_callbacks.reply !== undefined) {
            promise = promise.then(function() {return shell_callbacks.reply(reply)});
        }
        if (content.payload && shell_callbacks.payload) {
            promise = promise.then(function() {
                return that._handle_payloads(content.payload, shell_callbacks.payload, reply);
            });
        }
        return promise;
    };

    /**
     * @function _handle_payloads
     */
    Kernel.prototype._handle_payloads = function (payloads, payload_callbacks, msg) {
        var promise = [];
        var l = payloads.length;
        // Payloads are handled by triggering events because we don't want the Kernel
        // to depend on the Notebook or Pager classes.
        for (var i=0; i<l; i++) {
            var payload = payloads[i];
            var callback = payload_callbacks[payload.source];
            if (callback) {
                promise.push(callback(payload, msg));
            }
        }
        return Promise.all(promise);
    };

    /**
     * @function _handle_status_message
     */
    Kernel.prototype._handle_status_message = function (msg) {
        var execution_state = msg.content.execution_state;
        var parent_id = msg.parent_header.msg_id;
        
        // dispatch status msg callbacks, if any
        var callbacks = this.get_callbacks_for_msg(parent_id);
        if (callbacks && callbacks.iopub && callbacks.iopub.status) {
            try {
                callbacks.iopub.status(msg);
            } catch (e) {
                console.log("Exception in status msg handler", e, e.stack);
            }
        }
        
        if (execution_state === 'busy') {
            this.events.trigger('kernel_busy.Kernel', {kernel: this});

        } else if (execution_state === 'idle') {
            // signal that iopub callbacks are (probably) done
            // async output may still arrive,
            // but only for the most recent request
            this._finish_iopub(parent_id);
            
            // trigger status_idle event
            this.events.trigger('kernel_idle.Kernel', {kernel: this});

        } else if (execution_state === 'starting') {
            this.events.trigger('kernel_starting.Kernel', {kernel: this});
            var that = this;
            this.kernel_info(function (reply) {
                that.info_reply = reply.content;
                that.events.trigger('kernel_ready.Kernel', {kernel: that});
            });

        } else if (execution_state === 'restarting') {
            // autorestarting is distinct from restarting,
            // in that it means the kernel died and the server is restarting it.
            // kernel_restarting sets the notification widget,
            // autorestart shows the more prominent dialog.
            this._autorestart_attempt = this._autorestart_attempt + 1;
            this.events.trigger('kernel_restarting.Kernel', {kernel: this});
            this.events.trigger('kernel_autorestarting.Kernel', {kernel: this, attempt: this._autorestart_attempt});

        } else if (execution_state === 'dead') {
            this.events.trigger('kernel_dead.Kernel', {kernel: this});
            this._kernel_dead();
        }
    };

    /**
     * Handle clear_output message
     *
     * @function _handle_clear_output
     */
    Kernel.prototype._handle_clear_output = function (msg) {
        var callbacks = this.get_callbacks_for_msg(msg.parent_header.msg_id);
        if (!callbacks || !callbacks.iopub) {
            return;
        }
        var callback = callbacks.iopub.clear_output;
        if (callback) {
            callback(msg);
        }
    };

    /**
     * handle an output message (execute_result, display_data, etc.)
     *
     * @function _handle_output_message
     */
    Kernel.prototype._handle_output_message = function (msg) {
        var callbacks = this.get_callbacks_for_msg(msg.parent_header.msg_id);
        if (!callbacks || !callbacks.iopub) {
            // The message came from another client. Let the UI decide what to
            // do with it.
            this.events.trigger('received_unsolicited_message.Kernel', msg);
            return;
        }
        var callback = callbacks.iopub.output;
        if (callback) {
            callback(msg);
        }
    };

    /**
     * Handle an input message (execute_input).
     *
     * @function _handle_input message
     */
    Kernel.prototype._handle_input_message = function (msg) {
        var callbacks = this.get_callbacks_for_msg(msg.parent_header.msg_id);
        if (!callbacks) {
            // The message came from another client. Let the UI decide what to
            // do with it.
            this.events.trigger('received_unsolicited_message.Kernel', msg);
        }
    };

    /**
     * Dispatch IOPub messages to respective handlers. Each message
     * type should have a handler.
     *
     * @function _handle_iopub_message
     */
    Kernel.prototype._handle_iopub_message = function (msg) {
        var handler = this.get_iopub_handler(msg.header.msg_type);
        if (handler !== undefined) {
            return handler(msg);
        }
    };

    /**
     * @function _handle_input_request
     */
    Kernel.prototype._handle_input_request = function (request) {
        var header = request.header;
        var content = request.content;
        var metadata = request.metadata;
        var msg_type = header.msg_type;
        if (msg_type !== 'input_request') {
            console.log("Invalid input request!", request);
            return;
        }
        var callbacks = this.get_callbacks_for_msg(request.parent_header.msg_id);
        if (callbacks) {
            if (callbacks.input) {
                callbacks.input(request);
            }
        }
    };

    exports.Kernel = Kernel;

},{"./comm":"/Users/jon/jupyter/notebook/notebook/static-src/services/kernels/comm.js","./serialize":"/Users/jon/jupyter/notebook/notebook/static-src/services/kernels/serialize.js","base/js/events":"/Users/jon/jupyter/notebook/notebook/static-src/base/js/events.js","base/js/utils":"/Users/jon/jupyter/notebook/notebook/static-src/base/js/utils.js"}],"/Users/jon/jupyter/notebook/notebook/static-src/services/kernels/serialize.js":[function(require,module,exports){
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
    "use strict";

    var _deserialize_array_buffer = function (buf) {
        var data = new DataView(buf);
        // read the header: 1 + nbufs 32b integers
        var nbufs = data.getUint32(0);
        var offsets = [];
        var i;
        for (i = 1; i <= nbufs; i++) {
            offsets.push(data.getUint32(i * 4));
        }
        var json_bytes = new Uint8Array(buf.slice(offsets[0], offsets[1]));
        var msg = JSON.parse(
            (new TextDecoder('utf8')).decode(json_bytes)
        );
        // the remaining chunks are stored as DataViews in msg.buffers
        msg.buffers = [];
        var start, stop;
        for (i = 1; i < nbufs; i++) {
            start = offsets[i];
            stop = offsets[i+1] || buf.byteLength;
            msg.buffers.push(new DataView(buf.slice(start, stop)));
        }
        return msg;
    };

    var _deserialize_binary = function(data) {
        /**
         * deserialize the binary message format
         * callback will be called with a message whose buffers attribute
         * will be an array of DataViews.
         */
        if (data instanceof Blob) {
            // data is Blob, have to deserialize from ArrayBuffer in reader callback
            var reader = new FileReader();
            var promise = new Promise(function(resolve, reject) {
                reader.onload = function () {
                    var msg = _deserialize_array_buffer(this.result);
                    resolve(msg);
                };
            });
            reader.readAsArrayBuffer(data);
            return promise;
        } else {
            // data is ArrayBuffer, can deserialize directly
            var msg = _deserialize_array_buffer(data);
            return msg;
        }
    };

    var deserialize = function (data) {
        /**
         * deserialize a message and return a promise for the unpacked message
         */
        if (typeof data === "string") {
            // text JSON message
            return Promise.resolve(JSON.parse(data));
        } else {
            // binary message
            return Promise.resolve(_deserialize_binary(data));
        }
    };

    var _serialize_binary = function (msg) {
        /**
         * implement the binary serialization protocol
         * serializes JSON message to ArrayBuffer
         */
        msg = _.clone(msg);
        var offsets = [];
        var buffers = [];
        var i;
        for (i = 0; i < msg.buffers.length; i++) {
            // msg.buffers elements could be either views or ArrayBuffers
            // buffers elements are ArrayBuffers
            var b = msg.buffers[i];
            buffers.push(b.buffer instanceof ArrayBuffer ? b.buffer : b);
        }
        delete msg.buffers;
        var json_utf8 = (new TextEncoder('utf8')).encode(JSON.stringify(msg));
        buffers.unshift(json_utf8);
        var nbufs = buffers.length;
        offsets.push(4 * (nbufs + 1));
        for (i = 0; i + 1 < buffers.length; i++) {
            offsets.push(offsets[offsets.length-1] + buffers[i].byteLength);
        }
        var msg_buf = new Uint8Array(
            offsets[offsets.length-1] + buffers[buffers.length-1].byteLength
        );
        // use DataView.setUint32 for network byte-order
        var view = new DataView(msg_buf.buffer);
        // write nbufs to first 4 bytes
        view.setUint32(0, nbufs);
        // write offsets to next 4 * nbufs bytes
        for (i = 0; i < offsets.length; i++) {
            view.setUint32(4 * (i+1), offsets[i]);
        }
        // write all the buffers at their respective offsets
        for (i = 0; i < buffers.length; i++) {
            msg_buf.set(new Uint8Array(buffers[i]), offsets[i]);
        }
        
        // return raw ArrayBuffer
        return msg_buf.buffer;
    };

    var serialize = function (msg) {
        if (msg.buffers && msg.buffers.length) {
            return _serialize_binary(msg);
        } else {
            return JSON.stringify(msg);
        }
    };

    module.exports = {
        deserialize : deserialize,
        serialize: serialize
    };

},{}],"/Users/jon/jupyter/notebook/notebook/static-src/services/sessions/session.js":[function(require,module,exports){
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
    "use strict";

    var utils = require('base/js/utils');
    var kernel = require('services/kernels/kernel');

    /**
     * Session object for accessing the session REST api. The session
     * should be used to start kernels and then shut them down -- for
     * all other operations, the kernel object should be used.
     *
     * Preliminary documentation for the REST API is at 
     * https://github.com/ipython/ipython/wiki/IPEP-16%3A-Notebook-multi-directory-dashboard-and-URL-mapping#sessions-api
     *
     * Options should include:
     *  - notebook_path: the path (not including name) to the notebook
     *  - kernel_name: the type of kernel (e.g. python3)
     *  - base_url: the root url of the notebook server
     *  - ws_url: the url to access websockets
     *  - notebook: Notebook object
     *
     * @class Session
     * @param {Object} options
     */
    var Session = function (options) {
        this.id = null;
        this.notebook_model = {
            path: options.notebook_path
        };
        this.kernel_model = {
            id: null,
            name: options.kernel_name
        };

        this.base_url = options.base_url;
        this.ws_url = options.ws_url;
        this.session_service_url = utils.url_join_encode(this.base_url, 'api/sessions');
        this.session_url = null;

        this.notebook = options.notebook;
        this.kernel = null;
        this.events = options.notebook.events;

        this.bind_events();
    };

    Session.prototype.bind_events = function () {
        var that = this;
        var record_status = function (evt, info) {
            console.log('Session: ' + evt.type + ' (' + info.session.id + ')');
        };

        this.events.on('kernel_created.Session', record_status);
        this.events.on('kernel_dead.Session', record_status);
        this.events.on('kernel_killed.Session', record_status);

        // if the kernel dies, then also remove the session
        this.events.on('kernel_dead.Kernel', function () {
            that.delete();
        });
    };


    // Public REST api functions

    /**
     * GET /api/sessions
     *
     * Get a list of the current sessions.
     *
     * @function list
     * @param {function} [success] - function executed on ajax success
     * @param {function} [error] - functon executed on ajax error
     */
    Session.prototype.list = function (success, error) {
        $.ajax(this.session_service_url, {
            processData: false,
            cache: false,
            type: "GET",
            dataType: "json",
            success: success,
            error: this._on_error(error)
        });
    };

    /**
     * POST /api/sessions
     *
     * Start a new session. This function can only executed once.
     *
     * @function start
     * @param {function} [success] - function executed on ajax success
     * @param {function} [error] - functon executed on ajax error
     */
    Session.prototype.start = function (success, error) {
        var that = this;
        var on_success = function (data, status, xhr) {
            if (that.kernel) {
                that.kernel.name = that.kernel_model.name;
            } else {
                var kernel_service_url = utils.url_path_join(that.base_url, "api/kernels");
                that.kernel = new kernel.Kernel(kernel_service_url, that.ws_url, that.kernel_model.name);
            }
            that.events.trigger('kernel_created.Session', {session: that, kernel: that.kernel});
            that.kernel._kernel_created(data.kernel);
            if (success) {
                success(data, status, xhr);
            }
        };
        var on_error = function (xhr, status, err) {
            that.events.trigger('kernel_dead.Session', {session: that, xhr: xhr, status: status, error: err});
            if (error) {
                error(xhr, status, err);
            }
        };

        $.ajax(this.session_service_url, {
            processData: false,
            cache: false,
            type: "POST",
            data: JSON.stringify(this._get_model()),
            contentType: 'application/json',
            dataType: "json",
            success: this._on_success(on_success),
            error: this._on_error(on_error)
        });
    };

    /**
     * GET /api/sessions/[:session_id]
     *
     * Get information about a session.
     *
     * @function get_info
     * @param {function} [success] - function executed on ajax success
     * @param {function} [error] - functon executed on ajax error
     */
    Session.prototype.get_info = function (success, error) {
        $.ajax(this.session_url, {
            processData: false,
            cache: false,
            type: "GET",
            dataType: "json",
            success: this._on_success(success),
            error: this._on_error(error)
        });
    };

    /**
     * PATCH /api/sessions/[:session_id]
     *
     * Rename or move a notebook. If the given name or path are
     * undefined, then they will not be changed.
     *
     * @function rename_notebook
     * @param {string} [path] - new notebook path
     * @param {function} [success] - function executed on ajax success
     * @param {function} [error] - functon executed on ajax error
     */
    Session.prototype.rename_notebook = function (path, success, error) {
        if (path !== undefined) {
            this.notebook_model.path = path;
        }

        $.ajax(this.session_url, {
            processData: false,
            cache: false,
            type: "PATCH",
            data: JSON.stringify(this._get_model()),
            contentType: 'application/json',
            dataType: "json",
            success: this._on_success(success),
            error: this._on_error(error)
        });
    };

    /**
     * DELETE /api/sessions/[:session_id]
     *
     * Kill the kernel and shutdown the session.
     *
     * @function delete
     * @param {function} [success] - function executed on ajax success
     * @param {function} [error] - functon executed on ajax error
     */
    Session.prototype.delete = function (success, error) {
        if (this.kernel) {
            this.events.trigger('kernel_killed.Session', {session: this, kernel: this.kernel});
            this.kernel._kernel_dead();
        }

        $.ajax(this.session_url, {
            processData: false,
            cache: false,
            type: "DELETE",
            dataType: "json",
            success: this._on_success(success),
            error: this._on_error(error)
        });
    };

    /**
     * Restart the session by deleting it and the starting it
     * fresh. If options are given, they can include any of the
     * following:
     *
     * - notebook_path - the path to the notebook
     * - kernel_name - the name (type) of the kernel
     *
     * @function restart
     * @param {Object} [options] - options for the new kernel
     * @param {function} [success] - function executed on ajax success
     * @param {function} [error] - functon executed on ajax error
     */
    Session.prototype.restart = function (options, success, error) {
        var that = this;
        var start = function () {
            if (options && options.notebook_path) {
                that.notebook_model.path = options.notebook_path;
            }
            if (options && options.kernel_name) {
                that.kernel_model.name = options.kernel_name;
            }
            that.kernel_model.id = null;
            that.start(success, error);
        };
        this.delete(start, start);
    };

    // Helper functions

    /**
     * Get the data model for the session, which includes the notebook path
     * and kernel (name and id).
     *
     * @function _get_model
     * @returns {Object} - the data model
     */
    Session.prototype._get_model = function () {
        return {
            notebook: this.notebook_model,
            kernel: this.kernel_model
        };
    };

    /**
     * Update the data model from the given JSON object, which should
     * have attributes of `id`, `notebook`, and/or `kernel`. If
     * provided, the notebook data must include name and path, and the
     * kernel data must include name and id.
     *
     * @function _update_model
     * @param {Object} data - updated data model
     */
    Session.prototype._update_model = function (data) {
        if (data && data.id) {
            this.id = data.id;
            this.session_url = utils.url_join_encode(this.session_service_url, this.id);
        }
        if (data && data.notebook) {
            this.notebook_model.path = data.notebook.path;
        }
        if (data && data.kernel) {
            this.kernel_model.name = data.kernel.name;
            this.kernel_model.id = data.kernel.id;
        }
    };

    /**
     * Handle a successful AJAX request by updating the session data
     * model with the response, and then optionally calling a provided
     * callback.
     *
     * @function _on_success
     * @param {function} success - callback
     */
    Session.prototype._on_success = function (success) {
        var that = this;
        return function (data, status, xhr) {
            that._update_model(data);
            if (success) {
                success(data, status, xhr);
            }
        };
    };

    /**
     * Handle a failed AJAX request by logging the error message, and
     * then optionally calling a provided callback.
     *
     * @function _on_error
     * @param {function} error - callback
     */
    Session.prototype._on_error = function (error) {
        return function (xhr, status, err) {
            utils.log_ajax_error(xhr, status, err);
            if (error) {
                error(xhr, status, err);
            }
        };
    };

    /**
     * Error type indicating that the session is already starting.
     */
    var SessionAlreadyStarting = function (message) {
        this.name = "SessionAlreadyStarting";
        this.message = (message || "");
    };

    SessionAlreadyStarting.prototype = Error.prototype;

    module.exports = {
        Session: Session,
        SessionAlreadyStarting: SessionAlreadyStarting
    };

},{"base/js/utils":"/Users/jon/jupyter/notebook/notebook/static-src/base/js/utils.js","services/kernels/kernel":"/Users/jon/jupyter/notebook/notebook/static-src/services/kernels/kernel.js"}],"/Users/jon/jupyter/notebook/notebook/static-src/tree/js/sessionlist.js":[function(require,module,exports){
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
    "use strict";

    var utils = require('base/js/utils');

    var SesssionList = function (options) {
        /**
         * Constructor
         *
         * Parameters:
         *  options: dictionary
         *      Dictionary of keyword arguments.
         *          events: $(Events) instance
         *          base_url : string
         */
        this.events = options.events;
        this.sessions = {};
        this.base_url = options.base_url || utils.get_body_data("baseUrl");

        // Add collapse arrows.
        $('#running .panel-group .panel .panel-heading a').each(function(index, el) {
            var $link = $(el);
            var $icon = $('<i />')
                .addClass('fa fa-caret-down');
            $link.append($icon);
            $link.down = true;
            $link.click(function () {
                if ($link.down) {
                    $link.down = false;
                    // jQeury doesn't know how to animate rotations.  Abuse
                    // jQueries animate function by using an unused css attribute
                    // to do the animation (borderSpacing).
                    $icon.animate({ borderSpacing: 90 }, {
                        step: function(now,fx) {
                            $icon.css('transform','rotate(-' + now + 'deg)'); 
                        }
                    }, 250);
                } else {
                    $link.down = true;
                    // See comment above.
                    $icon.animate({ borderSpacing: 0 }, {
                        step: function(now,fx) {
                            $icon.css('transform','rotate(-' + now + 'deg)'); 
                        }
                    }, 250);
                }
            });
        });
    };

    SesssionList.prototype.load_sessions = function(){
        var that = this;
        var settings = {
            processData : false,
            cache : false,
            type : "GET",
            dataType : "json",
            success : $.proxy(that.sessions_loaded, this),
            error : utils.log_ajax_error,
        };
        var url = utils.url_join_encode(this.base_url, 'api/sessions');
        $.ajax(url, settings);
    };

    SesssionList.prototype.sessions_loaded = function(data){
        this.sessions = {};
        var len = data.length;
        var nb_path;
        for (var i=0; i<len; i++) {
            nb_path = data[i].notebook.path;
            this.sessions[nb_path] = data[i].id;
        }
        this.events.trigger('sessions_loaded.Dashboard', this.sessions);
    };

    exports.SesssionList = SesssionList;

},{"base/js/utils":"/Users/jon/jupyter/notebook/notebook/static-src/base/js/utils.js"}],"/Users/jon/jupyter/notebook/notebook/static/components/google-caja/html-css-sanitizer-minified.js":[function(require,module,exports){
var CSS_PROP_BIT_QUANTITY=1;var CSS_PROP_BIT_HASH_VALUE=2;var CSS_PROP_BIT_NEGATIVE_QUANTITY=4;var CSS_PROP_BIT_QSTRING=8;var CSS_PROP_BIT_URL=16;var CSS_PROP_BIT_UNRESERVED_WORD=64;var CSS_PROP_BIT_UNICODE_RANGE=128;var CSS_PROP_BIT_GLOBAL_NAME=512;var CSS_PROP_BIT_PROPERTY_NAME=1024;var cssSchema=function(){var L=[["aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","green","greenyellow","honeydew","hotpink","indianred","indigo","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","red","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","snow","springgreen","steelblue","tan","teal","thistle","tomato","transparent","turquoise","violet","wheat","white","whitesmoke","yellow","yellowgreen"],["all-scroll","col-resize","crosshair","default","e-resize","hand","help","move","n-resize","ne-resize","no-drop","not-allowed","nw-resize","pointer","progress","row-resize","s-resize","se-resize","sw-resize","text","vertical-text","w-resize","wait"],["armenian","decimal","decimal-leading-zero","disc","georgian","lower-alpha","lower-greek","lower-latin","lower-roman","square","upper-alpha","upper-latin","upper-roman"],["100","200","300","400","500","600","700","800","900","bold","bolder","lighter"],["block-level","inline-level","table-caption","table-cell","table-column","table-column-group","table-footer-group","table-header-group","table-row","table-row-group"],["condensed","expanded","extra-condensed","extra-expanded","narrower","semi-condensed","semi-expanded","ultra-condensed","ultra-expanded","wider"],["inherit","inline","inline-block","inline-box","inline-flex","inline-grid","inline-list-item","inline-stack","inline-table","run-in"],["behind","center-left","center-right","far-left","far-right","left-side","leftwards","right-side","rightwards"],["large","larger","small","smaller","x-large","x-small","xx-large","xx-small"],["dashed","dotted","double","groove","outset","ridge","solid"],["ease","ease-in","ease-in-out","ease-out","linear","step-end","step-start"],["at","closest-corner","closest-side","ellipse","farthest-corner","farthest-side"],["baseline","middle","sub","super","text-bottom","text-top"],["caption","icon","menu","message-box","small-caption","status-bar"],["fast","faster","slow","slower","x-fast","x-slow"],["above","below","higher","level","lower"],["cursive","fantasy","monospace","sans-serif","serif"],["loud","silent","soft","x-loud","x-soft"],["no-repeat","repeat-x","repeat-y","round","space"],["blink","line-through","overline","underline"],["block","flex","grid","table"],["high","low","x-high","x-low"],["nowrap","pre","pre-line","pre-wrap"],["absolute","relative","static"],["alternate","alternate-reverse","reverse"],["border-box","content-box","padding-box"],["capitalize","lowercase","uppercase"],["child","female","male"],["=","opacity"],["backwards","forwards"],["bidi-override","embed"],["bottom","top"],["break-all","keep-all"],["clip","ellipsis"],["contain","cover"],["continuous","digits"],["end","start"],["flat","preserve-3d"],["hide","show"],["horizontal","vertical"],["inside","outside"],["italic","oblique"],["left","right"],["ltr","rtl"],["no-content","no-display"],["paused","running"],["suppress","unrestricted"],["thick","thin"],[","],["/"],["all"],["always"],["auto"],["avoid"],["both"],["break-word"],["center"],["circle"],["code"],["collapse"],["contents"],["fixed"],["hidden"],["infinite"],["inset"],["invert"],["justify"],["list-item"],["local"],["medium"],["mix"],["none"],["normal"],["once"],["repeat"],["scroll"],["separate"],["small-caps"],["spell-out"],["to"],["visible"]];var schema={animation:{cssPropBits:517,cssLitGroup:[L[10],L[24],L[29],L[45],L[48],L[54],L[63],L[71],L[72]],cssFns:["cubic-bezier()","steps()"]},"animation-delay":{cssPropBits:5,cssLitGroup:[L[48]],cssFns:[]},"animation-direction":{cssPropBits:0,cssLitGroup:[L[24],L[48],L[72]],cssFns:[]},"animation-duration":"animation-delay","animation-fill-mode":{cssPropBits:0,cssLitGroup:[L[29],L[48],L[54],L[71]],cssFns:[]},"animation-iteration-count":{cssPropBits:5,cssLitGroup:[L[48],L[63]],cssFns:[]},"animation-name":{cssPropBits:512,cssLitGroup:[L[48],L[71]],cssFns:[]},"animation-play-state":{cssPropBits:0,cssLitGroup:[L[45],L[48]],cssFns:[]},"animation-timing-function":{cssPropBits:0,cssLitGroup:[L[10],L[48]],cssFns:["cubic-bezier()","steps()"]},appearance:{cssPropBits:0,cssLitGroup:[L[71]],cssFns:[]},azimuth:{cssPropBits:5,cssLitGroup:[L[7],L[42],L[56]],cssFns:[]},"backface-visibility":{cssPropBits:0,cssLitGroup:[L[59],L[62],L[80]],cssFns:[]},background:{cssPropBits:23,cssLitGroup:[L[0],L[18],L[25],L[31],L[34],L[42],L[48],L[49],L[52],L[56],L[61],L[68],L[71],L[74],L[75]],cssFns:["image()","linear-gradient()","radial-gradient()","repeating-linear-gradient()","repeating-radial-gradient()","rgb()","rgba()"]},"background-attachment":{cssPropBits:0,cssLitGroup:[L[48],L[61],L[68],L[75]],cssFns:[]},"background-color":{cssPropBits:2,cssLitGroup:[L[0]],cssFns:["rgb()","rgba()"]},"background-image":{cssPropBits:16,cssLitGroup:[L[48],L[71]],cssFns:["image()","linear-gradient()","radial-gradient()","repeating-linear-gradient()","repeating-radial-gradient()"]},"background-position":{cssPropBits:5,cssLitGroup:[L[31],L[42],L[48],L[56]],cssFns:[]},"background-repeat":{cssPropBits:0,cssLitGroup:[L[18],L[48],L[74]],cssFns:[]},"background-size":{cssPropBits:5,cssLitGroup:[L[34],L[48],L[52]],cssFns:[]},border:{cssPropBits:7,cssLitGroup:[L[0],L[9],L[47],L[62],L[64],L[69],L[71]],cssFns:["rgb()","rgba()"]},"border-bottom":"border","border-bottom-color":"background-color","border-bottom-left-radius":{cssPropBits:5,cssFns:[]},"border-bottom-right-radius":"border-bottom-left-radius","border-bottom-style":{cssPropBits:0,cssLitGroup:[L[9],L[62],L[64],L[71]],cssFns:[]},"border-bottom-width":{cssPropBits:5,cssLitGroup:[L[47],L[69]],cssFns:[]},"border-collapse":{cssPropBits:0,cssLitGroup:[L[59],L[76]],cssFns:[]},"border-color":"background-color","border-left":"border","border-left-color":"background-color","border-left-style":"border-bottom-style","border-left-width":"border-bottom-width","border-radius":{cssPropBits:5,cssLitGroup:[L[49]],cssFns:[]},"border-right":"border","border-right-color":"background-color","border-right-style":"border-bottom-style","border-right-width":"border-bottom-width","border-spacing":"border-bottom-left-radius","border-style":"border-bottom-style","border-top":"border","border-top-color":"background-color","border-top-left-radius":"border-bottom-left-radius","border-top-right-radius":"border-bottom-left-radius","border-top-style":"border-bottom-style","border-top-width":"border-bottom-width","border-width":"border-bottom-width",bottom:{cssPropBits:5,cssLitGroup:[L[52]],cssFns:[]},box:{cssPropBits:0,cssLitGroup:[L[60],L[71],L[72]],cssFns:[]},"box-shadow":{cssPropBits:7,cssLitGroup:[L[0],L[48],L[64],L[71]],cssFns:["rgb()","rgba()"]},"box-sizing":{cssPropBits:0,cssLitGroup:[L[25]],cssFns:[]},"caption-side":{cssPropBits:0,cssLitGroup:[L[31]],cssFns:[]},clear:{cssPropBits:0,cssLitGroup:[L[42],L[54],L[71]],cssFns:[]},clip:{cssPropBits:0,cssLitGroup:[L[52]],cssFns:["rect()"]},color:"background-color",content:{cssPropBits:8,cssLitGroup:[L[71],L[72]],cssFns:[]},cue:{cssPropBits:16,cssLitGroup:[L[71]],cssFns:[]},"cue-after":"cue","cue-before":"cue",cursor:{cssPropBits:16,cssLitGroup:[L[1],L[48],L[52]],cssFns:[]},direction:{cssPropBits:0,cssLitGroup:[L[43]],cssFns:[]},display:{cssPropBits:0,cssLitGroup:[L[4],L[6],L[20],L[52],L[67],L[71]],cssFns:[]},"display-extras":{cssPropBits:0,cssLitGroup:[L[67],L[71]],cssFns:[]},"display-inside":{cssPropBits:0,cssLitGroup:[L[20],L[52]],cssFns:[]},"display-outside":{cssPropBits:0,cssLitGroup:[L[4],L[71]],cssFns:[]},elevation:{cssPropBits:5,cssLitGroup:[L[15]],cssFns:[]},"empty-cells":{cssPropBits:0,cssLitGroup:[L[38]],cssFns:[]},filter:{cssPropBits:0,cssFns:["alpha()"]},"float":{cssPropBits:0,cssLitGroup:[L[42],L[71]],cssFns:[]},font:{cssPropBits:73,cssLitGroup:[L[3],L[8],L[13],L[16],L[41],L[48],L[49],L[69],L[72],L[77]],cssFns:[]},"font-family":{cssPropBits:72,cssLitGroup:[L[16],L[48]],cssFns:[]},"font-size":{cssPropBits:1,cssLitGroup:[L[8],L[69]],cssFns:[]},"font-stretch":{cssPropBits:0,cssLitGroup:[L[5],L[72]],cssFns:[]},"font-style":{cssPropBits:0,cssLitGroup:[L[41],L[72]],cssFns:[]},"font-variant":{cssPropBits:0,cssLitGroup:[L[72],L[77]],cssFns:[]},"font-weight":{cssPropBits:0,cssLitGroup:[L[3],L[72]],cssFns:[]},height:"bottom",left:"bottom","letter-spacing":{cssPropBits:5,cssLitGroup:[L[72]],cssFns:[]},"line-height":{cssPropBits:1,cssLitGroup:[L[72]],cssFns:[]},"list-style":{cssPropBits:16,cssLitGroup:[L[2],L[40],L[57],L[71]],cssFns:["image()","linear-gradient()","radial-gradient()","repeating-linear-gradient()","repeating-radial-gradient()"]},"list-style-image":{cssPropBits:16,cssLitGroup:[L[71]],cssFns:["image()","linear-gradient()","radial-gradient()","repeating-linear-gradient()","repeating-radial-gradient()"]},"list-style-position":{cssPropBits:0,cssLitGroup:[L[40]],cssFns:[]},"list-style-type":{cssPropBits:0,cssLitGroup:[L[2],L[57],L[71]],cssFns:[]},margin:"bottom","margin-bottom":"bottom","margin-left":"bottom","margin-right":"bottom","margin-top":"bottom","max-height":{cssPropBits:1,cssLitGroup:[L[52],L[71]],cssFns:[]},"max-width":"max-height","min-height":{cssPropBits:1,cssLitGroup:[L[52]],cssFns:[]},"min-width":"min-height",opacity:{cssPropBits:1,cssFns:[]},outline:{cssPropBits:7,cssLitGroup:[L[0],L[9],L[47],L[62],L[64],L[65],L[69],L[71]],cssFns:["rgb()","rgba()"]},"outline-color":{cssPropBits:2,cssLitGroup:[L[0],L[65]],cssFns:["rgb()","rgba()"]},"outline-style":"border-bottom-style","outline-width":"border-bottom-width",overflow:{cssPropBits:0,cssLitGroup:[L[52],L[62],L[75],L[80]],cssFns:[]},"overflow-wrap":{cssPropBits:0,cssLitGroup:[L[55],L[72]],cssFns:[]},"overflow-x":{cssPropBits:0,cssLitGroup:[L[44],L[52],L[62],L[75],L[80]],cssFns:[]},"overflow-y":"overflow-x",padding:"opacity","padding-bottom":"opacity","padding-left":"opacity","padding-right":"opacity","padding-top":"opacity","page-break-after":{cssPropBits:0,cssLitGroup:[L[42],L[51],L[52],L[53]],cssFns:[]},"page-break-before":"page-break-after","page-break-inside":{cssPropBits:0,cssLitGroup:[L[52],L[53]],cssFns:[]},pause:"border-bottom-left-radius","pause-after":"border-bottom-left-radius","pause-before":"border-bottom-left-radius",perspective:{cssPropBits:5,cssLitGroup:[L[71]],cssFns:[]},"perspective-origin":{cssPropBits:5,cssLitGroup:[L[31],L[42],L[56]],cssFns:[]},pitch:{cssPropBits:5,cssLitGroup:[L[21],L[69]],cssFns:[]},"pitch-range":"border-bottom-left-radius","play-during":{cssPropBits:16,cssLitGroup:[L[52],L[70],L[71],L[74]],cssFns:[]},position:{cssPropBits:0,cssLitGroup:[L[23]],cssFns:[]},quotes:{cssPropBits:8,cssLitGroup:[L[71]],cssFns:[]},resize:{cssPropBits:0,cssLitGroup:[L[39],L[54],L[71]],cssFns:[]},richness:"border-bottom-left-radius",right:"bottom",speak:{cssPropBits:0,cssLitGroup:[L[71],L[72],L[78]],cssFns:[]},"speak-header":{cssPropBits:0,cssLitGroup:[L[51],L[73]],cssFns:[]},"speak-numeral":{cssPropBits:0,cssLitGroup:[L[35]],cssFns:[]},"speak-punctuation":{cssPropBits:0,cssLitGroup:[L[58],L[71]],cssFns:[]},"speech-rate":{cssPropBits:5,cssLitGroup:[L[14],L[69]],cssFns:[]},stress:"border-bottom-left-radius","table-layout":{cssPropBits:0,cssLitGroup:[L[52],L[61]],cssFns:[]},"text-align":{cssPropBits:0,cssLitGroup:[L[42],L[56],L[66]],cssFns:[]},"text-decoration":{cssPropBits:0,cssLitGroup:[L[19],L[71]],cssFns:[]},"text-indent":"border-bottom-left-radius","text-overflow":{cssPropBits:8,cssLitGroup:[L[33]],cssFns:[]},"text-shadow":"box-shadow","text-transform":{cssPropBits:0,cssLitGroup:[L[26],L[71]],cssFns:[]},"text-wrap":{cssPropBits:0,cssLitGroup:[L[46],L[71],L[72]],cssFns:[]},top:"bottom",transform:{cssPropBits:0,cssLitGroup:[L[71]],cssFns:["matrix()","perspective()","rotate()","rotate3d()","rotatex()","rotatey()","rotatez()","scale()","scale3d()","scalex()","scaley()","scalez()","skew()","skewx()","skewy()","translate()","translate3d()","translatex()","translatey()","translatez()"]},"transform-origin":"perspective-origin","transform-style":{cssPropBits:0,cssLitGroup:[L[37]],cssFns:[]},transition:{cssPropBits:1029,cssLitGroup:[L[10],L[48],L[50],L[71]],cssFns:["cubic-bezier()","steps()"]},"transition-delay":"animation-delay","transition-duration":"animation-delay","transition-property":{cssPropBits:1024,cssLitGroup:[L[48],L[50]],cssFns:[]},"transition-timing-function":"animation-timing-function","unicode-bidi":{cssPropBits:0,cssLitGroup:[L[30],L[72]],cssFns:[]},"vertical-align":{cssPropBits:5,cssLitGroup:[L[12],L[31]],cssFns:[]},visibility:"backface-visibility","voice-family":{cssPropBits:8,cssLitGroup:[L[27],L[48]],cssFns:[]},volume:{cssPropBits:1,cssLitGroup:[L[17],L[69]],cssFns:[]},"white-space":{cssPropBits:0,cssLitGroup:[L[22],L[72]],cssFns:[]},width:"min-height","word-break":{cssPropBits:0,cssLitGroup:[L[32],L[72]],cssFns:[]},"word-spacing":"letter-spacing","word-wrap":"overflow-wrap","z-index":"bottom",zoom:"line-height","cubic-bezier()":"animation-delay","steps()":{cssPropBits:5,cssLitGroup:[L[36],L[48]],cssFns:[]},"image()":{cssPropBits:18,cssLitGroup:[L[0],L[48]],cssFns:["rgb()","rgba()"]},"linear-gradient()":{cssPropBits:7,cssLitGroup:[L[0],L[31],L[42],L[48],L[79]],cssFns:["rgb()","rgba()"]},"radial-gradient()":{cssPropBits:7,cssLitGroup:[L[0],L[11],L[31],L[42],L[48],L[56],L[57]],cssFns:["rgb()","rgba()"]},"repeating-linear-gradient()":"linear-gradient()","repeating-radial-gradient()":"radial-gradient()","rgb()":{cssPropBits:1,cssLitGroup:[L[48]],cssFns:[]},"rgba()":"rgb()","rect()":{cssPropBits:5,cssLitGroup:[L[48],L[52]],cssFns:[]},"alpha()":{cssPropBits:1,cssLitGroup:[L[28]],cssFns:[]},"matrix()":"animation-delay","perspective()":"border-bottom-left-radius","rotate()":"border-bottom-left-radius","rotate3d()":"animation-delay","rotatex()":"border-bottom-left-radius","rotatey()":"border-bottom-left-radius","rotatez()":"border-bottom-left-radius","scale()":"animation-delay","scale3d()":"animation-delay","scalex()":"border-bottom-left-radius","scaley()":"border-bottom-left-radius","scalez()":"border-bottom-left-radius","skew()":"animation-delay","skewx()":"border-bottom-left-radius","skewy()":"border-bottom-left-radius","translate()":"animation-delay","translate3d()":"animation-delay","translatex()":"border-bottom-left-radius","translatey()":"border-bottom-left-radius","translatez()":"border-bottom-left-radius"};if(true){for(var key in schema){if("string"===typeof schema[key]&&Object.hasOwnProperty.call(schema,key)){schema[key]=schema[schema[key]]}}}return schema}();if(typeof window!=="undefined"){window["cssSchema"]=cssSchema}var lexCss;var decodeCss;(function(){function decodeCssEscape(s){var i=parseInt(s.substring(1),16);if(i>65535){return i-=65536,String.fromCharCode(55296+(i>>10),56320+(i&1023))}else if(i==i){return String.fromCharCode(i)}else if(s[1]<" "){return""}else{return s[1]}}function escapeCssString(s,replacer){return'"'+s.replace(/[\u0000-\u001f\\\"<>]/g,replacer)+'"'}function escapeCssStrChar(ch){return cssStrChars[ch]||(cssStrChars[ch]="\\"+ch.charCodeAt(0).toString(16)+" ")}function escapeCssUrlChar(ch){return cssUrlChars[ch]||(cssUrlChars[ch]=(ch<""?"%0":"%")+ch.charCodeAt(0).toString(16))}var cssStrChars={"\\":"\\\\"};var cssUrlChars={"\\":"%5c"};var WC="[\\t\\n\\f ]";var W=WC+"*";var NL="[\\n\\f]";var SURROGATE_PAIR="[\\ud800-\\udbff][\\udc00-\\udfff]";var NONASCII="[\\u0080-\\ud7ff\\ue000-\\ufffd]|"+SURROGATE_PAIR;var UNICODE_TAIL="[0-9a-fA-F]{1,6}"+WC+"?";var UNICODE="\\\\"+UNICODE_TAIL;var ESCAPE_TAIL="(?:"+UNICODE_TAIL+"|[\\u0020-\\u007e\\u0080-\\ud7ff\\ue000\\ufffd]|"+SURROGATE_PAIR+")";var ESCAPE="\\\\"+ESCAPE_TAIL;var URLCHAR="(?:[\\t\\x21\\x23-\\x26\\x28-\\x5b\\x5d-\\x7e]|"+NONASCII+"|"+ESCAPE+")";var STRINGCHAR="[^'\"\\n\\f\\\\]|\\\\[\\s\\S]";var STRING="\"(?:'|"+STRINGCHAR+')*"'+"|'(?:\"|"+STRINGCHAR+")*'";var NUM="[-+]?(?:[0-9]+(?:[.][0-9]+)?|[.][0-9]+)";var NMSTART="(?:[a-zA-Z_]|"+NONASCII+"|"+ESCAPE+")";var NMCHAR="(?:[a-zA-Z0-9_-]|"+NONASCII+"|"+ESCAPE+")";var NAME=NMCHAR+"+";var IDENT="-?"+NMSTART+NMCHAR+"*";var ATKEYWORD="@"+IDENT;var HASH="#"+NAME;var NUMBER=NUM;var WORD_TERM="(?:@?-?"+NMSTART+"|#)"+NMCHAR+"*";var PERCENTAGE=NUM+"%";var DIMENSION=NUM+IDENT;var NUMERIC_VALUE=NUM+"(?:%|"+IDENT+")?";var URI="url[(]"+W+"(?:"+STRING+"|"+URLCHAR+"*)"+W+"[)]";var UNICODE_RANGE="U[+][0-9A-F?]{1,6}(?:-[0-9A-F]{1,6})?";var CDO="<!--";var CDC="-->";var S=WC+"+";var COMMENT="/(?:[*][^*]*[*]+(?:[^/][^*]*[*]+)*/|/[^\\n\\f]*)";var FUNCTION="(?!url[(])"+IDENT+"[(]";var INCLUDES="~=";var DASHMATCH="[|]=";var PREFIXMATCH="[^]=";var SUFFIXMATCH="[$]=";var SUBSTRINGMATCH="[*]=";var CMP_OPS="[~|^$*]=";var CHAR="[^\"'\\\\/]|/(?![/*])";var BOM="\\uFEFF";var CSS_TOKEN=new RegExp([BOM,UNICODE_RANGE,URI,FUNCTION,WORD_TERM,STRING,NUMERIC_VALUE,CDO,CDC,S,COMMENT,CMP_OPS,CHAR].join("|"),"gi");var CSS_DECODER=new RegExp("\\\\(?:"+ESCAPE_TAIL+"|"+NL+")","g");var URL_RE=new RegExp("^url\\("+W+"[\"']?|[\"']?"+W+"\\)$","gi");decodeCss=function(css){return css.replace(CSS_DECODER,decodeCssEscape)};lexCss=function(cssText){cssText=""+cssText;var tokens=cssText.replace(/\r\n?/g,"\n").match(CSS_TOKEN)||[];var j=0;var last=" ";for(var i=0,n=tokens.length;i<n;++i){var tok=decodeCss(tokens[i]);var len=tok.length;var cc=tok.charCodeAt(0);tok=cc=='"'.charCodeAt(0)||cc=="'".charCodeAt(0)?escapeCssString(tok.substring(1,len-1),escapeCssStrChar):cc=="/".charCodeAt(0)&&len>1||tok=="\\"||tok==CDC||tok==CDO||tok=="﻿"||cc<=" ".charCodeAt(0)?" ":/url\(/i.test(tok)?"url("+escapeCssString(tok.replace(URL_RE,""),escapeCssUrlChar)+")":tok;if(last!=tok||tok!=" "){tokens[j++]=last=tok}}tokens.length=j;return tokens}})();if(typeof window!=="undefined"){window["lexCss"]=lexCss;window["decodeCss"]=decodeCss}var URI=function(){function parse(uriStr){var m=(""+uriStr).match(URI_RE_);if(!m){return null}return new URI(nullIfAbsent(m[1]),nullIfAbsent(m[2]),nullIfAbsent(m[3]),nullIfAbsent(m[4]),nullIfAbsent(m[5]),nullIfAbsent(m[6]),nullIfAbsent(m[7]))}function create(scheme,credentials,domain,port,path,query,fragment){var uri=new URI(encodeIfExists2(scheme,URI_DISALLOWED_IN_SCHEME_OR_CREDENTIALS_),encodeIfExists2(credentials,URI_DISALLOWED_IN_SCHEME_OR_CREDENTIALS_),encodeIfExists(domain),port>0?port.toString():null,encodeIfExists2(path,URI_DISALLOWED_IN_PATH_),null,encodeIfExists(fragment));if(query){if("string"===typeof query){uri.setRawQuery(query.replace(/[^?&=0-9A-Za-z_\-~.%]/g,encodeOne))}else{uri.setAllParameters(query)}}return uri}function encodeIfExists(unescapedPart){if("string"==typeof unescapedPart){return encodeURIComponent(unescapedPart)}return null}function encodeIfExists2(unescapedPart,extra){if("string"==typeof unescapedPart){return encodeURI(unescapedPart).replace(extra,encodeOne)}return null}function encodeOne(ch){var n=ch.charCodeAt(0);return"%"+"0123456789ABCDEF".charAt(n>>4&15)+"0123456789ABCDEF".charAt(n&15)}function normPath(path){return path.replace(/(^|\/)\.(?:\/|$)/g,"$1").replace(/\/{2,}/g,"/")}var PARENT_DIRECTORY_HANDLER=new RegExp(""+"(/|^)"+"(?:[^./][^/]*|\\.{2,}(?:[^./][^/]*)|\\.{3,}[^/]*)"+"/\\.\\.(?:/|$)");var PARENT_DIRECTORY_HANDLER_RE=new RegExp(PARENT_DIRECTORY_HANDLER);var EXTRA_PARENT_PATHS_RE=/^(?:\.\.\/)*(?:\.\.$)?/;function collapse_dots(path){if(path===null){return null}var p=normPath(path);var r=PARENT_DIRECTORY_HANDLER_RE;for(var q;(q=p.replace(r,"$1"))!=p;p=q){}return p}function resolve(baseUri,relativeUri){var absoluteUri=baseUri.clone();var overridden=relativeUri.hasScheme();if(overridden){absoluteUri.setRawScheme(relativeUri.getRawScheme())}else{overridden=relativeUri.hasCredentials()}if(overridden){absoluteUri.setRawCredentials(relativeUri.getRawCredentials())}else{overridden=relativeUri.hasDomain()}if(overridden){absoluteUri.setRawDomain(relativeUri.getRawDomain())}else{overridden=relativeUri.hasPort()}var rawPath=relativeUri.getRawPath();var simplifiedPath=collapse_dots(rawPath);if(overridden){absoluteUri.setPort(relativeUri.getPort());simplifiedPath=simplifiedPath&&simplifiedPath.replace(EXTRA_PARENT_PATHS_RE,"")}else{overridden=!!rawPath;if(overridden){if(simplifiedPath.charCodeAt(0)!==47){var absRawPath=collapse_dots(absoluteUri.getRawPath()||"").replace(EXTRA_PARENT_PATHS_RE,"");var slash=absRawPath.lastIndexOf("/")+1;simplifiedPath=collapse_dots((slash?absRawPath.substring(0,slash):"")+collapse_dots(rawPath)).replace(EXTRA_PARENT_PATHS_RE,"")}}else{simplifiedPath=simplifiedPath&&simplifiedPath.replace(EXTRA_PARENT_PATHS_RE,"");if(simplifiedPath!==rawPath){absoluteUri.setRawPath(simplifiedPath)}}}if(overridden){absoluteUri.setRawPath(simplifiedPath)}else{overridden=relativeUri.hasQuery()}if(overridden){absoluteUri.setRawQuery(relativeUri.getRawQuery())}else{overridden=relativeUri.hasFragment()}if(overridden){absoluteUri.setRawFragment(relativeUri.getRawFragment())}return absoluteUri}function URI(rawScheme,rawCredentials,rawDomain,port,rawPath,rawQuery,rawFragment){this.scheme_=rawScheme;this.credentials_=rawCredentials;this.domain_=rawDomain;this.port_=port;this.path_=rawPath;this.query_=rawQuery;this.fragment_=rawFragment;this.paramCache_=null}URI.prototype.toString=function(){var out=[];if(null!==this.scheme_){out.push(this.scheme_,":")}if(null!==this.domain_){out.push("//");if(null!==this.credentials_){out.push(this.credentials_,"@")}out.push(this.domain_);if(null!==this.port_){out.push(":",this.port_.toString())}}if(null!==this.path_){out.push(this.path_)}if(null!==this.query_){out.push("?",this.query_)}if(null!==this.fragment_){out.push("#",this.fragment_)}return out.join("")};URI.prototype.clone=function(){return new URI(this.scheme_,this.credentials_,this.domain_,this.port_,this.path_,this.query_,this.fragment_)};URI.prototype.getScheme=function(){return this.scheme_&&decodeURIComponent(this.scheme_).toLowerCase()};URI.prototype.getRawScheme=function(){return this.scheme_};URI.prototype.setScheme=function(newScheme){this.scheme_=encodeIfExists2(newScheme,URI_DISALLOWED_IN_SCHEME_OR_CREDENTIALS_);return this};URI.prototype.setRawScheme=function(newScheme){this.scheme_=newScheme?newScheme:null;return this};URI.prototype.hasScheme=function(){return null!==this.scheme_};URI.prototype.getCredentials=function(){return this.credentials_&&decodeURIComponent(this.credentials_)};URI.prototype.getRawCredentials=function(){return this.credentials_};URI.prototype.setCredentials=function(newCredentials){this.credentials_=encodeIfExists2(newCredentials,URI_DISALLOWED_IN_SCHEME_OR_CREDENTIALS_);return this};URI.prototype.setRawCredentials=function(newCredentials){this.credentials_=newCredentials?newCredentials:null;return this};URI.prototype.hasCredentials=function(){return null!==this.credentials_};URI.prototype.getDomain=function(){return this.domain_&&decodeURIComponent(this.domain_)};URI.prototype.getRawDomain=function(){return this.domain_};URI.prototype.setDomain=function(newDomain){return this.setRawDomain(newDomain&&encodeURIComponent(newDomain))};URI.prototype.setRawDomain=function(newDomain){this.domain_=newDomain?newDomain:null;return this.setRawPath(this.path_)};URI.prototype.hasDomain=function(){return null!==this.domain_};URI.prototype.getPort=function(){return this.port_&&decodeURIComponent(this.port_)};URI.prototype.setPort=function(newPort){if(newPort){newPort=Number(newPort);if(newPort!==(newPort&65535)){throw new Error("Bad port number "+newPort)}this.port_=""+newPort}else{this.port_=null}return this};URI.prototype.hasPort=function(){return null!==this.port_};URI.prototype.getPath=function(){return this.path_&&decodeURIComponent(this.path_)};URI.prototype.getRawPath=function(){return this.path_};URI.prototype.setPath=function(newPath){return this.setRawPath(encodeIfExists2(newPath,URI_DISALLOWED_IN_PATH_))};URI.prototype.setRawPath=function(newPath){if(newPath){newPath=String(newPath);this.path_=!this.domain_||/^\//.test(newPath)?newPath:"/"+newPath}else{this.path_=null}return this};URI.prototype.hasPath=function(){return null!==this.path_};URI.prototype.getQuery=function(){return this.query_&&decodeURIComponent(this.query_).replace(/\+/g," ")};URI.prototype.getRawQuery=function(){return this.query_};URI.prototype.setQuery=function(newQuery){this.paramCache_=null;this.query_=encodeIfExists(newQuery);return this};URI.prototype.setRawQuery=function(newQuery){this.paramCache_=null;this.query_=newQuery?newQuery:null;return this};URI.prototype.hasQuery=function(){return null!==this.query_};URI.prototype.setAllParameters=function(params){if(typeof params==="object"){if(!(params instanceof Array)&&(params instanceof Object||Object.prototype.toString.call(params)!=="[object Array]")){var newParams=[];var i=-1;for(var k in params){var v=params[k];if("string"===typeof v){newParams[++i]=k;newParams[++i]=v}}params=newParams}}this.paramCache_=null;var queryBuf=[];var separator="";for(var j=0;j<params.length;){var k=params[j++];var v=params[j++];queryBuf.push(separator,encodeURIComponent(k.toString()));separator="&";if(v){queryBuf.push("=",encodeURIComponent(v.toString()))}}this.query_=queryBuf.join("");return this};URI.prototype.checkParameterCache_=function(){if(!this.paramCache_){var q=this.query_;if(!q){this.paramCache_=[]}else{var cgiParams=q.split(/[&\?]/);var out=[];var k=-1;for(var i=0;i<cgiParams.length;++i){var m=cgiParams[i].match(/^([^=]*)(?:=(.*))?$/);out[++k]=decodeURIComponent(m[1]).replace(/\+/g," ");out[++k]=decodeURIComponent(m[2]||"").replace(/\+/g," ")}this.paramCache_=out}}};URI.prototype.setParameterValues=function(key,values){if(typeof values==="string"){values=[values]}this.checkParameterCache_();var newValueIndex=0;var pc=this.paramCache_;var params=[];for(var i=0,k=0;i<pc.length;i+=2){if(key===pc[i]){if(newValueIndex<values.length){params.push(key,values[newValueIndex++])}}else{params.push(pc[i],pc[i+1])}}while(newValueIndex<values.length){params.push(key,values[newValueIndex++])}this.setAllParameters(params);return this};URI.prototype.removeParameter=function(key){return this.setParameterValues(key,[])};URI.prototype.getAllParameters=function(){this.checkParameterCache_();return this.paramCache_.slice(0,this.paramCache_.length)};URI.prototype.getParameterValues=function(paramNameUnescaped){this.checkParameterCache_();var values=[];for(var i=0;i<this.paramCache_.length;i+=2){if(paramNameUnescaped===this.paramCache_[i]){values.push(this.paramCache_[i+1])}}return values};URI.prototype.getParameterMap=function(paramNameUnescaped){this.checkParameterCache_();var paramMap={};for(var i=0;i<this.paramCache_.length;i+=2){var key=this.paramCache_[i++],value=this.paramCache_[i++];if(!(key in paramMap)){paramMap[key]=[value]}else{paramMap[key].push(value)}}return paramMap};URI.prototype.getParameterValue=function(paramNameUnescaped){this.checkParameterCache_();for(var i=0;i<this.paramCache_.length;i+=2){if(paramNameUnescaped===this.paramCache_[i]){return this.paramCache_[i+1]}}return null};URI.prototype.getFragment=function(){return this.fragment_&&decodeURIComponent(this.fragment_)};URI.prototype.getRawFragment=function(){return this.fragment_};URI.prototype.setFragment=function(newFragment){this.fragment_=newFragment?encodeURIComponent(newFragment):null;return this};URI.prototype.setRawFragment=function(newFragment){this.fragment_=newFragment?newFragment:null;return this};URI.prototype.hasFragment=function(){return null!==this.fragment_};function nullIfAbsent(matchPart){return"string"==typeof matchPart&&matchPart.length>0?matchPart:null}var URI_RE_=new RegExp("^"+"(?:"+"([^:/?#]+)"+":)?"+"(?://"+"(?:([^/?#]*)@)?"+"([^/?#:@]*)"+"(?::([0-9]+))?"+")?"+"([^?#]+)?"+"(?:\\?([^#]*))?"+"(?:#(.*))?"+"$");var URI_DISALLOWED_IN_SCHEME_OR_CREDENTIALS_=/[#\/\?@]/g;var URI_DISALLOWED_IN_PATH_=/[\#\?]/g;URI.parse=parse;URI.create=create;URI.resolve=resolve;URI.collapse_dots=collapse_dots;URI.utils={mimeTypeOf:function(uri){var uriObj=parse(uri);if(/\.html$/.test(uriObj.getPath())){return"text/html"}else{return"application/javascript"}},resolve:function(base,uri){if(base){return resolve(parse(base),parse(uri)).toString()}else{return""+uri}}};return URI}();if(typeof window!=="undefined"){window["URI"]=URI}var sanitizeCssProperty=undefined;var sanitizeCssSelectorList=undefined;var sanitizeStylesheet=undefined;var sanitizeStylesheetWithExternals=undefined;var sanitizeMediaQuery=undefined;(function(){var NOEFFECT_URL='url("about:blank")';var NORM_URL_REGEXP=/[\n\f\r\"\'()*<>]/g;var NORM_URL_REPLACEMENTS={"\n":"%0a","\f":"%0c","\r":"%0d",'"':"%22","'":"%27","(":"%28",")":"%29","*":"%2a","<":"%3c",">":"%3e"};function normalizeUrl(s){if("string"===typeof s){return'url("'+s.replace(NORM_URL_REGEXP,normalizeUrlChar)+'")'}else{return NOEFFECT_URL}}function normalizeUrlChar(ch){return NORM_URL_REPLACEMENTS[ch]}var URI_SCHEME_RE=new RegExp("^"+"(?:"+"([^:/?# ]+)"+":)?");var ALLOWED_URI_SCHEMES=/^(?:https?|mailto)$/i;function resolveUri(baseUri,uri){if(baseUri){return URI.utils.resolve(baseUri,uri)}return uri}function safeUri(uri,prop,naiveUriRewriter){if(!naiveUriRewriter){return null}var parsed=(""+uri).match(URI_SCHEME_RE);if(parsed&&(!parsed[1]||ALLOWED_URI_SCHEMES.test(parsed[1]))){return naiveUriRewriter(uri,prop)}else{return null}}function withoutVendorPrefix(ident){return ident.replace(/^-(?:apple|css|epub|khtml|moz|mso?|o|rim|wap|webkit|xv)-(?=[a-z])/,"")}sanitizeCssProperty=function(){function unionArrays(arrs){var map={};for(var i=arrs.length;--i>=0;){var arr=arrs[i];for(var j=arr.length;--j>=0;){map[arr[j]]=ALLOWED_LITERAL}}return map}var ALLOWED_LITERAL={};return function sanitize(property,tokens,opt_naiveUriRewriter,opt_baseUri,opt_idSuffix){var propertyKey=withoutVendorPrefix(property);var propertySchema=cssSchema[propertyKey];if(!propertySchema||"object"!==typeof propertySchema){tokens.length=0;return}var propBits=propertySchema["cssPropBits"];function sanitizeFunctionCall(tokens,start){var parenDepth=1,end=start+1,n=tokens.length;while(end<n&&parenDepth){var token=tokens[end++];parenDepth+=token===")"?-1:/^[^"']*\($/.test(token)}if(!parenDepth){var fnToken=tokens[start].toLowerCase();var bareFnToken=withoutVendorPrefix(fnToken);var fnTokens=tokens.splice(start,end-start,"");var fns=propertySchema["cssFns"];for(var i=0,nFns=fns.length;i<nFns;++i){if(fns[i].substring(0,bareFnToken.length)==bareFnToken){fnTokens[0]=fnTokens[fnTokens.length-1]="";sanitize(fns[i],fnTokens,opt_naiveUriRewriter,opt_baseUri);return fnToken+fnTokens.join(" ")+")"}}}return""}var stringDisposition=propBits&(CSS_PROP_BIT_URL|CSS_PROP_BIT_UNRESERVED_WORD);var identDisposition=propBits&(CSS_PROP_BIT_GLOBAL_NAME|CSS_PROP_BIT_PROPERTY_NAME);var lastQuoted=NaN;var i=0,k=0;for(;i<tokens.length;++i){var token=tokens[i].toLowerCase();var cc=token.charCodeAt(0),cc1,cc2,isnum1,isnum2,end;var litGroup,litMap;token=cc===" ".charCodeAt(0)?"":cc==='"'.charCodeAt(0)?stringDisposition===CSS_PROP_BIT_URL?opt_naiveUriRewriter?normalizeUrl(safeUri(resolveUri(opt_baseUri,decodeCss(tokens[i].substring(1,token.length-1))),propertyKey,opt_naiveUriRewriter)):"":propBits&CSS_PROP_BIT_QSTRING&&!(stringDisposition&stringDisposition-1)?token:"":token==="inherit"?token:(litGroup=propertySchema["cssLitGroup"],litMap=litGroup?propertySchema["cssLitMap"]||(propertySchema["cssLitMap"]=unionArrays(litGroup)):ALLOWED_LITERAL,litMap[withoutVendorPrefix(token)]===ALLOWED_LITERAL)?token:cc==="#".charCodeAt(0)&&/^#(?:[0-9a-f]{3}){1,2}$/.test(token)?propBits&CSS_PROP_BIT_HASH_VALUE?token:"":"0".charCodeAt(0)<=cc&&cc<="9".charCodeAt(0)?propBits&CSS_PROP_BIT_QUANTITY?token:"":(cc1=token.charCodeAt(1),cc2=token.charCodeAt(2),isnum1="0".charCodeAt(0)<=cc1&&cc1<="9".charCodeAt(0),isnum2="0".charCodeAt(0)<=cc2&&cc2<="9".charCodeAt(0),cc==="+".charCodeAt(0)&&(isnum1||cc1===".".charCodeAt(0)&&isnum2))?propBits&CSS_PROP_BIT_QUANTITY?(isnum1?"":"0")+token.substring(1):"":cc==="-".charCodeAt(0)&&(isnum1||cc1===".".charCodeAt(0)&&isnum2)?propBits&CSS_PROP_BIT_NEGATIVE_QUANTITY?(isnum1?"-":"-0")+token.substring(1):propBits&CSS_PROP_BIT_QUANTITY?"0":"":cc===".".charCodeAt(0)&&isnum1?propBits&CSS_PROP_BIT_QUANTITY?"0"+token:"":'url("'===token.substring(0,5)?opt_naiveUriRewriter&&propBits&CSS_PROP_BIT_URL?normalizeUrl(safeUri(resolveUri(opt_baseUri,tokens[i].substring(5,token.length-2)),propertyKey,opt_naiveUriRewriter)):"":token.charAt(token.length-1)==="("?sanitizeFunctionCall(tokens,i):identDisposition&&/^-?[a-z_][\w\-]*$/.test(token)&&!/__$/.test(token)?opt_idSuffix&&identDisposition===CSS_PROP_BIT_GLOBAL_NAME?tokens[i]+opt_idSuffix:identDisposition===CSS_PROP_BIT_PROPERTY_NAME&&cssSchema[token]&&"number"===typeof cssSchema[token].cssPropBits?token:"":/^\w+$/.test(token)&&stringDisposition===CSS_PROP_BIT_UNRESERVED_WORD&&propBits&CSS_PROP_BIT_QSTRING?lastQuoted+1===k?(tokens[lastQuoted]=tokens[lastQuoted].substring(0,tokens[lastQuoted].length-1)+" "+token+'"',token=""):(lastQuoted=k,'"'+token+'"'):"";
if(token){tokens[k++]=token}}if(k===1&&tokens[0]===NOEFFECT_URL){k=0}tokens.length=k}}();var PSEUDO_SELECTOR_WHITELIST=new RegExp("^(active|after|before|blank|checked|default|disabled"+"|drop|empty|enabled|first|first-child|first-letter"+"|first-line|first-of-type|fullscreen|focus|hover"+"|in-range|indeterminate|invalid|last-child|last-of-type"+"|left|link|only-child|only-of-type|optional|out-of-range"+"|placeholder-shown|read-only|read-write|required|right"+"|root|scope|user-error|valid|visited"+")$");var COMBINATOR={};COMBINATOR[">"]=COMBINATOR["+"]=COMBINATOR["~"]=COMBINATOR;sanitizeCssSelectorList=function(selectors,virtualization,opt_onUntranslatableSelector){var containerClass=virtualization.containerClass;var idSuffix=virtualization.idSuffix;var tagPolicy=virtualization.tagPolicy;var sanitized=[];var k=0,i,inBrackets=0,tok;for(i=0;i<selectors.length;++i){tok=selectors[i];if(tok=="("||tok=="["?(++inBrackets,true):tok==")"||tok=="]"?(inBrackets&&--inBrackets,true):!(selectors[i]==" "&&(inBrackets||COMBINATOR[selectors[i-1]]===COMBINATOR||COMBINATOR[selectors[i+1]]===COMBINATOR))){selectors[k++]=selectors[i]}}selectors.length=k;var n=selectors.length,start=0;for(i=0;i<n;++i){if(selectors[i]===","){if(!processComplexSelector(start,i)){return null}start=i+1}}if(!processComplexSelector(start,n)){return null}function processComplexSelector(start,end){if(selectors[start]===" "){++start}if(end-1!==start&&selectors[end]===" "){--end}var out=[];var lastOperator=start;var valid=true;for(var i=start;valid&&i<end;++i){var tok=selectors[i];if(COMBINATOR[tok]===COMBINATOR||tok===" "){if(!processCompoundSelector(lastOperator,i,tok)){valid=false}else{lastOperator=i+1}}}if(!processCompoundSelector(lastOperator,end,"")){valid=false}function processCompoundSelector(start,end,combinator){var element,classId,attrs,pseudoSelector,tok,valid=true;element="";if(start<end){tok=selectors[start];if(tok==="*"){++start;element=tok}else if(/^[a-zA-Z]/.test(tok)){var decision=tagPolicy(tok.toLowerCase(),[]);if(decision){if("tagName"in decision){tok=decision["tagName"]}++start;element=tok}}}classId="";attrs="";pseudoSelector="";for(;valid&&start<end;++start){tok=selectors[start];if(tok.charAt(0)==="#"){if(/^#_|__$|[^\w#:\-]/.test(tok)){valid=false}else{classId+=tok+idSuffix}}else if(tok==="."){if(++start<end&&/^[0-9A-Za-z:_\-]+$/.test(tok=selectors[start])&&!/^_|__$/.test(tok)){classId+="."+tok}else{valid=false}}else if(start+1<end&&selectors[start]==="["){++start;var vAttr=selectors[start++].toLowerCase();var atype=html4.ATTRIBS[element+"::"+vAttr];if(atype!==+atype){atype=html4.ATTRIBS["*::"+vAttr]}var rAttr;if(virtualization.virtualizeAttrName){rAttr=virtualization.virtualizeAttrName(element,vAttr);if(typeof rAttr!=="string"){valid=false;rAttr=vAttr}if(valid&&atype!==+atype){atype=html4.atype["NONE"]}}else{rAttr=vAttr;if(atype!==+atype){valid=false}}var op="",value="",ignoreCase=false;if(/^[~^$*|]?=$/.test(selectors[start])){op=selectors[start++];value=selectors[start++];if(/^[0-9A-Za-z:_\-]+$/.test(value)){value='"'+value+'"'}else if(value==="]"){value='""';--start}if(!/^"([^\"\\]|\\.)*"$/.test(value)){valid=false}ignoreCase=selectors[start]==="i";if(ignoreCase){++start}}if(selectors[start]!=="]"){++start;valid=false}switch(atype){case html4.atype["CLASSES"]:case html4.atype["LOCAL_NAME"]:case html4.atype["NONE"]:break;case html4.atype["GLOBAL_NAME"]:case html4.atype["ID"]:case html4.atype["IDREF"]:if((op==="="||op==="~="||op==="$=")&&value!='""'&&!ignoreCase){value='"'+value.substring(1,value.length-1)+idSuffix+'"'}else if(op==="|="||op===""){}else{valid=false}break;case html4.atype["URI"]:case html4.atype["URI_FRAGMENT"]:if(op!==""){valid=false}break;default:valid=false}if(valid){attrs+="["+rAttr.replace(/[^\w-]/g,"\\$&")+op+value+(ignoreCase?" i]":"]")}}else if(start<end&&selectors[start]===":"){tok=selectors[++start];if(PSEUDO_SELECTOR_WHITELIST.test(tok)){pseudoSelector+=":"+tok}else{break}}else{break}}if(start!==end){valid=false}if(valid){var selector=(element+classId).replace(/[^ .*#\w-]/g,"\\$&")+attrs+pseudoSelector+combinator;if(selector){out.push(selector)}}return valid}if(valid){if(out.length){var safeSelector=out.join("");if(containerClass!==null){safeSelector="."+containerClass+" "+safeSelector}sanitized.push(safeSelector)}return true}else{return!opt_onUntranslatableSelector||opt_onUntranslatableSelector(selectors.slice(start,end))}}return sanitized};(function(){var MEDIA_TYPE="(?:"+"all|aural|braille|embossed|handheld|print"+"|projection|screen|speech|tty|tv"+")";var MEDIA_FEATURE="(?:"+"(?:min-|max-)?"+"(?:"+("(?:device-)?"+"(?:aspect-ratio|height|width)"+"|color(?:-index)?"+"|monochrome"+"|orientation"+"|resolution")+")"+"|grid"+"|hover"+"|luminosity"+"|pointer"+"|scan"+"|script"+")";var LENGTH_UNIT="(?:p[cxt]|[cem]m|in|dpi|dppx|dpcm|%)";var CSS_VALUE="-?(?:"+"[a-z]\\w+(?:-\\w+)*"+"|\\d+(?: / \\d+|(?:\\.\\d+)?"+LENGTH_UNIT+"?)"+")";var MEDIA_EXPR="\\( "+MEDIA_FEATURE+" (?:"+": "+CSS_VALUE+" )?\\)";var MEDIA_QUERY="(?:"+"(?:(?:(?:only|not) )?"+MEDIA_TYPE+"|"+MEDIA_EXPR+")"+"(?: and ?"+MEDIA_EXPR+")*"+")";var STARTS_WITH_KEYWORD_REGEXP=/^\w/;var MEDIA_QUERY_LIST_REGEXP=new RegExp("^"+MEDIA_QUERY+"(?: , "+MEDIA_QUERY+")*"+"$","i");sanitizeMediaQuery=function(cssTokens){cssTokens=cssTokens.slice();var nTokens=cssTokens.length,k=0;for(var i=0;i<nTokens;++i){var tok=cssTokens[i];if(tok!=" "){cssTokens[k++]=tok}}cssTokens.length=k;var css=cssTokens.join(" ");css=!css.length?"":!MEDIA_QUERY_LIST_REGEXP.test(css)?"not all":STARTS_WITH_KEYWORD_REGEXP.test(css)?css:"not all , "+css;return css}})();(function(){function cssParseUri(candidate){var string1=/^\s*["]([^"]*)["]\s*$/;var string2=/^\s*[']([^']*)[']\s*$/;var url1=/^\s*url\s*[(]["]([^"]*)["][)]\s*$/;var url2=/^\s*url\s*[(][']([^']*)['][)]\s*$/;var url3=/^\s*url\s*[(]([^)]*)[)]\s*$/;var match;if(match=string1.exec(candidate)){return match[1]}else if(match=string2.exec(candidate)){return match[1]}else if(match=url1.exec(candidate)){return match[1]}else if(match=url2.exec(candidate)){return match[1]}else if(match=url3.exec(candidate)){return match[1]}return null}function sanitizeStylesheetInternal(baseUri,cssText,virtualization,naiveUriRewriter,naiveUriFetcher,continuation,opt_importCount){var safeCss=void 0;var importCount=opt_importCount||[0];var blockStack=[];var elide=false;parseCssStylesheet(cssText,{startStylesheet:function(){safeCss=[]},endStylesheet:function(){},startAtrule:function(atIdent,headerArray){if(elide){atIdent=null}else if(atIdent==="@media"){safeCss.push("@media"," ",sanitizeMediaQuery(headerArray))}else if(atIdent==="@keyframes"||atIdent==="@-webkit-keyframes"){var animationId=headerArray[0];if(headerArray.length===1&&!/__$|[^\w\-]/.test(animationId)){safeCss.push(atIdent," ",animationId+virtualization.idSuffix);atIdent="@keyframes"}else{atIdent=null}}else{if(atIdent==="@import"&&headerArray.length>0){atIdent=null;if("function"===typeof continuation){var mediaQuery=sanitizeMediaQuery(headerArray.slice(1));if(mediaQuery!=="not all"){++importCount[0];var placeholder=[];safeCss.push(placeholder);var cssUrl=safeUri(resolveUri(baseUri,cssParseUri(headerArray[0])),function(result){var sanitized=sanitizeStylesheetInternal(cssUrl,result.html,virtualization,naiveUriRewriter,naiveUriFetcher,continuation,importCount);--importCount[0];var safeImportedCss=mediaQuery?{toString:function(){return"@media "+mediaQuery+" {"+sanitized.result+"}"}}:sanitized.result;placeholder[0]=safeImportedCss;continuation(safeImportedCss,!!importCount[0])},naiveUriFetcher)}}else{if(window.console){window.console.log("@import "+headerArray.join(" ")+" elided")}}}}elide=!atIdent;blockStack.push(atIdent)},endAtrule:function(){blockStack.pop();if(!elide){safeCss.push(";")}checkElide()},startBlock:function(){if(!elide){safeCss.push("{")}},endBlock:function(){if(!elide){safeCss.push("}");elide=true}},startRuleset:function(selectorArray){if(!elide){var selector=void 0;if(blockStack[blockStack.length-1]==="@keyframes"){selector=selectorArray.join(" ").match(/^ *(?:from|to|\d+(?:\.\d+)?%) *(?:, *(?:from|to|\d+(?:\.\d+)?%) *)*$/i);elide=!selector;if(selector){selector=selector[0].replace(/ +/g,"")}}else{var selectors=sanitizeCssSelectorList(selectorArray,virtualization);if(!selectors||!selectors.length){elide=true}else{selector=selectors.join(", ")}}if(!elide){safeCss.push(selector,"{")}}blockStack.push(null)},endRuleset:function(){blockStack.pop();if(!elide){safeCss.push("}")}checkElide()},declaration:function(property,valueArray){if(!elide){var isImportant=false;var nValues=valueArray.length;if(nValues>=2&&valueArray[nValues-2]==="!"&&valueArray[nValues-1].toLowerCase()==="important"){isImportant=true;valueArray.length-=2}sanitizeCssProperty(property,valueArray,naiveUriRewriter,baseUri,virtualization.idSuffix);if(valueArray.length){safeCss.push(property,":",valueArray.join(" "),isImportant?" !important;":";")}}}});function checkElide(){elide=blockStack.length&&blockStack[blockStack.length-1]===null}return{result:{toString:function(){return safeCss.join("")}},moreToCome:!!importCount[0]}}sanitizeStylesheet=function(baseUri,cssText,virtualization,naiveUriRewriter){return sanitizeStylesheetInternal(baseUri,cssText,virtualization,naiveUriRewriter,undefined,undefined).result.toString()};sanitizeStylesheetWithExternals=function(baseUri,cssText,virtualization,naiveUriRewriter,naiveUriFetcher,continuation){return sanitizeStylesheetInternal(baseUri,cssText,virtualization,naiveUriRewriter,naiveUriFetcher,continuation)}})()})();if(typeof window!=="undefined"){window["sanitizeCssProperty"]=sanitizeCssProperty;window["sanitizeCssSelectorList"]=sanitizeCssSelectorList;window["sanitizeStylesheet"]=sanitizeStylesheet;window["sanitizeMediaQuery"]=sanitizeMediaQuery}if("I".toLowerCase()!=="i"){throw"I/i problem"}var parseCssStylesheet;var parseCssDeclarations;(function(){parseCssStylesheet=function(cssText,handler){var toks=lexCss(cssText);if(handler["startStylesheet"]){handler["startStylesheet"]()}for(var i=0,n=toks.length;i<n;){i=toks[i]===" "?i+1:statement(toks,i,n,handler)}if(handler["endStylesheet"]){handler["endStylesheet"]()}};function statement(toks,i,n,handler){if(i<n){var tok=toks[i];if(tok.charAt(0)==="@"){return atrule(toks,i,n,handler,true)}else{return ruleset(toks,i,n,handler)}}else{return i}}function atrule(toks,i,n,handler,blockok){var start=i++;while(i<n&&toks[i]!=="{"&&toks[i]!==";"){++i}if(i<n&&(blockok||toks[i]===";")){var s=start+1,e=i;if(s<n&&toks[s]===" "){++s}if(e>s&&toks[e-1]===" "){--e}if(handler["startAtrule"]){handler["startAtrule"](toks[start].toLowerCase(),toks.slice(s,e))}i=toks[i]==="{"?block(toks,i,n,handler):i+1;if(handler["endAtrule"]){handler["endAtrule"]()}}return i}function block(toks,i,n,handler){++i;if(handler["startBlock"]){handler["startBlock"]()}while(i<n){var ch=toks[i].charAt(0);if(ch=="}"){++i;break}if(ch===" "||ch===";"){i=i+1}else if(ch==="@"){i=atrule(toks,i,n,handler,false)}else if(ch==="{"){i=block(toks,i,n,handler)}else{i=ruleset(toks,i,n,handler)}}if(handler["endBlock"]){handler["endBlock"]()}return i}function ruleset(toks,i,n,handler){var s=i,e=selector(toks,i,n,true);if(e<0){e=~e;return e===s?e+1:e}var tok=toks[e];if(tok!=="{"){return e===s?e+1:e}i=e+1;if(e>s&&toks[e-1]===" "){--e}if(handler["startRuleset"]){handler["startRuleset"](toks.slice(s,e))}while(i<n){tok=toks[i];if(tok==="}"){++i;break}if(tok===" "){i=i+1}else{i=declaration(toks,i,n,handler)}}if(handler["endRuleset"]){handler["endRuleset"]()}return i}function selector(toks,i,n,allowSemi){var s=i;var tok;var brackets=[],stackLast=-1;for(;i<n;++i){tok=toks[i].charAt(0);if(tok==="["||tok==="("){brackets[++stackLast]=tok}else if(tok==="]"&&brackets[stackLast]==="["||tok===")"&&brackets[stackLast]==="("){--stackLast}else if(tok==="{"||tok==="}"||tok===";"||tok==="@"||tok===":"&&!allowSemi){break}}if(stackLast>=0){i=~(i+1)}return i}var ident=/^-?[a-z]/i;function skipDeclaration(toks,i,n){while(i<n&&toks[i]!==";"&&toks[i]!=="}"){++i}return i<n&&toks[i]===";"?i+1:i}function declaration(toks,i,n,handler){var property=toks[i++];if(!ident.test(property)){return skipDeclaration(toks,i,n)}var tok;if(i<n&&toks[i]===" "){++i}if(i==n||toks[i]!==":"){return skipDeclaration(toks,i,n)}++i;if(i<n&&toks[i]===" "){++i}var s=i,e=selector(toks,i,n,false);if(e<0){e=~e}else{var value=[],valuelen=0;for(var j=s;j<e;++j){tok=toks[j];if(tok!==" "){value[valuelen++]=tok}}if(e<n){do{tok=toks[e];if(tok===";"||tok==="}"){break}valuelen=0}while(++e<n);if(tok===";"){++e}}if(valuelen&&handler["declaration"]){handler["declaration"](property.toLowerCase(),value)}}return e}parseCssDeclarations=function(cssText,handler){var toks=lexCss(cssText);for(var i=0,n=toks.length;i<n;){i=toks[i]!==" "?declaration(toks,i,n,handler):i+1}}})();if(typeof window!=="undefined"){window["parseCssStylesheet"]=parseCssStylesheet;window["parseCssDeclarations"]=parseCssDeclarations}var html4={};html4.atype={NONE:0,URI:1,URI_FRAGMENT:11,SCRIPT:2,STYLE:3,HTML:12,ID:4,IDREF:5,IDREFS:6,GLOBAL_NAME:7,LOCAL_NAME:8,CLASSES:9,FRAME_TARGET:10,MEDIA_QUERY:13};html4["atype"]=html4.atype;html4.ATTRIBS={"*::class":9,"*::dir":0,"*::draggable":0,"*::hidden":0,"*::id":4,"*::inert":0,"*::itemprop":0,"*::itemref":6,"*::itemscope":0,"*::lang":0,"*::onblur":2,"*::onchange":2,"*::onclick":2,"*::ondblclick":2,"*::onerror":2,"*::onfocus":2,"*::onkeydown":2,"*::onkeypress":2,"*::onkeyup":2,"*::onload":2,"*::onmousedown":2,"*::onmousemove":2,"*::onmouseout":2,"*::onmouseover":2,"*::onmouseup":2,"*::onreset":2,"*::onscroll":2,"*::onselect":2,"*::onsubmit":2,"*::ontouchcancel":2,"*::ontouchend":2,"*::ontouchenter":2,"*::ontouchleave":2,"*::ontouchmove":2,"*::ontouchstart":2,"*::onunload":2,"*::spellcheck":0,"*::style":3,"*::title":0,"*::translate":0,"a::accesskey":0,"a::coords":0,"a::href":1,"a::hreflang":0,"a::name":7,"a::onblur":2,"a::onfocus":2,"a::shape":0,"a::tabindex":0,"a::target":10,"a::type":0,"area::accesskey":0,"area::alt":0,"area::coords":0,"area::href":1,"area::nohref":0,"area::onblur":2,"area::onfocus":2,"area::shape":0,"area::tabindex":0,"area::target":10,"audio::controls":0,"audio::loop":0,"audio::mediagroup":5,"audio::muted":0,"audio::preload":0,"audio::src":1,"bdo::dir":0,"blockquote::cite":1,"br::clear":0,"button::accesskey":0,"button::disabled":0,"button::name":8,"button::onblur":2,"button::onfocus":2,"button::tabindex":0,"button::type":0,"button::value":0,"canvas::height":0,"canvas::width":0,"caption::align":0,"col::align":0,"col::char":0,"col::charoff":0,"col::span":0,"col::valign":0,"col::width":0,"colgroup::align":0,"colgroup::char":0,"colgroup::charoff":0,"colgroup::span":0,"colgroup::valign":0,"colgroup::width":0,"command::checked":0,"command::command":5,"command::disabled":0,"command::icon":1,"command::label":0,"command::radiogroup":0,"command::type":0,"data::value":0,"del::cite":1,"del::datetime":0,"details::open":0,"dir::compact":0,"div::align":0,"dl::compact":0,"fieldset::disabled":0,"font::color":0,"font::face":0,"font::size":0,"form::accept":0,"form::action":1,"form::autocomplete":0,"form::enctype":0,"form::method":0,"form::name":7,"form::novalidate":0,"form::onreset":2,"form::onsubmit":2,"form::target":10,"h1::align":0,"h2::align":0,"h3::align":0,"h4::align":0,"h5::align":0,"h6::align":0,"hr::align":0,"hr::noshade":0,"hr::size":0,"hr::width":0,"iframe::align":0,"iframe::frameborder":0,"iframe::height":0,"iframe::marginheight":0,"iframe::marginwidth":0,"iframe::width":0,"img::align":0,"img::alt":0,"img::border":0,"img::height":0,"img::hspace":0,"img::ismap":0,"img::name":7,"img::src":1,"img::usemap":11,"img::vspace":0,"img::width":0,"input::accept":0,"input::accesskey":0,"input::align":0,"input::alt":0,"input::autocomplete":0,"input::checked":0,"input::disabled":0,"input::inputmode":0,"input::ismap":0,"input::list":5,"input::max":0,"input::maxlength":0,"input::min":0,"input::multiple":0,"input::name":8,"input::onblur":2,"input::onchange":2,"input::onfocus":2,"input::onselect":2,"input::placeholder":0,"input::readonly":0,"input::required":0,"input::size":0,"input::src":1,"input::step":0,"input::tabindex":0,"input::type":0,"input::usemap":11,"input::value":0,"ins::cite":1,"ins::datetime":0,"label::accesskey":0,"label::for":5,"label::onblur":2,"label::onfocus":2,"legend::accesskey":0,"legend::align":0,"li::type":0,"li::value":0,"map::name":7,"menu::compact":0,"menu::label":0,"menu::type":0,"meter::high":0,"meter::low":0,"meter::max":0,"meter::min":0,"meter::value":0,"ol::compact":0,"ol::reversed":0,"ol::start":0,"ol::type":0,"optgroup::disabled":0,"optgroup::label":0,"option::disabled":0,"option::label":0,"option::selected":0,"option::value":0,"output::for":6,"output::name":8,"p::align":0,"pre::width":0,"progress::max":0,"progress::min":0,"progress::value":0,"q::cite":1,"select::autocomplete":0,"select::disabled":0,"select::multiple":0,"select::name":8,"select::onblur":2,"select::onchange":2,"select::onfocus":2,"select::required":0,"select::size":0,"select::tabindex":0,"source::type":0,"table::align":0,"table::bgcolor":0,"table::border":0,"table::cellpadding":0,"table::cellspacing":0,"table::frame":0,"table::rules":0,"table::summary":0,"table::width":0,"tbody::align":0,"tbody::char":0,"tbody::charoff":0,"tbody::valign":0,"td::abbr":0,"td::align":0,"td::axis":0,"td::bgcolor":0,"td::char":0,"td::charoff":0,"td::colspan":0,"td::headers":6,"td::height":0,"td::nowrap":0,"td::rowspan":0,"td::scope":0,"td::valign":0,"td::width":0,"textarea::accesskey":0,"textarea::autocomplete":0,"textarea::cols":0,"textarea::disabled":0,"textarea::inputmode":0,"textarea::name":8,"textarea::onblur":2,"textarea::onchange":2,"textarea::onfocus":2,"textarea::onselect":2,"textarea::placeholder":0,"textarea::readonly":0,"textarea::required":0,"textarea::rows":0,"textarea::tabindex":0,"textarea::wrap":0,"tfoot::align":0,"tfoot::char":0,"tfoot::charoff":0,"tfoot::valign":0,"th::abbr":0,"th::align":0,"th::axis":0,"th::bgcolor":0,"th::char":0,"th::charoff":0,"th::colspan":0,"th::headers":6,"th::height":0,"th::nowrap":0,"th::rowspan":0,"th::scope":0,"th::valign":0,"th::width":0,"thead::align":0,"thead::char":0,"thead::charoff":0,"thead::valign":0,"tr::align":0,"tr::bgcolor":0,"tr::char":0,"tr::charoff":0,"tr::valign":0,"track::default":0,"track::kind":0,"track::label":0,"track::srclang":0,"ul::compact":0,"ul::type":0,"video::controls":0,"video::height":0,"video::loop":0,"video::mediagroup":5,"video::muted":0,"video::poster":1,"video::preload":0,"video::src":1,"video::width":0};html4["ATTRIBS"]=html4.ATTRIBS;html4.eflags={OPTIONAL_ENDTAG:1,EMPTY:2,CDATA:4,RCDATA:8,UNSAFE:16,FOLDABLE:32,SCRIPT:64,STYLE:128,VIRTUALIZED:256};html4["eflags"]=html4.eflags;html4.ELEMENTS={a:0,abbr:0,acronym:0,address:0,applet:272,area:2,article:0,aside:0,audio:0,b:0,base:274,basefont:274,bdi:0,bdo:0,big:0,blockquote:0,body:305,br:2,button:0,canvas:0,caption:0,center:0,cite:0,code:0,col:2,colgroup:1,command:2,data:0,datalist:0,dd:1,del:0,details:0,dfn:0,dialog:272,dir:0,div:0,dl:0,dt:1,em:0,fieldset:0,figcaption:0,figure:0,font:0,footer:0,form:0,frame:274,frameset:272,h1:0,h2:0,h3:0,h4:0,h5:0,h6:0,head:305,header:0,hgroup:0,hr:2,html:305,i:0,iframe:4,img:2,input:2,ins:0,isindex:274,kbd:0,keygen:274,label:0,legend:0,li:1,link:274,map:0,mark:0,menu:0,meta:274,meter:0,nav:0,nobr:0,noembed:276,noframes:276,noscript:276,object:272,ol:0,optgroup:0,option:1,output:0,p:1,param:274,pre:0,progress:0,q:0,s:0,samp:0,script:84,section:0,select:0,small:0,source:2,span:0,strike:0,strong:0,style:148,sub:0,summary:0,sup:0,table:0,tbody:1,td:1,textarea:8,tfoot:1,th:1,thead:1,time:0,title:280,tr:1,track:2,tt:0,u:0,ul:0,"var":0,video:0,wbr:2};html4["ELEMENTS"]=html4.ELEMENTS;html4.ELEMENT_DOM_INTERFACES={a:"HTMLAnchorElement",abbr:"HTMLElement",acronym:"HTMLElement",address:"HTMLElement",applet:"HTMLAppletElement",area:"HTMLAreaElement",article:"HTMLElement",aside:"HTMLElement",audio:"HTMLAudioElement",b:"HTMLElement",base:"HTMLBaseElement",basefont:"HTMLBaseFontElement",bdi:"HTMLElement",bdo:"HTMLElement",big:"HTMLElement",blockquote:"HTMLQuoteElement",body:"HTMLBodyElement",br:"HTMLBRElement",button:"HTMLButtonElement",canvas:"HTMLCanvasElement",caption:"HTMLTableCaptionElement",center:"HTMLElement",cite:"HTMLElement",code:"HTMLElement",col:"HTMLTableColElement",colgroup:"HTMLTableColElement",command:"HTMLCommandElement",data:"HTMLElement",datalist:"HTMLDataListElement",dd:"HTMLElement",del:"HTMLModElement",details:"HTMLDetailsElement",dfn:"HTMLElement",dialog:"HTMLDialogElement",dir:"HTMLDirectoryElement",div:"HTMLDivElement",dl:"HTMLDListElement",dt:"HTMLElement",em:"HTMLElement",fieldset:"HTMLFieldSetElement",figcaption:"HTMLElement",figure:"HTMLElement",font:"HTMLFontElement",footer:"HTMLElement",form:"HTMLFormElement",frame:"HTMLFrameElement",frameset:"HTMLFrameSetElement",h1:"HTMLHeadingElement",h2:"HTMLHeadingElement",h3:"HTMLHeadingElement",h4:"HTMLHeadingElement",h5:"HTMLHeadingElement",h6:"HTMLHeadingElement",head:"HTMLHeadElement",header:"HTMLElement",hgroup:"HTMLElement",hr:"HTMLHRElement",html:"HTMLHtmlElement",i:"HTMLElement",iframe:"HTMLIFrameElement",img:"HTMLImageElement",input:"HTMLInputElement",ins:"HTMLModElement",isindex:"HTMLUnknownElement",kbd:"HTMLElement",keygen:"HTMLKeygenElement",label:"HTMLLabelElement",legend:"HTMLLegendElement",li:"HTMLLIElement",link:"HTMLLinkElement",map:"HTMLMapElement",mark:"HTMLElement",menu:"HTMLMenuElement",meta:"HTMLMetaElement",meter:"HTMLMeterElement",nav:"HTMLElement",nobr:"HTMLElement",noembed:"HTMLElement",noframes:"HTMLElement",noscript:"HTMLElement",object:"HTMLObjectElement",ol:"HTMLOListElement",optgroup:"HTMLOptGroupElement",option:"HTMLOptionElement",output:"HTMLOutputElement",p:"HTMLParagraphElement",param:"HTMLParamElement",pre:"HTMLPreElement",progress:"HTMLProgressElement",q:"HTMLQuoteElement",s:"HTMLElement",samp:"HTMLElement",script:"HTMLScriptElement",section:"HTMLElement",select:"HTMLSelectElement",small:"HTMLElement",source:"HTMLSourceElement",span:"HTMLSpanElement",strike:"HTMLElement",strong:"HTMLElement",style:"HTMLStyleElement",sub:"HTMLElement",summary:"HTMLElement",sup:"HTMLElement",table:"HTMLTableElement",tbody:"HTMLTableSectionElement",td:"HTMLTableDataCellElement",textarea:"HTMLTextAreaElement",tfoot:"HTMLTableSectionElement",th:"HTMLTableHeaderCellElement",thead:"HTMLTableSectionElement",time:"HTMLTimeElement",title:"HTMLTitleElement",tr:"HTMLTableRowElement",track:"HTMLTrackElement",tt:"HTMLElement",u:"HTMLElement",ul:"HTMLUListElement","var":"HTMLElement",video:"HTMLVideoElement",wbr:"HTMLElement"};html4["ELEMENT_DOM_INTERFACES"]=html4.ELEMENT_DOM_INTERFACES;html4.ueffects={NOT_LOADED:0,SAME_DOCUMENT:1,NEW_DOCUMENT:2};html4["ueffects"]=html4.ueffects;html4.URIEFFECTS={"a::href":2,"area::href":2,"audio::src":1,"blockquote::cite":0,"command::icon":1,"del::cite":0,"form::action":2,"img::src":1,"input::src":1,"ins::cite":0,"q::cite":0,"video::poster":1,"video::src":1};html4["URIEFFECTS"]=html4.URIEFFECTS;html4.ltypes={UNSANDBOXED:2,SANDBOXED:1,DATA:0};html4["ltypes"]=html4.ltypes;html4.LOADERTYPES={"a::href":2,"area::href":2,"audio::src":2,"blockquote::cite":2,"command::icon":1,"del::cite":2,"form::action":2,"img::src":1,"input::src":1,"ins::cite":2,"q::cite":2,"video::poster":1,"video::src":2};html4["LOADERTYPES"]=html4.LOADERTYPES;if(typeof window!=="undefined"){window["html4"]=html4}if("I".toLowerCase()!=="i"){throw"I/i problem"}var html=function(html4){var parseCssDeclarations,sanitizeCssProperty,cssSchema;if("undefined"!==typeof window){parseCssDeclarations=window["parseCssDeclarations"];sanitizeCssProperty=window["sanitizeCssProperty"];cssSchema=window["cssSchema"]}var ENTITIES={lt:"<",LT:"<",gt:">",GT:">",amp:"&",AMP:"&",quot:'"',apos:"'",nbsp:" "};var decimalEscapeRe=/^#(\d+)$/;var hexEscapeRe=/^#x([0-9A-Fa-f]+)$/;var safeEntityNameRe=/^[A-Za-z][A-za-z0-9]+$/;var entityLookupElement="undefined"!==typeof window&&window["document"]?window["document"].createElement("textarea"):null;function lookupEntity(name){if(ENTITIES.hasOwnProperty(name)){return ENTITIES[name]}var m=name.match(decimalEscapeRe);if(m){return String.fromCharCode(parseInt(m[1],10))}else if(!!(m=name.match(hexEscapeRe))){return String.fromCharCode(parseInt(m[1],16))}else if(entityLookupElement&&safeEntityNameRe.test(name)){entityLookupElement.innerHTML="&"+name+";";var text=entityLookupElement.textContent;ENTITIES[name]=text;return text}else{return"&"+name+";"}}function decodeOneEntity(_,name){return lookupEntity(name)}var nulRe=/\0/g;function stripNULs(s){return s.replace(nulRe,"")}var ENTITY_RE_1=/&(#[0-9]+|#[xX][0-9A-Fa-f]+|\w+);/g;var ENTITY_RE_2=/^(#[0-9]+|#[xX][0-9A-Fa-f]+|\w+);/;function unescapeEntities(s){return s.replace(ENTITY_RE_1,decodeOneEntity)}var ampRe=/&/g;var looseAmpRe=/&([^a-z#]|#(?:[^0-9x]|x(?:[^0-9a-f]|$)|$)|$)/gi;var ltRe=/[<]/g;var gtRe=/>/g;var quotRe=/\"/g;function escapeAttrib(s){return(""+s).replace(ampRe,"&amp;").replace(ltRe,"&lt;").replace(gtRe,"&gt;").replace(quotRe,"&#34;")}function normalizeRCData(rcdata){return rcdata.replace(looseAmpRe,"&amp;$1").replace(ltRe,"&lt;").replace(gtRe,"&gt;")}var ATTR_RE=new RegExp("^\\s*"+"([-.:\\w]+)"+"(?:"+("\\s*(=)\\s*"+"("+('(")[^"]*("|$)'+"|"+"(')[^']*('|$)"+"|"+"(?=[a-z][-\\w]*\\s*=)"+"|"+"[^\"'\\s]*")+")")+")?","i");var splitWillCapture="a,b".split(/(,)/).length===3;var EFLAGS_TEXT=html4.eflags["CDATA"]|html4.eflags["RCDATA"];function makeSaxParser(handler){var hcopy={cdata:handler.cdata||handler["cdata"],comment:handler.comment||handler["comment"],endDoc:handler.endDoc||handler["endDoc"],endTag:handler.endTag||handler["endTag"],pcdata:handler.pcdata||handler["pcdata"],rcdata:handler.rcdata||handler["rcdata"],startDoc:handler.startDoc||handler["startDoc"],startTag:handler.startTag||handler["startTag"]};return function(htmlText,param){return parse(htmlText,hcopy,param)}}var continuationMarker={};function parse(htmlText,handler,param){var m,p,tagName;var parts=htmlSplit(htmlText);var state={noMoreGT:false,noMoreEndComments:false};parseCPS(handler,parts,0,state,param)}function continuationMaker(h,parts,initial,state,param){return function(){parseCPS(h,parts,initial,state,param)}}function parseCPS(h,parts,initial,state,param){try{if(h.startDoc&&initial==0){h.startDoc(param)}var m,p,tagName;for(var pos=initial,end=parts.length;pos<end;){var current=parts[pos++];var next=parts[pos];switch(current){case"&":if(ENTITY_RE_2.test(next)){if(h.pcdata){h.pcdata("&"+next,param,continuationMarker,continuationMaker(h,parts,pos,state,param))}pos++}else{if(h.pcdata){h.pcdata("&amp;",param,continuationMarker,continuationMaker(h,parts,pos,state,param))}}break;case"</":if(m=/^([-\w:]+)[^\'\"]*/.exec(next)){if(m[0].length===next.length&&parts[pos+1]===">"){pos+=2;tagName=m[1].toLowerCase();if(h.endTag){h.endTag(tagName,param,continuationMarker,continuationMaker(h,parts,pos,state,param))}}else{pos=parseEndTag(parts,pos,h,param,continuationMarker,state)}}else{if(h.pcdata){h.pcdata("&lt;/",param,continuationMarker,continuationMaker(h,parts,pos,state,param))}}break;case"<":if(m=/^([-\w:]+)\s*\/?/.exec(next)){if(m[0].length===next.length&&parts[pos+1]===">"){pos+=2;tagName=m[1].toLowerCase();if(h.startTag){h.startTag(tagName,[],param,continuationMarker,continuationMaker(h,parts,pos,state,param))}var eflags=html4.ELEMENTS[tagName];if(eflags&EFLAGS_TEXT){var tag={name:tagName,next:pos,eflags:eflags};pos=parseText(parts,tag,h,param,continuationMarker,state)}}else{pos=parseStartTag(parts,pos,h,param,continuationMarker,state)}}else{if(h.pcdata){h.pcdata("&lt;",param,continuationMarker,continuationMaker(h,parts,pos,state,param))}}break;case"<!--":if(!state.noMoreEndComments){for(p=pos+1;p<end;p++){if(parts[p]===">"&&/--$/.test(parts[p-1])){break}}if(p<end){if(h.comment){var comment=parts.slice(pos,p).join("");h.comment(comment.substr(0,comment.length-2),param,continuationMarker,continuationMaker(h,parts,p+1,state,param))}pos=p+1}else{state.noMoreEndComments=true}}if(state.noMoreEndComments){if(h.pcdata){h.pcdata("&lt;!--",param,continuationMarker,continuationMaker(h,parts,pos,state,param))}}break;case"<!":if(!/^\w/.test(next)){if(h.pcdata){h.pcdata("&lt;!",param,continuationMarker,continuationMaker(h,parts,pos,state,param))}}else{if(!state.noMoreGT){for(p=pos+1;p<end;p++){if(parts[p]===">"){break}}if(p<end){pos=p+1}else{state.noMoreGT=true}}if(state.noMoreGT){if(h.pcdata){h.pcdata("&lt;!",param,continuationMarker,continuationMaker(h,parts,pos,state,param))}}}break;case"<?":if(!state.noMoreGT){for(p=pos+1;p<end;p++){if(parts[p]===">"){break}}if(p<end){pos=p+1}else{state.noMoreGT=true}}if(state.noMoreGT){if(h.pcdata){h.pcdata("&lt;?",param,continuationMarker,continuationMaker(h,parts,pos,state,param))}}break;case">":if(h.pcdata){h.pcdata("&gt;",param,continuationMarker,continuationMaker(h,parts,pos,state,param))}break;case"":break;default:if(h.pcdata){h.pcdata(current,param,continuationMarker,continuationMaker(h,parts,pos,state,param))}break}}if(h.endDoc){h.endDoc(param)}}catch(e){if(e!==continuationMarker){throw e}}}function htmlSplit(str){var re=/(<\/|<\!--|<[!?]|[&<>])/g;str+="";if(splitWillCapture){return str.split(re)}else{var parts=[];var lastPos=0;var m;while((m=re.exec(str))!==null){parts.push(str.substring(lastPos,m.index));parts.push(m[0]);lastPos=m.index+m[0].length}parts.push(str.substring(lastPos));return parts}}function parseEndTag(parts,pos,h,param,continuationMarker,state){var tag=parseTagAndAttrs(parts,pos);if(!tag){return parts.length}if(h.endTag){h.endTag(tag.name,param,continuationMarker,continuationMaker(h,parts,pos,state,param))}return tag.next}function parseStartTag(parts,pos,h,param,continuationMarker,state){var tag=parseTagAndAttrs(parts,pos);if(!tag){return parts.length}if(h.startTag){h.startTag(tag.name,tag.attrs,param,continuationMarker,continuationMaker(h,parts,tag.next,state,param))}if(tag.eflags&EFLAGS_TEXT){return parseText(parts,tag,h,param,continuationMarker,state)}else{return tag.next}}var endTagRe={};function parseText(parts,tag,h,param,continuationMarker,state){var end=parts.length;if(!endTagRe.hasOwnProperty(tag.name)){endTagRe[tag.name]=new RegExp("^"+tag.name+"(?:[\\s\\/]|$)","i")}var re=endTagRe[tag.name];var first=tag.next;var p=tag.next+1;for(;p<end;p++){if(parts[p-1]==="</"&&re.test(parts[p])){break}}if(p<end){p-=1}var buf=parts.slice(first,p).join("");if(tag.eflags&html4.eflags["CDATA"]){if(h.cdata){h.cdata(buf,param,continuationMarker,continuationMaker(h,parts,p,state,param))}}else if(tag.eflags&html4.eflags["RCDATA"]){if(h.rcdata){h.rcdata(normalizeRCData(buf),param,continuationMarker,continuationMaker(h,parts,p,state,param))}}else{throw new Error("bug")}return p}function parseTagAndAttrs(parts,pos){var m=/^([-\w:]+)/.exec(parts[pos]);var tag={};tag.name=m[1].toLowerCase();tag.eflags=html4.ELEMENTS[tag.name];var buf=parts[pos].substr(m[0].length);var p=pos+1;var end=parts.length;for(;p<end;p++){if(parts[p]===">"){break}buf+=parts[p]}if(end<=p){return void 0}var attrs=[];while(buf!==""){m=ATTR_RE.exec(buf);if(!m){buf=buf.replace(/^[\s\S][^a-z\s]*/,"")}else if(m[4]&&!m[5]||m[6]&&!m[7]){var quote=m[4]||m[6];var sawQuote=false;var abuf=[buf,parts[p++]];for(;p<end;p++){if(sawQuote){if(parts[p]===">"){break}}else if(0<=parts[p].indexOf(quote)){sawQuote=true}abuf.push(parts[p])}if(end<=p){break}buf=abuf.join("");continue}else{var aName=m[1].toLowerCase();var aValue=m[2]?decodeValue(m[3]):"";attrs.push(aName,aValue);buf=buf.substr(m[0].length)}}tag.attrs=attrs;tag.next=p+1;return tag}function decodeValue(v){var q=v.charCodeAt(0);if(q===34||q===39){v=v.substr(1,v.length-2)}return unescapeEntities(stripNULs(v))}function makeHtmlSanitizer(tagPolicy){var stack;var ignoring;var emit=function(text,out){if(!ignoring){out.push(text)}};return makeSaxParser({startDoc:function(_){stack=[];ignoring=false},startTag:function(tagNameOrig,attribs,out){if(ignoring){return}if(!html4.ELEMENTS.hasOwnProperty(tagNameOrig)){return}var eflagsOrig=html4.ELEMENTS[tagNameOrig];if(eflagsOrig&html4.eflags["FOLDABLE"]){return}var decision=tagPolicy(tagNameOrig,attribs);if(!decision){ignoring=!(eflagsOrig&html4.eflags["EMPTY"]);
return}else if(typeof decision!=="object"){throw new Error("tagPolicy did not return object (old API?)")}if("attribs"in decision){attribs=decision["attribs"]}else{throw new Error("tagPolicy gave no attribs")}var eflagsRep;var tagNameRep;if("tagName"in decision){tagNameRep=decision["tagName"];eflagsRep=html4.ELEMENTS[tagNameRep]}else{tagNameRep=tagNameOrig;eflagsRep=eflagsOrig}if(eflagsOrig&html4.eflags["OPTIONAL_ENDTAG"]){var onStack=stack[stack.length-1];if(onStack&&onStack.orig===tagNameOrig&&(onStack.rep!==tagNameRep||tagNameOrig!==tagNameRep)){out.push("</",onStack.rep,">")}}if(!(eflagsOrig&html4.eflags["EMPTY"])){stack.push({orig:tagNameOrig,rep:tagNameRep})}out.push("<",tagNameRep);for(var i=0,n=attribs.length;i<n;i+=2){var attribName=attribs[i],value=attribs[i+1];if(value!==null&&value!==void 0){out.push(" ",attribName,'="',escapeAttrib(value),'"')}}out.push(">");if(eflagsOrig&html4.eflags["EMPTY"]&&!(eflagsRep&html4.eflags["EMPTY"])){out.push("</",tagNameRep,">")}},endTag:function(tagName,out){if(ignoring){ignoring=false;return}if(!html4.ELEMENTS.hasOwnProperty(tagName)){return}var eflags=html4.ELEMENTS[tagName];if(!(eflags&(html4.eflags["EMPTY"]|html4.eflags["FOLDABLE"]))){var index;if(eflags&html4.eflags["OPTIONAL_ENDTAG"]){for(index=stack.length;--index>=0;){var stackElOrigTag=stack[index].orig;if(stackElOrigTag===tagName){break}if(!(html4.ELEMENTS[stackElOrigTag]&html4.eflags["OPTIONAL_ENDTAG"])){return}}}else{for(index=stack.length;--index>=0;){if(stack[index].orig===tagName){break}}}if(index<0){return}for(var i=stack.length;--i>index;){var stackElRepTag=stack[i].rep;if(!(html4.ELEMENTS[stackElRepTag]&html4.eflags["OPTIONAL_ENDTAG"])){out.push("</",stackElRepTag,">")}}if(index<stack.length){tagName=stack[index].rep}stack.length=index;out.push("</",tagName,">")}},pcdata:emit,rcdata:emit,cdata:emit,endDoc:function(out){for(;stack.length;stack.length--){out.push("</",stack[stack.length-1].rep,">")}}})}var ALLOWED_URI_SCHEMES=/^(?:https?|mailto)$/i;function safeUri(uri,effect,ltype,hints,naiveUriRewriter){if(!naiveUriRewriter){return null}try{var parsed=URI.parse(""+uri);if(parsed){if(!parsed.hasScheme()||ALLOWED_URI_SCHEMES.test(parsed.getScheme())){var safe=naiveUriRewriter(parsed,effect,ltype,hints);return safe?safe.toString():null}}}catch(e){return null}return null}function log(logger,tagName,attribName,oldValue,newValue){if(!attribName){logger(tagName+" removed",{change:"removed",tagName:tagName})}if(oldValue!==newValue){var changed="changed";if(oldValue&&!newValue){changed="removed"}else if(!oldValue&&newValue){changed="added"}logger(tagName+"."+attribName+" "+changed,{change:changed,tagName:tagName,attribName:attribName,oldValue:oldValue,newValue:newValue})}}function lookupAttribute(map,tagName,attribName){var attribKey;attribKey=tagName+"::"+attribName;if(map.hasOwnProperty(attribKey)){return map[attribKey]}attribKey="*::"+attribName;if(map.hasOwnProperty(attribKey)){return map[attribKey]}return void 0}function getAttributeType(tagName,attribName){return lookupAttribute(html4.ATTRIBS,tagName,attribName)}function getLoaderType(tagName,attribName){return lookupAttribute(html4.LOADERTYPES,tagName,attribName)}function getUriEffect(tagName,attribName){return lookupAttribute(html4.URIEFFECTS,tagName,attribName)}function sanitizeAttribs(tagName,attribs,opt_naiveUriRewriter,opt_nmTokenPolicy,opt_logger){for(var i=0;i<attribs.length;i+=2){var attribName=attribs[i];var value=attribs[i+1];var oldValue=value;var atype=null,attribKey;if((attribKey=tagName+"::"+attribName,html4.ATTRIBS.hasOwnProperty(attribKey))||(attribKey="*::"+attribName,html4.ATTRIBS.hasOwnProperty(attribKey))){atype=html4.ATTRIBS[attribKey]}if(atype!==null){switch(atype){case html4.atype["NONE"]:break;case html4.atype["SCRIPT"]:value=null;if(opt_logger){log(opt_logger,tagName,attribName,oldValue,value)}break;case html4.atype["STYLE"]:if("undefined"===typeof parseCssDeclarations){value=null;if(opt_logger){log(opt_logger,tagName,attribName,oldValue,value)}break}var sanitizedDeclarations=[];parseCssDeclarations(value,{declaration:function(property,tokens){var normProp=property.toLowerCase();sanitizeCssProperty(normProp,tokens,opt_naiveUriRewriter?function(url){return safeUri(url,html4.ueffects.SAME_DOCUMENT,html4.ltypes.SANDBOXED,{TYPE:"CSS",CSS_PROP:normProp},opt_naiveUriRewriter)}:null);if(tokens.length){sanitizedDeclarations.push(normProp+": "+tokens.join(" "))}}});value=sanitizedDeclarations.length>0?sanitizedDeclarations.join(" ; "):null;if(opt_logger){log(opt_logger,tagName,attribName,oldValue,value)}break;case html4.atype["ID"]:case html4.atype["IDREF"]:case html4.atype["IDREFS"]:case html4.atype["GLOBAL_NAME"]:case html4.atype["LOCAL_NAME"]:case html4.atype["CLASSES"]:value=opt_nmTokenPolicy?opt_nmTokenPolicy(value):value;if(opt_logger){log(opt_logger,tagName,attribName,oldValue,value)}break;case html4.atype["URI"]:value=safeUri(value,getUriEffect(tagName,attribName),getLoaderType(tagName,attribName),{TYPE:"MARKUP",XML_ATTR:attribName,XML_TAG:tagName},opt_naiveUriRewriter);if(opt_logger){log(opt_logger,tagName,attribName,oldValue,value)}break;case html4.atype["URI_FRAGMENT"]:if(value&&"#"===value.charAt(0)){value=value.substring(1);value=opt_nmTokenPolicy?opt_nmTokenPolicy(value):value;if(value!==null&&value!==void 0){value="#"+value}}else{value=null}if(opt_logger){log(opt_logger,tagName,attribName,oldValue,value)}break;default:value=null;if(opt_logger){log(opt_logger,tagName,attribName,oldValue,value)}break}}else{value=null;if(opt_logger){log(opt_logger,tagName,attribName,oldValue,value)}}attribs[i+1]=value}return attribs}function makeTagPolicy(opt_naiveUriRewriter,opt_nmTokenPolicy,opt_logger){return function(tagName,attribs){if(!(html4.ELEMENTS[tagName]&html4.eflags["UNSAFE"])){return{attribs:sanitizeAttribs(tagName,attribs,opt_naiveUriRewriter,opt_nmTokenPolicy,opt_logger)}}else{if(opt_logger){log(opt_logger,tagName,undefined,undefined,undefined)}}}}function sanitizeWithPolicy(inputHtml,tagPolicy){var outputArray=[];makeHtmlSanitizer(tagPolicy)(inputHtml,outputArray);return outputArray.join("")}function sanitize(inputHtml,opt_naiveUriRewriter,opt_nmTokenPolicy,opt_logger){var tagPolicy=makeTagPolicy(opt_naiveUriRewriter,opt_nmTokenPolicy,opt_logger);return sanitizeWithPolicy(inputHtml,tagPolicy)}var html={};html.escapeAttrib=html["escapeAttrib"]=escapeAttrib;html.makeHtmlSanitizer=html["makeHtmlSanitizer"]=makeHtmlSanitizer;html.makeSaxParser=html["makeSaxParser"]=makeSaxParser;html.makeTagPolicy=html["makeTagPolicy"]=makeTagPolicy;html.normalizeRCData=html["normalizeRCData"]=normalizeRCData;html.sanitize=html["sanitize"]=sanitize;html.sanitizeAttribs=html["sanitizeAttribs"]=sanitizeAttribs;html.sanitizeWithPolicy=html["sanitizeWithPolicy"]=sanitizeWithPolicy;html.unescapeEntities=html["unescapeEntities"]=unescapeEntities;return html}(html4);var html_sanitize=html["sanitize"];if(typeof window!=="undefined"){window["html"]=html;window["html_sanitize"]=html_sanitize}
},{}]},{},["/Users/jon/jupyter/notebook/notebook/static-src/auth/js/main.js"])
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvbWFya2VkL2xpYi9tYXJrZWQuanMiLCJub2RlX21vZHVsZXMvbW9tZW50L21vbWVudC5qcyIsIm5vdGVib29rL3N0YXRpYy1zcmMvYXV0aC9qcy9sb2dpbm1haW4uanMiLCJub3RlYm9vay9zdGF0aWMtc3JjL2F1dGgvanMvbG9naW53aWRnZXQuanMiLCJub3RlYm9vay9zdGF0aWMtc3JjL2F1dGgvanMvbG9nb3V0bWFpbi5qcyIsIm5vdGVib29rL3N0YXRpYy1zcmMvYXV0aC9qcy9tYWluLmpzIiwibm90ZWJvb2svc3RhdGljLXNyYy9iYXNlL2pzL2RpYWxvZy5qcyIsIm5vdGVib29rL3N0YXRpYy1zcmMvYmFzZS9qcy9ldmVudHMuanMiLCJub3RlYm9vay9zdGF0aWMtc3JjL2Jhc2UvanMva2V5Ym9hcmQuanMiLCJub3RlYm9vay9zdGF0aWMtc3JjL2Jhc2UvanMvbmFtZXNwYWNlLmpzIiwibm90ZWJvb2svc3RhdGljLXNyYy9iYXNlL2pzL25vdGlmaWNhdGlvbmFyZWEuanMiLCJub3RlYm9vay9zdGF0aWMtc3JjL2Jhc2UvanMvbm90aWZpY2F0aW9ud2lkZ2V0LmpzIiwibm90ZWJvb2svc3RhdGljLXNyYy9iYXNlL2pzL3BhZ2UuanMiLCJub3RlYm9vay9zdGF0aWMtc3JjL2Jhc2UvanMvc2VjdXJpdHkuanMiLCJub3RlYm9vay9zdGF0aWMtc3JjL2Jhc2UvanMvdXRpbHMuanMiLCJub3RlYm9vay9zdGF0aWMtc3JjL25vdGVib29rL2pzL2NlbGwuanMiLCJub3RlYm9vay9zdGF0aWMtc3JjL25vdGVib29rL2pzL2NlbGx0b29sYmFyLmpzIiwibm90ZWJvb2svc3RhdGljLXNyYy9ub3RlYm9vay9qcy9jZWxsdG9vbGJhcnByZXNldHMvZGVmYXVsdC5qcyIsIm5vdGVib29rL3N0YXRpYy1zcmMvbm90ZWJvb2svanMvY2VsbHRvb2xiYXJwcmVzZXRzL3Jhd2NlbGwuanMiLCJub3RlYm9vay9zdGF0aWMtc3JjL25vdGVib29rL2pzL2NlbGx0b29sYmFycHJlc2V0cy9zbGlkZXNob3cuanMiLCJub3RlYm9vay9zdGF0aWMtc3JjL25vdGVib29rL2pzL2NvZGVjZWxsLmpzIiwibm90ZWJvb2svc3RhdGljLXNyYy9ub3RlYm9vay9qcy9jb21tYW5kcGFsZXR0ZS5qcyIsIm5vdGVib29rL3N0YXRpYy1zcmMvbm90ZWJvb2svanMvY29tcGxldGVyLmpzIiwibm90ZWJvb2svc3RhdGljLXNyYy9ub3RlYm9vay9qcy9jb250ZXh0aGludC5qcyIsIm5vdGVib29rL3N0YXRpYy1zcmMvbm90ZWJvb2svanMva2V5Ym9hcmRtYW5hZ2VyLmpzIiwibm90ZWJvb2svc3RhdGljLXNyYy9ub3RlYm9vay9qcy9tYWludG9vbGJhci5qcyIsIm5vdGVib29rL3N0YXRpYy1zcmMvbm90ZWJvb2svanMvbWF0aGpheHV0aWxzLmpzIiwibm90ZWJvb2svc3RhdGljLXNyYy9ub3RlYm9vay9qcy9tZW51YmFyLmpzIiwibm90ZWJvb2svc3RhdGljLXNyYy9ub3RlYm9vay9qcy9ub3RlYm9vay5qcyIsIm5vdGVib29rL3N0YXRpYy1zcmMvbm90ZWJvb2svanMvbm90aWZpY2F0aW9uYXJlYS5qcyIsIm5vdGVib29rL3N0YXRpYy1zcmMvbm90ZWJvb2svanMvb3V0cHV0YXJlYS5qcyIsIm5vdGVib29rL3N0YXRpYy1zcmMvbm90ZWJvb2svanMvcGFnZXIuanMiLCJub3RlYm9vay9zdGF0aWMtc3JjL25vdGVib29rL2pzL3F1aWNraGVscC5qcyIsIm5vdGVib29rL3N0YXRpYy1zcmMvbm90ZWJvb2svanMvc2F2ZXdpZGdldC5qcyIsIm5vdGVib29rL3N0YXRpYy1zcmMvbm90ZWJvb2svanMvc2Nyb2xsbWFuYWdlci5qcyIsIm5vdGVib29rL3N0YXRpYy1zcmMvbm90ZWJvb2svanMvdGV4dGNlbGwuanMiLCJub3RlYm9vay9zdGF0aWMtc3JjL25vdGVib29rL2pzL3Rvb2xiYXIuanMiLCJub3RlYm9vay9zdGF0aWMtc3JjL25vdGVib29rL2pzL3Rvb2x0aXAuanMiLCJub3RlYm9vay9zdGF0aWMtc3JjL25vdGVib29rL2pzL3RvdXIuanMiLCJub3RlYm9vay9zdGF0aWMtc3JjL3NlcnZpY2VzL2NvbmZpZy5qcyIsIm5vdGVib29rL3N0YXRpYy1zcmMvc2VydmljZXMva2VybmVscy9jb21tLmpzIiwibm90ZWJvb2svc3RhdGljLXNyYy9zZXJ2aWNlcy9rZXJuZWxzL2tlcm5lbC5qcyIsIm5vdGVib29rL3N0YXRpYy1zcmMvc2VydmljZXMva2VybmVscy9zZXJpYWxpemUuanMiLCJub3RlYm9vay9zdGF0aWMtc3JjL3NlcnZpY2VzL3Nlc3Npb25zL3Nlc3Npb24uanMiLCJub3RlYm9vay9zdGF0aWMtc3JjL3RyZWUvanMvc2Vzc2lvbmxpc3QuanMiLCJub3RlYm9vay9zdGF0aWMvY29tcG9uZW50cy9nb29nbGUtY2FqYS9odG1sLWNzcy1zYW5pdGl6ZXItbWluaWZpZWQuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNyd0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3gzRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL2NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvMkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0tBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2WkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaG9GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2o4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOVRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDck5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcGlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0VBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIvKipcbiAqIG1hcmtlZCAtIGEgbWFya2Rvd24gcGFyc2VyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTEtMjAxNCwgQ2hyaXN0b3BoZXIgSmVmZnJleS4gKE1JVCBMaWNlbnNlZClcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGpqL21hcmtlZFxuICovXG5cbjsoZnVuY3Rpb24oKSB7XG5cbi8qKlxuICogQmxvY2stTGV2ZWwgR3JhbW1hclxuICovXG5cbnZhciBibG9jayA9IHtcbiAgbmV3bGluZTogL15cXG4rLyxcbiAgY29kZTogL14oIHs0fVteXFxuXStcXG4qKSsvLFxuICBmZW5jZXM6IG5vb3AsXG4gIGhyOiAvXiggKlstKl9dKXszLH0gKig/Olxcbit8JCkvLFxuICBoZWFkaW5nOiAvXiAqKCN7MSw2fSkgKihbXlxcbl0rPykgKiMqICooPzpcXG4rfCQpLyxcbiAgbnB0YWJsZTogbm9vcCxcbiAgbGhlYWRpbmc6IC9eKFteXFxuXSspXFxuICooPXwtKXsyLH0gKig/Olxcbit8JCkvLFxuICBibG9ja3F1b3RlOiAvXiggKj5bXlxcbl0rKFxcbig/IWRlZilbXlxcbl0rKSpcXG4qKSsvLFxuICBsaXN0OiAvXiggKikoYnVsbCkgW1xcc1xcU10rPyg/OmhyfGRlZnxcXG57Mix9KD8hICkoPyFcXDFidWxsIClcXG4qfFxccyokKS8sXG4gIGh0bWw6IC9eICooPzpjb21tZW50ICooPzpcXG58XFxzKiQpfGNsb3NlZCAqKD86XFxuezIsfXxcXHMqJCl8Y2xvc2luZyAqKD86XFxuezIsfXxcXHMqJCkpLyxcbiAgZGVmOiAvXiAqXFxbKFteXFxdXSspXFxdOiAqPD8oW15cXHM+XSspPj8oPzogK1tcIihdKFteXFxuXSspW1wiKV0pPyAqKD86XFxuK3wkKS8sXG4gIHRhYmxlOiBub29wLFxuICBwYXJhZ3JhcGg6IC9eKCg/OlteXFxuXStcXG4/KD8haHJ8aGVhZGluZ3xsaGVhZGluZ3xibG9ja3F1b3RlfHRhZ3xkZWYpKSspXFxuKi8sXG4gIHRleHQ6IC9eW15cXG5dKy9cbn07XG5cbmJsb2NrLmJ1bGxldCA9IC8oPzpbKistXXxcXGQrXFwuKS87XG5ibG9jay5pdGVtID0gL14oICopKGJ1bGwpIFteXFxuXSooPzpcXG4oPyFcXDFidWxsIClbXlxcbl0qKSovO1xuYmxvY2suaXRlbSA9IHJlcGxhY2UoYmxvY2suaXRlbSwgJ2dtJylcbiAgKC9idWxsL2csIGJsb2NrLmJ1bGxldClcbiAgKCk7XG5cbmJsb2NrLmxpc3QgPSByZXBsYWNlKGJsb2NrLmxpc3QpXG4gICgvYnVsbC9nLCBibG9jay5idWxsZXQpXG4gICgnaHInLCAnXFxcXG4rKD89XFxcXDE/KD86Wy0qX10gKil7Myx9KD86XFxcXG4rfCQpKScpXG4gICgnZGVmJywgJ1xcXFxuKyg/PScgKyBibG9jay5kZWYuc291cmNlICsgJyknKVxuICAoKTtcblxuYmxvY2suYmxvY2txdW90ZSA9IHJlcGxhY2UoYmxvY2suYmxvY2txdW90ZSlcbiAgKCdkZWYnLCBibG9jay5kZWYpXG4gICgpO1xuXG5ibG9jay5fdGFnID0gJyg/ISg/OidcbiAgKyAnYXxlbXxzdHJvbmd8c21hbGx8c3xjaXRlfHF8ZGZufGFiYnJ8ZGF0YXx0aW1lfGNvZGUnXG4gICsgJ3x2YXJ8c2FtcHxrYmR8c3VifHN1cHxpfGJ8dXxtYXJrfHJ1Ynl8cnR8cnB8YmRpfGJkbydcbiAgKyAnfHNwYW58YnJ8d2JyfGluc3xkZWx8aW1nKVxcXFxiKVxcXFx3Kyg/ITovfFteXFxcXHdcXFxcc0BdKkApXFxcXGInO1xuXG5ibG9jay5odG1sID0gcmVwbGFjZShibG9jay5odG1sKVxuICAoJ2NvbW1lbnQnLCAvPCEtLVtcXHNcXFNdKj8tLT4vKVxuICAoJ2Nsb3NlZCcsIC88KHRhZylbXFxzXFxTXSs/PFxcL1xcMT4vKVxuICAoJ2Nsb3NpbmcnLCAvPHRhZyg/OlwiW15cIl0qXCJ8J1teJ10qJ3xbXidcIj5dKSo/Pi8pXG4gICgvdGFnL2csIGJsb2NrLl90YWcpXG4gICgpO1xuXG5ibG9jay5wYXJhZ3JhcGggPSByZXBsYWNlKGJsb2NrLnBhcmFncmFwaClcbiAgKCdocicsIGJsb2NrLmhyKVxuICAoJ2hlYWRpbmcnLCBibG9jay5oZWFkaW5nKVxuICAoJ2xoZWFkaW5nJywgYmxvY2subGhlYWRpbmcpXG4gICgnYmxvY2txdW90ZScsIGJsb2NrLmJsb2NrcXVvdGUpXG4gICgndGFnJywgJzwnICsgYmxvY2suX3RhZylcbiAgKCdkZWYnLCBibG9jay5kZWYpXG4gICgpO1xuXG4vKipcbiAqIE5vcm1hbCBCbG9jayBHcmFtbWFyXG4gKi9cblxuYmxvY2subm9ybWFsID0gbWVyZ2Uoe30sIGJsb2NrKTtcblxuLyoqXG4gKiBHRk0gQmxvY2sgR3JhbW1hclxuICovXG5cbmJsb2NrLmdmbSA9IG1lcmdlKHt9LCBibG9jay5ub3JtYWwsIHtcbiAgZmVuY2VzOiAvXiAqKGB7Myx9fH57Myx9KVsgXFwuXSooXFxTKyk/ICpcXG4oW1xcc1xcU10qPylcXHMqXFwxICooPzpcXG4rfCQpLyxcbiAgcGFyYWdyYXBoOiAvXi8sXG4gIGhlYWRpbmc6IC9eICooI3sxLDZ9KSArKFteXFxuXSs/KSAqIyogKig/Olxcbit8JCkvXG59KTtcblxuYmxvY2suZ2ZtLnBhcmFncmFwaCA9IHJlcGxhY2UoYmxvY2sucGFyYWdyYXBoKVxuICAoJyg/IScsICcoPyEnXG4gICAgKyBibG9jay5nZm0uZmVuY2VzLnNvdXJjZS5yZXBsYWNlKCdcXFxcMScsICdcXFxcMicpICsgJ3wnXG4gICAgKyBibG9jay5saXN0LnNvdXJjZS5yZXBsYWNlKCdcXFxcMScsICdcXFxcMycpICsgJ3wnKVxuICAoKTtcblxuLyoqXG4gKiBHRk0gKyBUYWJsZXMgQmxvY2sgR3JhbW1hclxuICovXG5cbmJsb2NrLnRhYmxlcyA9IG1lcmdlKHt9LCBibG9jay5nZm0sIHtcbiAgbnB0YWJsZTogL14gKihcXFMuKlxcfC4qKVxcbiAqKFstOl0rICpcXHxbLXwgOl0qKVxcbigoPzouKlxcfC4qKD86XFxufCQpKSopXFxuKi8sXG4gIHRhYmxlOiAvXiAqXFx8KC4rKVxcbiAqXFx8KCAqWy06XStbLXwgOl0qKVxcbigoPzogKlxcfC4qKD86XFxufCQpKSopXFxuKi9cbn0pO1xuXG4vKipcbiAqIEJsb2NrIExleGVyXG4gKi9cblxuZnVuY3Rpb24gTGV4ZXIob3B0aW9ucykge1xuICB0aGlzLnRva2VucyA9IFtdO1xuICB0aGlzLnRva2Vucy5saW5rcyA9IHt9O1xuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IG1hcmtlZC5kZWZhdWx0cztcbiAgdGhpcy5ydWxlcyA9IGJsb2NrLm5vcm1hbDtcblxuICBpZiAodGhpcy5vcHRpb25zLmdmbSkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMudGFibGVzKSB7XG4gICAgICB0aGlzLnJ1bGVzID0gYmxvY2sudGFibGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJ1bGVzID0gYmxvY2suZ2ZtO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEV4cG9zZSBCbG9jayBSdWxlc1xuICovXG5cbkxleGVyLnJ1bGVzID0gYmxvY2s7XG5cbi8qKlxuICogU3RhdGljIExleCBNZXRob2RcbiAqL1xuXG5MZXhlci5sZXggPSBmdW5jdGlvbihzcmMsIG9wdGlvbnMpIHtcbiAgdmFyIGxleGVyID0gbmV3IExleGVyKG9wdGlvbnMpO1xuICByZXR1cm4gbGV4ZXIubGV4KHNyYyk7XG59O1xuXG4vKipcbiAqIFByZXByb2Nlc3NpbmdcbiAqL1xuXG5MZXhlci5wcm90b3R5cGUubGV4ID0gZnVuY3Rpb24oc3JjKSB7XG4gIHNyYyA9IHNyY1xuICAgIC5yZXBsYWNlKC9cXHJcXG58XFxyL2csICdcXG4nKVxuICAgIC5yZXBsYWNlKC9cXHQvZywgJyAgICAnKVxuICAgIC5yZXBsYWNlKC9cXHUwMGEwL2csICcgJylcbiAgICAucmVwbGFjZSgvXFx1MjQyNC9nLCAnXFxuJyk7XG5cbiAgcmV0dXJuIHRoaXMudG9rZW4oc3JjLCB0cnVlKTtcbn07XG5cbi8qKlxuICogTGV4aW5nXG4gKi9cblxuTGV4ZXIucHJvdG90eXBlLnRva2VuID0gZnVuY3Rpb24oc3JjLCB0b3AsIGJxKSB7XG4gIHZhciBzcmMgPSBzcmMucmVwbGFjZSgvXiArJC9nbSwgJycpXG4gICAgLCBuZXh0XG4gICAgLCBsb29zZVxuICAgICwgY2FwXG4gICAgLCBidWxsXG4gICAgLCBiXG4gICAgLCBpdGVtXG4gICAgLCBzcGFjZVxuICAgICwgaVxuICAgICwgbDtcblxuICB3aGlsZSAoc3JjKSB7XG4gICAgLy8gbmV3bGluZVxuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLm5ld2xpbmUuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgaWYgKGNhcFswXS5sZW5ndGggPiAxKSB7XG4gICAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICAgIHR5cGU6ICdzcGFjZSdcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gY29kZVxuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmNvZGUuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgY2FwID0gY2FwWzBdLnJlcGxhY2UoL14gezR9L2dtLCAnJyk7XG4gICAgICB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ2NvZGUnLFxuICAgICAgICB0ZXh0OiAhdGhpcy5vcHRpb25zLnBlZGFudGljXG4gICAgICAgICAgPyBjYXAucmVwbGFjZSgvXFxuKyQvLCAnJylcbiAgICAgICAgICA6IGNhcFxuICAgICAgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBmZW5jZXMgKGdmbSlcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5mZW5jZXMuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdjb2RlJyxcbiAgICAgICAgbGFuZzogY2FwWzJdLFxuICAgICAgICB0ZXh0OiBjYXBbM10gfHwgJydcbiAgICAgIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gaGVhZGluZ1xuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmhlYWRpbmcuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdoZWFkaW5nJyxcbiAgICAgICAgZGVwdGg6IGNhcFsxXS5sZW5ndGgsXG4gICAgICAgIHRleHQ6IGNhcFsyXVxuICAgICAgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyB0YWJsZSBubyBsZWFkaW5nIHBpcGUgKGdmbSlcbiAgICBpZiAodG9wICYmIChjYXAgPSB0aGlzLnJ1bGVzLm5wdGFibGUuZXhlYyhzcmMpKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcblxuICAgICAgaXRlbSA9IHtcbiAgICAgICAgdHlwZTogJ3RhYmxlJyxcbiAgICAgICAgaGVhZGVyOiBjYXBbMV0ucmVwbGFjZSgvXiAqfCAqXFx8ICokL2csICcnKS5zcGxpdCgvICpcXHwgKi8pLFxuICAgICAgICBhbGlnbjogY2FwWzJdLnJlcGxhY2UoL14gKnxcXHwgKiQvZywgJycpLnNwbGl0KC8gKlxcfCAqLyksXG4gICAgICAgIGNlbGxzOiBjYXBbM10ucmVwbGFjZSgvXFxuJC8sICcnKS5zcGxpdCgnXFxuJylcbiAgICAgIH07XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBpdGVtLmFsaWduLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICgvXiAqLSs6ICokLy50ZXN0KGl0ZW0uYWxpZ25baV0pKSB7XG4gICAgICAgICAgaXRlbS5hbGlnbltpXSA9ICdyaWdodCc7XG4gICAgICAgIH0gZWxzZSBpZiAoL14gKjotKzogKiQvLnRlc3QoaXRlbS5hbGlnbltpXSkpIHtcbiAgICAgICAgICBpdGVtLmFsaWduW2ldID0gJ2NlbnRlcic7XG4gICAgICAgIH0gZWxzZSBpZiAoL14gKjotKyAqJC8udGVzdChpdGVtLmFsaWduW2ldKSkge1xuICAgICAgICAgIGl0ZW0uYWxpZ25baV0gPSAnbGVmdCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbS5hbGlnbltpXSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMDsgaSA8IGl0ZW0uY2VsbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaXRlbS5jZWxsc1tpXSA9IGl0ZW0uY2VsbHNbaV0uc3BsaXQoLyAqXFx8ICovKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy50b2tlbnMucHVzaChpdGVtKTtcblxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gbGhlYWRpbmdcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5saGVhZGluZy5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ2hlYWRpbmcnLFxuICAgICAgICBkZXB0aDogY2FwWzJdID09PSAnPScgPyAxIDogMixcbiAgICAgICAgdGV4dDogY2FwWzFdXG4gICAgICB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGhyXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMuaHIuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdocidcbiAgICAgIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gYmxvY2txdW90ZVxuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrcXVvdGUuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuXG4gICAgICB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ2Jsb2NrcXVvdGVfc3RhcnQnXG4gICAgICB9KTtcblxuICAgICAgY2FwID0gY2FwWzBdLnJlcGxhY2UoL14gKj4gPy9nbSwgJycpO1xuXG4gICAgICAvLyBQYXNzIGB0b3BgIHRvIGtlZXAgdGhlIGN1cnJlbnRcbiAgICAgIC8vIFwidG9wbGV2ZWxcIiBzdGF0ZS4gVGhpcyBpcyBleGFjdGx5XG4gICAgICAvLyBob3cgbWFya2Rvd24ucGwgd29ya3MuXG4gICAgICB0aGlzLnRva2VuKGNhcCwgdG9wLCB0cnVlKTtcblxuICAgICAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdibG9ja3F1b3RlX2VuZCdcbiAgICAgIH0pO1xuXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBsaXN0XG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMubGlzdC5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICBidWxsID0gY2FwWzJdO1xuXG4gICAgICB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ2xpc3Rfc3RhcnQnLFxuICAgICAgICBvcmRlcmVkOiBidWxsLmxlbmd0aCA+IDFcbiAgICAgIH0pO1xuXG4gICAgICAvLyBHZXQgZWFjaCB0b3AtbGV2ZWwgaXRlbS5cbiAgICAgIGNhcCA9IGNhcFswXS5tYXRjaCh0aGlzLnJ1bGVzLml0ZW0pO1xuXG4gICAgICBuZXh0ID0gZmFsc2U7XG4gICAgICBsID0gY2FwLmxlbmd0aDtcbiAgICAgIGkgPSAwO1xuXG4gICAgICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgICAgICBpdGVtID0gY2FwW2ldO1xuXG4gICAgICAgIC8vIFJlbW92ZSB0aGUgbGlzdCBpdGVtJ3MgYnVsbGV0XG4gICAgICAgIC8vIHNvIGl0IGlzIHNlZW4gYXMgdGhlIG5leHQgdG9rZW4uXG4gICAgICAgIHNwYWNlID0gaXRlbS5sZW5ndGg7XG4gICAgICAgIGl0ZW0gPSBpdGVtLnJlcGxhY2UoL14gKihbKistXXxcXGQrXFwuKSArLywgJycpO1xuXG4gICAgICAgIC8vIE91dGRlbnQgd2hhdGV2ZXIgdGhlXG4gICAgICAgIC8vIGxpc3QgaXRlbSBjb250YWlucy4gSGFja3kuXG4gICAgICAgIGlmICh+aXRlbS5pbmRleE9mKCdcXG4gJykpIHtcbiAgICAgICAgICBzcGFjZSAtPSBpdGVtLmxlbmd0aDtcbiAgICAgICAgICBpdGVtID0gIXRoaXMub3B0aW9ucy5wZWRhbnRpY1xuICAgICAgICAgICAgPyBpdGVtLnJlcGxhY2UobmV3IFJlZ0V4cCgnXiB7MSwnICsgc3BhY2UgKyAnfScsICdnbScpLCAnJylcbiAgICAgICAgICAgIDogaXRlbS5yZXBsYWNlKC9eIHsxLDR9L2dtLCAnJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZXRlcm1pbmUgd2hldGhlciB0aGUgbmV4dCBsaXN0IGl0ZW0gYmVsb25ncyBoZXJlLlxuICAgICAgICAvLyBCYWNrcGVkYWwgaWYgaXQgZG9lcyBub3QgYmVsb25nIGluIHRoaXMgbGlzdC5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zbWFydExpc3RzICYmIGkgIT09IGwgLSAxKSB7XG4gICAgICAgICAgYiA9IGJsb2NrLmJ1bGxldC5leGVjKGNhcFtpICsgMV0pWzBdO1xuICAgICAgICAgIGlmIChidWxsICE9PSBiICYmICEoYnVsbC5sZW5ndGggPiAxICYmIGIubGVuZ3RoID4gMSkpIHtcbiAgICAgICAgICAgIHNyYyA9IGNhcC5zbGljZShpICsgMSkuam9pbignXFxuJykgKyBzcmM7XG4gICAgICAgICAgICBpID0gbCAtIDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGV0ZXJtaW5lIHdoZXRoZXIgaXRlbSBpcyBsb29zZSBvciBub3QuXG4gICAgICAgIC8vIFVzZTogLyhefFxcbikoPyEgKVteXFxuXStcXG5cXG4oPyFcXHMqJCkvXG4gICAgICAgIC8vIGZvciBkaXNjb3VudCBiZWhhdmlvci5cbiAgICAgICAgbG9vc2UgPSBuZXh0IHx8IC9cXG5cXG4oPyFcXHMqJCkvLnRlc3QoaXRlbSk7XG4gICAgICAgIGlmIChpICE9PSBsIC0gMSkge1xuICAgICAgICAgIG5leHQgPSBpdGVtLmNoYXJBdChpdGVtLmxlbmd0aCAtIDEpID09PSAnXFxuJztcbiAgICAgICAgICBpZiAoIWxvb3NlKSBsb29zZSA9IG5leHQ7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBsb29zZVxuICAgICAgICAgICAgPyAnbG9vc2VfaXRlbV9zdGFydCdcbiAgICAgICAgICAgIDogJ2xpc3RfaXRlbV9zdGFydCdcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gUmVjdXJzZS5cbiAgICAgICAgdGhpcy50b2tlbihpdGVtLCBmYWxzZSwgYnEpO1xuXG4gICAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICAgIHR5cGU6ICdsaXN0X2l0ZW1fZW5kJ1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdsaXN0X2VuZCdcbiAgICAgIH0pO1xuXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBodG1sXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMuaHRtbC5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogdGhpcy5vcHRpb25zLnNhbml0aXplXG4gICAgICAgICAgPyAncGFyYWdyYXBoJ1xuICAgICAgICAgIDogJ2h0bWwnLFxuICAgICAgICBwcmU6ICF0aGlzLm9wdGlvbnMuc2FuaXRpemVyXG4gICAgICAgICAgJiYgKGNhcFsxXSA9PT0gJ3ByZScgfHwgY2FwWzFdID09PSAnc2NyaXB0JyB8fCBjYXBbMV0gPT09ICdzdHlsZScpLFxuICAgICAgICB0ZXh0OiBjYXBbMF1cbiAgICAgIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gZGVmXG4gICAgaWYgKCghYnEgJiYgdG9wKSAmJiAoY2FwID0gdGhpcy5ydWxlcy5kZWYuZXhlYyhzcmMpKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIHRoaXMudG9rZW5zLmxpbmtzW2NhcFsxXS50b0xvd2VyQ2FzZSgpXSA9IHtcbiAgICAgICAgaHJlZjogY2FwWzJdLFxuICAgICAgICB0aXRsZTogY2FwWzNdXG4gICAgICB9O1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gdGFibGUgKGdmbSlcbiAgICBpZiAodG9wICYmIChjYXAgPSB0aGlzLnJ1bGVzLnRhYmxlLmV4ZWMoc3JjKSkpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG5cbiAgICAgIGl0ZW0gPSB7XG4gICAgICAgIHR5cGU6ICd0YWJsZScsXG4gICAgICAgIGhlYWRlcjogY2FwWzFdLnJlcGxhY2UoL14gKnwgKlxcfCAqJC9nLCAnJykuc3BsaXQoLyAqXFx8ICovKSxcbiAgICAgICAgYWxpZ246IGNhcFsyXS5yZXBsYWNlKC9eICp8XFx8ICokL2csICcnKS5zcGxpdCgvICpcXHwgKi8pLFxuICAgICAgICBjZWxsczogY2FwWzNdLnJlcGxhY2UoLyg/OiAqXFx8ICopP1xcbiQvLCAnJykuc3BsaXQoJ1xcbicpXG4gICAgICB9O1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgaXRlbS5hbGlnbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoL14gKi0rOiAqJC8udGVzdChpdGVtLmFsaWduW2ldKSkge1xuICAgICAgICAgIGl0ZW0uYWxpZ25baV0gPSAncmlnaHQnO1xuICAgICAgICB9IGVsc2UgaWYgKC9eICo6LSs6ICokLy50ZXN0KGl0ZW0uYWxpZ25baV0pKSB7XG4gICAgICAgICAgaXRlbS5hbGlnbltpXSA9ICdjZW50ZXInO1xuICAgICAgICB9IGVsc2UgaWYgKC9eICo6LSsgKiQvLnRlc3QoaXRlbS5hbGlnbltpXSkpIHtcbiAgICAgICAgICBpdGVtLmFsaWduW2ldID0gJ2xlZnQnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW0uYWxpZ25baV0gPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBpdGVtLmNlbGxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGl0ZW0uY2VsbHNbaV0gPSBpdGVtLmNlbGxzW2ldXG4gICAgICAgICAgLnJlcGxhY2UoL14gKlxcfCAqfCAqXFx8ICokL2csICcnKVxuICAgICAgICAgIC5zcGxpdCgvICpcXHwgKi8pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnRva2Vucy5wdXNoKGl0ZW0pO1xuXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyB0b3AtbGV2ZWwgcGFyYWdyYXBoXG4gICAgaWYgKHRvcCAmJiAoY2FwID0gdGhpcy5ydWxlcy5wYXJhZ3JhcGguZXhlYyhzcmMpKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAncGFyYWdyYXBoJyxcbiAgICAgICAgdGV4dDogY2FwWzFdLmNoYXJBdChjYXBbMV0ubGVuZ3RoIC0gMSkgPT09ICdcXG4nXG4gICAgICAgICAgPyBjYXBbMV0uc2xpY2UoMCwgLTEpXG4gICAgICAgICAgOiBjYXBbMV1cbiAgICAgIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gdGV4dFxuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLnRleHQuZXhlYyhzcmMpKSB7XG4gICAgICAvLyBUb3AtbGV2ZWwgc2hvdWxkIG5ldmVyIHJlYWNoIGhlcmUuXG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgdGV4dDogY2FwWzBdXG4gICAgICB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChzcmMpIHtcbiAgICAgIHRocm93IG5ld1xuICAgICAgICBFcnJvcignSW5maW5pdGUgbG9vcCBvbiBieXRlOiAnICsgc3JjLmNoYXJDb2RlQXQoMCkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzLnRva2Vucztcbn07XG5cbi8qKlxuICogSW5saW5lLUxldmVsIEdyYW1tYXJcbiAqL1xuXG52YXIgaW5saW5lID0ge1xuICBlc2NhcGU6IC9eXFxcXChbXFxcXGAqe31cXFtcXF0oKSMrXFwtLiFfPl0pLyxcbiAgYXV0b2xpbms6IC9ePChbXiA+XSsoQHw6XFwvKVteID5dKyk+LyxcbiAgdXJsOiBub29wLFxuICB0YWc6IC9ePCEtLVtcXHNcXFNdKj8tLT58XjxcXC8/XFx3Kyg/OlwiW15cIl0qXCJ8J1teJ10qJ3xbXidcIj5dKSo/Pi8sXG4gIGxpbms6IC9eIT9cXFsoaW5zaWRlKVxcXVxcKGhyZWZcXCkvLFxuICByZWZsaW5rOiAvXiE/XFxbKGluc2lkZSlcXF1cXHMqXFxbKFteXFxdXSopXFxdLyxcbiAgbm9saW5rOiAvXiE/XFxbKCg/OlxcW1teXFxdXSpcXF18W15cXFtcXF1dKSopXFxdLyxcbiAgc3Ryb25nOiAvXl9fKFtcXHNcXFNdKz8pX18oPyFfKXxeXFwqXFwqKFtcXHNcXFNdKz8pXFwqXFwqKD8hXFwqKS8sXG4gIGVtOiAvXlxcYl8oKD86W15fXXxfXykrPylfXFxifF5cXCooKD86XFwqXFwqfFtcXHNcXFNdKSs/KVxcKig/IVxcKikvLFxuICBjb2RlOiAvXihgKylcXHMqKFtcXHNcXFNdKj9bXmBdKVxccypcXDEoPyFgKS8sXG4gIGJyOiAvXiB7Mix9XFxuKD8hXFxzKiQpLyxcbiAgZGVsOiBub29wLFxuICB0ZXh0OiAvXltcXHNcXFNdKz8oPz1bXFxcXDwhXFxbXypgXXwgezIsfVxcbnwkKS9cbn07XG5cbmlubGluZS5faW5zaWRlID0gLyg/OlxcW1teXFxdXSpcXF18W15cXFtcXF1dfFxcXSg/PVteXFxbXSpcXF0pKSovO1xuaW5saW5lLl9ocmVmID0gL1xccyo8PyhbXFxzXFxTXSo/KT4/KD86XFxzK1snXCJdKFtcXHNcXFNdKj8pWydcIl0pP1xccyovO1xuXG5pbmxpbmUubGluayA9IHJlcGxhY2UoaW5saW5lLmxpbmspXG4gICgnaW5zaWRlJywgaW5saW5lLl9pbnNpZGUpXG4gICgnaHJlZicsIGlubGluZS5faHJlZilcbiAgKCk7XG5cbmlubGluZS5yZWZsaW5rID0gcmVwbGFjZShpbmxpbmUucmVmbGluaylcbiAgKCdpbnNpZGUnLCBpbmxpbmUuX2luc2lkZSlcbiAgKCk7XG5cbi8qKlxuICogTm9ybWFsIElubGluZSBHcmFtbWFyXG4gKi9cblxuaW5saW5lLm5vcm1hbCA9IG1lcmdlKHt9LCBpbmxpbmUpO1xuXG4vKipcbiAqIFBlZGFudGljIElubGluZSBHcmFtbWFyXG4gKi9cblxuaW5saW5lLnBlZGFudGljID0gbWVyZ2Uoe30sIGlubGluZS5ub3JtYWwsIHtcbiAgc3Ryb25nOiAvXl9fKD89XFxTKShbXFxzXFxTXSo/XFxTKV9fKD8hXyl8XlxcKlxcKig/PVxcUykoW1xcc1xcU10qP1xcUylcXCpcXCooPyFcXCopLyxcbiAgZW06IC9eXyg/PVxcUykoW1xcc1xcU10qP1xcUylfKD8hXyl8XlxcKig/PVxcUykoW1xcc1xcU10qP1xcUylcXCooPyFcXCopL1xufSk7XG5cbi8qKlxuICogR0ZNIElubGluZSBHcmFtbWFyXG4gKi9cblxuaW5saW5lLmdmbSA9IG1lcmdlKHt9LCBpbmxpbmUubm9ybWFsLCB7XG4gIGVzY2FwZTogcmVwbGFjZShpbmxpbmUuZXNjYXBlKSgnXSknLCAnfnxdKScpKCksXG4gIHVybDogL14oaHR0cHM/OlxcL1xcL1teXFxzPF0rW148Liw6O1wiJylcXF1cXHNdKS8sXG4gIGRlbDogL15+fig/PVxcUykoW1xcc1xcU10qP1xcUyl+fi8sXG4gIHRleHQ6IHJlcGxhY2UoaW5saW5lLnRleHQpXG4gICAgKCddfCcsICd+XXwnKVxuICAgICgnfCcsICd8aHR0cHM/Oi8vfCcpXG4gICAgKClcbn0pO1xuXG4vKipcbiAqIEdGTSArIExpbmUgQnJlYWtzIElubGluZSBHcmFtbWFyXG4gKi9cblxuaW5saW5lLmJyZWFrcyA9IG1lcmdlKHt9LCBpbmxpbmUuZ2ZtLCB7XG4gIGJyOiByZXBsYWNlKGlubGluZS5icikoJ3syLH0nLCAnKicpKCksXG4gIHRleHQ6IHJlcGxhY2UoaW5saW5lLmdmbS50ZXh0KSgnezIsfScsICcqJykoKVxufSk7XG5cbi8qKlxuICogSW5saW5lIExleGVyICYgQ29tcGlsZXJcbiAqL1xuXG5mdW5jdGlvbiBJbmxpbmVMZXhlcihsaW5rcywgb3B0aW9ucykge1xuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IG1hcmtlZC5kZWZhdWx0cztcbiAgdGhpcy5saW5rcyA9IGxpbmtzO1xuICB0aGlzLnJ1bGVzID0gaW5saW5lLm5vcm1hbDtcbiAgdGhpcy5yZW5kZXJlciA9IHRoaXMub3B0aW9ucy5yZW5kZXJlciB8fCBuZXcgUmVuZGVyZXI7XG4gIHRoaXMucmVuZGVyZXIub3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuICBpZiAoIXRoaXMubGlua3MpIHtcbiAgICB0aHJvdyBuZXdcbiAgICAgIEVycm9yKCdUb2tlbnMgYXJyYXkgcmVxdWlyZXMgYSBgbGlua3NgIHByb3BlcnR5LicpO1xuICB9XG5cbiAgaWYgKHRoaXMub3B0aW9ucy5nZm0pIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmJyZWFrcykge1xuICAgICAgdGhpcy5ydWxlcyA9IGlubGluZS5icmVha3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucnVsZXMgPSBpbmxpbmUuZ2ZtO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMucGVkYW50aWMpIHtcbiAgICB0aGlzLnJ1bGVzID0gaW5saW5lLnBlZGFudGljO1xuICB9XG59XG5cbi8qKlxuICogRXhwb3NlIElubGluZSBSdWxlc1xuICovXG5cbklubGluZUxleGVyLnJ1bGVzID0gaW5saW5lO1xuXG4vKipcbiAqIFN0YXRpYyBMZXhpbmcvQ29tcGlsaW5nIE1ldGhvZFxuICovXG5cbklubGluZUxleGVyLm91dHB1dCA9IGZ1bmN0aW9uKHNyYywgbGlua3MsIG9wdGlvbnMpIHtcbiAgdmFyIGlubGluZSA9IG5ldyBJbmxpbmVMZXhlcihsaW5rcywgb3B0aW9ucyk7XG4gIHJldHVybiBpbmxpbmUub3V0cHV0KHNyYyk7XG59O1xuXG4vKipcbiAqIExleGluZy9Db21waWxpbmdcbiAqL1xuXG5JbmxpbmVMZXhlci5wcm90b3R5cGUub3V0cHV0ID0gZnVuY3Rpb24oc3JjKSB7XG4gIHZhciBvdXQgPSAnJ1xuICAgICwgbGlua1xuICAgICwgdGV4dFxuICAgICwgaHJlZlxuICAgICwgY2FwO1xuXG4gIHdoaWxlIChzcmMpIHtcbiAgICAvLyBlc2NhcGVcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5lc2NhcGUuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgb3V0ICs9IGNhcFsxXTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGF1dG9saW5rXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMuYXV0b2xpbmsuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgaWYgKGNhcFsyXSA9PT0gJ0AnKSB7XG4gICAgICAgIHRleHQgPSBjYXBbMV0uY2hhckF0KDYpID09PSAnOidcbiAgICAgICAgICA/IHRoaXMubWFuZ2xlKGNhcFsxXS5zdWJzdHJpbmcoNykpXG4gICAgICAgICAgOiB0aGlzLm1hbmdsZShjYXBbMV0pO1xuICAgICAgICBocmVmID0gdGhpcy5tYW5nbGUoJ21haWx0bzonKSArIHRleHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ZXh0ID0gZXNjYXBlKGNhcFsxXSk7XG4gICAgICAgIGhyZWYgPSB0ZXh0O1xuICAgICAgfVxuICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIubGluayhocmVmLCBudWxsLCB0ZXh0KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIHVybCAoZ2ZtKVxuICAgIGlmICghdGhpcy5pbkxpbmsgJiYgKGNhcCA9IHRoaXMucnVsZXMudXJsLmV4ZWMoc3JjKSkpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICB0ZXh0ID0gZXNjYXBlKGNhcFsxXSk7XG4gICAgICBocmVmID0gdGV4dDtcbiAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLmxpbmsoaHJlZiwgbnVsbCwgdGV4dCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyB0YWdcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy50YWcuZXhlYyhzcmMpKSB7XG4gICAgICBpZiAoIXRoaXMuaW5MaW5rICYmIC9ePGEgL2kudGVzdChjYXBbMF0pKSB7XG4gICAgICAgIHRoaXMuaW5MaW5rID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5pbkxpbmsgJiYgL148XFwvYT4vaS50ZXN0KGNhcFswXSkpIHtcbiAgICAgICAgdGhpcy5pbkxpbmsgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICBvdXQgKz0gdGhpcy5vcHRpb25zLnNhbml0aXplXG4gICAgICAgID8gdGhpcy5vcHRpb25zLnNhbml0aXplclxuICAgICAgICAgID8gdGhpcy5vcHRpb25zLnNhbml0aXplcihjYXBbMF0pXG4gICAgICAgICAgOiBlc2NhcGUoY2FwWzBdKVxuICAgICAgICA6IGNhcFswXVxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gbGlua1xuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmxpbmsuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgdGhpcy5pbkxpbmsgPSB0cnVlO1xuICAgICAgb3V0ICs9IHRoaXMub3V0cHV0TGluayhjYXAsIHtcbiAgICAgICAgaHJlZjogY2FwWzJdLFxuICAgICAgICB0aXRsZTogY2FwWzNdXG4gICAgICB9KTtcbiAgICAgIHRoaXMuaW5MaW5rID0gZmFsc2U7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyByZWZsaW5rLCBub2xpbmtcbiAgICBpZiAoKGNhcCA9IHRoaXMucnVsZXMucmVmbGluay5leGVjKHNyYykpXG4gICAgICAgIHx8IChjYXAgPSB0aGlzLnJ1bGVzLm5vbGluay5leGVjKHNyYykpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgbGluayA9IChjYXBbMl0gfHwgY2FwWzFdKS5yZXBsYWNlKC9cXHMrL2csICcgJyk7XG4gICAgICBsaW5rID0gdGhpcy5saW5rc1tsaW5rLnRvTG93ZXJDYXNlKCldO1xuICAgICAgaWYgKCFsaW5rIHx8ICFsaW5rLmhyZWYpIHtcbiAgICAgICAgb3V0ICs9IGNhcFswXS5jaGFyQXQoMCk7XG4gICAgICAgIHNyYyA9IGNhcFswXS5zdWJzdHJpbmcoMSkgKyBzcmM7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdGhpcy5pbkxpbmsgPSB0cnVlO1xuICAgICAgb3V0ICs9IHRoaXMub3V0cHV0TGluayhjYXAsIGxpbmspO1xuICAgICAgdGhpcy5pbkxpbmsgPSBmYWxzZTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIHN0cm9uZ1xuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLnN0cm9uZy5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5zdHJvbmcodGhpcy5vdXRwdXQoY2FwWzJdIHx8IGNhcFsxXSkpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gZW1cbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5lbS5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5lbSh0aGlzLm91dHB1dChjYXBbMl0gfHwgY2FwWzFdKSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBjb2RlXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMuY29kZS5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5jb2Rlc3Bhbihlc2NhcGUoY2FwWzJdLCB0cnVlKSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBiclxuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmJyLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLmJyKCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBkZWwgKGdmbSlcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5kZWwuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIuZGVsKHRoaXMub3V0cHV0KGNhcFsxXSkpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gdGV4dFxuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLnRleHQuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIudGV4dChlc2NhcGUodGhpcy5zbWFydHlwYW50cyhjYXBbMF0pKSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoc3JjKSB7XG4gICAgICB0aHJvdyBuZXdcbiAgICAgICAgRXJyb3IoJ0luZmluaXRlIGxvb3Agb24gYnl0ZTogJyArIHNyYy5jaGFyQ29kZUF0KDApKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDb21waWxlIExpbmtcbiAqL1xuXG5JbmxpbmVMZXhlci5wcm90b3R5cGUub3V0cHV0TGluayA9IGZ1bmN0aW9uKGNhcCwgbGluaykge1xuICB2YXIgaHJlZiA9IGVzY2FwZShsaW5rLmhyZWYpXG4gICAgLCB0aXRsZSA9IGxpbmsudGl0bGUgPyBlc2NhcGUobGluay50aXRsZSkgOiBudWxsO1xuXG4gIHJldHVybiBjYXBbMF0uY2hhckF0KDApICE9PSAnISdcbiAgICA/IHRoaXMucmVuZGVyZXIubGluayhocmVmLCB0aXRsZSwgdGhpcy5vdXRwdXQoY2FwWzFdKSlcbiAgICA6IHRoaXMucmVuZGVyZXIuaW1hZ2UoaHJlZiwgdGl0bGUsIGVzY2FwZShjYXBbMV0pKTtcbn07XG5cbi8qKlxuICogU21hcnR5cGFudHMgVHJhbnNmb3JtYXRpb25zXG4gKi9cblxuSW5saW5lTGV4ZXIucHJvdG90eXBlLnNtYXJ0eXBhbnRzID0gZnVuY3Rpb24odGV4dCkge1xuICBpZiAoIXRoaXMub3B0aW9ucy5zbWFydHlwYW50cykgcmV0dXJuIHRleHQ7XG4gIHJldHVybiB0ZXh0XG4gICAgLy8gZW0tZGFzaGVzXG4gICAgLnJlcGxhY2UoLy0tLS9nLCAnXFx1MjAxNCcpXG4gICAgLy8gZW4tZGFzaGVzXG4gICAgLnJlcGxhY2UoLy0tL2csICdcXHUyMDEzJylcbiAgICAvLyBvcGVuaW5nIHNpbmdsZXNcbiAgICAucmVwbGFjZSgvKF58Wy1cXHUyMDE0LyhcXFt7XCJcXHNdKScvZywgJyQxXFx1MjAxOCcpXG4gICAgLy8gY2xvc2luZyBzaW5nbGVzICYgYXBvc3Ryb3BoZXNcbiAgICAucmVwbGFjZSgvJy9nLCAnXFx1MjAxOScpXG4gICAgLy8gb3BlbmluZyBkb3VibGVzXG4gICAgLnJlcGxhY2UoLyhefFstXFx1MjAxNC8oXFxbe1xcdTIwMThcXHNdKVwiL2csICckMVxcdTIwMWMnKVxuICAgIC8vIGNsb3NpbmcgZG91Ymxlc1xuICAgIC5yZXBsYWNlKC9cIi9nLCAnXFx1MjAxZCcpXG4gICAgLy8gZWxsaXBzZXNcbiAgICAucmVwbGFjZSgvXFwuezN9L2csICdcXHUyMDI2Jyk7XG59O1xuXG4vKipcbiAqIE1hbmdsZSBMaW5rc1xuICovXG5cbklubGluZUxleGVyLnByb3RvdHlwZS5tYW5nbGUgPSBmdW5jdGlvbih0ZXh0KSB7XG4gIGlmICghdGhpcy5vcHRpb25zLm1hbmdsZSkgcmV0dXJuIHRleHQ7XG4gIHZhciBvdXQgPSAnJ1xuICAgICwgbCA9IHRleHQubGVuZ3RoXG4gICAgLCBpID0gMFxuICAgICwgY2g7XG5cbiAgZm9yICg7IGkgPCBsOyBpKyspIHtcbiAgICBjaCA9IHRleHQuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoTWF0aC5yYW5kb20oKSA+IDAuNSkge1xuICAgICAgY2ggPSAneCcgKyBjaC50b1N0cmluZygxNik7XG4gICAgfVxuICAgIG91dCArPSAnJiMnICsgY2ggKyAnOyc7XG4gIH1cblxuICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSZW5kZXJlclxuICovXG5cbmZ1bmN0aW9uIFJlbmRlcmVyKG9wdGlvbnMpIHtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbn1cblxuUmVuZGVyZXIucHJvdG90eXBlLmNvZGUgPSBmdW5jdGlvbihjb2RlLCBsYW5nLCBlc2NhcGVkKSB7XG4gIGlmICh0aGlzLm9wdGlvbnMuaGlnaGxpZ2h0KSB7XG4gICAgdmFyIG91dCA9IHRoaXMub3B0aW9ucy5oaWdobGlnaHQoY29kZSwgbGFuZyk7XG4gICAgaWYgKG91dCAhPSBudWxsICYmIG91dCAhPT0gY29kZSkge1xuICAgICAgZXNjYXBlZCA9IHRydWU7XG4gICAgICBjb2RlID0gb3V0O1xuICAgIH1cbiAgfVxuXG4gIGlmICghbGFuZykge1xuICAgIHJldHVybiAnPHByZT48Y29kZT4nXG4gICAgICArIChlc2NhcGVkID8gY29kZSA6IGVzY2FwZShjb2RlLCB0cnVlKSlcbiAgICAgICsgJ1xcbjwvY29kZT48L3ByZT4nO1xuICB9XG5cbiAgcmV0dXJuICc8cHJlPjxjb2RlIGNsYXNzPVwiJ1xuICAgICsgdGhpcy5vcHRpb25zLmxhbmdQcmVmaXhcbiAgICArIGVzY2FwZShsYW5nLCB0cnVlKVxuICAgICsgJ1wiPidcbiAgICArIChlc2NhcGVkID8gY29kZSA6IGVzY2FwZShjb2RlLCB0cnVlKSlcbiAgICArICdcXG48L2NvZGU+PC9wcmU+XFxuJztcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5ibG9ja3F1b3RlID0gZnVuY3Rpb24ocXVvdGUpIHtcbiAgcmV0dXJuICc8YmxvY2txdW90ZT5cXG4nICsgcXVvdGUgKyAnPC9ibG9ja3F1b3RlPlxcbic7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUuaHRtbCA9IGZ1bmN0aW9uKGh0bWwpIHtcbiAgcmV0dXJuIGh0bWw7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUuaGVhZGluZyA9IGZ1bmN0aW9uKHRleHQsIGxldmVsLCByYXcpIHtcbiAgcmV0dXJuICc8aCdcbiAgICArIGxldmVsXG4gICAgKyAnIGlkPVwiJ1xuICAgICsgdGhpcy5vcHRpb25zLmhlYWRlclByZWZpeFxuICAgICsgcmF3LnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvW15cXHddKy9nLCAnLScpXG4gICAgKyAnXCI+J1xuICAgICsgdGV4dFxuICAgICsgJzwvaCdcbiAgICArIGxldmVsXG4gICAgKyAnPlxcbic7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUuaHIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMub3B0aW9ucy54aHRtbCA/ICc8aHIvPlxcbicgOiAnPGhyPlxcbic7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUubGlzdCA9IGZ1bmN0aW9uKGJvZHksIG9yZGVyZWQpIHtcbiAgdmFyIHR5cGUgPSBvcmRlcmVkID8gJ29sJyA6ICd1bCc7XG4gIHJldHVybiAnPCcgKyB0eXBlICsgJz5cXG4nICsgYm9keSArICc8LycgKyB0eXBlICsgJz5cXG4nO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLmxpc3RpdGVtID0gZnVuY3Rpb24odGV4dCkge1xuICByZXR1cm4gJzxsaT4nICsgdGV4dCArICc8L2xpPlxcbic7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUucGFyYWdyYXBoID0gZnVuY3Rpb24odGV4dCkge1xuICByZXR1cm4gJzxwPicgKyB0ZXh0ICsgJzwvcD5cXG4nO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLnRhYmxlID0gZnVuY3Rpb24oaGVhZGVyLCBib2R5KSB7XG4gIHJldHVybiAnPHRhYmxlPlxcbidcbiAgICArICc8dGhlYWQ+XFxuJ1xuICAgICsgaGVhZGVyXG4gICAgKyAnPC90aGVhZD5cXG4nXG4gICAgKyAnPHRib2R5PlxcbidcbiAgICArIGJvZHlcbiAgICArICc8L3Rib2R5PlxcbidcbiAgICArICc8L3RhYmxlPlxcbic7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUudGFibGVyb3cgPSBmdW5jdGlvbihjb250ZW50KSB7XG4gIHJldHVybiAnPHRyPlxcbicgKyBjb250ZW50ICsgJzwvdHI+XFxuJztcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS50YWJsZWNlbGwgPSBmdW5jdGlvbihjb250ZW50LCBmbGFncykge1xuICB2YXIgdHlwZSA9IGZsYWdzLmhlYWRlciA/ICd0aCcgOiAndGQnO1xuICB2YXIgdGFnID0gZmxhZ3MuYWxpZ25cbiAgICA/ICc8JyArIHR5cGUgKyAnIHN0eWxlPVwidGV4dC1hbGlnbjonICsgZmxhZ3MuYWxpZ24gKyAnXCI+J1xuICAgIDogJzwnICsgdHlwZSArICc+JztcbiAgcmV0dXJuIHRhZyArIGNvbnRlbnQgKyAnPC8nICsgdHlwZSArICc+XFxuJztcbn07XG5cbi8vIHNwYW4gbGV2ZWwgcmVuZGVyZXJcblJlbmRlcmVyLnByb3RvdHlwZS5zdHJvbmcgPSBmdW5jdGlvbih0ZXh0KSB7XG4gIHJldHVybiAnPHN0cm9uZz4nICsgdGV4dCArICc8L3N0cm9uZz4nO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLmVtID0gZnVuY3Rpb24odGV4dCkge1xuICByZXR1cm4gJzxlbT4nICsgdGV4dCArICc8L2VtPic7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUuY29kZXNwYW4gPSBmdW5jdGlvbih0ZXh0KSB7XG4gIHJldHVybiAnPGNvZGU+JyArIHRleHQgKyAnPC9jb2RlPic7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUuYnIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMub3B0aW9ucy54aHRtbCA/ICc8YnIvPicgOiAnPGJyPic7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUuZGVsID0gZnVuY3Rpb24odGV4dCkge1xuICByZXR1cm4gJzxkZWw+JyArIHRleHQgKyAnPC9kZWw+Jztcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5saW5rID0gZnVuY3Rpb24oaHJlZiwgdGl0bGUsIHRleHQpIHtcbiAgaWYgKHRoaXMub3B0aW9ucy5zYW5pdGl6ZSkge1xuICAgIHRyeSB7XG4gICAgICB2YXIgcHJvdCA9IGRlY29kZVVSSUNvbXBvbmVudCh1bmVzY2FwZShocmVmKSlcbiAgICAgICAgLnJlcGxhY2UoL1teXFx3Ol0vZywgJycpXG4gICAgICAgIC50b0xvd2VyQ2FzZSgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgaWYgKHByb3QuaW5kZXhPZignamF2YXNjcmlwdDonKSA9PT0gMCB8fCBwcm90LmluZGV4T2YoJ3Zic2NyaXB0OicpID09PSAwKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICB9XG4gIHZhciBvdXQgPSAnPGEgaHJlZj1cIicgKyBocmVmICsgJ1wiJztcbiAgaWYgKHRpdGxlKSB7XG4gICAgb3V0ICs9ICcgdGl0bGU9XCInICsgdGl0bGUgKyAnXCInO1xuICB9XG4gIG91dCArPSAnPicgKyB0ZXh0ICsgJzwvYT4nO1xuICByZXR1cm4gb3V0O1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLmltYWdlID0gZnVuY3Rpb24oaHJlZiwgdGl0bGUsIHRleHQpIHtcbiAgdmFyIG91dCA9ICc8aW1nIHNyYz1cIicgKyBocmVmICsgJ1wiIGFsdD1cIicgKyB0ZXh0ICsgJ1wiJztcbiAgaWYgKHRpdGxlKSB7XG4gICAgb3V0ICs9ICcgdGl0bGU9XCInICsgdGl0bGUgKyAnXCInO1xuICB9XG4gIG91dCArPSB0aGlzLm9wdGlvbnMueGh0bWwgPyAnLz4nIDogJz4nO1xuICByZXR1cm4gb3V0O1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLnRleHQgPSBmdW5jdGlvbih0ZXh0KSB7XG4gIHJldHVybiB0ZXh0O1xufTtcblxuLyoqXG4gKiBQYXJzaW5nICYgQ29tcGlsaW5nXG4gKi9cblxuZnVuY3Rpb24gUGFyc2VyKG9wdGlvbnMpIHtcbiAgdGhpcy50b2tlbnMgPSBbXTtcbiAgdGhpcy50b2tlbiA9IG51bGw7XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwgbWFya2VkLmRlZmF1bHRzO1xuICB0aGlzLm9wdGlvbnMucmVuZGVyZXIgPSB0aGlzLm9wdGlvbnMucmVuZGVyZXIgfHwgbmV3IFJlbmRlcmVyO1xuICB0aGlzLnJlbmRlcmVyID0gdGhpcy5vcHRpb25zLnJlbmRlcmVyO1xuICB0aGlzLnJlbmRlcmVyLm9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG59XG5cbi8qKlxuICogU3RhdGljIFBhcnNlIE1ldGhvZFxuICovXG5cblBhcnNlci5wYXJzZSA9IGZ1bmN0aW9uKHNyYywgb3B0aW9ucywgcmVuZGVyZXIpIHtcbiAgdmFyIHBhcnNlciA9IG5ldyBQYXJzZXIob3B0aW9ucywgcmVuZGVyZXIpO1xuICByZXR1cm4gcGFyc2VyLnBhcnNlKHNyYyk7XG59O1xuXG4vKipcbiAqIFBhcnNlIExvb3BcbiAqL1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24oc3JjKSB7XG4gIHRoaXMuaW5saW5lID0gbmV3IElubGluZUxleGVyKHNyYy5saW5rcywgdGhpcy5vcHRpb25zLCB0aGlzLnJlbmRlcmVyKTtcbiAgdGhpcy50b2tlbnMgPSBzcmMucmV2ZXJzZSgpO1xuXG4gIHZhciBvdXQgPSAnJztcbiAgd2hpbGUgKHRoaXMubmV4dCgpKSB7XG4gICAgb3V0ICs9IHRoaXMudG9rKCk7XG4gIH1cblxuICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBOZXh0IFRva2VuXG4gKi9cblxuUGFyc2VyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnRva2VuID0gdGhpcy50b2tlbnMucG9wKCk7XG59O1xuXG4vKipcbiAqIFByZXZpZXcgTmV4dCBUb2tlblxuICovXG5cblBhcnNlci5wcm90b3R5cGUucGVlayA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy50b2tlbnNbdGhpcy50b2tlbnMubGVuZ3RoIC0gMV0gfHwgMDtcbn07XG5cbi8qKlxuICogUGFyc2UgVGV4dCBUb2tlbnNcbiAqL1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlVGV4dCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgYm9keSA9IHRoaXMudG9rZW4udGV4dDtcblxuICB3aGlsZSAodGhpcy5wZWVrKCkudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgYm9keSArPSAnXFxuJyArIHRoaXMubmV4dCgpLnRleHQ7XG4gIH1cblxuICByZXR1cm4gdGhpcy5pbmxpbmUub3V0cHV0KGJvZHkpO1xufTtcblxuLyoqXG4gKiBQYXJzZSBDdXJyZW50IFRva2VuXG4gKi9cblxuUGFyc2VyLnByb3RvdHlwZS50b2sgPSBmdW5jdGlvbigpIHtcbiAgc3dpdGNoICh0aGlzLnRva2VuLnR5cGUpIHtcbiAgICBjYXNlICdzcGFjZSc6IHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgY2FzZSAnaHInOiB7XG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5ocigpO1xuICAgIH1cbiAgICBjYXNlICdoZWFkaW5nJzoge1xuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIuaGVhZGluZyhcbiAgICAgICAgdGhpcy5pbmxpbmUub3V0cHV0KHRoaXMudG9rZW4udGV4dCksXG4gICAgICAgIHRoaXMudG9rZW4uZGVwdGgsXG4gICAgICAgIHRoaXMudG9rZW4udGV4dCk7XG4gICAgfVxuICAgIGNhc2UgJ2NvZGUnOiB7XG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5jb2RlKHRoaXMudG9rZW4udGV4dCxcbiAgICAgICAgdGhpcy50b2tlbi5sYW5nLFxuICAgICAgICB0aGlzLnRva2VuLmVzY2FwZWQpO1xuICAgIH1cbiAgICBjYXNlICd0YWJsZSc6IHtcbiAgICAgIHZhciBoZWFkZXIgPSAnJ1xuICAgICAgICAsIGJvZHkgPSAnJ1xuICAgICAgICAsIGlcbiAgICAgICAgLCByb3dcbiAgICAgICAgLCBjZWxsXG4gICAgICAgICwgZmxhZ3NcbiAgICAgICAgLCBqO1xuXG4gICAgICAvLyBoZWFkZXJcbiAgICAgIGNlbGwgPSAnJztcbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLnRva2VuLmhlYWRlci5sZW5ndGg7IGkrKykge1xuICAgICAgICBmbGFncyA9IHsgaGVhZGVyOiB0cnVlLCBhbGlnbjogdGhpcy50b2tlbi5hbGlnbltpXSB9O1xuICAgICAgICBjZWxsICs9IHRoaXMucmVuZGVyZXIudGFibGVjZWxsKFxuICAgICAgICAgIHRoaXMuaW5saW5lLm91dHB1dCh0aGlzLnRva2VuLmhlYWRlcltpXSksXG4gICAgICAgICAgeyBoZWFkZXI6IHRydWUsIGFsaWduOiB0aGlzLnRva2VuLmFsaWduW2ldIH1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGhlYWRlciArPSB0aGlzLnJlbmRlcmVyLnRhYmxlcm93KGNlbGwpO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy50b2tlbi5jZWxscy5sZW5ndGg7IGkrKykge1xuICAgICAgICByb3cgPSB0aGlzLnRva2VuLmNlbGxzW2ldO1xuXG4gICAgICAgIGNlbGwgPSAnJztcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IHJvdy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGNlbGwgKz0gdGhpcy5yZW5kZXJlci50YWJsZWNlbGwoXG4gICAgICAgICAgICB0aGlzLmlubGluZS5vdXRwdXQocm93W2pdKSxcbiAgICAgICAgICAgIHsgaGVhZGVyOiBmYWxzZSwgYWxpZ246IHRoaXMudG9rZW4uYWxpZ25bal0gfVxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBib2R5ICs9IHRoaXMucmVuZGVyZXIudGFibGVyb3coY2VsbCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci50YWJsZShoZWFkZXIsIGJvZHkpO1xuICAgIH1cbiAgICBjYXNlICdibG9ja3F1b3RlX3N0YXJ0Jzoge1xuICAgICAgdmFyIGJvZHkgPSAnJztcblxuICAgICAgd2hpbGUgKHRoaXMubmV4dCgpLnR5cGUgIT09ICdibG9ja3F1b3RlX2VuZCcpIHtcbiAgICAgICAgYm9keSArPSB0aGlzLnRvaygpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5ibG9ja3F1b3RlKGJvZHkpO1xuICAgIH1cbiAgICBjYXNlICdsaXN0X3N0YXJ0Jzoge1xuICAgICAgdmFyIGJvZHkgPSAnJ1xuICAgICAgICAsIG9yZGVyZWQgPSB0aGlzLnRva2VuLm9yZGVyZWQ7XG5cbiAgICAgIHdoaWxlICh0aGlzLm5leHQoKS50eXBlICE9PSAnbGlzdF9lbmQnKSB7XG4gICAgICAgIGJvZHkgKz0gdGhpcy50b2soKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIubGlzdChib2R5LCBvcmRlcmVkKTtcbiAgICB9XG4gICAgY2FzZSAnbGlzdF9pdGVtX3N0YXJ0Jzoge1xuICAgICAgdmFyIGJvZHkgPSAnJztcblxuICAgICAgd2hpbGUgKHRoaXMubmV4dCgpLnR5cGUgIT09ICdsaXN0X2l0ZW1fZW5kJykge1xuICAgICAgICBib2R5ICs9IHRoaXMudG9rZW4udHlwZSA9PT0gJ3RleHQnXG4gICAgICAgICAgPyB0aGlzLnBhcnNlVGV4dCgpXG4gICAgICAgICAgOiB0aGlzLnRvaygpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5saXN0aXRlbShib2R5KTtcbiAgICB9XG4gICAgY2FzZSAnbG9vc2VfaXRlbV9zdGFydCc6IHtcbiAgICAgIHZhciBib2R5ID0gJyc7XG5cbiAgICAgIHdoaWxlICh0aGlzLm5leHQoKS50eXBlICE9PSAnbGlzdF9pdGVtX2VuZCcpIHtcbiAgICAgICAgYm9keSArPSB0aGlzLnRvaygpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5saXN0aXRlbShib2R5KTtcbiAgICB9XG4gICAgY2FzZSAnaHRtbCc6IHtcbiAgICAgIHZhciBodG1sID0gIXRoaXMudG9rZW4ucHJlICYmICF0aGlzLm9wdGlvbnMucGVkYW50aWNcbiAgICAgICAgPyB0aGlzLmlubGluZS5vdXRwdXQodGhpcy50b2tlbi50ZXh0KVxuICAgICAgICA6IHRoaXMudG9rZW4udGV4dDtcbiAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLmh0bWwoaHRtbCk7XG4gICAgfVxuICAgIGNhc2UgJ3BhcmFncmFwaCc6IHtcbiAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLnBhcmFncmFwaCh0aGlzLmlubGluZS5vdXRwdXQodGhpcy50b2tlbi50ZXh0KSk7XG4gICAgfVxuICAgIGNhc2UgJ3RleHQnOiB7XG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5wYXJhZ3JhcGgodGhpcy5wYXJzZVRleHQoKSk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEhlbHBlcnNcbiAqL1xuXG5mdW5jdGlvbiBlc2NhcGUoaHRtbCwgZW5jb2RlKSB7XG4gIHJldHVybiBodG1sXG4gICAgLnJlcGxhY2UoIWVuY29kZSA/IC8mKD8hIz9cXHcrOykvZyA6IC8mL2csICcmYW1wOycpXG4gICAgLnJlcGxhY2UoLzwvZywgJyZsdDsnKVxuICAgIC5yZXBsYWNlKC8+L2csICcmZ3Q7JylcbiAgICAucmVwbGFjZSgvXCIvZywgJyZxdW90OycpXG4gICAgLnJlcGxhY2UoLycvZywgJyYjMzk7Jyk7XG59XG5cbmZ1bmN0aW9uIHVuZXNjYXBlKGh0bWwpIHtcbiAgcmV0dXJuIGh0bWwucmVwbGFjZSgvJihbI1xcd10rKTsvZywgZnVuY3Rpb24oXywgbikge1xuICAgIG4gPSBuLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKG4gPT09ICdjb2xvbicpIHJldHVybiAnOic7XG4gICAgaWYgKG4uY2hhckF0KDApID09PSAnIycpIHtcbiAgICAgIHJldHVybiBuLmNoYXJBdCgxKSA9PT0gJ3gnXG4gICAgICAgID8gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChuLnN1YnN0cmluZygyKSwgMTYpKVxuICAgICAgICA6IFN0cmluZy5mcm9tQ2hhckNvZGUoK24uc3Vic3RyaW5nKDEpKTtcbiAgICB9XG4gICAgcmV0dXJuICcnO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcmVwbGFjZShyZWdleCwgb3B0KSB7XG4gIHJlZ2V4ID0gcmVnZXguc291cmNlO1xuICBvcHQgPSBvcHQgfHwgJyc7XG4gIHJldHVybiBmdW5jdGlvbiBzZWxmKG5hbWUsIHZhbCkge1xuICAgIGlmICghbmFtZSkgcmV0dXJuIG5ldyBSZWdFeHAocmVnZXgsIG9wdCk7XG4gICAgdmFsID0gdmFsLnNvdXJjZSB8fCB2YWw7XG4gICAgdmFsID0gdmFsLnJlcGxhY2UoLyhefFteXFxbXSlcXF4vZywgJyQxJyk7XG4gICAgcmVnZXggPSByZWdleC5yZXBsYWNlKG5hbWUsIHZhbCk7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH07XG59XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxubm9vcC5leGVjID0gbm9vcDtcblxuZnVuY3Rpb24gbWVyZ2Uob2JqKSB7XG4gIHZhciBpID0gMVxuICAgICwgdGFyZ2V0XG4gICAgLCBrZXk7XG5cbiAgZm9yICg7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB0YXJnZXQgPSBhcmd1bWVudHNbaV07XG4gICAgZm9yIChrZXkgaW4gdGFyZ2V0KSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRhcmdldCwga2V5KSkge1xuICAgICAgICBvYmpba2V5XSA9IHRhcmdldFtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cblxuLyoqXG4gKiBNYXJrZWRcbiAqL1xuXG5mdW5jdGlvbiBtYXJrZWQoc3JjLCBvcHQsIGNhbGxiYWNrKSB7XG4gIGlmIChjYWxsYmFjayB8fCB0eXBlb2Ygb3B0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgY2FsbGJhY2sgPSBvcHQ7XG4gICAgICBvcHQgPSBudWxsO1xuICAgIH1cblxuICAgIG9wdCA9IG1lcmdlKHt9LCBtYXJrZWQuZGVmYXVsdHMsIG9wdCB8fCB7fSk7XG5cbiAgICB2YXIgaGlnaGxpZ2h0ID0gb3B0LmhpZ2hsaWdodFxuICAgICAgLCB0b2tlbnNcbiAgICAgICwgcGVuZGluZ1xuICAgICAgLCBpID0gMDtcblxuICAgIHRyeSB7XG4gICAgICB0b2tlbnMgPSBMZXhlci5sZXgoc3JjLCBvcHQpXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKGUpO1xuICAgIH1cblxuICAgIHBlbmRpbmcgPSB0b2tlbnMubGVuZ3RoO1xuXG4gICAgdmFyIGRvbmUgPSBmdW5jdGlvbihlcnIpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgb3B0LmhpZ2hsaWdodCA9IGhpZ2hsaWdodDtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICB9XG5cbiAgICAgIHZhciBvdXQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIG91dCA9IFBhcnNlci5wYXJzZSh0b2tlbnMsIG9wdCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGVyciA9IGU7XG4gICAgICB9XG5cbiAgICAgIG9wdC5oaWdobGlnaHQgPSBoaWdobGlnaHQ7XG5cbiAgICAgIHJldHVybiBlcnJcbiAgICAgICAgPyBjYWxsYmFjayhlcnIpXG4gICAgICAgIDogY2FsbGJhY2sobnVsbCwgb3V0KTtcbiAgICB9O1xuXG4gICAgaWYgKCFoaWdobGlnaHQgfHwgaGlnaGxpZ2h0Lmxlbmd0aCA8IDMpIHtcbiAgICAgIHJldHVybiBkb25lKCk7XG4gICAgfVxuXG4gICAgZGVsZXRlIG9wdC5oaWdobGlnaHQ7XG5cbiAgICBpZiAoIXBlbmRpbmcpIHJldHVybiBkb25lKCk7XG5cbiAgICBmb3IgKDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgKGZ1bmN0aW9uKHRva2VuKSB7XG4gICAgICAgIGlmICh0b2tlbi50eXBlICE9PSAnY29kZScpIHtcbiAgICAgICAgICByZXR1cm4gLS1wZW5kaW5nIHx8IGRvbmUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGlnaGxpZ2h0KHRva2VuLnRleHQsIHRva2VuLmxhbmcsIGZ1bmN0aW9uKGVyciwgY29kZSkge1xuICAgICAgICAgIGlmIChlcnIpIHJldHVybiBkb25lKGVycik7XG4gICAgICAgICAgaWYgKGNvZGUgPT0gbnVsbCB8fCBjb2RlID09PSB0b2tlbi50ZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gLS1wZW5kaW5nIHx8IGRvbmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdG9rZW4udGV4dCA9IGNvZGU7XG4gICAgICAgICAgdG9rZW4uZXNjYXBlZCA9IHRydWU7XG4gICAgICAgICAgLS1wZW5kaW5nIHx8IGRvbmUoKTtcbiAgICAgICAgfSk7XG4gICAgICB9KSh0b2tlbnNbaV0pO1xuICAgIH1cblxuICAgIHJldHVybjtcbiAgfVxuICB0cnkge1xuICAgIGlmIChvcHQpIG9wdCA9IG1lcmdlKHt9LCBtYXJrZWQuZGVmYXVsdHMsIG9wdCk7XG4gICAgcmV0dXJuIFBhcnNlci5wYXJzZShMZXhlci5sZXgoc3JjLCBvcHQpLCBvcHQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgZS5tZXNzYWdlICs9ICdcXG5QbGVhc2UgcmVwb3J0IHRoaXMgdG8gaHR0cHM6Ly9naXRodWIuY29tL2NoamovbWFya2VkLic7XG4gICAgaWYgKChvcHQgfHwgbWFya2VkLmRlZmF1bHRzKS5zaWxlbnQpIHtcbiAgICAgIHJldHVybiAnPHA+QW4gZXJyb3Igb2NjdXJlZDo8L3A+PHByZT4nXG4gICAgICAgICsgZXNjYXBlKGUubWVzc2FnZSArICcnLCB0cnVlKVxuICAgICAgICArICc8L3ByZT4nO1xuICAgIH1cbiAgICB0aHJvdyBlO1xuICB9XG59XG5cbi8qKlxuICogT3B0aW9uc1xuICovXG5cbm1hcmtlZC5vcHRpb25zID1cbm1hcmtlZC5zZXRPcHRpb25zID0gZnVuY3Rpb24ob3B0KSB7XG4gIG1lcmdlKG1hcmtlZC5kZWZhdWx0cywgb3B0KTtcbiAgcmV0dXJuIG1hcmtlZDtcbn07XG5cbm1hcmtlZC5kZWZhdWx0cyA9IHtcbiAgZ2ZtOiB0cnVlLFxuICB0YWJsZXM6IHRydWUsXG4gIGJyZWFrczogZmFsc2UsXG4gIHBlZGFudGljOiBmYWxzZSxcbiAgc2FuaXRpemU6IGZhbHNlLFxuICBzYW5pdGl6ZXI6IG51bGwsXG4gIG1hbmdsZTogdHJ1ZSxcbiAgc21hcnRMaXN0czogZmFsc2UsXG4gIHNpbGVudDogZmFsc2UsXG4gIGhpZ2hsaWdodDogbnVsbCxcbiAgbGFuZ1ByZWZpeDogJ2xhbmctJyxcbiAgc21hcnR5cGFudHM6IGZhbHNlLFxuICBoZWFkZXJQcmVmaXg6ICcnLFxuICByZW5kZXJlcjogbmV3IFJlbmRlcmVyLFxuICB4aHRtbDogZmFsc2Vcbn07XG5cbi8qKlxuICogRXhwb3NlXG4gKi9cblxubWFya2VkLlBhcnNlciA9IFBhcnNlcjtcbm1hcmtlZC5wYXJzZXIgPSBQYXJzZXIucGFyc2U7XG5cbm1hcmtlZC5SZW5kZXJlciA9IFJlbmRlcmVyO1xuXG5tYXJrZWQuTGV4ZXIgPSBMZXhlcjtcbm1hcmtlZC5sZXhlciA9IExleGVyLmxleDtcblxubWFya2VkLklubGluZUxleGVyID0gSW5saW5lTGV4ZXI7XG5tYXJrZWQuaW5saW5lTGV4ZXIgPSBJbmxpbmVMZXhlci5vdXRwdXQ7XG5cbm1hcmtlZC5wYXJzZSA9IG1hcmtlZDtcblxuaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuICBtb2R1bGUuZXhwb3J0cyA9IG1hcmtlZDtcbn0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gIGRlZmluZShmdW5jdGlvbigpIHsgcmV0dXJuIG1hcmtlZDsgfSk7XG59IGVsc2Uge1xuICB0aGlzLm1hcmtlZCA9IG1hcmtlZDtcbn1cblxufSkuY2FsbChmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMgfHwgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogZ2xvYmFsKTtcbn0oKSk7XG4iLCIvLyEgbW9tZW50LmpzXG4vLyEgdmVyc2lvbiA6IDIuOC40XG4vLyEgYXV0aG9ycyA6IFRpbSBXb29kLCBJc2tyZW4gQ2hlcm5ldiwgTW9tZW50LmpzIGNvbnRyaWJ1dG9yc1xuLy8hIGxpY2Vuc2UgOiBNSVRcbi8vISBtb21lbnRqcy5jb21cblxuKGZ1bmN0aW9uICh1bmRlZmluZWQpIHtcbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgIENvbnN0YW50c1xuICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgIHZhciBtb21lbnQsXG4gICAgICAgIFZFUlNJT04gPSAnMi44LjQnLFxuICAgICAgICAvLyB0aGUgZ2xvYmFsLXNjb3BlIHRoaXMgaXMgTk9UIHRoZSBnbG9iYWwgb2JqZWN0IGluIE5vZGUuanNcbiAgICAgICAgZ2xvYmFsU2NvcGUgPSB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHRoaXMsXG4gICAgICAgIG9sZEdsb2JhbE1vbWVudCxcbiAgICAgICAgcm91bmQgPSBNYXRoLnJvdW5kLFxuICAgICAgICBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksXG4gICAgICAgIGksXG5cbiAgICAgICAgWUVBUiA9IDAsXG4gICAgICAgIE1PTlRIID0gMSxcbiAgICAgICAgREFURSA9IDIsXG4gICAgICAgIEhPVVIgPSAzLFxuICAgICAgICBNSU5VVEUgPSA0LFxuICAgICAgICBTRUNPTkQgPSA1LFxuICAgICAgICBNSUxMSVNFQ09ORCA9IDYsXG5cbiAgICAgICAgLy8gaW50ZXJuYWwgc3RvcmFnZSBmb3IgbG9jYWxlIGNvbmZpZyBmaWxlc1xuICAgICAgICBsb2NhbGVzID0ge30sXG5cbiAgICAgICAgLy8gZXh0cmEgbW9tZW50IGludGVybmFsIHByb3BlcnRpZXMgKHBsdWdpbnMgcmVnaXN0ZXIgcHJvcHMgaGVyZSlcbiAgICAgICAgbW9tZW50UHJvcGVydGllcyA9IFtdLFxuXG4gICAgICAgIC8vIGNoZWNrIGZvciBub2RlSlNcbiAgICAgICAgaGFzTW9kdWxlID0gKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZSAmJiBtb2R1bGUuZXhwb3J0cyksXG5cbiAgICAgICAgLy8gQVNQLk5FVCBqc29uIGRhdGUgZm9ybWF0IHJlZ2V4XG4gICAgICAgIGFzcE5ldEpzb25SZWdleCA9IC9eXFwvP0RhdGVcXCgoXFwtP1xcZCspL2ksXG4gICAgICAgIGFzcE5ldFRpbWVTcGFuSnNvblJlZ2V4ID0gLyhcXC0pPyg/OihcXGQqKVxcLik/KFxcZCspXFw6KFxcZCspKD86XFw6KFxcZCspXFwuPyhcXGR7M30pPyk/LyxcblxuICAgICAgICAvLyBmcm9tIGh0dHA6Ly9kb2NzLmNsb3N1cmUtbGlicmFyeS5nb29nbGVjb2RlLmNvbS9naXQvY2xvc3VyZV9nb29nX2RhdGVfZGF0ZS5qcy5zb3VyY2UuaHRtbFxuICAgICAgICAvLyBzb21ld2hhdCBtb3JlIGluIGxpbmUgd2l0aCA0LjQuMy4yIDIwMDQgc3BlYywgYnV0IGFsbG93cyBkZWNpbWFsIGFueXdoZXJlXG4gICAgICAgIGlzb0R1cmF0aW9uUmVnZXggPSAvXigtKT9QKD86KD86KFswLTksLl0qKVkpPyg/OihbMC05LC5dKilNKT8oPzooWzAtOSwuXSopRCk/KD86VCg/OihbMC05LC5dKilIKT8oPzooWzAtOSwuXSopTSk/KD86KFswLTksLl0qKVMpPyk/fChbMC05LC5dKilXKSQvLFxuXG4gICAgICAgIC8vIGZvcm1hdCB0b2tlbnNcbiAgICAgICAgZm9ybWF0dGluZ1Rva2VucyA9IC8oXFxbW15cXFtdKlxcXSl8KFxcXFwpPyhNb3xNTT9NP00/fERvfERERG98REQ/RD9EP3xkZGQ/ZD98ZG8/fHdbb3x3XT98V1tvfFddP3xRfFlZWVlZWXxZWVlZWXxZWVlZfFlZfGdnKGdnZz8pP3xHRyhHR0c/KT98ZXxFfGF8QXxoaD98SEg/fG1tP3xzcz98U3sxLDR9fHh8WHx6ej98Wlo/fC4pL2csXG4gICAgICAgIGxvY2FsRm9ybWF0dGluZ1Rva2VucyA9IC8oXFxbW15cXFtdKlxcXSl8KFxcXFwpPyhMVFN8TFR8TEw/TD9MP3xsezEsNH0pL2csXG5cbiAgICAgICAgLy8gcGFyc2luZyB0b2tlbiByZWdleGVzXG4gICAgICAgIHBhcnNlVG9rZW5PbmVPclR3b0RpZ2l0cyA9IC9cXGRcXGQ/LywgLy8gMCAtIDk5XG4gICAgICAgIHBhcnNlVG9rZW5PbmVUb1RocmVlRGlnaXRzID0gL1xcZHsxLDN9LywgLy8gMCAtIDk5OVxuICAgICAgICBwYXJzZVRva2VuT25lVG9Gb3VyRGlnaXRzID0gL1xcZHsxLDR9LywgLy8gMCAtIDk5OTlcbiAgICAgICAgcGFyc2VUb2tlbk9uZVRvU2l4RGlnaXRzID0gL1srXFwtXT9cXGR7MSw2fS8sIC8vIC05OTksOTk5IC0gOTk5LDk5OVxuICAgICAgICBwYXJzZVRva2VuRGlnaXRzID0gL1xcZCsvLCAvLyBub256ZXJvIG51bWJlciBvZiBkaWdpdHNcbiAgICAgICAgcGFyc2VUb2tlbldvcmQgPSAvWzAtOV0qWydhLXpcXHUwMEEwLVxcdTA1RkZcXHUwNzAwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdK3xbXFx1MDYwMC1cXHUwNkZGXFwvXSsoXFxzKj9bXFx1MDYwMC1cXHUwNkZGXSspezEsMn0vaSwgLy8gYW55IHdvcmQgKG9yIHR3bykgY2hhcmFjdGVycyBvciBudW1iZXJzIGluY2x1ZGluZyB0d28vdGhyZWUgd29yZCBtb250aCBpbiBhcmFiaWMuXG4gICAgICAgIHBhcnNlVG9rZW5UaW1lem9uZSA9IC9afFtcXCtcXC1dXFxkXFxkOj9cXGRcXGQvZ2ksIC8vICswMDowMCAtMDA6MDAgKzAwMDAgLTAwMDAgb3IgWlxuICAgICAgICBwYXJzZVRva2VuVCA9IC9UL2ksIC8vIFQgKElTTyBzZXBhcmF0b3IpXG4gICAgICAgIHBhcnNlVG9rZW5PZmZzZXRNcyA9IC9bXFwrXFwtXT9cXGQrLywgLy8gMTIzNDU2Nzg5MDEyM1xuICAgICAgICBwYXJzZVRva2VuVGltZXN0YW1wTXMgPSAvW1xcK1xcLV0/XFxkKyhcXC5cXGR7MSwzfSk/LywgLy8gMTIzNDU2Nzg5IDEyMzQ1Njc4OS4xMjNcblxuICAgICAgICAvL3N0cmljdCBwYXJzaW5nIHJlZ2V4ZXNcbiAgICAgICAgcGFyc2VUb2tlbk9uZURpZ2l0ID0gL1xcZC8sIC8vIDAgLSA5XG4gICAgICAgIHBhcnNlVG9rZW5Ud29EaWdpdHMgPSAvXFxkXFxkLywgLy8gMDAgLSA5OVxuICAgICAgICBwYXJzZVRva2VuVGhyZWVEaWdpdHMgPSAvXFxkezN9LywgLy8gMDAwIC0gOTk5XG4gICAgICAgIHBhcnNlVG9rZW5Gb3VyRGlnaXRzID0gL1xcZHs0fS8sIC8vIDAwMDAgLSA5OTk5XG4gICAgICAgIHBhcnNlVG9rZW5TaXhEaWdpdHMgPSAvWystXT9cXGR7Nn0vLCAvLyAtOTk5LDk5OSAtIDk5OSw5OTlcbiAgICAgICAgcGFyc2VUb2tlblNpZ25lZE51bWJlciA9IC9bKy1dP1xcZCsvLCAvLyAtaW5mIC0gaW5mXG5cbiAgICAgICAgLy8gaXNvIDg2MDEgcmVnZXhcbiAgICAgICAgLy8gMDAwMC0wMC0wMCAwMDAwLVcwMCBvciAwMDAwLVcwMC0wICsgVCArIDAwIG9yIDAwOjAwIG9yIDAwOjAwOjAwIG9yIDAwOjAwOjAwLjAwMCArICswMDowMCBvciArMDAwMCBvciArMDApXG4gICAgICAgIGlzb1JlZ2V4ID0gL15cXHMqKD86WystXVxcZHs2fXxcXGR7NH0pLSg/OihcXGRcXGQtXFxkXFxkKXwoV1xcZFxcZCQpfChXXFxkXFxkLVxcZCl8KFxcZFxcZFxcZCkpKChUfCApKFxcZFxcZCg6XFxkXFxkKDpcXGRcXGQoXFwuXFxkKyk/KT8pPyk/KFtcXCtcXC1dXFxkXFxkKD86Oj9cXGRcXGQpP3xcXHMqWik/KT8kLyxcblxuICAgICAgICBpc29Gb3JtYXQgPSAnWVlZWS1NTS1ERFRISDptbTpzc1onLFxuXG4gICAgICAgIGlzb0RhdGVzID0gW1xuICAgICAgICAgICAgWydZWVlZWVktTU0tREQnLCAvWystXVxcZHs2fS1cXGR7Mn0tXFxkezJ9L10sXG4gICAgICAgICAgICBbJ1lZWVktTU0tREQnLCAvXFxkezR9LVxcZHsyfS1cXGR7Mn0vXSxcbiAgICAgICAgICAgIFsnR0dHRy1bV11XVy1FJywgL1xcZHs0fS1XXFxkezJ9LVxcZC9dLFxuICAgICAgICAgICAgWydHR0dHLVtXXVdXJywgL1xcZHs0fS1XXFxkezJ9L10sXG4gICAgICAgICAgICBbJ1lZWVktREREJywgL1xcZHs0fS1cXGR7M30vXVxuICAgICAgICBdLFxuXG4gICAgICAgIC8vIGlzbyB0aW1lIGZvcm1hdHMgYW5kIHJlZ2V4ZXNcbiAgICAgICAgaXNvVGltZXMgPSBbXG4gICAgICAgICAgICBbJ0hIOm1tOnNzLlNTU1MnLCAvKFR8IClcXGRcXGQ6XFxkXFxkOlxcZFxcZFxcLlxcZCsvXSxcbiAgICAgICAgICAgIFsnSEg6bW06c3MnLCAvKFR8IClcXGRcXGQ6XFxkXFxkOlxcZFxcZC9dLFxuICAgICAgICAgICAgWydISDptbScsIC8oVHwgKVxcZFxcZDpcXGRcXGQvXSxcbiAgICAgICAgICAgIFsnSEgnLCAvKFR8IClcXGRcXGQvXVxuICAgICAgICBdLFxuXG4gICAgICAgIC8vIHRpbWV6b25lIGNodW5rZXIgJysxMDowMCcgPiBbJzEwJywgJzAwJ10gb3IgJy0xNTMwJyA+IFsnLTE1JywgJzMwJ11cbiAgICAgICAgcGFyc2VUaW1lem9uZUNodW5rZXIgPSAvKFtcXCtcXC1dfFxcZFxcZCkvZ2ksXG5cbiAgICAgICAgLy8gZ2V0dGVyIGFuZCBzZXR0ZXIgbmFtZXNcbiAgICAgICAgcHJveHlHZXR0ZXJzQW5kU2V0dGVycyA9ICdEYXRlfEhvdXJzfE1pbnV0ZXN8U2Vjb25kc3xNaWxsaXNlY29uZHMnLnNwbGl0KCd8JyksXG4gICAgICAgIHVuaXRNaWxsaXNlY29uZEZhY3RvcnMgPSB7XG4gICAgICAgICAgICAnTWlsbGlzZWNvbmRzJyA6IDEsXG4gICAgICAgICAgICAnU2Vjb25kcycgOiAxZTMsXG4gICAgICAgICAgICAnTWludXRlcycgOiA2ZTQsXG4gICAgICAgICAgICAnSG91cnMnIDogMzZlNSxcbiAgICAgICAgICAgICdEYXlzJyA6IDg2NGU1LFxuICAgICAgICAgICAgJ01vbnRocycgOiAyNTkyZTYsXG4gICAgICAgICAgICAnWWVhcnMnIDogMzE1MzZlNlxuICAgICAgICB9LFxuXG4gICAgICAgIHVuaXRBbGlhc2VzID0ge1xuICAgICAgICAgICAgbXMgOiAnbWlsbGlzZWNvbmQnLFxuICAgICAgICAgICAgcyA6ICdzZWNvbmQnLFxuICAgICAgICAgICAgbSA6ICdtaW51dGUnLFxuICAgICAgICAgICAgaCA6ICdob3VyJyxcbiAgICAgICAgICAgIGQgOiAnZGF5JyxcbiAgICAgICAgICAgIEQgOiAnZGF0ZScsXG4gICAgICAgICAgICB3IDogJ3dlZWsnLFxuICAgICAgICAgICAgVyA6ICdpc29XZWVrJyxcbiAgICAgICAgICAgIE0gOiAnbW9udGgnLFxuICAgICAgICAgICAgUSA6ICdxdWFydGVyJyxcbiAgICAgICAgICAgIHkgOiAneWVhcicsXG4gICAgICAgICAgICBEREQgOiAnZGF5T2ZZZWFyJyxcbiAgICAgICAgICAgIGUgOiAnd2Vla2RheScsXG4gICAgICAgICAgICBFIDogJ2lzb1dlZWtkYXknLFxuICAgICAgICAgICAgZ2c6ICd3ZWVrWWVhcicsXG4gICAgICAgICAgICBHRzogJ2lzb1dlZWtZZWFyJ1xuICAgICAgICB9LFxuXG4gICAgICAgIGNhbWVsRnVuY3Rpb25zID0ge1xuICAgICAgICAgICAgZGF5b2Z5ZWFyIDogJ2RheU9mWWVhcicsXG4gICAgICAgICAgICBpc293ZWVrZGF5IDogJ2lzb1dlZWtkYXknLFxuICAgICAgICAgICAgaXNvd2VlayA6ICdpc29XZWVrJyxcbiAgICAgICAgICAgIHdlZWt5ZWFyIDogJ3dlZWtZZWFyJyxcbiAgICAgICAgICAgIGlzb3dlZWt5ZWFyIDogJ2lzb1dlZWtZZWFyJ1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIGZvcm1hdCBmdW5jdGlvbiBzdHJpbmdzXG4gICAgICAgIGZvcm1hdEZ1bmN0aW9ucyA9IHt9LFxuXG4gICAgICAgIC8vIGRlZmF1bHQgcmVsYXRpdmUgdGltZSB0aHJlc2hvbGRzXG4gICAgICAgIHJlbGF0aXZlVGltZVRocmVzaG9sZHMgPSB7XG4gICAgICAgICAgICBzOiA0NSwgIC8vIHNlY29uZHMgdG8gbWludXRlXG4gICAgICAgICAgICBtOiA0NSwgIC8vIG1pbnV0ZXMgdG8gaG91clxuICAgICAgICAgICAgaDogMjIsICAvLyBob3VycyB0byBkYXlcbiAgICAgICAgICAgIGQ6IDI2LCAgLy8gZGF5cyB0byBtb250aFxuICAgICAgICAgICAgTTogMTEgICAvLyBtb250aHMgdG8geWVhclxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIHRva2VucyB0byBvcmRpbmFsaXplIGFuZCBwYWRcbiAgICAgICAgb3JkaW5hbGl6ZVRva2VucyA9ICdEREQgdyBXIE0gRCBkJy5zcGxpdCgnICcpLFxuICAgICAgICBwYWRkZWRUb2tlbnMgPSAnTSBEIEggaCBtIHMgdyBXJy5zcGxpdCgnICcpLFxuXG4gICAgICAgIGZvcm1hdFRva2VuRnVuY3Rpb25zID0ge1xuICAgICAgICAgICAgTSAgICA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5tb250aCgpICsgMTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBNTU0gIDogZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5tb250aHNTaG9ydCh0aGlzLCBmb3JtYXQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIE1NTU0gOiBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm1vbnRocyh0aGlzLCBmb3JtYXQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIEQgICAgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0ZSgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIERERCAgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF5T2ZZZWFyKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZCAgICA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kYXkoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZCAgIDogZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS53ZWVrZGF5c01pbih0aGlzLCBmb3JtYXQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRkZCAgOiBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLndlZWtkYXlzU2hvcnQodGhpcywgZm9ybWF0KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZGRkIDogZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS53ZWVrZGF5cyh0aGlzLCBmb3JtYXQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHcgICAgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMud2VlaygpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFcgICAgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNvV2VlaygpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFlZICAgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlZnRaZXJvRmlsbCh0aGlzLnllYXIoKSAlIDEwMCwgMik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgWVlZWSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGVmdFplcm9GaWxsKHRoaXMueWVhcigpLCA0KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBZWVlZWSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGVmdFplcm9GaWxsKHRoaXMueWVhcigpLCA1KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBZWVlZWVkgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHkgPSB0aGlzLnllYXIoKSwgc2lnbiA9IHkgPj0gMCA/ICcrJyA6ICctJztcbiAgICAgICAgICAgICAgICByZXR1cm4gc2lnbiArIGxlZnRaZXJvRmlsbChNYXRoLmFicyh5KSwgNik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2cgICA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGVmdFplcm9GaWxsKHRoaXMud2Vla1llYXIoKSAlIDEwMCwgMik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2dnZyA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGVmdFplcm9GaWxsKHRoaXMud2Vla1llYXIoKSwgNCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2dnZ2cgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlZnRaZXJvRmlsbCh0aGlzLndlZWtZZWFyKCksIDUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIEdHICAgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlZnRaZXJvRmlsbCh0aGlzLmlzb1dlZWtZZWFyKCkgJSAxMDAsIDIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIEdHR0cgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlZnRaZXJvRmlsbCh0aGlzLmlzb1dlZWtZZWFyKCksIDQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIEdHR0dHIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0WmVyb0ZpbGwodGhpcy5pc29XZWVrWWVhcigpLCA1KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLndlZWtkYXkoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBFIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmlzb1dlZWtkYXkoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhICAgIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5tZXJpZGllbSh0aGlzLmhvdXJzKCksIHRoaXMubWludXRlcygpLCB0cnVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBBICAgIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5tZXJpZGllbSh0aGlzLmhvdXJzKCksIHRoaXMubWludXRlcygpLCBmYWxzZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgSCAgICA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ob3VycygpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGggICAgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaG91cnMoKSAlIDEyIHx8IDEyO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG0gICAgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubWludXRlcygpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHMgICAgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2Vjb25kcygpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFMgICAgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvSW50KHRoaXMubWlsbGlzZWNvbmRzKCkgLyAxMDApO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFNTICAgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlZnRaZXJvRmlsbCh0b0ludCh0aGlzLm1pbGxpc2Vjb25kcygpIC8gMTApLCAyKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBTU1MgIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0WmVyb0ZpbGwodGhpcy5taWxsaXNlY29uZHMoKSwgMyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgU1NTUyA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGVmdFplcm9GaWxsKHRoaXMubWlsbGlzZWNvbmRzKCksIDMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFogICAgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGEgPSAtdGhpcy56b25lKCksXG4gICAgICAgICAgICAgICAgICAgIGIgPSAnKyc7XG4gICAgICAgICAgICAgICAgaWYgKGEgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGEgPSAtYTtcbiAgICAgICAgICAgICAgICAgICAgYiA9ICctJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGIgKyBsZWZ0WmVyb0ZpbGwodG9JbnQoYSAvIDYwKSwgMikgKyAnOicgKyBsZWZ0WmVyb0ZpbGwodG9JbnQoYSkgJSA2MCwgMik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgWlogICA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYSA9IC10aGlzLnpvbmUoKSxcbiAgICAgICAgICAgICAgICAgICAgYiA9ICcrJztcbiAgICAgICAgICAgICAgICBpZiAoYSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYSA9IC1hO1xuICAgICAgICAgICAgICAgICAgICBiID0gJy0nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYiArIGxlZnRaZXJvRmlsbCh0b0ludChhIC8gNjApLCAyKSArIGxlZnRaZXJvRmlsbCh0b0ludChhKSAlIDYwLCAyKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB6IDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnpvbmVBYmJyKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgenogOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuem9uZU5hbWUoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB4ICAgIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlT2YoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBYICAgIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnVuaXgoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBRIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnF1YXJ0ZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBkZXByZWNhdGlvbnMgPSB7fSxcblxuICAgICAgICBsaXN0cyA9IFsnbW9udGhzJywgJ21vbnRoc1Nob3J0JywgJ3dlZWtkYXlzJywgJ3dlZWtkYXlzU2hvcnQnLCAnd2Vla2RheXNNaW4nXTtcblxuICAgIC8vIFBpY2sgdGhlIGZpcnN0IGRlZmluZWQgb2YgdHdvIG9yIHRocmVlIGFyZ3VtZW50cy4gZGZsIGNvbWVzIGZyb21cbiAgICAvLyBkZWZhdWx0LlxuICAgIGZ1bmN0aW9uIGRmbChhLCBiLCBjKSB7XG4gICAgICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gYSAhPSBudWxsID8gYSA6IGI7XG4gICAgICAgICAgICBjYXNlIDM6IHJldHVybiBhICE9IG51bGwgPyBhIDogYiAhPSBudWxsID8gYiA6IGM7XG4gICAgICAgICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoJ0ltcGxlbWVudCBtZScpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFzT3duUHJvcChhLCBiKSB7XG4gICAgICAgIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGEsIGIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlZmF1bHRQYXJzaW5nRmxhZ3MoKSB7XG4gICAgICAgIC8vIFdlIG5lZWQgdG8gZGVlcCBjbG9uZSB0aGlzIG9iamVjdCwgYW5kIGVzNSBzdGFuZGFyZCBpcyBub3QgdmVyeVxuICAgICAgICAvLyBoZWxwZnVsLlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZW1wdHkgOiBmYWxzZSxcbiAgICAgICAgICAgIHVudXNlZFRva2VucyA6IFtdLFxuICAgICAgICAgICAgdW51c2VkSW5wdXQgOiBbXSxcbiAgICAgICAgICAgIG92ZXJmbG93IDogLTIsXG4gICAgICAgICAgICBjaGFyc0xlZnRPdmVyIDogMCxcbiAgICAgICAgICAgIG51bGxJbnB1dCA6IGZhbHNlLFxuICAgICAgICAgICAgaW52YWxpZE1vbnRoIDogbnVsbCxcbiAgICAgICAgICAgIGludmFsaWRGb3JtYXQgOiBmYWxzZSxcbiAgICAgICAgICAgIHVzZXJJbnZhbGlkYXRlZCA6IGZhbHNlLFxuICAgICAgICAgICAgaXNvOiBmYWxzZVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByaW50TXNnKG1zZykge1xuICAgICAgICBpZiAobW9tZW50LnN1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5ncyA9PT0gZmFsc2UgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgY29uc29sZS53YXJuKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0RlcHJlY2F0aW9uIHdhcm5pbmc6ICcgKyBtc2cpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVwcmVjYXRlKG1zZywgZm4pIHtcbiAgICAgICAgdmFyIGZpcnN0VGltZSA9IHRydWU7XG4gICAgICAgIHJldHVybiBleHRlbmQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGZpcnN0VGltZSkge1xuICAgICAgICAgICAgICAgIHByaW50TXNnKG1zZyk7XG4gICAgICAgICAgICAgICAgZmlyc3RUaW1lID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSwgZm4pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlcHJlY2F0ZVNpbXBsZShuYW1lLCBtc2cpIHtcbiAgICAgICAgaWYgKCFkZXByZWNhdGlvbnNbbmFtZV0pIHtcbiAgICAgICAgICAgIHByaW50TXNnKG1zZyk7XG4gICAgICAgICAgICBkZXByZWNhdGlvbnNbbmFtZV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFkVG9rZW4oZnVuYywgY291bnQpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICByZXR1cm4gbGVmdFplcm9GaWxsKGZ1bmMuY2FsbCh0aGlzLCBhKSwgY291bnQpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBvcmRpbmFsaXplVG9rZW4oZnVuYywgcGVyaW9kKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm9yZGluYWwoZnVuYy5jYWxsKHRoaXMsIGEpLCBwZXJpb2QpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHdoaWxlIChvcmRpbmFsaXplVG9rZW5zLmxlbmd0aCkge1xuICAgICAgICBpID0gb3JkaW5hbGl6ZVRva2Vucy5wb3AoKTtcbiAgICAgICAgZm9ybWF0VG9rZW5GdW5jdGlvbnNbaSArICdvJ10gPSBvcmRpbmFsaXplVG9rZW4oZm9ybWF0VG9rZW5GdW5jdGlvbnNbaV0sIGkpO1xuICAgIH1cbiAgICB3aGlsZSAocGFkZGVkVG9rZW5zLmxlbmd0aCkge1xuICAgICAgICBpID0gcGFkZGVkVG9rZW5zLnBvcCgpO1xuICAgICAgICBmb3JtYXRUb2tlbkZ1bmN0aW9uc1tpICsgaV0gPSBwYWRUb2tlbihmb3JtYXRUb2tlbkZ1bmN0aW9uc1tpXSwgMik7XG4gICAgfVxuICAgIGZvcm1hdFRva2VuRnVuY3Rpb25zLkREREQgPSBwYWRUb2tlbihmb3JtYXRUb2tlbkZ1bmN0aW9ucy5EREQsIDMpO1xuXG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgIENvbnN0cnVjdG9yc1xuICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgIGZ1bmN0aW9uIExvY2FsZSgpIHtcbiAgICB9XG5cbiAgICAvLyBNb21lbnQgcHJvdG90eXBlIG9iamVjdFxuICAgIGZ1bmN0aW9uIE1vbWVudChjb25maWcsIHNraXBPdmVyZmxvdykge1xuICAgICAgICBpZiAoc2tpcE92ZXJmbG93ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgY2hlY2tPdmVyZmxvdyhjb25maWcpO1xuICAgICAgICB9XG4gICAgICAgIGNvcHlDb25maWcodGhpcywgY29uZmlnKTtcbiAgICAgICAgdGhpcy5fZCA9IG5ldyBEYXRlKCtjb25maWcuX2QpO1xuICAgIH1cblxuICAgIC8vIER1cmF0aW9uIENvbnN0cnVjdG9yXG4gICAgZnVuY3Rpb24gRHVyYXRpb24oZHVyYXRpb24pIHtcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWRJbnB1dCA9IG5vcm1hbGl6ZU9iamVjdFVuaXRzKGR1cmF0aW9uKSxcbiAgICAgICAgICAgIHllYXJzID0gbm9ybWFsaXplZElucHV0LnllYXIgfHwgMCxcbiAgICAgICAgICAgIHF1YXJ0ZXJzID0gbm9ybWFsaXplZElucHV0LnF1YXJ0ZXIgfHwgMCxcbiAgICAgICAgICAgIG1vbnRocyA9IG5vcm1hbGl6ZWRJbnB1dC5tb250aCB8fCAwLFxuICAgICAgICAgICAgd2Vla3MgPSBub3JtYWxpemVkSW5wdXQud2VlayB8fCAwLFxuICAgICAgICAgICAgZGF5cyA9IG5vcm1hbGl6ZWRJbnB1dC5kYXkgfHwgMCxcbiAgICAgICAgICAgIGhvdXJzID0gbm9ybWFsaXplZElucHV0LmhvdXIgfHwgMCxcbiAgICAgICAgICAgIG1pbnV0ZXMgPSBub3JtYWxpemVkSW5wdXQubWludXRlIHx8IDAsXG4gICAgICAgICAgICBzZWNvbmRzID0gbm9ybWFsaXplZElucHV0LnNlY29uZCB8fCAwLFxuICAgICAgICAgICAgbWlsbGlzZWNvbmRzID0gbm9ybWFsaXplZElucHV0Lm1pbGxpc2Vjb25kIHx8IDA7XG5cbiAgICAgICAgLy8gcmVwcmVzZW50YXRpb24gZm9yIGRhdGVBZGRSZW1vdmVcbiAgICAgICAgdGhpcy5fbWlsbGlzZWNvbmRzID0gK21pbGxpc2Vjb25kcyArXG4gICAgICAgICAgICBzZWNvbmRzICogMWUzICsgLy8gMTAwMFxuICAgICAgICAgICAgbWludXRlcyAqIDZlNCArIC8vIDEwMDAgKiA2MFxuICAgICAgICAgICAgaG91cnMgKiAzNmU1OyAvLyAxMDAwICogNjAgKiA2MFxuICAgICAgICAvLyBCZWNhdXNlIG9mIGRhdGVBZGRSZW1vdmUgdHJlYXRzIDI0IGhvdXJzIGFzIGRpZmZlcmVudCBmcm9tIGFcbiAgICAgICAgLy8gZGF5IHdoZW4gd29ya2luZyBhcm91bmQgRFNULCB3ZSBuZWVkIHRvIHN0b3JlIHRoZW0gc2VwYXJhdGVseVxuICAgICAgICB0aGlzLl9kYXlzID0gK2RheXMgK1xuICAgICAgICAgICAgd2Vla3MgKiA3O1xuICAgICAgICAvLyBJdCBpcyBpbXBvc3NpYmxlIHRyYW5zbGF0ZSBtb250aHMgaW50byBkYXlzIHdpdGhvdXQga25vd2luZ1xuICAgICAgICAvLyB3aGljaCBtb250aHMgeW91IGFyZSBhcmUgdGFsa2luZyBhYm91dCwgc28gd2UgaGF2ZSB0byBzdG9yZVxuICAgICAgICAvLyBpdCBzZXBhcmF0ZWx5LlxuICAgICAgICB0aGlzLl9tb250aHMgPSArbW9udGhzICtcbiAgICAgICAgICAgIHF1YXJ0ZXJzICogMyArXG4gICAgICAgICAgICB5ZWFycyAqIDEyO1xuXG4gICAgICAgIHRoaXMuX2RhdGEgPSB7fTtcblxuICAgICAgICB0aGlzLl9sb2NhbGUgPSBtb21lbnQubG9jYWxlRGF0YSgpO1xuXG4gICAgICAgIHRoaXMuX2J1YmJsZSgpO1xuICAgIH1cblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgSGVscGVyc1xuICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXG4gICAgZnVuY3Rpb24gZXh0ZW5kKGEsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgaSBpbiBiKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcChiLCBpKSkge1xuICAgICAgICAgICAgICAgIGFbaV0gPSBiW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc093blByb3AoYiwgJ3RvU3RyaW5nJykpIHtcbiAgICAgICAgICAgIGEudG9TdHJpbmcgPSBiLnRvU3RyaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc093blByb3AoYiwgJ3ZhbHVlT2YnKSkge1xuICAgICAgICAgICAgYS52YWx1ZU9mID0gYi52YWx1ZU9mO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29weUNvbmZpZyh0bywgZnJvbSkge1xuICAgICAgICB2YXIgaSwgcHJvcCwgdmFsO1xuXG4gICAgICAgIGlmICh0eXBlb2YgZnJvbS5faXNBTW9tZW50T2JqZWN0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdG8uX2lzQU1vbWVudE9iamVjdCA9IGZyb20uX2lzQU1vbWVudE9iamVjdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGZyb20uX2kgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0by5faSA9IGZyb20uX2k7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBmcm9tLl9mICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdG8uX2YgPSBmcm9tLl9mO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZnJvbS5fbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRvLl9sID0gZnJvbS5fbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGZyb20uX3N0cmljdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRvLl9zdHJpY3QgPSBmcm9tLl9zdHJpY3Q7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBmcm9tLl90em0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0by5fdHptID0gZnJvbS5fdHptO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZnJvbS5faXNVVEMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0by5faXNVVEMgPSBmcm9tLl9pc1VUQztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGZyb20uX29mZnNldCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRvLl9vZmZzZXQgPSBmcm9tLl9vZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBmcm9tLl9wZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRvLl9wZiA9IGZyb20uX3BmO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZnJvbS5fbG9jYWxlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdG8uX2xvY2FsZSA9IGZyb20uX2xvY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtb21lbnRQcm9wZXJ0aWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGZvciAoaSBpbiBtb21lbnRQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgcHJvcCA9IG1vbWVudFByb3BlcnRpZXNbaV07XG4gICAgICAgICAgICAgICAgdmFsID0gZnJvbVtwcm9wXTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9bcHJvcF0gPSB2YWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFic1JvdW5kKG51bWJlcikge1xuICAgICAgICBpZiAobnVtYmVyIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguY2VpbChudW1iZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IobnVtYmVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGxlZnQgemVybyBmaWxsIGEgbnVtYmVyXG4gICAgLy8gc2VlIGh0dHA6Ly9qc3BlcmYuY29tL2xlZnQtemVyby1maWxsaW5nIGZvciBwZXJmb3JtYW5jZSBjb21wYXJpc29uXG4gICAgZnVuY3Rpb24gbGVmdFplcm9GaWxsKG51bWJlciwgdGFyZ2V0TGVuZ3RoLCBmb3JjZVNpZ24pIHtcbiAgICAgICAgdmFyIG91dHB1dCA9ICcnICsgTWF0aC5hYnMobnVtYmVyKSxcbiAgICAgICAgICAgIHNpZ24gPSBudW1iZXIgPj0gMDtcblxuICAgICAgICB3aGlsZSAob3V0cHV0Lmxlbmd0aCA8IHRhcmdldExlbmd0aCkge1xuICAgICAgICAgICAgb3V0cHV0ID0gJzAnICsgb3V0cHV0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoc2lnbiA/IChmb3JjZVNpZ24gPyAnKycgOiAnJykgOiAnLScpICsgb3V0cHV0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBvc2l0aXZlTW9tZW50c0RpZmZlcmVuY2UoYmFzZSwgb3RoZXIpIHtcbiAgICAgICAgdmFyIHJlcyA9IHttaWxsaXNlY29uZHM6IDAsIG1vbnRoczogMH07XG5cbiAgICAgICAgcmVzLm1vbnRocyA9IG90aGVyLm1vbnRoKCkgLSBiYXNlLm1vbnRoKCkgK1xuICAgICAgICAgICAgKG90aGVyLnllYXIoKSAtIGJhc2UueWVhcigpKSAqIDEyO1xuICAgICAgICBpZiAoYmFzZS5jbG9uZSgpLmFkZChyZXMubW9udGhzLCAnTScpLmlzQWZ0ZXIob3RoZXIpKSB7XG4gICAgICAgICAgICAtLXJlcy5tb250aHM7XG4gICAgICAgIH1cblxuICAgICAgICByZXMubWlsbGlzZWNvbmRzID0gK290aGVyIC0gKyhiYXNlLmNsb25lKCkuYWRkKHJlcy5tb250aHMsICdNJykpO1xuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9tZW50c0RpZmZlcmVuY2UoYmFzZSwgb3RoZXIpIHtcbiAgICAgICAgdmFyIHJlcztcbiAgICAgICAgb3RoZXIgPSBtYWtlQXMob3RoZXIsIGJhc2UpO1xuICAgICAgICBpZiAoYmFzZS5pc0JlZm9yZShvdGhlcikpIHtcbiAgICAgICAgICAgIHJlcyA9IHBvc2l0aXZlTW9tZW50c0RpZmZlcmVuY2UoYmFzZSwgb3RoZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzID0gcG9zaXRpdmVNb21lbnRzRGlmZmVyZW5jZShvdGhlciwgYmFzZSk7XG4gICAgICAgICAgICByZXMubWlsbGlzZWNvbmRzID0gLXJlcy5taWxsaXNlY29uZHM7XG4gICAgICAgICAgICByZXMubW9udGhzID0gLXJlcy5tb250aHM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIC8vIFRPRE86IHJlbW92ZSAnbmFtZScgYXJnIGFmdGVyIGRlcHJlY2F0aW9uIGlzIHJlbW92ZWRcbiAgICBmdW5jdGlvbiBjcmVhdGVBZGRlcihkaXJlY3Rpb24sIG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWwsIHBlcmlvZCkge1xuICAgICAgICAgICAgdmFyIGR1ciwgdG1wO1xuICAgICAgICAgICAgLy9pbnZlcnQgdGhlIGFyZ3VtZW50cywgYnV0IGNvbXBsYWluIGFib3V0IGl0XG4gICAgICAgICAgICBpZiAocGVyaW9kICE9PSBudWxsICYmICFpc05hTigrcGVyaW9kKSkge1xuICAgICAgICAgICAgICAgIGRlcHJlY2F0ZVNpbXBsZShuYW1lLCAnbW9tZW50KCkuJyArIG5hbWUgICsgJyhwZXJpb2QsIG51bWJlcikgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBtb21lbnQoKS4nICsgbmFtZSArICcobnVtYmVyLCBwZXJpb2QpLicpO1xuICAgICAgICAgICAgICAgIHRtcCA9IHZhbDsgdmFsID0gcGVyaW9kOyBwZXJpb2QgPSB0bXA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhbCA9IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnID8gK3ZhbCA6IHZhbDtcbiAgICAgICAgICAgIGR1ciA9IG1vbWVudC5kdXJhdGlvbih2YWwsIHBlcmlvZCk7XG4gICAgICAgICAgICBhZGRPclN1YnRyYWN0RHVyYXRpb25Gcm9tTW9tZW50KHRoaXMsIGR1ciwgZGlyZWN0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZE9yU3VidHJhY3REdXJhdGlvbkZyb21Nb21lbnQobW9tLCBkdXJhdGlvbiwgaXNBZGRpbmcsIHVwZGF0ZU9mZnNldCkge1xuICAgICAgICB2YXIgbWlsbGlzZWNvbmRzID0gZHVyYXRpb24uX21pbGxpc2Vjb25kcyxcbiAgICAgICAgICAgIGRheXMgPSBkdXJhdGlvbi5fZGF5cyxcbiAgICAgICAgICAgIG1vbnRocyA9IGR1cmF0aW9uLl9tb250aHM7XG4gICAgICAgIHVwZGF0ZU9mZnNldCA9IHVwZGF0ZU9mZnNldCA9PSBudWxsID8gdHJ1ZSA6IHVwZGF0ZU9mZnNldDtcblxuICAgICAgICBpZiAobWlsbGlzZWNvbmRzKSB7XG4gICAgICAgICAgICBtb20uX2Quc2V0VGltZSgrbW9tLl9kICsgbWlsbGlzZWNvbmRzICogaXNBZGRpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXlzKSB7XG4gICAgICAgICAgICByYXdTZXR0ZXIobW9tLCAnRGF0ZScsIHJhd0dldHRlcihtb20sICdEYXRlJykgKyBkYXlzICogaXNBZGRpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtb250aHMpIHtcbiAgICAgICAgICAgIHJhd01vbnRoU2V0dGVyKG1vbSwgcmF3R2V0dGVyKG1vbSwgJ01vbnRoJykgKyBtb250aHMgKiBpc0FkZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVwZGF0ZU9mZnNldCkge1xuICAgICAgICAgICAgbW9tZW50LnVwZGF0ZU9mZnNldChtb20sIGRheXMgfHwgbW9udGhzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNoZWNrIGlmIGlzIGFuIGFycmF5XG4gICAgZnVuY3Rpb24gaXNBcnJheShpbnB1dCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0RhdGUoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IERhdGVdJyB8fFxuICAgICAgICAgICAgaW5wdXQgaW5zdGFuY2VvZiBEYXRlO1xuICAgIH1cblxuICAgIC8vIGNvbXBhcmUgdHdvIGFycmF5cywgcmV0dXJuIHRoZSBudW1iZXIgb2YgZGlmZmVyZW5jZXNcbiAgICBmdW5jdGlvbiBjb21wYXJlQXJyYXlzKGFycmF5MSwgYXJyYXkyLCBkb250Q29udmVydCkge1xuICAgICAgICB2YXIgbGVuID0gTWF0aC5taW4oYXJyYXkxLmxlbmd0aCwgYXJyYXkyLmxlbmd0aCksXG4gICAgICAgICAgICBsZW5ndGhEaWZmID0gTWF0aC5hYnMoYXJyYXkxLmxlbmd0aCAtIGFycmF5Mi5sZW5ndGgpLFxuICAgICAgICAgICAgZGlmZnMgPSAwLFxuICAgICAgICAgICAgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoKGRvbnRDb252ZXJ0ICYmIGFycmF5MVtpXSAhPT0gYXJyYXkyW2ldKSB8fFxuICAgICAgICAgICAgICAgICghZG9udENvbnZlcnQgJiYgdG9JbnQoYXJyYXkxW2ldKSAhPT0gdG9JbnQoYXJyYXkyW2ldKSkpIHtcbiAgICAgICAgICAgICAgICBkaWZmcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaWZmcyArIGxlbmd0aERpZmY7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplVW5pdHModW5pdHMpIHtcbiAgICAgICAgaWYgKHVuaXRzKSB7XG4gICAgICAgICAgICB2YXIgbG93ZXJlZCA9IHVuaXRzLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvKC4pcyQvLCAnJDEnKTtcbiAgICAgICAgICAgIHVuaXRzID0gdW5pdEFsaWFzZXNbdW5pdHNdIHx8IGNhbWVsRnVuY3Rpb25zW2xvd2VyZWRdIHx8IGxvd2VyZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuaXRzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZU9iamVjdFVuaXRzKGlucHV0T2JqZWN0KSB7XG4gICAgICAgIHZhciBub3JtYWxpemVkSW5wdXQgPSB7fSxcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRQcm9wLFxuICAgICAgICAgICAgcHJvcDtcblxuICAgICAgICBmb3IgKHByb3AgaW4gaW5wdXRPYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKGlucHV0T2JqZWN0LCBwcm9wKSkge1xuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRQcm9wID0gbm9ybWFsaXplVW5pdHMocHJvcCk7XG4gICAgICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWRQcm9wKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRJbnB1dFtub3JtYWxpemVkUHJvcF0gPSBpbnB1dE9iamVjdFtwcm9wXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbm9ybWFsaXplZElucHV0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VMaXN0KGZpZWxkKSB7XG4gICAgICAgIHZhciBjb3VudCwgc2V0dGVyO1xuXG4gICAgICAgIGlmIChmaWVsZC5pbmRleE9mKCd3ZWVrJykgPT09IDApIHtcbiAgICAgICAgICAgIGNvdW50ID0gNztcbiAgICAgICAgICAgIHNldHRlciA9ICdkYXknO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZpZWxkLmluZGV4T2YoJ21vbnRoJykgPT09IDApIHtcbiAgICAgICAgICAgIGNvdW50ID0gMTI7XG4gICAgICAgICAgICBzZXR0ZXIgPSAnbW9udGgnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbW9tZW50W2ZpZWxkXSA9IGZ1bmN0aW9uIChmb3JtYXQsIGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgaSwgZ2V0dGVyLFxuICAgICAgICAgICAgICAgIG1ldGhvZCA9IG1vbWVudC5fbG9jYWxlW2ZpZWxkXSxcbiAgICAgICAgICAgICAgICByZXN1bHRzID0gW107XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZm9ybWF0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gZm9ybWF0O1xuICAgICAgICAgICAgICAgIGZvcm1hdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ2V0dGVyID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbSA9IG1vbWVudCgpLnV0YygpLnNldChzZXR0ZXIsIGkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBtZXRob2QuY2FsbChtb21lbnQuX2xvY2FsZSwgbSwgZm9ybWF0IHx8ICcnKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmIChpbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldHRlcihpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goZ2V0dGVyKGkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9JbnQoYXJndW1lbnRGb3JDb2VyY2lvbikge1xuICAgICAgICB2YXIgY29lcmNlZE51bWJlciA9ICthcmd1bWVudEZvckNvZXJjaW9uLFxuICAgICAgICAgICAgdmFsdWUgPSAwO1xuXG4gICAgICAgIGlmIChjb2VyY2VkTnVtYmVyICE9PSAwICYmIGlzRmluaXRlKGNvZXJjZWROdW1iZXIpKSB7XG4gICAgICAgICAgICBpZiAoY29lcmNlZE51bWJlciA+PSAwKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBNYXRoLmZsb29yKGNvZXJjZWROdW1iZXIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IE1hdGguY2VpbChjb2VyY2VkTnVtYmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkYXlzSW5Nb250aCh5ZWFyLCBtb250aCkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoeWVhciwgbW9udGggKyAxLCAwKSkuZ2V0VVRDRGF0ZSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdlZWtzSW5ZZWFyKHllYXIsIGRvdywgZG95KSB7XG4gICAgICAgIHJldHVybiB3ZWVrT2ZZZWFyKG1vbWVudChbeWVhciwgMTEsIDMxICsgZG93IC0gZG95XSksIGRvdywgZG95KS53ZWVrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRheXNJblllYXIoeWVhcikge1xuICAgICAgICByZXR1cm4gaXNMZWFwWWVhcih5ZWFyKSA/IDM2NiA6IDM2NTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0xlYXBZZWFyKHllYXIpIHtcbiAgICAgICAgcmV0dXJuICh5ZWFyICUgNCA9PT0gMCAmJiB5ZWFyICUgMTAwICE9PSAwKSB8fCB5ZWFyICUgNDAwID09PSAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNoZWNrT3ZlcmZsb3cobSkge1xuICAgICAgICB2YXIgb3ZlcmZsb3c7XG4gICAgICAgIGlmIChtLl9hICYmIG0uX3BmLm92ZXJmbG93ID09PSAtMikge1xuICAgICAgICAgICAgb3ZlcmZsb3cgPVxuICAgICAgICAgICAgICAgIG0uX2FbTU9OVEhdIDwgMCB8fCBtLl9hW01PTlRIXSA+IDExID8gTU9OVEggOlxuICAgICAgICAgICAgICAgIG0uX2FbREFURV0gPCAxIHx8IG0uX2FbREFURV0gPiBkYXlzSW5Nb250aChtLl9hW1lFQVJdLCBtLl9hW01PTlRIXSkgPyBEQVRFIDpcbiAgICAgICAgICAgICAgICBtLl9hW0hPVVJdIDwgMCB8fCBtLl9hW0hPVVJdID4gMjQgfHxcbiAgICAgICAgICAgICAgICAgICAgKG0uX2FbSE9VUl0gPT09IDI0ICYmIChtLl9hW01JTlVURV0gIT09IDAgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtLl9hW1NFQ09ORF0gIT09IDAgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtLl9hW01JTExJU0VDT05EXSAhPT0gMCkpID8gSE9VUiA6XG4gICAgICAgICAgICAgICAgbS5fYVtNSU5VVEVdIDwgMCB8fCBtLl9hW01JTlVURV0gPiA1OSA/IE1JTlVURSA6XG4gICAgICAgICAgICAgICAgbS5fYVtTRUNPTkRdIDwgMCB8fCBtLl9hW1NFQ09ORF0gPiA1OSA/IFNFQ09ORCA6XG4gICAgICAgICAgICAgICAgbS5fYVtNSUxMSVNFQ09ORF0gPCAwIHx8IG0uX2FbTUlMTElTRUNPTkRdID4gOTk5ID8gTUlMTElTRUNPTkQgOlxuICAgICAgICAgICAgICAgIC0xO1xuXG4gICAgICAgICAgICBpZiAobS5fcGYuX292ZXJmbG93RGF5T2ZZZWFyICYmIChvdmVyZmxvdyA8IFlFQVIgfHwgb3ZlcmZsb3cgPiBEQVRFKSkge1xuICAgICAgICAgICAgICAgIG92ZXJmbG93ID0gREFURTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbS5fcGYub3ZlcmZsb3cgPSBvdmVyZmxvdztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVmFsaWQobSkge1xuICAgICAgICBpZiAobS5faXNWYWxpZCA9PSBudWxsKSB7XG4gICAgICAgICAgICBtLl9pc1ZhbGlkID0gIWlzTmFOKG0uX2QuZ2V0VGltZSgpKSAmJlxuICAgICAgICAgICAgICAgIG0uX3BmLm92ZXJmbG93IDwgMCAmJlxuICAgICAgICAgICAgICAgICFtLl9wZi5lbXB0eSAmJlxuICAgICAgICAgICAgICAgICFtLl9wZi5pbnZhbGlkTW9udGggJiZcbiAgICAgICAgICAgICAgICAhbS5fcGYubnVsbElucHV0ICYmXG4gICAgICAgICAgICAgICAgIW0uX3BmLmludmFsaWRGb3JtYXQgJiZcbiAgICAgICAgICAgICAgICAhbS5fcGYudXNlckludmFsaWRhdGVkO1xuXG4gICAgICAgICAgICBpZiAobS5fc3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgbS5faXNWYWxpZCA9IG0uX2lzVmFsaWQgJiZcbiAgICAgICAgICAgICAgICAgICAgbS5fcGYuY2hhcnNMZWZ0T3ZlciA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICBtLl9wZi51bnVzZWRUb2tlbnMubGVuZ3RoID09PSAwICYmXG4gICAgICAgICAgICAgICAgICAgIG0uX3BmLmJpZ0hvdXIgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbS5faXNWYWxpZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBub3JtYWxpemVMb2NhbGUoa2V5KSB7XG4gICAgICAgIHJldHVybiBrZXkgPyBrZXkudG9Mb3dlckNhc2UoKS5yZXBsYWNlKCdfJywgJy0nKSA6IGtleTtcbiAgICB9XG5cbiAgICAvLyBwaWNrIHRoZSBsb2NhbGUgZnJvbSB0aGUgYXJyYXlcbiAgICAvLyB0cnkgWydlbi1hdScsICdlbi1nYiddIGFzICdlbi1hdScsICdlbi1nYicsICdlbicsIGFzIGluIG1vdmUgdGhyb3VnaCB0aGUgbGlzdCB0cnlpbmcgZWFjaFxuICAgIC8vIHN1YnN0cmluZyBmcm9tIG1vc3Qgc3BlY2lmaWMgdG8gbGVhc3QsIGJ1dCBtb3ZlIHRvIHRoZSBuZXh0IGFycmF5IGl0ZW0gaWYgaXQncyBhIG1vcmUgc3BlY2lmaWMgdmFyaWFudCB0aGFuIHRoZSBjdXJyZW50IHJvb3RcbiAgICBmdW5jdGlvbiBjaG9vc2VMb2NhbGUobmFtZXMpIHtcbiAgICAgICAgdmFyIGkgPSAwLCBqLCBuZXh0LCBsb2NhbGUsIHNwbGl0O1xuXG4gICAgICAgIHdoaWxlIChpIDwgbmFtZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBzcGxpdCA9IG5vcm1hbGl6ZUxvY2FsZShuYW1lc1tpXSkuc3BsaXQoJy0nKTtcbiAgICAgICAgICAgIGogPSBzcGxpdC5sZW5ndGg7XG4gICAgICAgICAgICBuZXh0ID0gbm9ybWFsaXplTG9jYWxlKG5hbWVzW2kgKyAxXSk7XG4gICAgICAgICAgICBuZXh0ID0gbmV4dCA/IG5leHQuc3BsaXQoJy0nKSA6IG51bGw7XG4gICAgICAgICAgICB3aGlsZSAoaiA+IDApIHtcbiAgICAgICAgICAgICAgICBsb2NhbGUgPSBsb2FkTG9jYWxlKHNwbGl0LnNsaWNlKDAsIGopLmpvaW4oJy0nKSk7XG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobmV4dCAmJiBuZXh0Lmxlbmd0aCA+PSBqICYmIGNvbXBhcmVBcnJheXMoc3BsaXQsIG5leHQsIHRydWUpID49IGogLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vdGhlIG5leHQgYXJyYXkgaXRlbSBpcyBiZXR0ZXIgdGhhbiBhIHNoYWxsb3dlciBzdWJzdHJpbmcgb2YgdGhpcyBvbmVcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGotLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2FkTG9jYWxlKG5hbWUpIHtcbiAgICAgICAgdmFyIG9sZExvY2FsZSA9IG51bGw7XG4gICAgICAgIGlmICghbG9jYWxlc1tuYW1lXSAmJiBoYXNNb2R1bGUpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgb2xkTG9jYWxlID0gbW9tZW50LmxvY2FsZSgpO1xuICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vbG9jYWxlLycgKyBuYW1lKTtcbiAgICAgICAgICAgICAgICAvLyBiZWNhdXNlIGRlZmluZUxvY2FsZSBjdXJyZW50bHkgYWxzbyBzZXRzIHRoZSBnbG9iYWwgbG9jYWxlLCB3ZSB3YW50IHRvIHVuZG8gdGhhdCBmb3IgbGF6eSBsb2FkZWQgbG9jYWxlc1xuICAgICAgICAgICAgICAgIG1vbWVudC5sb2NhbGUob2xkTG9jYWxlKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHsgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2NhbGVzW25hbWVdO1xuICAgIH1cblxuICAgIC8vIFJldHVybiBhIG1vbWVudCBmcm9tIGlucHV0LCB0aGF0IGlzIGxvY2FsL3V0Yy96b25lIGVxdWl2YWxlbnQgdG8gbW9kZWwuXG4gICAgZnVuY3Rpb24gbWFrZUFzKGlucHV0LCBtb2RlbCkge1xuICAgICAgICB2YXIgcmVzLCBkaWZmO1xuICAgICAgICBpZiAobW9kZWwuX2lzVVRDKSB7XG4gICAgICAgICAgICByZXMgPSBtb2RlbC5jbG9uZSgpO1xuICAgICAgICAgICAgZGlmZiA9IChtb21lbnQuaXNNb21lbnQoaW5wdXQpIHx8IGlzRGF0ZShpbnB1dCkgP1xuICAgICAgICAgICAgICAgICAgICAraW5wdXQgOiArbW9tZW50KGlucHV0KSkgLSAoK3Jlcyk7XG4gICAgICAgICAgICAvLyBVc2UgbG93LWxldmVsIGFwaSwgYmVjYXVzZSB0aGlzIGZuIGlzIGxvdy1sZXZlbCBhcGkuXG4gICAgICAgICAgICByZXMuX2Quc2V0VGltZSgrcmVzLl9kICsgZGlmZik7XG4gICAgICAgICAgICBtb21lbnQudXBkYXRlT2Zmc2V0KHJlcywgZmFsc2UpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBtb21lbnQoaW5wdXQpLmxvY2FsKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgIExvY2FsZVxuICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXG4gICAgZXh0ZW5kKExvY2FsZS5wcm90b3R5cGUsIHtcblxuICAgICAgICBzZXQgOiBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgICAgICB2YXIgcHJvcCwgaTtcbiAgICAgICAgICAgIGZvciAoaSBpbiBjb25maWcpIHtcbiAgICAgICAgICAgICAgICBwcm9wID0gY29uZmlnW2ldO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvcCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzW2ldID0gcHJvcDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzWydfJyArIGldID0gcHJvcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBMZW5pZW50IG9yZGluYWwgcGFyc2luZyBhY2NlcHRzIGp1c3QgYSBudW1iZXIgaW4gYWRkaXRpb24gdG9cbiAgICAgICAgICAgIC8vIG51bWJlciArIChwb3NzaWJseSkgc3R1ZmYgY29taW5nIGZyb20gX29yZGluYWxQYXJzZUxlbmllbnQuXG4gICAgICAgICAgICB0aGlzLl9vcmRpbmFsUGFyc2VMZW5pZW50ID0gbmV3IFJlZ0V4cCh0aGlzLl9vcmRpbmFsUGFyc2Uuc291cmNlICsgJ3wnICsgL1xcZHsxLDJ9Ly5zb3VyY2UpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9tb250aHMgOiAnSmFudWFyeV9GZWJydWFyeV9NYXJjaF9BcHJpbF9NYXlfSnVuZV9KdWx5X0F1Z3VzdF9TZXB0ZW1iZXJfT2N0b2Jlcl9Ob3ZlbWJlcl9EZWNlbWJlcicuc3BsaXQoJ18nKSxcbiAgICAgICAgbW9udGhzIDogZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNbbS5tb250aCgpXTtcbiAgICAgICAgfSxcblxuICAgICAgICBfbW9udGhzU2hvcnQgOiAnSmFuX0ZlYl9NYXJfQXByX01heV9KdW5fSnVsX0F1Z19TZXBfT2N0X05vdl9EZWMnLnNwbGl0KCdfJyksXG4gICAgICAgIG1vbnRoc1Nob3J0IDogZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTaG9ydFttLm1vbnRoKCldO1xuICAgICAgICB9LFxuXG4gICAgICAgIG1vbnRoc1BhcnNlIDogZnVuY3Rpb24gKG1vbnRoTmFtZSwgZm9ybWF0LCBzdHJpY3QpIHtcbiAgICAgICAgICAgIHZhciBpLCBtb20sIHJlZ2V4O1xuXG4gICAgICAgICAgICBpZiAoIXRoaXMuX21vbnRoc1BhcnNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlID0gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgLy8gbWFrZSB0aGUgcmVnZXggaWYgd2UgZG9uJ3QgaGF2ZSBpdCBhbHJlYWR5XG4gICAgICAgICAgICAgICAgbW9tID0gbW9tZW50LnV0YyhbMjAwMCwgaV0pO1xuICAgICAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgIXRoaXMuX2xvbmdNb250aHNQYXJzZVtpXSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKCdeJyArIHRoaXMubW9udGhzKG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnJykgKyAnJCcsICdpJyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0TW9udGhzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKCdeJyArIHRoaXMubW9udGhzU2hvcnQobW9tLCAnJykucmVwbGFjZSgnLicsICcnKSArICckJywgJ2knKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFzdHJpY3QgJiYgIXRoaXMuX21vbnRoc1BhcnNlW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZ2V4ID0gJ14nICsgdGhpcy5tb250aHMobW9tLCAnJykgKyAnfF4nICsgdGhpcy5tb250aHNTaG9ydChtb20sICcnKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKHJlZ2V4LnJlcGxhY2UoJy4nLCAnJyksICdpJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHRlc3QgdGhlIHJlZ2V4XG4gICAgICAgICAgICAgICAgaWYgKHN0cmljdCAmJiBmb3JtYXQgPT09ICdNTU1NJyAmJiB0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0udGVzdChtb250aE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RyaWN0ICYmIGZvcm1hdCA9PT0gJ01NTScgJiYgdGhpcy5fc2hvcnRNb250aHNQYXJzZVtpXS50ZXN0KG1vbnRoTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghc3RyaWN0ICYmIHRoaXMuX21vbnRoc1BhcnNlW2ldLnRlc3QobW9udGhOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3dlZWtkYXlzIDogJ1N1bmRheV9Nb25kYXlfVHVlc2RheV9XZWRuZXNkYXlfVGh1cnNkYXlfRnJpZGF5X1NhdHVyZGF5Jy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5cyA6IGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNbbS5kYXkoKV07XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3dlZWtkYXlzU2hvcnQgOiAnU3VuX01vbl9UdWVfV2VkX1RodV9GcmlfU2F0Jy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c1Nob3J0IDogZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1Nob3J0W20uZGF5KCldO1xuICAgICAgICB9LFxuXG4gICAgICAgIF93ZWVrZGF5c01pbiA6ICdTdV9Nb19UdV9XZV9UaF9Gcl9TYScuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNNaW4gOiBmdW5jdGlvbiAobSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzTWluW20uZGF5KCldO1xuICAgICAgICB9LFxuXG4gICAgICAgIHdlZWtkYXlzUGFyc2UgOiBmdW5jdGlvbiAod2Vla2RheU5hbWUpIHtcbiAgICAgICAgICAgIHZhciBpLCBtb20sIHJlZ2V4O1xuXG4gICAgICAgICAgICBpZiAoIXRoaXMuX3dlZWtkYXlzUGFyc2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgICAgICAgICAvLyBtYWtlIHRoZSByZWdleCBpZiB3ZSBkb24ndCBoYXZlIGl0IGFscmVhZHlcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3dlZWtkYXlzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgbW9tID0gbW9tZW50KFsyMDAwLCAxXSkuZGF5KGkpO1xuICAgICAgICAgICAgICAgICAgICByZWdleCA9ICdeJyArIHRoaXMud2Vla2RheXMobW9tLCAnJykgKyAnfF4nICsgdGhpcy53ZWVrZGF5c1Nob3J0KG1vbSwgJycpICsgJ3xeJyArIHRoaXMud2Vla2RheXNNaW4obW9tLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKHJlZ2V4LnJlcGxhY2UoJy4nLCAnJyksICdpJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHRlc3QgdGhlIHJlZ2V4XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VbaV0udGVzdCh3ZWVrZGF5TmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIF9sb25nRGF0ZUZvcm1hdCA6IHtcbiAgICAgICAgICAgIExUUyA6ICdoOm1tOnNzIEEnLFxuICAgICAgICAgICAgTFQgOiAnaDptbSBBJyxcbiAgICAgICAgICAgIEwgOiAnTU0vREQvWVlZWScsXG4gICAgICAgICAgICBMTCA6ICdNTU1NIEQsIFlZWVknLFxuICAgICAgICAgICAgTExMIDogJ01NTU0gRCwgWVlZWSBMVCcsXG4gICAgICAgICAgICBMTExMIDogJ2RkZGQsIE1NTU0gRCwgWVlZWSBMVCdcbiAgICAgICAgfSxcbiAgICAgICAgbG9uZ0RhdGVGb3JtYXQgOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5XTtcbiAgICAgICAgICAgIGlmICghb3V0cHV0ICYmIHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleS50b1VwcGVyQ2FzZSgpXSkge1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleS50b1VwcGVyQ2FzZSgpXS5yZXBsYWNlKC9NTU1NfE1NfEREfGRkZGQvZywgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsLnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV0gPSBvdXRwdXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICB9LFxuXG4gICAgICAgIGlzUE0gOiBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgICAgIC8vIElFOCBRdWlya3MgTW9kZSAmIElFNyBTdGFuZGFyZHMgTW9kZSBkbyBub3QgYWxsb3cgYWNjZXNzaW5nIHN0cmluZ3MgbGlrZSBhcnJheXNcbiAgICAgICAgICAgIC8vIFVzaW5nIGNoYXJBdCBzaG91bGQgYmUgbW9yZSBjb21wYXRpYmxlLlxuICAgICAgICAgICAgcmV0dXJuICgoaW5wdXQgKyAnJykudG9Mb3dlckNhc2UoKS5jaGFyQXQoMCkgPT09ICdwJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX21lcmlkaWVtUGFyc2UgOiAvW2FwXVxcLj9tP1xcLj8vaSxcbiAgICAgICAgbWVyaWRpZW0gOiBmdW5jdGlvbiAoaG91cnMsIG1pbnV0ZXMsIGlzTG93ZXIpIHtcbiAgICAgICAgICAgIGlmIChob3VycyA+IDExKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzTG93ZXIgPyAncG0nIDogJ1BNJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzTG93ZXIgPyAnYW0nIDogJ0FNJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfY2FsZW5kYXIgOiB7XG4gICAgICAgICAgICBzYW1lRGF5IDogJ1tUb2RheSBhdF0gTFQnLFxuICAgICAgICAgICAgbmV4dERheSA6ICdbVG9tb3Jyb3cgYXRdIExUJyxcbiAgICAgICAgICAgIG5leHRXZWVrIDogJ2RkZGQgW2F0XSBMVCcsXG4gICAgICAgICAgICBsYXN0RGF5IDogJ1tZZXN0ZXJkYXkgYXRdIExUJyxcbiAgICAgICAgICAgIGxhc3RXZWVrIDogJ1tMYXN0XSBkZGRkIFthdF0gTFQnLFxuICAgICAgICAgICAgc2FtZUVsc2UgOiAnTCdcbiAgICAgICAgfSxcbiAgICAgICAgY2FsZW5kYXIgOiBmdW5jdGlvbiAoa2V5LCBtb20sIG5vdykge1xuICAgICAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMuX2NhbGVuZGFyW2tleV07XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIG91dHB1dCA9PT0gJ2Z1bmN0aW9uJyA/IG91dHB1dC5hcHBseShtb20sIFtub3ddKSA6IG91dHB1dDtcbiAgICAgICAgfSxcblxuICAgICAgICBfcmVsYXRpdmVUaW1lIDoge1xuICAgICAgICAgICAgZnV0dXJlIDogJ2luICVzJyxcbiAgICAgICAgICAgIHBhc3QgOiAnJXMgYWdvJyxcbiAgICAgICAgICAgIHMgOiAnYSBmZXcgc2Vjb25kcycsXG4gICAgICAgICAgICBtIDogJ2EgbWludXRlJyxcbiAgICAgICAgICAgIG1tIDogJyVkIG1pbnV0ZXMnLFxuICAgICAgICAgICAgaCA6ICdhbiBob3VyJyxcbiAgICAgICAgICAgIGhoIDogJyVkIGhvdXJzJyxcbiAgICAgICAgICAgIGQgOiAnYSBkYXknLFxuICAgICAgICAgICAgZGQgOiAnJWQgZGF5cycsXG4gICAgICAgICAgICBNIDogJ2EgbW9udGgnLFxuICAgICAgICAgICAgTU0gOiAnJWQgbW9udGhzJyxcbiAgICAgICAgICAgIHkgOiAnYSB5ZWFyJyxcbiAgICAgICAgICAgIHl5IDogJyVkIHllYXJzJ1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbGF0aXZlVGltZSA6IGZ1bmN0aW9uIChudW1iZXIsIHdpdGhvdXRTdWZmaXgsIHN0cmluZywgaXNGdXR1cmUpIHtcbiAgICAgICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLl9yZWxhdGl2ZVRpbWVbc3RyaW5nXTtcbiAgICAgICAgICAgIHJldHVybiAodHlwZW9mIG91dHB1dCA9PT0gJ2Z1bmN0aW9uJykgP1xuICAgICAgICAgICAgICAgIG91dHB1dChudW1iZXIsIHdpdGhvdXRTdWZmaXgsIHN0cmluZywgaXNGdXR1cmUpIDpcbiAgICAgICAgICAgICAgICBvdXRwdXQucmVwbGFjZSgvJWQvaSwgbnVtYmVyKTtcbiAgICAgICAgfSxcblxuICAgICAgICBwYXN0RnV0dXJlIDogZnVuY3Rpb24gKGRpZmYsIG91dHB1dCkge1xuICAgICAgICAgICAgdmFyIGZvcm1hdCA9IHRoaXMuX3JlbGF0aXZlVGltZVtkaWZmID4gMCA/ICdmdXR1cmUnIDogJ3Bhc3QnXTtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgZm9ybWF0ID09PSAnZnVuY3Rpb24nID8gZm9ybWF0KG91dHB1dCkgOiBmb3JtYXQucmVwbGFjZSgvJXMvaSwgb3V0cHV0KTtcbiAgICAgICAgfSxcblxuICAgICAgICBvcmRpbmFsIDogZnVuY3Rpb24gKG51bWJlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29yZGluYWwucmVwbGFjZSgnJWQnLCBudW1iZXIpO1xuICAgICAgICB9LFxuICAgICAgICBfb3JkaW5hbCA6ICclZCcsXG4gICAgICAgIF9vcmRpbmFsUGFyc2UgOiAvXFxkezEsMn0vLFxuXG4gICAgICAgIHByZXBhcnNlIDogZnVuY3Rpb24gKHN0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgICAgfSxcblxuICAgICAgICBwb3N0Zm9ybWF0IDogZnVuY3Rpb24gKHN0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgICAgfSxcblxuICAgICAgICB3ZWVrIDogZnVuY3Rpb24gKG1vbSkge1xuICAgICAgICAgICAgcmV0dXJuIHdlZWtPZlllYXIobW9tLCB0aGlzLl93ZWVrLmRvdywgdGhpcy5fd2Vlay5kb3kpLndlZWs7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3dlZWsgOiB7XG4gICAgICAgICAgICBkb3cgOiAwLCAvLyBTdW5kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICAgICAgICAgIGRveSA6IDYgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgICAgICAgfSxcblxuICAgICAgICBfaW52YWxpZERhdGU6ICdJbnZhbGlkIGRhdGUnLFxuICAgICAgICBpbnZhbGlkRGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ludmFsaWREYXRlO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgIEZvcm1hdHRpbmdcbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblxuICAgIGZ1bmN0aW9uIHJlbW92ZUZvcm1hdHRpbmdUb2tlbnMoaW5wdXQpIHtcbiAgICAgICAgaWYgKGlucHV0Lm1hdGNoKC9cXFtbXFxzXFxTXS8pKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQucmVwbGFjZSgvXlxcW3xcXF0kL2csICcnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5wdXQucmVwbGFjZSgvXFxcXC9nLCAnJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUZvcm1hdEZ1bmN0aW9uKGZvcm1hdCkge1xuICAgICAgICB2YXIgYXJyYXkgPSBmb3JtYXQubWF0Y2goZm9ybWF0dGluZ1Rva2VucyksIGksIGxlbmd0aDtcblxuICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBhcnJheS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGZvcm1hdFRva2VuRnVuY3Rpb25zW2FycmF5W2ldXSkge1xuICAgICAgICAgICAgICAgIGFycmF5W2ldID0gZm9ybWF0VG9rZW5GdW5jdGlvbnNbYXJyYXlbaV1dO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhcnJheVtpXSA9IHJlbW92ZUZvcm1hdHRpbmdUb2tlbnMoYXJyYXlbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChtb20pIHtcbiAgICAgICAgICAgIHZhciBvdXRwdXQgPSAnJztcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIG91dHB1dCArPSBhcnJheVtpXSBpbnN0YW5jZW9mIEZ1bmN0aW9uID8gYXJyYXlbaV0uY2FsbChtb20sIGZvcm1hdCkgOiBhcnJheVtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gZm9ybWF0IGRhdGUgdXNpbmcgbmF0aXZlIGRhdGUgb2JqZWN0XG4gICAgZnVuY3Rpb24gZm9ybWF0TW9tZW50KG0sIGZvcm1hdCkge1xuICAgICAgICBpZiAoIW0uaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbS5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcm1hdCA9IGV4cGFuZEZvcm1hdChmb3JtYXQsIG0ubG9jYWxlRGF0YSgpKTtcblxuICAgICAgICBpZiAoIWZvcm1hdEZ1bmN0aW9uc1tmb3JtYXRdKSB7XG4gICAgICAgICAgICBmb3JtYXRGdW5jdGlvbnNbZm9ybWF0XSA9IG1ha2VGb3JtYXRGdW5jdGlvbihmb3JtYXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZvcm1hdEZ1bmN0aW9uc1tmb3JtYXRdKG0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4cGFuZEZvcm1hdChmb3JtYXQsIGxvY2FsZSkge1xuICAgICAgICB2YXIgaSA9IDU7XG5cbiAgICAgICAgZnVuY3Rpb24gcmVwbGFjZUxvbmdEYXRlRm9ybWF0VG9rZW5zKGlucHV0KSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxlLmxvbmdEYXRlRm9ybWF0KGlucHV0KSB8fCBpbnB1dDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxvY2FsRm9ybWF0dGluZ1Rva2Vucy5sYXN0SW5kZXggPSAwO1xuICAgICAgICB3aGlsZSAoaSA+PSAwICYmIGxvY2FsRm9ybWF0dGluZ1Rva2Vucy50ZXN0KGZvcm1hdCkpIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKGxvY2FsRm9ybWF0dGluZ1Rva2VucywgcmVwbGFjZUxvbmdEYXRlRm9ybWF0VG9rZW5zKTtcbiAgICAgICAgICAgIGxvY2FsRm9ybWF0dGluZ1Rva2Vucy5sYXN0SW5kZXggPSAwO1xuICAgICAgICAgICAgaSAtPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZvcm1hdDtcbiAgICB9XG5cblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgUGFyc2luZ1xuICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXG4gICAgLy8gZ2V0IHRoZSByZWdleCB0byBmaW5kIHRoZSBuZXh0IHRva2VuXG4gICAgZnVuY3Rpb24gZ2V0UGFyc2VSZWdleEZvclRva2VuKHRva2VuLCBjb25maWcpIHtcbiAgICAgICAgdmFyIGEsIHN0cmljdCA9IGNvbmZpZy5fc3RyaWN0O1xuICAgICAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAgIGNhc2UgJ1EnOlxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlVG9rZW5PbmVEaWdpdDtcbiAgICAgICAgY2FzZSAnRERERCc6XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VUb2tlblRocmVlRGlnaXRzO1xuICAgICAgICBjYXNlICdZWVlZJzpcbiAgICAgICAgY2FzZSAnR0dHRyc6XG4gICAgICAgIGNhc2UgJ2dnZ2cnOlxuICAgICAgICAgICAgcmV0dXJuIHN0cmljdCA/IHBhcnNlVG9rZW5Gb3VyRGlnaXRzIDogcGFyc2VUb2tlbk9uZVRvRm91ckRpZ2l0cztcbiAgICAgICAgY2FzZSAnWSc6XG4gICAgICAgIGNhc2UgJ0cnOlxuICAgICAgICBjYXNlICdnJzpcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVRva2VuU2lnbmVkTnVtYmVyO1xuICAgICAgICBjYXNlICdZWVlZWVknOlxuICAgICAgICBjYXNlICdZWVlZWSc6XG4gICAgICAgIGNhc2UgJ0dHR0dHJzpcbiAgICAgICAgY2FzZSAnZ2dnZ2cnOlxuICAgICAgICAgICAgcmV0dXJuIHN0cmljdCA/IHBhcnNlVG9rZW5TaXhEaWdpdHMgOiBwYXJzZVRva2VuT25lVG9TaXhEaWdpdHM7XG4gICAgICAgIGNhc2UgJ1MnOlxuICAgICAgICAgICAgaWYgKHN0cmljdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZVRva2VuT25lRGlnaXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgIGNhc2UgJ1NTJzpcbiAgICAgICAgICAgIGlmIChzdHJpY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VUb2tlblR3b0RpZ2l0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgY2FzZSAnU1NTJzpcbiAgICAgICAgICAgIGlmIChzdHJpY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VUb2tlblRocmVlRGlnaXRzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICBjYXNlICdEREQnOlxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlVG9rZW5PbmVUb1RocmVlRGlnaXRzO1xuICAgICAgICBjYXNlICdNTU0nOlxuICAgICAgICBjYXNlICdNTU1NJzpcbiAgICAgICAgY2FzZSAnZGQnOlxuICAgICAgICBjYXNlICdkZGQnOlxuICAgICAgICBjYXNlICdkZGRkJzpcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVRva2VuV29yZDtcbiAgICAgICAgY2FzZSAnYSc6XG4gICAgICAgIGNhc2UgJ0EnOlxuICAgICAgICAgICAgcmV0dXJuIGNvbmZpZy5fbG9jYWxlLl9tZXJpZGllbVBhcnNlO1xuICAgICAgICBjYXNlICd4JzpcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVRva2VuT2Zmc2V0TXM7XG4gICAgICAgIGNhc2UgJ1gnOlxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlVG9rZW5UaW1lc3RhbXBNcztcbiAgICAgICAgY2FzZSAnWic6XG4gICAgICAgIGNhc2UgJ1paJzpcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVRva2VuVGltZXpvbmU7XG4gICAgICAgIGNhc2UgJ1QnOlxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlVG9rZW5UO1xuICAgICAgICBjYXNlICdTU1NTJzpcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVRva2VuRGlnaXRzO1xuICAgICAgICBjYXNlICdNTSc6XG4gICAgICAgIGNhc2UgJ0REJzpcbiAgICAgICAgY2FzZSAnWVknOlxuICAgICAgICBjYXNlICdHRyc6XG4gICAgICAgIGNhc2UgJ2dnJzpcbiAgICAgICAgY2FzZSAnSEgnOlxuICAgICAgICBjYXNlICdoaCc6XG4gICAgICAgIGNhc2UgJ21tJzpcbiAgICAgICAgY2FzZSAnc3MnOlxuICAgICAgICBjYXNlICd3dyc6XG4gICAgICAgIGNhc2UgJ1dXJzpcbiAgICAgICAgICAgIHJldHVybiBzdHJpY3QgPyBwYXJzZVRva2VuVHdvRGlnaXRzIDogcGFyc2VUb2tlbk9uZU9yVHdvRGlnaXRzO1xuICAgICAgICBjYXNlICdNJzpcbiAgICAgICAgY2FzZSAnRCc6XG4gICAgICAgIGNhc2UgJ2QnOlxuICAgICAgICBjYXNlICdIJzpcbiAgICAgICAgY2FzZSAnaCc6XG4gICAgICAgIGNhc2UgJ20nOlxuICAgICAgICBjYXNlICdzJzpcbiAgICAgICAgY2FzZSAndyc6XG4gICAgICAgIGNhc2UgJ1cnOlxuICAgICAgICBjYXNlICdlJzpcbiAgICAgICAgY2FzZSAnRSc6XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VUb2tlbk9uZU9yVHdvRGlnaXRzO1xuICAgICAgICBjYXNlICdEbyc6XG4gICAgICAgICAgICByZXR1cm4gc3RyaWN0ID8gY29uZmlnLl9sb2NhbGUuX29yZGluYWxQYXJzZSA6IGNvbmZpZy5fbG9jYWxlLl9vcmRpbmFsUGFyc2VMZW5pZW50O1xuICAgICAgICBkZWZhdWx0IDpcbiAgICAgICAgICAgIGEgPSBuZXcgUmVnRXhwKHJlZ2V4cEVzY2FwZSh1bmVzY2FwZUZvcm1hdCh0b2tlbi5yZXBsYWNlKCdcXFxcJywgJycpKSwgJ2knKSk7XG4gICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRpbWV6b25lTWludXRlc0Zyb21TdHJpbmcoc3RyaW5nKSB7XG4gICAgICAgIHN0cmluZyA9IHN0cmluZyB8fCAnJztcbiAgICAgICAgdmFyIHBvc3NpYmxlVHpNYXRjaGVzID0gKHN0cmluZy5tYXRjaChwYXJzZVRva2VuVGltZXpvbmUpIHx8IFtdKSxcbiAgICAgICAgICAgIHR6Q2h1bmsgPSBwb3NzaWJsZVR6TWF0Y2hlc1twb3NzaWJsZVR6TWF0Y2hlcy5sZW5ndGggLSAxXSB8fCBbXSxcbiAgICAgICAgICAgIHBhcnRzID0gKHR6Q2h1bmsgKyAnJykubWF0Y2gocGFyc2VUaW1lem9uZUNodW5rZXIpIHx8IFsnLScsIDAsIDBdLFxuICAgICAgICAgICAgbWludXRlcyA9ICsocGFydHNbMV0gKiA2MCkgKyB0b0ludChwYXJ0c1syXSk7XG5cbiAgICAgICAgcmV0dXJuIHBhcnRzWzBdID09PSAnKycgPyAtbWludXRlcyA6IG1pbnV0ZXM7XG4gICAgfVxuXG4gICAgLy8gZnVuY3Rpb24gdG8gY29udmVydCBzdHJpbmcgaW5wdXQgdG8gZGF0ZVxuICAgIGZ1bmN0aW9uIGFkZFRpbWVUb0FycmF5RnJvbVRva2VuKHRva2VuLCBpbnB1dCwgY29uZmlnKSB7XG4gICAgICAgIHZhciBhLCBkYXRlUGFydEFycmF5ID0gY29uZmlnLl9hO1xuXG4gICAgICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgICAgLy8gUVVBUlRFUlxuICAgICAgICBjYXNlICdRJzpcbiAgICAgICAgICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGF0ZVBhcnRBcnJheVtNT05USF0gPSAodG9JbnQoaW5wdXQpIC0gMSkgKiAzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIE1PTlRIXG4gICAgICAgIGNhc2UgJ00nIDogLy8gZmFsbCB0aHJvdWdoIHRvIE1NXG4gICAgICAgIGNhc2UgJ01NJyA6XG4gICAgICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRhdGVQYXJ0QXJyYXlbTU9OVEhdID0gdG9JbnQoaW5wdXQpIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdNTU0nIDogLy8gZmFsbCB0aHJvdWdoIHRvIE1NTU1cbiAgICAgICAgY2FzZSAnTU1NTScgOlxuICAgICAgICAgICAgYSA9IGNvbmZpZy5fbG9jYWxlLm1vbnRoc1BhcnNlKGlucHV0LCB0b2tlbiwgY29uZmlnLl9zdHJpY3QpO1xuICAgICAgICAgICAgLy8gaWYgd2UgZGlkbid0IGZpbmQgYSBtb250aCBuYW1lLCBtYXJrIHRoZSBkYXRlIGFzIGludmFsaWQuXG4gICAgICAgICAgICBpZiAoYSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGF0ZVBhcnRBcnJheVtNT05USF0gPSBhO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25maWcuX3BmLmludmFsaWRNb250aCA9IGlucHV0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIERBWSBPRiBNT05USFxuICAgICAgICBjYXNlICdEJyA6IC8vIGZhbGwgdGhyb3VnaCB0byBERFxuICAgICAgICBjYXNlICdERCcgOlxuICAgICAgICAgICAgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkYXRlUGFydEFycmF5W0RBVEVdID0gdG9JbnQoaW5wdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0RvJyA6XG4gICAgICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRhdGVQYXJ0QXJyYXlbREFURV0gPSB0b0ludChwYXJzZUludChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dC5tYXRjaCgvXFxkezEsMn0vKVswXSwgMTApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBEQVkgT0YgWUVBUlxuICAgICAgICBjYXNlICdEREQnIDogLy8gZmFsbCB0aHJvdWdoIHRvIERERERcbiAgICAgICAgY2FzZSAnRERERCcgOlxuICAgICAgICAgICAgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25maWcuX2RheU9mWWVhciA9IHRvSW50KGlucHV0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIFlFQVJcbiAgICAgICAgY2FzZSAnWVknIDpcbiAgICAgICAgICAgIGRhdGVQYXJ0QXJyYXlbWUVBUl0gPSBtb21lbnQucGFyc2VUd29EaWdpdFllYXIoaW5wdXQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ1lZWVknIDpcbiAgICAgICAgY2FzZSAnWVlZWVknIDpcbiAgICAgICAgY2FzZSAnWVlZWVlZJyA6XG4gICAgICAgICAgICBkYXRlUGFydEFycmF5W1lFQVJdID0gdG9JbnQoaW5wdXQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIEFNIC8gUE1cbiAgICAgICAgY2FzZSAnYScgOiAvLyBmYWxsIHRocm91Z2ggdG8gQVxuICAgICAgICBjYXNlICdBJyA6XG4gICAgICAgICAgICBjb25maWcuX2lzUG0gPSBjb25maWcuX2xvY2FsZS5pc1BNKGlucHV0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBIT1VSXG4gICAgICAgIGNhc2UgJ2gnIDogLy8gZmFsbCB0aHJvdWdoIHRvIGhoXG4gICAgICAgIGNhc2UgJ2hoJyA6XG4gICAgICAgICAgICBjb25maWcuX3BmLmJpZ0hvdXIgPSB0cnVlO1xuICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICBjYXNlICdIJyA6IC8vIGZhbGwgdGhyb3VnaCB0byBISFxuICAgICAgICBjYXNlICdISCcgOlxuICAgICAgICAgICAgZGF0ZVBhcnRBcnJheVtIT1VSXSA9IHRvSW50KGlucHV0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBNSU5VVEVcbiAgICAgICAgY2FzZSAnbScgOiAvLyBmYWxsIHRocm91Z2ggdG8gbW1cbiAgICAgICAgY2FzZSAnbW0nIDpcbiAgICAgICAgICAgIGRhdGVQYXJ0QXJyYXlbTUlOVVRFXSA9IHRvSW50KGlucHV0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBTRUNPTkRcbiAgICAgICAgY2FzZSAncycgOiAvLyBmYWxsIHRocm91Z2ggdG8gc3NcbiAgICAgICAgY2FzZSAnc3MnIDpcbiAgICAgICAgICAgIGRhdGVQYXJ0QXJyYXlbU0VDT05EXSA9IHRvSW50KGlucHV0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBNSUxMSVNFQ09ORFxuICAgICAgICBjYXNlICdTJyA6XG4gICAgICAgIGNhc2UgJ1NTJyA6XG4gICAgICAgIGNhc2UgJ1NTUycgOlxuICAgICAgICBjYXNlICdTU1NTJyA6XG4gICAgICAgICAgICBkYXRlUGFydEFycmF5W01JTExJU0VDT05EXSA9IHRvSW50KCgnMC4nICsgaW5wdXQpICogMTAwMCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gVU5JWCBPRkZTRVQgKE1JTExJU0VDT05EUylcbiAgICAgICAgY2FzZSAneCc6XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZSh0b0ludChpbnB1dCkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIFVOSVggVElNRVNUQU1QIFdJVEggTVNcbiAgICAgICAgY2FzZSAnWCc6XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShwYXJzZUZsb2F0KGlucHV0KSAqIDEwMDApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIFRJTUVaT05FXG4gICAgICAgIGNhc2UgJ1onIDogLy8gZmFsbCB0aHJvdWdoIHRvIFpaXG4gICAgICAgIGNhc2UgJ1paJyA6XG4gICAgICAgICAgICBjb25maWcuX3VzZVVUQyA9IHRydWU7XG4gICAgICAgICAgICBjb25maWcuX3R6bSA9IHRpbWV6b25lTWludXRlc0Zyb21TdHJpbmcoaW5wdXQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIFdFRUtEQVkgLSBodW1hblxuICAgICAgICBjYXNlICdkZCc6XG4gICAgICAgIGNhc2UgJ2RkZCc6XG4gICAgICAgIGNhc2UgJ2RkZGQnOlxuICAgICAgICAgICAgYSA9IGNvbmZpZy5fbG9jYWxlLndlZWtkYXlzUGFyc2UoaW5wdXQpO1xuICAgICAgICAgICAgLy8gaWYgd2UgZGlkbid0IGdldCBhIHdlZWtkYXkgbmFtZSwgbWFyayB0aGUgZGF0ZSBhcyBpbnZhbGlkXG4gICAgICAgICAgICBpZiAoYSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLl93ID0gY29uZmlnLl93IHx8IHt9O1xuICAgICAgICAgICAgICAgIGNvbmZpZy5fd1snZCddID0gYTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLl9wZi5pbnZhbGlkV2Vla2RheSA9IGlucHV0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIFdFRUssIFdFRUsgREFZIC0gbnVtZXJpY1xuICAgICAgICBjYXNlICd3JzpcbiAgICAgICAgY2FzZSAnd3cnOlxuICAgICAgICBjYXNlICdXJzpcbiAgICAgICAgY2FzZSAnV1cnOlxuICAgICAgICBjYXNlICdkJzpcbiAgICAgICAgY2FzZSAnZSc6XG4gICAgICAgIGNhc2UgJ0UnOlxuICAgICAgICAgICAgdG9rZW4gPSB0b2tlbi5zdWJzdHIoMCwgMSk7XG4gICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgIGNhc2UgJ2dnZ2cnOlxuICAgICAgICBjYXNlICdHR0dHJzpcbiAgICAgICAgY2FzZSAnR0dHR0cnOlxuICAgICAgICAgICAgdG9rZW4gPSB0b2tlbi5zdWJzdHIoMCwgMik7XG4gICAgICAgICAgICBpZiAoaW5wdXQpIHtcbiAgICAgICAgICAgICAgICBjb25maWcuX3cgPSBjb25maWcuX3cgfHwge307XG4gICAgICAgICAgICAgICAgY29uZmlnLl93W3Rva2VuXSA9IHRvSW50KGlucHV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdnZyc6XG4gICAgICAgIGNhc2UgJ0dHJzpcbiAgICAgICAgICAgIGNvbmZpZy5fdyA9IGNvbmZpZy5fdyB8fCB7fTtcbiAgICAgICAgICAgIGNvbmZpZy5fd1t0b2tlbl0gPSBtb21lbnQucGFyc2VUd29EaWdpdFllYXIoaW5wdXQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGF5T2ZZZWFyRnJvbVdlZWtJbmZvKGNvbmZpZykge1xuICAgICAgICB2YXIgdywgd2Vla1llYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95LCB0ZW1wO1xuXG4gICAgICAgIHcgPSBjb25maWcuX3c7XG4gICAgICAgIGlmICh3LkdHICE9IG51bGwgfHwgdy5XICE9IG51bGwgfHwgdy5FICE9IG51bGwpIHtcbiAgICAgICAgICAgIGRvdyA9IDE7XG4gICAgICAgICAgICBkb3kgPSA0O1xuXG4gICAgICAgICAgICAvLyBUT0RPOiBXZSBuZWVkIHRvIHRha2UgdGhlIGN1cnJlbnQgaXNvV2Vla1llYXIsIGJ1dCB0aGF0IGRlcGVuZHMgb25cbiAgICAgICAgICAgIC8vIGhvdyB3ZSBpbnRlcnByZXQgbm93IChsb2NhbCwgdXRjLCBmaXhlZCBvZmZzZXQpLiBTbyBjcmVhdGVcbiAgICAgICAgICAgIC8vIGEgbm93IHZlcnNpb24gb2YgY3VycmVudCBjb25maWcgKHRha2UgbG9jYWwvdXRjL29mZnNldCBmbGFncywgYW5kXG4gICAgICAgICAgICAvLyBjcmVhdGUgbm93KS5cbiAgICAgICAgICAgIHdlZWtZZWFyID0gZGZsKHcuR0csIGNvbmZpZy5fYVtZRUFSXSwgd2Vla09mWWVhcihtb21lbnQoKSwgMSwgNCkueWVhcik7XG4gICAgICAgICAgICB3ZWVrID0gZGZsKHcuVywgMSk7XG4gICAgICAgICAgICB3ZWVrZGF5ID0gZGZsKHcuRSwgMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkb3cgPSBjb25maWcuX2xvY2FsZS5fd2Vlay5kb3c7XG4gICAgICAgICAgICBkb3kgPSBjb25maWcuX2xvY2FsZS5fd2Vlay5kb3k7XG5cbiAgICAgICAgICAgIHdlZWtZZWFyID0gZGZsKHcuZ2csIGNvbmZpZy5fYVtZRUFSXSwgd2Vla09mWWVhcihtb21lbnQoKSwgZG93LCBkb3kpLnllYXIpO1xuICAgICAgICAgICAgd2VlayA9IGRmbCh3LncsIDEpO1xuXG4gICAgICAgICAgICBpZiAody5kICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyB3ZWVrZGF5IC0tIGxvdyBkYXkgbnVtYmVycyBhcmUgY29uc2lkZXJlZCBuZXh0IHdlZWtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5ID0gdy5kO1xuICAgICAgICAgICAgICAgIGlmICh3ZWVrZGF5IDwgZG93KSB7XG4gICAgICAgICAgICAgICAgICAgICsrd2VlaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHcuZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gbG9jYWwgd2Vla2RheSAtLSBjb3VudGluZyBzdGFydHMgZnJvbSBiZWdpbmluZyBvZiB3ZWVrXG4gICAgICAgICAgICAgICAgd2Vla2RheSA9IHcuZSArIGRvdztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZGVmYXVsdCB0byBiZWdpbmluZyBvZiB3ZWVrXG4gICAgICAgICAgICAgICAgd2Vla2RheSA9IGRvdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0ZW1wID0gZGF5T2ZZZWFyRnJvbVdlZWtzKHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3ksIGRvdyk7XG5cbiAgICAgICAgY29uZmlnLl9hW1lFQVJdID0gdGVtcC55ZWFyO1xuICAgICAgICBjb25maWcuX2RheU9mWWVhciA9IHRlbXAuZGF5T2ZZZWFyO1xuICAgIH1cblxuICAgIC8vIGNvbnZlcnQgYW4gYXJyYXkgdG8gYSBkYXRlLlxuICAgIC8vIHRoZSBhcnJheSBzaG91bGQgbWlycm9yIHRoZSBwYXJhbWV0ZXJzIGJlbG93XG4gICAgLy8gbm90ZTogYWxsIHZhbHVlcyBwYXN0IHRoZSB5ZWFyIGFyZSBvcHRpb25hbCBhbmQgd2lsbCBkZWZhdWx0IHRvIHRoZSBsb3dlc3QgcG9zc2libGUgdmFsdWUuXG4gICAgLy8gW3llYXIsIG1vbnRoLCBkYXkgLCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmRdXG4gICAgZnVuY3Rpb24gZGF0ZUZyb21Db25maWcoY29uZmlnKSB7XG4gICAgICAgIHZhciBpLCBkYXRlLCBpbnB1dCA9IFtdLCBjdXJyZW50RGF0ZSwgeWVhclRvVXNlO1xuXG4gICAgICAgIGlmIChjb25maWcuX2QpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnREYXRlID0gY3VycmVudERhdGVBcnJheShjb25maWcpO1xuXG4gICAgICAgIC8vY29tcHV0ZSBkYXkgb2YgdGhlIHllYXIgZnJvbSB3ZWVrcyBhbmQgd2Vla2RheXNcbiAgICAgICAgaWYgKGNvbmZpZy5fdyAmJiBjb25maWcuX2FbREFURV0gPT0gbnVsbCAmJiBjb25maWcuX2FbTU9OVEhdID09IG51bGwpIHtcbiAgICAgICAgICAgIGRheU9mWWVhckZyb21XZWVrSW5mbyhjb25maWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9pZiB0aGUgZGF5IG9mIHRoZSB5ZWFyIGlzIHNldCwgZmlndXJlIG91dCB3aGF0IGl0IGlzXG4gICAgICAgIGlmIChjb25maWcuX2RheU9mWWVhcikge1xuICAgICAgICAgICAgeWVhclRvVXNlID0gZGZsKGNvbmZpZy5fYVtZRUFSXSwgY3VycmVudERhdGVbWUVBUl0pO1xuXG4gICAgICAgICAgICBpZiAoY29uZmlnLl9kYXlPZlllYXIgPiBkYXlzSW5ZZWFyKHllYXJUb1VzZSkpIHtcbiAgICAgICAgICAgICAgICBjb25maWcuX3BmLl9vdmVyZmxvd0RheU9mWWVhciA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRhdGUgPSBtYWtlVVRDRGF0ZSh5ZWFyVG9Vc2UsIDAsIGNvbmZpZy5fZGF5T2ZZZWFyKTtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtNT05USF0gPSBkYXRlLmdldFVUQ01vbnRoKCk7XG4gICAgICAgICAgICBjb25maWcuX2FbREFURV0gPSBkYXRlLmdldFVUQ0RhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlZmF1bHQgdG8gY3VycmVudCBkYXRlLlxuICAgICAgICAvLyAqIGlmIG5vIHllYXIsIG1vbnRoLCBkYXkgb2YgbW9udGggYXJlIGdpdmVuLCBkZWZhdWx0IHRvIHRvZGF5XG4gICAgICAgIC8vICogaWYgZGF5IG9mIG1vbnRoIGlzIGdpdmVuLCBkZWZhdWx0IG1vbnRoIGFuZCB5ZWFyXG4gICAgICAgIC8vICogaWYgbW9udGggaXMgZ2l2ZW4sIGRlZmF1bHQgb25seSB5ZWFyXG4gICAgICAgIC8vICogaWYgeWVhciBpcyBnaXZlbiwgZG9uJ3QgZGVmYXVsdCBhbnl0aGluZ1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMyAmJiBjb25maWcuX2FbaV0gPT0gbnVsbDsgKytpKSB7XG4gICAgICAgICAgICBjb25maWcuX2FbaV0gPSBpbnB1dFtpXSA9IGN1cnJlbnREYXRlW2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gWmVybyBvdXQgd2hhdGV2ZXIgd2FzIG5vdCBkZWZhdWx0ZWQsIGluY2x1ZGluZyB0aW1lXG4gICAgICAgIGZvciAoOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgICAgICBjb25maWcuX2FbaV0gPSBpbnB1dFtpXSA9IChjb25maWcuX2FbaV0gPT0gbnVsbCkgPyAoaSA9PT0gMiA/IDEgOiAwKSA6IGNvbmZpZy5fYVtpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGZvciAyNDowMDowMC4wMDBcbiAgICAgICAgaWYgKGNvbmZpZy5fYVtIT1VSXSA9PT0gMjQgJiZcbiAgICAgICAgICAgICAgICBjb25maWcuX2FbTUlOVVRFXSA9PT0gMCAmJlxuICAgICAgICAgICAgICAgIGNvbmZpZy5fYVtTRUNPTkRdID09PSAwICYmXG4gICAgICAgICAgICAgICAgY29uZmlnLl9hW01JTExJU0VDT05EXSA9PT0gMCkge1xuICAgICAgICAgICAgY29uZmlnLl9uZXh0RGF5ID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtIT1VSXSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBjb25maWcuX2QgPSAoY29uZmlnLl91c2VVVEMgPyBtYWtlVVRDRGF0ZSA6IG1ha2VEYXRlKS5hcHBseShudWxsLCBpbnB1dCk7XG4gICAgICAgIC8vIEFwcGx5IHRpbWV6b25lIG9mZnNldCBmcm9tIGlucHV0LiBUaGUgYWN0dWFsIHpvbmUgY2FuIGJlIGNoYW5nZWRcbiAgICAgICAgLy8gd2l0aCBwYXJzZVpvbmUuXG4gICAgICAgIGlmIChjb25maWcuX3R6bSAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25maWcuX2Quc2V0VVRDTWludXRlcyhjb25maWcuX2QuZ2V0VVRDTWludXRlcygpICsgY29uZmlnLl90em0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbmZpZy5fbmV4dERheSkge1xuICAgICAgICAgICAgY29uZmlnLl9hW0hPVVJdID0gMjQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkYXRlRnJvbU9iamVjdChjb25maWcpIHtcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWRJbnB1dDtcblxuICAgICAgICBpZiAoY29uZmlnLl9kKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBub3JtYWxpemVkSW5wdXQgPSBub3JtYWxpemVPYmplY3RVbml0cyhjb25maWcuX2kpO1xuICAgICAgICBjb25maWcuX2EgPSBbXG4gICAgICAgICAgICBub3JtYWxpemVkSW5wdXQueWVhcixcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRJbnB1dC5tb250aCxcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRJbnB1dC5kYXkgfHwgbm9ybWFsaXplZElucHV0LmRhdGUsXG4gICAgICAgICAgICBub3JtYWxpemVkSW5wdXQuaG91cixcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRJbnB1dC5taW51dGUsXG4gICAgICAgICAgICBub3JtYWxpemVkSW5wdXQuc2Vjb25kLFxuICAgICAgICAgICAgbm9ybWFsaXplZElucHV0Lm1pbGxpc2Vjb25kXG4gICAgICAgIF07XG5cbiAgICAgICAgZGF0ZUZyb21Db25maWcoY29uZmlnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjdXJyZW50RGF0ZUFycmF5KGNvbmZpZykge1xuICAgICAgICB2YXIgbm93ID0gbmV3IERhdGUoKTtcbiAgICAgICAgaWYgKGNvbmZpZy5fdXNlVVRDKSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIG5vdy5nZXRVVENGdWxsWWVhcigpLFxuICAgICAgICAgICAgICAgIG5vdy5nZXRVVENNb250aCgpLFxuICAgICAgICAgICAgICAgIG5vdy5nZXRVVENEYXRlKClcbiAgICAgICAgICAgIF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gW25vdy5nZXRGdWxsWWVhcigpLCBub3cuZ2V0TW9udGgoKSwgbm93LmdldERhdGUoKV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBkYXRlIGZyb20gc3RyaW5nIGFuZCBmb3JtYXQgc3RyaW5nXG4gICAgZnVuY3Rpb24gbWFrZURhdGVGcm9tU3RyaW5nQW5kRm9ybWF0KGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnLl9mID09PSBtb21lbnQuSVNPXzg2MDEpIHtcbiAgICAgICAgICAgIHBhcnNlSVNPKGNvbmZpZyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25maWcuX2EgPSBbXTtcbiAgICAgICAgY29uZmlnLl9wZi5lbXB0eSA9IHRydWU7XG5cbiAgICAgICAgLy8gVGhpcyBhcnJheSBpcyB1c2VkIHRvIG1ha2UgYSBEYXRlLCBlaXRoZXIgd2l0aCBgbmV3IERhdGVgIG9yIGBEYXRlLlVUQ2BcbiAgICAgICAgdmFyIHN0cmluZyA9ICcnICsgY29uZmlnLl9pLFxuICAgICAgICAgICAgaSwgcGFyc2VkSW5wdXQsIHRva2VucywgdG9rZW4sIHNraXBwZWQsXG4gICAgICAgICAgICBzdHJpbmdMZW5ndGggPSBzdHJpbmcubGVuZ3RoLFxuICAgICAgICAgICAgdG90YWxQYXJzZWRJbnB1dExlbmd0aCA9IDA7XG5cbiAgICAgICAgdG9rZW5zID0gZXhwYW5kRm9ybWF0KGNvbmZpZy5fZiwgY29uZmlnLl9sb2NhbGUpLm1hdGNoKGZvcm1hdHRpbmdUb2tlbnMpIHx8IFtdO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgICAgICAgcGFyc2VkSW5wdXQgPSAoc3RyaW5nLm1hdGNoKGdldFBhcnNlUmVnZXhGb3JUb2tlbih0b2tlbiwgY29uZmlnKSkgfHwgW10pWzBdO1xuICAgICAgICAgICAgaWYgKHBhcnNlZElucHV0KSB7XG4gICAgICAgICAgICAgICAgc2tpcHBlZCA9IHN0cmluZy5zdWJzdHIoMCwgc3RyaW5nLmluZGV4T2YocGFyc2VkSW5wdXQpKTtcbiAgICAgICAgICAgICAgICBpZiAoc2tpcHBlZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5fcGYudW51c2VkSW5wdXQucHVzaChza2lwcGVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RyaW5nID0gc3RyaW5nLnNsaWNlKHN0cmluZy5pbmRleE9mKHBhcnNlZElucHV0KSArIHBhcnNlZElucHV0Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdG90YWxQYXJzZWRJbnB1dExlbmd0aCArPSBwYXJzZWRJbnB1dC5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBkb24ndCBwYXJzZSBpZiBpdCdzIG5vdCBhIGtub3duIHRva2VuXG4gICAgICAgICAgICBpZiAoZm9ybWF0VG9rZW5GdW5jdGlvbnNbdG9rZW5dKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlZElucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5fcGYuZW1wdHkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5fcGYudW51c2VkVG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhZGRUaW1lVG9BcnJheUZyb21Ub2tlbih0b2tlbiwgcGFyc2VkSW5wdXQsIGNvbmZpZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb25maWcuX3N0cmljdCAmJiAhcGFyc2VkSW5wdXQpIHtcbiAgICAgICAgICAgICAgICBjb25maWcuX3BmLnVudXNlZFRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkZCByZW1haW5pbmcgdW5wYXJzZWQgaW5wdXQgbGVuZ3RoIHRvIHRoZSBzdHJpbmdcbiAgICAgICAgY29uZmlnLl9wZi5jaGFyc0xlZnRPdmVyID0gc3RyaW5nTGVuZ3RoIC0gdG90YWxQYXJzZWRJbnB1dExlbmd0aDtcbiAgICAgICAgaWYgKHN0cmluZy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25maWcuX3BmLnVudXNlZElucHV0LnB1c2goc3RyaW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNsZWFyIF8xMmggZmxhZyBpZiBob3VyIGlzIDw9IDEyXG4gICAgICAgIGlmIChjb25maWcuX3BmLmJpZ0hvdXIgPT09IHRydWUgJiYgY29uZmlnLl9hW0hPVVJdIDw9IDEyKSB7XG4gICAgICAgICAgICBjb25maWcuX3BmLmJpZ0hvdXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaGFuZGxlIGFtIHBtXG4gICAgICAgIGlmIChjb25maWcuX2lzUG0gJiYgY29uZmlnLl9hW0hPVVJdIDwgMTIpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtIT1VSXSArPSAxMjtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiBpcyAxMiBhbSwgY2hhbmdlIGhvdXJzIHRvIDBcbiAgICAgICAgaWYgKGNvbmZpZy5faXNQbSA9PT0gZmFsc2UgJiYgY29uZmlnLl9hW0hPVVJdID09PSAxMikge1xuICAgICAgICAgICAgY29uZmlnLl9hW0hPVVJdID0gMDtcbiAgICAgICAgfVxuICAgICAgICBkYXRlRnJvbUNvbmZpZyhjb25maWcpO1xuICAgICAgICBjaGVja092ZXJmbG93KGNvbmZpZyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdW5lc2NhcGVGb3JtYXQocykge1xuICAgICAgICByZXR1cm4gcy5yZXBsYWNlKC9cXFxcKFxcWyl8XFxcXChcXF0pfFxcWyhbXlxcXVxcW10qKVxcXXxcXFxcKC4pL2csIGZ1bmN0aW9uIChtYXRjaGVkLCBwMSwgcDIsIHAzLCBwNCkge1xuICAgICAgICAgICAgcmV0dXJuIHAxIHx8IHAyIHx8IHAzIHx8IHA0O1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBDb2RlIGZyb20gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zNTYxNDkzL2lzLXRoZXJlLWEtcmVnZXhwLWVzY2FwZS1mdW5jdGlvbi1pbi1qYXZhc2NyaXB0XG4gICAgZnVuY3Rpb24gcmVnZXhwRXNjYXBlKHMpIHtcbiAgICAgICAgcmV0dXJuIHMucmVwbGFjZSgvWy1cXC9cXFxcXiQqKz8uKCl8W1xcXXt9XS9nLCAnXFxcXCQmJyk7XG4gICAgfVxuXG4gICAgLy8gZGF0ZSBmcm9tIHN0cmluZyBhbmQgYXJyYXkgb2YgZm9ybWF0IHN0cmluZ3NcbiAgICBmdW5jdGlvbiBtYWtlRGF0ZUZyb21TdHJpbmdBbmRBcnJheShjb25maWcpIHtcbiAgICAgICAgdmFyIHRlbXBDb25maWcsXG4gICAgICAgICAgICBiZXN0TW9tZW50LFxuXG4gICAgICAgICAgICBzY29yZVRvQmVhdCxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBjdXJyZW50U2NvcmU7XG5cbiAgICAgICAgaWYgKGNvbmZpZy5fZi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGNvbmZpZy5fcGYuaW52YWxpZEZvcm1hdCA9IHRydWU7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShOYU4pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvbmZpZy5fZi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY3VycmVudFNjb3JlID0gMDtcbiAgICAgICAgICAgIHRlbXBDb25maWcgPSBjb3B5Q29uZmlnKHt9LCBjb25maWcpO1xuICAgICAgICAgICAgaWYgKGNvbmZpZy5fdXNlVVRDICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0ZW1wQ29uZmlnLl91c2VVVEMgPSBjb25maWcuX3VzZVVUQztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRlbXBDb25maWcuX3BmID0gZGVmYXVsdFBhcnNpbmdGbGFncygpO1xuICAgICAgICAgICAgdGVtcENvbmZpZy5fZiA9IGNvbmZpZy5fZltpXTtcbiAgICAgICAgICAgIG1ha2VEYXRlRnJvbVN0cmluZ0FuZEZvcm1hdCh0ZW1wQ29uZmlnKTtcblxuICAgICAgICAgICAgaWYgKCFpc1ZhbGlkKHRlbXBDb25maWcpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIGFueSBpbnB1dCB0aGF0IHdhcyBub3QgcGFyc2VkIGFkZCBhIHBlbmFsdHkgZm9yIHRoYXQgZm9ybWF0XG4gICAgICAgICAgICBjdXJyZW50U2NvcmUgKz0gdGVtcENvbmZpZy5fcGYuY2hhcnNMZWZ0T3ZlcjtcblxuICAgICAgICAgICAgLy9vciB0b2tlbnNcbiAgICAgICAgICAgIGN1cnJlbnRTY29yZSArPSB0ZW1wQ29uZmlnLl9wZi51bnVzZWRUb2tlbnMubGVuZ3RoICogMTA7XG5cbiAgICAgICAgICAgIHRlbXBDb25maWcuX3BmLnNjb3JlID0gY3VycmVudFNjb3JlO1xuXG4gICAgICAgICAgICBpZiAoc2NvcmVUb0JlYXQgPT0gbnVsbCB8fCBjdXJyZW50U2NvcmUgPCBzY29yZVRvQmVhdCkge1xuICAgICAgICAgICAgICAgIHNjb3JlVG9CZWF0ID0gY3VycmVudFNjb3JlO1xuICAgICAgICAgICAgICAgIGJlc3RNb21lbnQgPSB0ZW1wQ29uZmlnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZXh0ZW5kKGNvbmZpZywgYmVzdE1vbWVudCB8fCB0ZW1wQ29uZmlnKTtcbiAgICB9XG5cbiAgICAvLyBkYXRlIGZyb20gaXNvIGZvcm1hdFxuICAgIGZ1bmN0aW9uIHBhcnNlSVNPKGNvbmZpZykge1xuICAgICAgICB2YXIgaSwgbCxcbiAgICAgICAgICAgIHN0cmluZyA9IGNvbmZpZy5faSxcbiAgICAgICAgICAgIG1hdGNoID0gaXNvUmVnZXguZXhlYyhzdHJpbmcpO1xuXG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgY29uZmlnLl9wZi5pc28gPSB0cnVlO1xuICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IGlzb0RhdGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpc29EYXRlc1tpXVsxXS5leGVjKHN0cmluZykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbWF0Y2hbNV0gc2hvdWxkIGJlICdUJyBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLl9mID0gaXNvRGF0ZXNbaV1bMF0gKyAobWF0Y2hbNl0gfHwgJyAnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IGlzb1RpbWVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpc29UaW1lc1tpXVsxXS5leGVjKHN0cmluZykpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLl9mICs9IGlzb1RpbWVzW2ldWzBdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RyaW5nLm1hdGNoKHBhcnNlVG9rZW5UaW1lem9uZSkpIHtcbiAgICAgICAgICAgICAgICBjb25maWcuX2YgKz0gJ1onO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWFrZURhdGVGcm9tU3RyaW5nQW5kRm9ybWF0KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGRhdGUgZnJvbSBpc28gZm9ybWF0IG9yIGZhbGxiYWNrXG4gICAgZnVuY3Rpb24gbWFrZURhdGVGcm9tU3RyaW5nKGNvbmZpZykge1xuICAgICAgICBwYXJzZUlTTyhjb25maWcpO1xuICAgICAgICBpZiAoY29uZmlnLl9pc1ZhbGlkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgZGVsZXRlIGNvbmZpZy5faXNWYWxpZDtcbiAgICAgICAgICAgIG1vbWVudC5jcmVhdGVGcm9tSW5wdXRGYWxsYmFjayhjb25maWcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFwKGFyciwgZm4pIHtcbiAgICAgICAgdmFyIHJlcyA9IFtdLCBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICByZXMucHVzaChmbihhcnJbaV0sIGkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VEYXRlRnJvbUlucHV0KGNvbmZpZykge1xuICAgICAgICB2YXIgaW5wdXQgPSBjb25maWcuX2ksIG1hdGNoZWQ7XG4gICAgICAgIGlmIChpbnB1dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZSgpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRGF0ZShpbnB1dCkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKCtpbnB1dCk7XG4gICAgICAgIH0gZWxzZSBpZiAoKG1hdGNoZWQgPSBhc3BOZXRKc29uUmVnZXguZXhlYyhpbnB1dCkpICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZSgrbWF0Y2hlZFsxXSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgbWFrZURhdGVGcm9tU3RyaW5nKGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fYSA9IG1hcChpbnB1dC5zbGljZSgwKSwgZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUludChvYmosIDEwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZGF0ZUZyb21Db25maWcoY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YoaW5wdXQpID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgZGF0ZUZyb21PYmplY3QoY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YoaW5wdXQpID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgLy8gZnJvbSBtaWxsaXNlY29uZHNcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKGlucHV0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1vbWVudC5jcmVhdGVGcm9tSW5wdXRGYWxsYmFjayhjb25maWcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZURhdGUoeSwgbSwgZCwgaCwgTSwgcywgbXMpIHtcbiAgICAgICAgLy9jYW4ndCBqdXN0IGFwcGx5KCkgdG8gY3JlYXRlIGEgZGF0ZTpcbiAgICAgICAgLy9odHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE4MTM0OC9pbnN0YW50aWF0aW5nLWEtamF2YXNjcmlwdC1vYmplY3QtYnktY2FsbGluZy1wcm90b3R5cGUtY29uc3RydWN0b3ItYXBwbHlcbiAgICAgICAgdmFyIGRhdGUgPSBuZXcgRGF0ZSh5LCBtLCBkLCBoLCBNLCBzLCBtcyk7XG5cbiAgICAgICAgLy90aGUgZGF0ZSBjb25zdHJ1Y3RvciBkb2Vzbid0IGFjY2VwdCB5ZWFycyA8IDE5NzBcbiAgICAgICAgaWYgKHkgPCAxOTcwKSB7XG4gICAgICAgICAgICBkYXRlLnNldEZ1bGxZZWFyKHkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VVVENEYXRlKHkpIHtcbiAgICAgICAgdmFyIGRhdGUgPSBuZXcgRGF0ZShEYXRlLlVUQy5hcHBseShudWxsLCBhcmd1bWVudHMpKTtcbiAgICAgICAgaWYgKHkgPCAxOTcwKSB7XG4gICAgICAgICAgICBkYXRlLnNldFVUQ0Z1bGxZZWFyKHkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlV2Vla2RheShpbnB1dCwgbG9jYWxlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAoIWlzTmFOKGlucHV0KSkge1xuICAgICAgICAgICAgICAgIGlucHV0ID0gcGFyc2VJbnQoaW5wdXQsIDEwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlucHV0ID0gbG9jYWxlLndlZWtkYXlzUGFyc2UoaW5wdXQpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgfVxuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICBSZWxhdGl2ZSBUaW1lXG4gICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cbiAgICAvLyBoZWxwZXIgZnVuY3Rpb24gZm9yIG1vbWVudC5mbi5mcm9tLCBtb21lbnQuZm4uZnJvbU5vdywgYW5kIG1vbWVudC5kdXJhdGlvbi5mbi5odW1hbml6ZVxuICAgIGZ1bmN0aW9uIHN1YnN0aXR1dGVUaW1lQWdvKHN0cmluZywgbnVtYmVyLCB3aXRob3V0U3VmZml4LCBpc0Z1dHVyZSwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUucmVsYXRpdmVUaW1lKG51bWJlciB8fCAxLCAhIXdpdGhvdXRTdWZmaXgsIHN0cmluZywgaXNGdXR1cmUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbGF0aXZlVGltZShwb3NOZWdEdXJhdGlvbiwgd2l0aG91dFN1ZmZpeCwgbG9jYWxlKSB7XG4gICAgICAgIHZhciBkdXJhdGlvbiA9IG1vbWVudC5kdXJhdGlvbihwb3NOZWdEdXJhdGlvbikuYWJzKCksXG4gICAgICAgICAgICBzZWNvbmRzID0gcm91bmQoZHVyYXRpb24uYXMoJ3MnKSksXG4gICAgICAgICAgICBtaW51dGVzID0gcm91bmQoZHVyYXRpb24uYXMoJ20nKSksXG4gICAgICAgICAgICBob3VycyA9IHJvdW5kKGR1cmF0aW9uLmFzKCdoJykpLFxuICAgICAgICAgICAgZGF5cyA9IHJvdW5kKGR1cmF0aW9uLmFzKCdkJykpLFxuICAgICAgICAgICAgbW9udGhzID0gcm91bmQoZHVyYXRpb24uYXMoJ00nKSksXG4gICAgICAgICAgICB5ZWFycyA9IHJvdW5kKGR1cmF0aW9uLmFzKCd5JykpLFxuXG4gICAgICAgICAgICBhcmdzID0gc2Vjb25kcyA8IHJlbGF0aXZlVGltZVRocmVzaG9sZHMucyAmJiBbJ3MnLCBzZWNvbmRzXSB8fFxuICAgICAgICAgICAgICAgIG1pbnV0ZXMgPT09IDEgJiYgWydtJ10gfHxcbiAgICAgICAgICAgICAgICBtaW51dGVzIDwgcmVsYXRpdmVUaW1lVGhyZXNob2xkcy5tICYmIFsnbW0nLCBtaW51dGVzXSB8fFxuICAgICAgICAgICAgICAgIGhvdXJzID09PSAxICYmIFsnaCddIHx8XG4gICAgICAgICAgICAgICAgaG91cnMgPCByZWxhdGl2ZVRpbWVUaHJlc2hvbGRzLmggJiYgWydoaCcsIGhvdXJzXSB8fFxuICAgICAgICAgICAgICAgIGRheXMgPT09IDEgJiYgWydkJ10gfHxcbiAgICAgICAgICAgICAgICBkYXlzIDwgcmVsYXRpdmVUaW1lVGhyZXNob2xkcy5kICYmIFsnZGQnLCBkYXlzXSB8fFxuICAgICAgICAgICAgICAgIG1vbnRocyA9PT0gMSAmJiBbJ00nXSB8fFxuICAgICAgICAgICAgICAgIG1vbnRocyA8IHJlbGF0aXZlVGltZVRocmVzaG9sZHMuTSAmJiBbJ01NJywgbW9udGhzXSB8fFxuICAgICAgICAgICAgICAgIHllYXJzID09PSAxICYmIFsneSddIHx8IFsneXknLCB5ZWFyc107XG5cbiAgICAgICAgYXJnc1syXSA9IHdpdGhvdXRTdWZmaXg7XG4gICAgICAgIGFyZ3NbM10gPSArcG9zTmVnRHVyYXRpb24gPiAwO1xuICAgICAgICBhcmdzWzRdID0gbG9jYWxlO1xuICAgICAgICByZXR1cm4gc3Vic3RpdHV0ZVRpbWVBZ28uYXBwbHkoe30sIGFyZ3MpO1xuICAgIH1cblxuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICBXZWVrIG9mIFllYXJcbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblxuICAgIC8vIGZpcnN0RGF5T2ZXZWVrICAgICAgIDAgPSBzdW4sIDYgPSBzYXRcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICB0aGUgZGF5IG9mIHRoZSB3ZWVrIHRoYXQgc3RhcnRzIHRoZSB3ZWVrXG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgKHVzdWFsbHkgc3VuZGF5IG9yIG1vbmRheSlcbiAgICAvLyBmaXJzdERheU9mV2Vla09mWWVhciAwID0gc3VuLCA2ID0gc2F0XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgdGhlIGZpcnN0IHdlZWsgaXMgdGhlIHdlZWsgdGhhdCBjb250YWlucyB0aGUgZmlyc3RcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICBvZiB0aGlzIGRheSBvZiB0aGUgd2Vla1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgIChlZy4gSVNPIHdlZWtzIHVzZSB0aHVyc2RheSAoNCkpXG4gICAgZnVuY3Rpb24gd2Vla09mWWVhcihtb20sIGZpcnN0RGF5T2ZXZWVrLCBmaXJzdERheU9mV2Vla09mWWVhcikge1xuICAgICAgICB2YXIgZW5kID0gZmlyc3REYXlPZldlZWtPZlllYXIgLSBmaXJzdERheU9mV2VlayxcbiAgICAgICAgICAgIGRheXNUb0RheU9mV2VlayA9IGZpcnN0RGF5T2ZXZWVrT2ZZZWFyIC0gbW9tLmRheSgpLFxuICAgICAgICAgICAgYWRqdXN0ZWRNb21lbnQ7XG5cblxuICAgICAgICBpZiAoZGF5c1RvRGF5T2ZXZWVrID4gZW5kKSB7XG4gICAgICAgICAgICBkYXlzVG9EYXlPZldlZWsgLT0gNztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkYXlzVG9EYXlPZldlZWsgPCBlbmQgLSA3KSB7XG4gICAgICAgICAgICBkYXlzVG9EYXlPZldlZWsgKz0gNztcbiAgICAgICAgfVxuXG4gICAgICAgIGFkanVzdGVkTW9tZW50ID0gbW9tZW50KG1vbSkuYWRkKGRheXNUb0RheU9mV2VlaywgJ2QnKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdlZWs6IE1hdGguY2VpbChhZGp1c3RlZE1vbWVudC5kYXlPZlllYXIoKSAvIDcpLFxuICAgICAgICAgICAgeWVhcjogYWRqdXN0ZWRNb21lbnQueWVhcigpXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy9odHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT193ZWVrX2RhdGUjQ2FsY3VsYXRpbmdfYV9kYXRlX2dpdmVuX3RoZV95ZWFyLjJDX3dlZWtfbnVtYmVyX2FuZF93ZWVrZGF5XG4gICAgZnVuY3Rpb24gZGF5T2ZZZWFyRnJvbVdlZWtzKHllYXIsIHdlZWssIHdlZWtkYXksIGZpcnN0RGF5T2ZXZWVrT2ZZZWFyLCBmaXJzdERheU9mV2Vlaykge1xuICAgICAgICB2YXIgZCA9IG1ha2VVVENEYXRlKHllYXIsIDAsIDEpLmdldFVUQ0RheSgpLCBkYXlzVG9BZGQsIGRheU9mWWVhcjtcblxuICAgICAgICBkID0gZCA9PT0gMCA/IDcgOiBkO1xuICAgICAgICB3ZWVrZGF5ID0gd2Vla2RheSAhPSBudWxsID8gd2Vla2RheSA6IGZpcnN0RGF5T2ZXZWVrO1xuICAgICAgICBkYXlzVG9BZGQgPSBmaXJzdERheU9mV2VlayAtIGQgKyAoZCA+IGZpcnN0RGF5T2ZXZWVrT2ZZZWFyID8gNyA6IDApIC0gKGQgPCBmaXJzdERheU9mV2VlayA/IDcgOiAwKTtcbiAgICAgICAgZGF5T2ZZZWFyID0gNyAqICh3ZWVrIC0gMSkgKyAod2Vla2RheSAtIGZpcnN0RGF5T2ZXZWVrKSArIGRheXNUb0FkZCArIDE7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHllYXI6IGRheU9mWWVhciA+IDAgPyB5ZWFyIDogeWVhciAtIDEsXG4gICAgICAgICAgICBkYXlPZlllYXI6IGRheU9mWWVhciA+IDAgPyAgZGF5T2ZZZWFyIDogZGF5c0luWWVhcih5ZWFyIC0gMSkgKyBkYXlPZlllYXJcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgIFRvcCBMZXZlbCBGdW5jdGlvbnNcbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICBmdW5jdGlvbiBtYWtlTW9tZW50KGNvbmZpZykge1xuICAgICAgICB2YXIgaW5wdXQgPSBjb25maWcuX2ksXG4gICAgICAgICAgICBmb3JtYXQgPSBjb25maWcuX2YsXG4gICAgICAgICAgICByZXM7XG5cbiAgICAgICAgY29uZmlnLl9sb2NhbGUgPSBjb25maWcuX2xvY2FsZSB8fCBtb21lbnQubG9jYWxlRGF0YShjb25maWcuX2wpO1xuXG4gICAgICAgIGlmIChpbnB1dCA9PT0gbnVsbCB8fCAoZm9ybWF0ID09PSB1bmRlZmluZWQgJiYgaW5wdXQgPT09ICcnKSkge1xuICAgICAgICAgICAgcmV0dXJuIG1vbWVudC5pbnZhbGlkKHtudWxsSW5wdXQ6IHRydWV9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25maWcuX2kgPSBpbnB1dCA9IGNvbmZpZy5fbG9jYWxlLnByZXBhcnNlKGlucHV0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtb21lbnQuaXNNb21lbnQoaW5wdXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE1vbWVudChpbnB1dCwgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZm9ybWF0KSB7XG4gICAgICAgICAgICBpZiAoaXNBcnJheShmb3JtYXQpKSB7XG4gICAgICAgICAgICAgICAgbWFrZURhdGVGcm9tU3RyaW5nQW5kQXJyYXkoY29uZmlnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWFrZURhdGVGcm9tU3RyaW5nQW5kRm9ybWF0KGNvbmZpZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYWtlRGF0ZUZyb21JbnB1dChjb25maWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzID0gbmV3IE1vbWVudChjb25maWcpO1xuICAgICAgICBpZiAocmVzLl9uZXh0RGF5KSB7XG4gICAgICAgICAgICAvLyBBZGRpbmcgaXMgc21hcnQgZW5vdWdoIGFyb3VuZCBEU1RcbiAgICAgICAgICAgIHJlcy5hZGQoMSwgJ2QnKTtcbiAgICAgICAgICAgIHJlcy5fbmV4dERheSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgbW9tZW50ID0gZnVuY3Rpb24gKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0KSB7XG4gICAgICAgIHZhciBjO1xuXG4gICAgICAgIGlmICh0eXBlb2YobG9jYWxlKSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICBzdHJpY3QgPSBsb2NhbGU7XG4gICAgICAgICAgICBsb2NhbGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gb2JqZWN0IGNvbnN0cnVjdGlvbiBtdXN0IGJlIGRvbmUgdGhpcyB3YXkuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8xNDIzXG4gICAgICAgIGMgPSB7fTtcbiAgICAgICAgYy5faXNBTW9tZW50T2JqZWN0ID0gdHJ1ZTtcbiAgICAgICAgYy5faSA9IGlucHV0O1xuICAgICAgICBjLl9mID0gZm9ybWF0O1xuICAgICAgICBjLl9sID0gbG9jYWxlO1xuICAgICAgICBjLl9zdHJpY3QgPSBzdHJpY3Q7XG4gICAgICAgIGMuX2lzVVRDID0gZmFsc2U7XG4gICAgICAgIGMuX3BmID0gZGVmYXVsdFBhcnNpbmdGbGFncygpO1xuXG4gICAgICAgIHJldHVybiBtYWtlTW9tZW50KGMpO1xuICAgIH07XG5cbiAgICBtb21lbnQuc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmdzID0gZmFsc2U7XG5cbiAgICBtb21lbnQuY3JlYXRlRnJvbUlucHV0RmFsbGJhY2sgPSBkZXByZWNhdGUoXG4gICAgICAgICdtb21lbnQgY29uc3RydWN0aW9uIGZhbGxzIGJhY2sgdG8ganMgRGF0ZS4gVGhpcyBpcyAnICtcbiAgICAgICAgJ2Rpc2NvdXJhZ2VkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdXBjb21pbmcgbWFqb3IgJyArXG4gICAgICAgICdyZWxlYXNlLiBQbGVhc2UgcmVmZXIgdG8gJyArXG4gICAgICAgICdodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMTQwNyBmb3IgbW9yZSBpbmZvLicsXG4gICAgICAgIGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKGNvbmZpZy5faSArIChjb25maWcuX3VzZVVUQyA/ICcgVVRDJyA6ICcnKSk7XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgLy8gUGljayBhIG1vbWVudCBtIGZyb20gbW9tZW50cyBzbyB0aGF0IG1bZm5dKG90aGVyKSBpcyB0cnVlIGZvciBhbGxcbiAgICAvLyBvdGhlci4gVGhpcyByZWxpZXMgb24gdGhlIGZ1bmN0aW9uIGZuIHRvIGJlIHRyYW5zaXRpdmUuXG4gICAgLy9cbiAgICAvLyBtb21lbnRzIHNob3VsZCBlaXRoZXIgYmUgYW4gYXJyYXkgb2YgbW9tZW50IG9iamVjdHMgb3IgYW4gYXJyYXksIHdob3NlXG4gICAgLy8gZmlyc3QgZWxlbWVudCBpcyBhbiBhcnJheSBvZiBtb21lbnQgb2JqZWN0cy5cbiAgICBmdW5jdGlvbiBwaWNrQnkoZm4sIG1vbWVudHMpIHtcbiAgICAgICAgdmFyIHJlcywgaTtcbiAgICAgICAgaWYgKG1vbWVudHMubGVuZ3RoID09PSAxICYmIGlzQXJyYXkobW9tZW50c1swXSkpIHtcbiAgICAgICAgICAgIG1vbWVudHMgPSBtb21lbnRzWzBdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbW9tZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBtb21lbnQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXMgPSBtb21lbnRzWzBdO1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgbW9tZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKG1vbWVudHNbaV1bZm5dKHJlcykpIHtcbiAgICAgICAgICAgICAgICByZXMgPSBtb21lbnRzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgbW9tZW50Lm1pbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG5cbiAgICAgICAgcmV0dXJuIHBpY2tCeSgnaXNCZWZvcmUnLCBhcmdzKTtcbiAgICB9O1xuXG4gICAgbW9tZW50Lm1heCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG5cbiAgICAgICAgcmV0dXJuIHBpY2tCeSgnaXNBZnRlcicsIGFyZ3MpO1xuICAgIH07XG5cbiAgICAvLyBjcmVhdGluZyB3aXRoIHV0Y1xuICAgIG1vbWVudC51dGMgPSBmdW5jdGlvbiAoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QpIHtcbiAgICAgICAgdmFyIGM7XG5cbiAgICAgICAgaWYgKHR5cGVvZihsb2NhbGUpID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHN0cmljdCA9IGxvY2FsZTtcbiAgICAgICAgICAgIGxvY2FsZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBvYmplY3QgY29uc3RydWN0aW9uIG11c3QgYmUgZG9uZSB0aGlzIHdheS5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzE0MjNcbiAgICAgICAgYyA9IHt9O1xuICAgICAgICBjLl9pc0FNb21lbnRPYmplY3QgPSB0cnVlO1xuICAgICAgICBjLl91c2VVVEMgPSB0cnVlO1xuICAgICAgICBjLl9pc1VUQyA9IHRydWU7XG4gICAgICAgIGMuX2wgPSBsb2NhbGU7XG4gICAgICAgIGMuX2kgPSBpbnB1dDtcbiAgICAgICAgYy5fZiA9IGZvcm1hdDtcbiAgICAgICAgYy5fc3RyaWN0ID0gc3RyaWN0O1xuICAgICAgICBjLl9wZiA9IGRlZmF1bHRQYXJzaW5nRmxhZ3MoKTtcblxuICAgICAgICByZXR1cm4gbWFrZU1vbWVudChjKS51dGMoKTtcbiAgICB9O1xuXG4gICAgLy8gY3JlYXRpbmcgd2l0aCB1bml4IHRpbWVzdGFtcCAoaW4gc2Vjb25kcylcbiAgICBtb21lbnQudW5peCA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICByZXR1cm4gbW9tZW50KGlucHV0ICogMTAwMCk7XG4gICAgfTtcblxuICAgIC8vIGR1cmF0aW9uXG4gICAgbW9tZW50LmR1cmF0aW9uID0gZnVuY3Rpb24gKGlucHV0LCBrZXkpIHtcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gaW5wdXQsXG4gICAgICAgICAgICAvLyBtYXRjaGluZyBhZ2FpbnN0IHJlZ2V4cCBpcyBleHBlbnNpdmUsIGRvIGl0IG9uIGRlbWFuZFxuICAgICAgICAgICAgbWF0Y2ggPSBudWxsLFxuICAgICAgICAgICAgc2lnbixcbiAgICAgICAgICAgIHJldCxcbiAgICAgICAgICAgIHBhcnNlSXNvLFxuICAgICAgICAgICAgZGlmZlJlcztcblxuICAgICAgICBpZiAobW9tZW50LmlzRHVyYXRpb24oaW5wdXQpKSB7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHtcbiAgICAgICAgICAgICAgICBtczogaW5wdXQuX21pbGxpc2Vjb25kcyxcbiAgICAgICAgICAgICAgICBkOiBpbnB1dC5fZGF5cyxcbiAgICAgICAgICAgICAgICBNOiBpbnB1dC5fbW9udGhzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge307XG4gICAgICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgZHVyYXRpb25ba2V5XSA9IGlucHV0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkdXJhdGlvbi5taWxsaXNlY29uZHMgPSBpbnB1dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghIShtYXRjaCA9IGFzcE5ldFRpbWVTcGFuSnNvblJlZ2V4LmV4ZWMoaW5wdXQpKSkge1xuICAgICAgICAgICAgc2lnbiA9IChtYXRjaFsxXSA9PT0gJy0nKSA/IC0xIDogMTtcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge1xuICAgICAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICAgICAgZDogdG9JbnQobWF0Y2hbREFURV0pICogc2lnbixcbiAgICAgICAgICAgICAgICBoOiB0b0ludChtYXRjaFtIT1VSXSkgKiBzaWduLFxuICAgICAgICAgICAgICAgIG06IHRvSW50KG1hdGNoW01JTlVURV0pICogc2lnbixcbiAgICAgICAgICAgICAgICBzOiB0b0ludChtYXRjaFtTRUNPTkRdKSAqIHNpZ24sXG4gICAgICAgICAgICAgICAgbXM6IHRvSW50KG1hdGNoW01JTExJU0VDT05EXSkgKiBzaWduXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKCEhKG1hdGNoID0gaXNvRHVyYXRpb25SZWdleC5leGVjKGlucHV0KSkpIHtcbiAgICAgICAgICAgIHNpZ24gPSAobWF0Y2hbMV0gPT09ICctJykgPyAtMSA6IDE7XG4gICAgICAgICAgICBwYXJzZUlzbyA9IGZ1bmN0aW9uIChpbnApIHtcbiAgICAgICAgICAgICAgICAvLyBXZSdkIG5vcm1hbGx5IHVzZSB+fmlucCBmb3IgdGhpcywgYnV0IHVuZm9ydHVuYXRlbHkgaXQgYWxzb1xuICAgICAgICAgICAgICAgIC8vIGNvbnZlcnRzIGZsb2F0cyB0byBpbnRzLlxuICAgICAgICAgICAgICAgIC8vIGlucCBtYXkgYmUgdW5kZWZpbmVkLCBzbyBjYXJlZnVsIGNhbGxpbmcgcmVwbGFjZSBvbiBpdC5cbiAgICAgICAgICAgICAgICB2YXIgcmVzID0gaW5wICYmIHBhcnNlRmxvYXQoaW5wLnJlcGxhY2UoJywnLCAnLicpKTtcbiAgICAgICAgICAgICAgICAvLyBhcHBseSBzaWduIHdoaWxlIHdlJ3JlIGF0IGl0XG4gICAgICAgICAgICAgICAgcmV0dXJuIChpc05hTihyZXMpID8gMCA6IHJlcykgKiBzaWduO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge1xuICAgICAgICAgICAgICAgIHk6IHBhcnNlSXNvKG1hdGNoWzJdKSxcbiAgICAgICAgICAgICAgICBNOiBwYXJzZUlzbyhtYXRjaFszXSksXG4gICAgICAgICAgICAgICAgZDogcGFyc2VJc28obWF0Y2hbNF0pLFxuICAgICAgICAgICAgICAgIGg6IHBhcnNlSXNvKG1hdGNoWzVdKSxcbiAgICAgICAgICAgICAgICBtOiBwYXJzZUlzbyhtYXRjaFs2XSksXG4gICAgICAgICAgICAgICAgczogcGFyc2VJc28obWF0Y2hbN10pLFxuICAgICAgICAgICAgICAgIHc6IHBhcnNlSXNvKG1hdGNoWzhdKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZHVyYXRpb24gPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAgICAgKCdmcm9tJyBpbiBkdXJhdGlvbiB8fCAndG8nIGluIGR1cmF0aW9uKSkge1xuICAgICAgICAgICAgZGlmZlJlcyA9IG1vbWVudHNEaWZmZXJlbmNlKG1vbWVudChkdXJhdGlvbi5mcm9tKSwgbW9tZW50KGR1cmF0aW9uLnRvKSk7XG5cbiAgICAgICAgICAgIGR1cmF0aW9uID0ge307XG4gICAgICAgICAgICBkdXJhdGlvbi5tcyA9IGRpZmZSZXMubWlsbGlzZWNvbmRzO1xuICAgICAgICAgICAgZHVyYXRpb24uTSA9IGRpZmZSZXMubW9udGhzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0ID0gbmV3IER1cmF0aW9uKGR1cmF0aW9uKTtcblxuICAgICAgICBpZiAobW9tZW50LmlzRHVyYXRpb24oaW5wdXQpICYmIGhhc093blByb3AoaW5wdXQsICdfbG9jYWxlJykpIHtcbiAgICAgICAgICAgIHJldC5fbG9jYWxlID0gaW5wdXQuX2xvY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcblxuICAgIC8vIHZlcnNpb24gbnVtYmVyXG4gICAgbW9tZW50LnZlcnNpb24gPSBWRVJTSU9OO1xuXG4gICAgLy8gZGVmYXVsdCBmb3JtYXRcbiAgICBtb21lbnQuZGVmYXVsdEZvcm1hdCA9IGlzb0Zvcm1hdDtcblxuICAgIC8vIGNvbnN0YW50IHRoYXQgcmVmZXJzIHRvIHRoZSBJU08gc3RhbmRhcmRcbiAgICBtb21lbnQuSVNPXzg2MDEgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgIC8vIFBsdWdpbnMgdGhhdCBhZGQgcHJvcGVydGllcyBzaG91bGQgYWxzbyBhZGQgdGhlIGtleSBoZXJlIChudWxsIHZhbHVlKSxcbiAgICAvLyBzbyB3ZSBjYW4gcHJvcGVybHkgY2xvbmUgb3Vyc2VsdmVzLlxuICAgIG1vbWVudC5tb21lbnRQcm9wZXJ0aWVzID0gbW9tZW50UHJvcGVydGllcztcblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2hlbmV2ZXIgYSBtb21lbnQgaXMgbXV0YXRlZC5cbiAgICAvLyBJdCBpcyBpbnRlbmRlZCB0byBrZWVwIHRoZSBvZmZzZXQgaW4gc3luYyB3aXRoIHRoZSB0aW1lem9uZS5cbiAgICBtb21lbnQudXBkYXRlT2Zmc2V0ID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGFsbG93cyB5b3UgdG8gc2V0IGEgdGhyZXNob2xkIGZvciByZWxhdGl2ZSB0aW1lIHN0cmluZ3NcbiAgICBtb21lbnQucmVsYXRpdmVUaW1lVGhyZXNob2xkID0gZnVuY3Rpb24gKHRocmVzaG9sZCwgbGltaXQpIHtcbiAgICAgICAgaWYgKHJlbGF0aXZlVGltZVRocmVzaG9sZHNbdGhyZXNob2xkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbWl0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiByZWxhdGl2ZVRpbWVUaHJlc2hvbGRzW3RocmVzaG9sZF07XG4gICAgICAgIH1cbiAgICAgICAgcmVsYXRpdmVUaW1lVGhyZXNob2xkc1t0aHJlc2hvbGRdID0gbGltaXQ7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICBtb21lbnQubGFuZyA9IGRlcHJlY2F0ZShcbiAgICAgICAgJ21vbWVudC5sYW5nIGlzIGRlcHJlY2F0ZWQuIFVzZSBtb21lbnQubG9jYWxlIGluc3RlYWQuJyxcbiAgICAgICAgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBtb21lbnQubG9jYWxlKGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgKTtcblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gd2lsbCBsb2FkIGxvY2FsZSBhbmQgdGhlbiBzZXQgdGhlIGdsb2JhbCBsb2NhbGUuICBJZlxuICAgIC8vIG5vIGFyZ3VtZW50cyBhcmUgcGFzc2VkIGluLCBpdCB3aWxsIHNpbXBseSByZXR1cm4gdGhlIGN1cnJlbnQgZ2xvYmFsXG4gICAgLy8gbG9jYWxlIGtleS5cbiAgICBtb21lbnQubG9jYWxlID0gZnVuY3Rpb24gKGtleSwgdmFsdWVzKSB7XG4gICAgICAgIHZhciBkYXRhO1xuICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mKHZhbHVlcykgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IG1vbWVudC5kZWZpbmVMb2NhbGUoa2V5LCB2YWx1ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IG1vbWVudC5sb2NhbGVEYXRhKGtleSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgbW9tZW50LmR1cmF0aW9uLl9sb2NhbGUgPSBtb21lbnQuX2xvY2FsZSA9IGRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbW9tZW50Ll9sb2NhbGUuX2FiYnI7XG4gICAgfTtcblxuICAgIG1vbWVudC5kZWZpbmVMb2NhbGUgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWVzKSB7XG4gICAgICAgIGlmICh2YWx1ZXMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhbHVlcy5hYmJyID0gbmFtZTtcbiAgICAgICAgICAgIGlmICghbG9jYWxlc1tuYW1lXSkge1xuICAgICAgICAgICAgICAgIGxvY2FsZXNbbmFtZV0gPSBuZXcgTG9jYWxlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2NhbGVzW25hbWVdLnNldCh2YWx1ZXMpO1xuXG4gICAgICAgICAgICAvLyBiYWNrd2FyZHMgY29tcGF0IGZvciBub3c6IGFsc28gc2V0IHRoZSBsb2NhbGVcbiAgICAgICAgICAgIG1vbWVudC5sb2NhbGUobmFtZSk7XG5cbiAgICAgICAgICAgIHJldHVybiBsb2NhbGVzW25hbWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gdXNlZnVsIGZvciB0ZXN0aW5nXG4gICAgICAgICAgICBkZWxldGUgbG9jYWxlc1tuYW1lXTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIG1vbWVudC5sYW5nRGF0YSA9IGRlcHJlY2F0ZShcbiAgICAgICAgJ21vbWVudC5sYW5nRGF0YSBpcyBkZXByZWNhdGVkLiBVc2UgbW9tZW50LmxvY2FsZURhdGEgaW5zdGVhZC4nLFxuICAgICAgICBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gbW9tZW50LmxvY2FsZURhdGEoa2V5KTtcbiAgICAgICAgfVxuICAgICk7XG5cbiAgICAvLyByZXR1cm5zIGxvY2FsZSBkYXRhXG4gICAgbW9tZW50LmxvY2FsZURhdGEgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciBsb2NhbGU7XG5cbiAgICAgICAgaWYgKGtleSAmJiBrZXkuX2xvY2FsZSAmJiBrZXkuX2xvY2FsZS5fYWJicikge1xuICAgICAgICAgICAga2V5ID0ga2V5Ll9sb2NhbGUuX2FiYnI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWtleSkge1xuICAgICAgICAgICAgcmV0dXJuIG1vbWVudC5fbG9jYWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc0FycmF5KGtleSkpIHtcbiAgICAgICAgICAgIC8vc2hvcnQtY2lyY3VpdCBldmVyeXRoaW5nIGVsc2VcbiAgICAgICAgICAgIGxvY2FsZSA9IGxvYWRMb2NhbGUoa2V5KTtcbiAgICAgICAgICAgIGlmIChsb2NhbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAga2V5ID0gW2tleV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2hvb3NlTG9jYWxlKGtleSk7XG4gICAgfTtcblxuICAgIC8vIGNvbXBhcmUgbW9tZW50IG9iamVjdFxuICAgIG1vbWVudC5pc01vbWVudCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIE1vbWVudCB8fFxuICAgICAgICAgICAgKG9iaiAhPSBudWxsICYmIGhhc093blByb3Aob2JqLCAnX2lzQU1vbWVudE9iamVjdCcpKTtcbiAgICB9O1xuXG4gICAgLy8gZm9yIHR5cGVjaGVja2luZyBEdXJhdGlvbiBvYmplY3RzXG4gICAgbW9tZW50LmlzRHVyYXRpb24gPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBEdXJhdGlvbjtcbiAgICB9O1xuXG4gICAgZm9yIChpID0gbGlzdHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgbWFrZUxpc3QobGlzdHNbaV0pO1xuICAgIH1cblxuICAgIG1vbWVudC5ub3JtYWxpemVVbml0cyA9IGZ1bmN0aW9uICh1bml0cykge1xuICAgICAgICByZXR1cm4gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgIH07XG5cbiAgICBtb21lbnQuaW52YWxpZCA9IGZ1bmN0aW9uIChmbGFncykge1xuICAgICAgICB2YXIgbSA9IG1vbWVudC51dGMoTmFOKTtcbiAgICAgICAgaWYgKGZsYWdzICE9IG51bGwpIHtcbiAgICAgICAgICAgIGV4dGVuZChtLl9wZiwgZmxhZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbS5fcGYudXNlckludmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtO1xuICAgIH07XG5cbiAgICBtb21lbnQucGFyc2Vab25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbW9tZW50LmFwcGx5KG51bGwsIGFyZ3VtZW50cykucGFyc2Vab25lKCk7XG4gICAgfTtcblxuICAgIG1vbWVudC5wYXJzZVR3b0RpZ2l0WWVhciA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICByZXR1cm4gdG9JbnQoaW5wdXQpICsgKHRvSW50KGlucHV0KSA+IDY4ID8gMTkwMCA6IDIwMDApO1xuICAgIH07XG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgIE1vbWVudCBQcm90b3R5cGVcbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblxuICAgIGV4dGVuZChtb21lbnQuZm4gPSBNb21lbnQucHJvdG90eXBlLCB7XG5cbiAgICAgICAgY2xvbmUgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbW9tZW50KHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHZhbHVlT2YgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gK3RoaXMuX2QgKyAoKHRoaXMuX29mZnNldCB8fCAwKSAqIDYwMDAwKTtcbiAgICAgICAgfSxcblxuICAgICAgICB1bml4IDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoK3RoaXMgLyAxMDAwKTtcbiAgICAgICAgfSxcblxuICAgICAgICB0b1N0cmluZyA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkubG9jYWxlKCdlbicpLmZvcm1hdCgnZGRkIE1NTSBERCBZWVlZIEhIOm1tOnNzIFtHTVRdWlonKTtcbiAgICAgICAgfSxcblxuICAgICAgICB0b0RhdGUgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fb2Zmc2V0ID8gbmV3IERhdGUoK3RoaXMpIDogdGhpcy5fZDtcbiAgICAgICAgfSxcblxuICAgICAgICB0b0lTT1N0cmluZyA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBtID0gbW9tZW50KHRoaXMpLnV0YygpO1xuICAgICAgICAgICAgaWYgKDAgPCBtLnllYXIoKSAmJiBtLnllYXIoKSA8PSA5OTk5KSB7XG4gICAgICAgICAgICAgICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZykge1xuICAgICAgICAgICAgICAgICAgICAvLyBuYXRpdmUgaW1wbGVtZW50YXRpb24gaXMgfjUweCBmYXN0ZXIsIHVzZSBpdCB3aGVuIHdlIGNhblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50b0RhdGUoKS50b0lTT1N0cmluZygpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmb3JtYXRNb21lbnQobSwgJ1lZWVktTU0tRERbVF1ISDptbTpzcy5TU1NbWl0nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBmb3JtYXRNb21lbnQobSwgJ1lZWVlZWS1NTS1ERFtUXUhIOm1tOnNzLlNTU1taXScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHRvQXJyYXkgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbSA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIG0ueWVhcigpLFxuICAgICAgICAgICAgICAgIG0ubW9udGgoKSxcbiAgICAgICAgICAgICAgICBtLmRhdGUoKSxcbiAgICAgICAgICAgICAgICBtLmhvdXJzKCksXG4gICAgICAgICAgICAgICAgbS5taW51dGVzKCksXG4gICAgICAgICAgICAgICAgbS5zZWNvbmRzKCksXG4gICAgICAgICAgICAgICAgbS5taWxsaXNlY29uZHMoKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfSxcblxuICAgICAgICBpc1ZhbGlkIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGlzVmFsaWQodGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNEU1RTaGlmdGVkIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2EpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgJiYgY29tcGFyZUFycmF5cyh0aGlzLl9hLCAodGhpcy5faXNVVEMgPyBtb21lbnQudXRjKHRoaXMuX2EpIDogbW9tZW50KHRoaXMuX2EpKS50b0FycmF5KCkpID4gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LFxuXG4gICAgICAgIHBhcnNpbmdGbGFncyA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBleHRlbmQoe30sIHRoaXMuX3BmKTtcbiAgICAgICAgfSxcblxuICAgICAgICBpbnZhbGlkQXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wZi5vdmVyZmxvdztcbiAgICAgICAgfSxcblxuICAgICAgICB1dGMgOiBmdW5jdGlvbiAoa2VlcExvY2FsVGltZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuem9uZSgwLCBrZWVwTG9jYWxUaW1lKTtcbiAgICAgICAgfSxcblxuICAgICAgICBsb2NhbCA6IGZ1bmN0aW9uIChrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5faXNVVEMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnpvbmUoMCwga2VlcExvY2FsVGltZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5faXNVVEMgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgIGlmIChrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkKHRoaXMuX2RhdGVUek9mZnNldCgpLCAnbScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZvcm1hdCA6IGZ1bmN0aW9uIChpbnB1dFN0cmluZykge1xuICAgICAgICAgICAgdmFyIG91dHB1dCA9IGZvcm1hdE1vbWVudCh0aGlzLCBpbnB1dFN0cmluZyB8fCBtb21lbnQuZGVmYXVsdEZvcm1hdCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkucG9zdGZvcm1hdChvdXRwdXQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFkZCA6IGNyZWF0ZUFkZGVyKDEsICdhZGQnKSxcblxuICAgICAgICBzdWJ0cmFjdCA6IGNyZWF0ZUFkZGVyKC0xLCAnc3VidHJhY3QnKSxcblxuICAgICAgICBkaWZmIDogZnVuY3Rpb24gKGlucHV0LCB1bml0cywgYXNGbG9hdCkge1xuICAgICAgICAgICAgdmFyIHRoYXQgPSBtYWtlQXMoaW5wdXQsIHRoaXMpLFxuICAgICAgICAgICAgICAgIHpvbmVEaWZmID0gKHRoaXMuem9uZSgpIC0gdGhhdC56b25lKCkpICogNmU0LFxuICAgICAgICAgICAgICAgIGRpZmYsIG91dHB1dCwgZGF5c0FkanVzdDtcblxuICAgICAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG5cbiAgICAgICAgICAgIGlmICh1bml0cyA9PT0gJ3llYXInIHx8IHVuaXRzID09PSAnbW9udGgnKSB7XG4gICAgICAgICAgICAgICAgLy8gYXZlcmFnZSBudW1iZXIgb2YgZGF5cyBpbiB0aGUgbW9udGhzIGluIHRoZSBnaXZlbiBkYXRlc1xuICAgICAgICAgICAgICAgIGRpZmYgPSAodGhpcy5kYXlzSW5Nb250aCgpICsgdGhhdC5kYXlzSW5Nb250aCgpKSAqIDQzMmU1OyAvLyAyNCAqIDYwICogNjAgKiAxMDAwIC8gMlxuICAgICAgICAgICAgICAgIC8vIGRpZmZlcmVuY2UgaW4gbW9udGhzXG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gKCh0aGlzLnllYXIoKSAtIHRoYXQueWVhcigpKSAqIDEyKSArICh0aGlzLm1vbnRoKCkgLSB0aGF0Lm1vbnRoKCkpO1xuICAgICAgICAgICAgICAgIC8vIGFkanVzdCBieSB0YWtpbmcgZGlmZmVyZW5jZSBpbiBkYXlzLCBhdmVyYWdlIG51bWJlciBvZiBkYXlzXG4gICAgICAgICAgICAgICAgLy8gYW5kIGRzdCBpbiB0aGUgZ2l2ZW4gbW9udGhzLlxuICAgICAgICAgICAgICAgIGRheXNBZGp1c3QgPSAodGhpcyAtIG1vbWVudCh0aGlzKS5zdGFydE9mKCdtb250aCcpKSAtXG4gICAgICAgICAgICAgICAgICAgICh0aGF0IC0gbW9tZW50KHRoYXQpLnN0YXJ0T2YoJ21vbnRoJykpO1xuICAgICAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdpdGggem9uZXMsIHRvIG5lZ2F0ZSBhbGwgZHN0XG4gICAgICAgICAgICAgICAgZGF5c0FkanVzdCAtPSAoKHRoaXMuem9uZSgpIC0gbW9tZW50KHRoaXMpLnN0YXJ0T2YoJ21vbnRoJykuem9uZSgpKSAtXG4gICAgICAgICAgICAgICAgICAgICAgICAodGhhdC56b25lKCkgLSBtb21lbnQodGhhdCkuc3RhcnRPZignbW9udGgnKS56b25lKCkpKSAqIDZlNDtcbiAgICAgICAgICAgICAgICBvdXRwdXQgKz0gZGF5c0FkanVzdCAvIGRpZmY7XG4gICAgICAgICAgICAgICAgaWYgKHVuaXRzID09PSAneWVhcicpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0ID0gb3V0cHV0IC8gMTI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkaWZmID0gKHRoaXMgLSB0aGF0KTtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSB1bml0cyA9PT0gJ3NlY29uZCcgPyBkaWZmIC8gMWUzIDogLy8gMTAwMFxuICAgICAgICAgICAgICAgICAgICB1bml0cyA9PT0gJ21pbnV0ZScgPyBkaWZmIC8gNmU0IDogLy8gMTAwMCAqIDYwXG4gICAgICAgICAgICAgICAgICAgIHVuaXRzID09PSAnaG91cicgPyBkaWZmIC8gMzZlNSA6IC8vIDEwMDAgKiA2MCAqIDYwXG4gICAgICAgICAgICAgICAgICAgIHVuaXRzID09PSAnZGF5JyA/IChkaWZmIC0gem9uZURpZmYpIC8gODY0ZTUgOiAvLyAxMDAwICogNjAgKiA2MCAqIDI0LCBuZWdhdGUgZHN0XG4gICAgICAgICAgICAgICAgICAgIHVuaXRzID09PSAnd2VlaycgPyAoZGlmZiAtIHpvbmVEaWZmKSAvIDYwNDhlNSA6IC8vIDEwMDAgKiA2MCAqIDYwICogMjQgKiA3LCBuZWdhdGUgZHN0XG4gICAgICAgICAgICAgICAgICAgIGRpZmY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXNGbG9hdCA/IG91dHB1dCA6IGFic1JvdW5kKG91dHB1dCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZnJvbSA6IGZ1bmN0aW9uICh0aW1lLCB3aXRob3V0U3VmZml4KSB7XG4gICAgICAgICAgICByZXR1cm4gbW9tZW50LmR1cmF0aW9uKHt0bzogdGhpcywgZnJvbTogdGltZX0pLmxvY2FsZSh0aGlzLmxvY2FsZSgpKS5odW1hbml6ZSghd2l0aG91dFN1ZmZpeCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZnJvbU5vdyA6IGZ1bmN0aW9uICh3aXRob3V0U3VmZml4KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mcm9tKG1vbWVudCgpLCB3aXRob3V0U3VmZml4KTtcbiAgICAgICAgfSxcblxuICAgICAgICBjYWxlbmRhciA6IGZ1bmN0aW9uICh0aW1lKSB7XG4gICAgICAgICAgICAvLyBXZSB3YW50IHRvIGNvbXBhcmUgdGhlIHN0YXJ0IG9mIHRvZGF5LCB2cyB0aGlzLlxuICAgICAgICAgICAgLy8gR2V0dGluZyBzdGFydC1vZi10b2RheSBkZXBlbmRzIG9uIHdoZXRoZXIgd2UncmUgem9uZSdkIG9yIG5vdC5cbiAgICAgICAgICAgIHZhciBub3cgPSB0aW1lIHx8IG1vbWVudCgpLFxuICAgICAgICAgICAgICAgIHNvZCA9IG1ha2VBcyhub3csIHRoaXMpLnN0YXJ0T2YoJ2RheScpLFxuICAgICAgICAgICAgICAgIGRpZmYgPSB0aGlzLmRpZmYoc29kLCAnZGF5cycsIHRydWUpLFxuICAgICAgICAgICAgICAgIGZvcm1hdCA9IGRpZmYgPCAtNiA/ICdzYW1lRWxzZScgOlxuICAgICAgICAgICAgICAgICAgICBkaWZmIDwgLTEgPyAnbGFzdFdlZWsnIDpcbiAgICAgICAgICAgICAgICAgICAgZGlmZiA8IDAgPyAnbGFzdERheScgOlxuICAgICAgICAgICAgICAgICAgICBkaWZmIDwgMSA/ICdzYW1lRGF5JyA6XG4gICAgICAgICAgICAgICAgICAgIGRpZmYgPCAyID8gJ25leHREYXknIDpcbiAgICAgICAgICAgICAgICAgICAgZGlmZiA8IDcgPyAnbmV4dFdlZWsnIDogJ3NhbWVFbHNlJztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZvcm1hdCh0aGlzLmxvY2FsZURhdGEoKS5jYWxlbmRhcihmb3JtYXQsIHRoaXMsIG1vbWVudChub3cpKSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNMZWFwWWVhciA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0xlYXBZZWFyKHRoaXMueWVhcigpKTtcbiAgICAgICAgfSxcblxuICAgICAgICBpc0RTVCA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy56b25lKCkgPCB0aGlzLmNsb25lKCkubW9udGgoMCkuem9uZSgpIHx8XG4gICAgICAgICAgICAgICAgdGhpcy56b25lKCkgPCB0aGlzLmNsb25lKCkubW9udGgoNSkuem9uZSgpKTtcbiAgICAgICAgfSxcblxuICAgICAgICBkYXkgOiBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgICAgIHZhciBkYXkgPSB0aGlzLl9pc1VUQyA/IHRoaXMuX2QuZ2V0VVRDRGF5KCkgOiB0aGlzLl9kLmdldERheSgpO1xuICAgICAgICAgICAgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IHBhcnNlV2Vla2RheShpbnB1dCwgdGhpcy5sb2NhbGVEYXRhKCkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZChpbnB1dCAtIGRheSwgJ2QnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRheTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBtb250aCA6IG1ha2VBY2Nlc3NvcignTW9udGgnLCB0cnVlKSxcblxuICAgICAgICBzdGFydE9mIDogZnVuY3Rpb24gKHVuaXRzKSB7XG4gICAgICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgICAgIC8vIHRoZSBmb2xsb3dpbmcgc3dpdGNoIGludGVudGlvbmFsbHkgb21pdHMgYnJlYWsga2V5d29yZHNcbiAgICAgICAgICAgIC8vIHRvIHV0aWxpemUgZmFsbGluZyB0aHJvdWdoIHRoZSBjYXNlcy5cbiAgICAgICAgICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgICAgICAgIGNhc2UgJ3llYXInOlxuICAgICAgICAgICAgICAgIHRoaXMubW9udGgoMCk7XG4gICAgICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICAgICAgY2FzZSAncXVhcnRlcic6XG4gICAgICAgICAgICBjYXNlICdtb250aCc6XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRlKDEpO1xuICAgICAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgICAgIGNhc2UgJ3dlZWsnOlxuICAgICAgICAgICAgY2FzZSAnaXNvV2Vlayc6XG4gICAgICAgICAgICBjYXNlICdkYXknOlxuICAgICAgICAgICAgICAgIHRoaXMuaG91cnMoMCk7XG4gICAgICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICAgICAgY2FzZSAnaG91cic6XG4gICAgICAgICAgICAgICAgdGhpcy5taW51dGVzKDApO1xuICAgICAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgICAgICAgICAgICAgdGhpcy5zZWNvbmRzKDApO1xuICAgICAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgICAgICAgICAgICAgdGhpcy5taWxsaXNlY29uZHMoMCk7XG4gICAgICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB3ZWVrcyBhcmUgYSBzcGVjaWFsIGNhc2VcbiAgICAgICAgICAgIGlmICh1bml0cyA9PT0gJ3dlZWsnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy53ZWVrZGF5KDApO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh1bml0cyA9PT0gJ2lzb1dlZWsnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pc29XZWVrZGF5KDEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBxdWFydGVycyBhcmUgYWxzbyBzcGVjaWFsXG4gICAgICAgICAgICBpZiAodW5pdHMgPT09ICdxdWFydGVyJykge1xuICAgICAgICAgICAgICAgIHRoaXMubW9udGgoTWF0aC5mbG9vcih0aGlzLm1vbnRoKCkgLyAzKSAqIDMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBlbmRPZjogZnVuY3Rpb24gKHVuaXRzKSB7XG4gICAgICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgICAgIGlmICh1bml0cyA9PT0gdW5kZWZpbmVkIHx8IHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFydE9mKHVuaXRzKS5hZGQoMSwgKHVuaXRzID09PSAnaXNvV2VlaycgPyAnd2VlaycgOiB1bml0cykpLnN1YnRyYWN0KDEsICdtcycpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGlzQWZ0ZXI6IGZ1bmN0aW9uIChpbnB1dCwgdW5pdHMpIHtcbiAgICAgICAgICAgIHZhciBpbnB1dE1zO1xuICAgICAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh0eXBlb2YgdW5pdHMgIT09ICd1bmRlZmluZWQnID8gdW5pdHMgOiAnbWlsbGlzZWNvbmQnKTtcbiAgICAgICAgICAgIGlmICh1bml0cyA9PT0gJ21pbGxpc2Vjb25kJykge1xuICAgICAgICAgICAgICAgIGlucHV0ID0gbW9tZW50LmlzTW9tZW50KGlucHV0KSA/IGlucHV0IDogbW9tZW50KGlucHV0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gK3RoaXMgPiAraW5wdXQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlucHV0TXMgPSBtb21lbnQuaXNNb21lbnQoaW5wdXQpID8gK2lucHV0IDogK21vbWVudChpbnB1dCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlucHV0TXMgPCArdGhpcy5jbG9uZSgpLnN0YXJ0T2YodW5pdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGlzQmVmb3JlOiBmdW5jdGlvbiAoaW5wdXQsIHVuaXRzKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXRNcztcbiAgICAgICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModHlwZW9mIHVuaXRzICE9PSAndW5kZWZpbmVkJyA/IHVuaXRzIDogJ21pbGxpc2Vjb25kJyk7XG4gICAgICAgICAgICBpZiAodW5pdHMgPT09ICdtaWxsaXNlY29uZCcpIHtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IG1vbWVudC5pc01vbWVudChpbnB1dCkgPyBpbnB1dCA6IG1vbWVudChpbnB1dCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICt0aGlzIDwgK2lucHV0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbnB1dE1zID0gbW9tZW50LmlzTW9tZW50KGlucHV0KSA/ICtpbnB1dCA6ICttb21lbnQoaW5wdXQpO1xuICAgICAgICAgICAgICAgIHJldHVybiArdGhpcy5jbG9uZSgpLmVuZE9mKHVuaXRzKSA8IGlucHV0TXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNTYW1lOiBmdW5jdGlvbiAoaW5wdXQsIHVuaXRzKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXRNcztcbiAgICAgICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMgfHwgJ21pbGxpc2Vjb25kJyk7XG4gICAgICAgICAgICBpZiAodW5pdHMgPT09ICdtaWxsaXNlY29uZCcpIHtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IG1vbWVudC5pc01vbWVudChpbnB1dCkgPyBpbnB1dCA6IG1vbWVudChpbnB1dCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICt0aGlzID09PSAraW5wdXQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlucHV0TXMgPSArbW9tZW50KGlucHV0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKyh0aGlzLmNsb25lKCkuc3RhcnRPZih1bml0cykpIDw9IGlucHV0TXMgJiYgaW5wdXRNcyA8PSArKHRoaXMuY2xvbmUoKS5lbmRPZih1bml0cykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG1pbjogZGVwcmVjYXRlKFxuICAgICAgICAgICAgICAgICAnbW9tZW50KCkubWluIGlzIGRlcHJlY2F0ZWQsIHVzZSBtb21lbnQubWluIGluc3RlYWQuIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8xNTQ4JyxcbiAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICBvdGhlciA9IG1vbWVudC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG90aGVyIDwgdGhpcyA/IHRoaXMgOiBvdGhlcjtcbiAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgKSxcblxuICAgICAgICBtYXg6IGRlcHJlY2F0ZShcbiAgICAgICAgICAgICAgICAnbW9tZW50KCkubWF4IGlzIGRlcHJlY2F0ZWQsIHVzZSBtb21lbnQubWF4IGluc3RlYWQuIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8xNTQ4JyxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgb3RoZXIgPSBtb21lbnQuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG90aGVyID4gdGhpcyA/IHRoaXMgOiBvdGhlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICksXG5cbiAgICAgICAgLy8ga2VlcExvY2FsVGltZSA9IHRydWUgbWVhbnMgb25seSBjaGFuZ2UgdGhlIHRpbWV6b25lLCB3aXRob3V0XG4gICAgICAgIC8vIGFmZmVjdGluZyB0aGUgbG9jYWwgaG91ci4gU28gNTozMToyNiArMDMwMCAtLVt6b25lKDIsIHRydWUpXS0tPlxuICAgICAgICAvLyA1OjMxOjI2ICswMjAwIEl0IGlzIHBvc3NpYmxlIHRoYXQgNTozMToyNiBkb2Vzbid0IGV4aXN0IGludCB6b25lXG4gICAgICAgIC8vICswMjAwLCBzbyB3ZSBhZGp1c3QgdGhlIHRpbWUgYXMgbmVlZGVkLCB0byBiZSB2YWxpZC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gS2VlcGluZyB0aGUgdGltZSBhY3R1YWxseSBhZGRzL3N1YnRyYWN0cyAob25lIGhvdXIpXG4gICAgICAgIC8vIGZyb20gdGhlIGFjdHVhbCByZXByZXNlbnRlZCB0aW1lLiBUaGF0IGlzIHdoeSB3ZSBjYWxsIHVwZGF0ZU9mZnNldFxuICAgICAgICAvLyBhIHNlY29uZCB0aW1lLiBJbiBjYXNlIGl0IHdhbnRzIHVzIHRvIGNoYW5nZSB0aGUgb2Zmc2V0IGFnYWluXG4gICAgICAgIC8vIF9jaGFuZ2VJblByb2dyZXNzID09IHRydWUgY2FzZSwgdGhlbiB3ZSBoYXZlIHRvIGFkanVzdCwgYmVjYXVzZVxuICAgICAgICAvLyB0aGVyZSBpcyBubyBzdWNoIHRpbWUgaW4gdGhlIGdpdmVuIHRpbWV6b25lLlxuICAgICAgICB6b25lIDogZnVuY3Rpb24gKGlucHV0LCBrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5fb2Zmc2V0IHx8IDAsXG4gICAgICAgICAgICAgICAgbG9jYWxBZGp1c3Q7XG4gICAgICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0ID0gdGltZXpvbmVNaW51dGVzRnJvbVN0cmluZyhpbnB1dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhpbnB1dCkgPCAxNikge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dCA9IGlucHV0ICogNjA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5faXNVVEMgJiYga2VlcExvY2FsVGltZSkge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbEFkanVzdCA9IHRoaXMuX2RhdGVUek9mZnNldCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9vZmZzZXQgPSBpbnB1dDtcbiAgICAgICAgICAgICAgICB0aGlzLl9pc1VUQyA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsQWRqdXN0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdWJ0cmFjdChsb2NhbEFkanVzdCwgJ20nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldCAhPT0gaW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFrZWVwTG9jYWxUaW1lIHx8IHRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZE9yU3VidHJhY3REdXJhdGlvbkZyb21Nb21lbnQodGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9tZW50LmR1cmF0aW9uKG9mZnNldCAtIGlucHV0LCAnbScpLCAxLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9tZW50LnVwZGF0ZU9mZnNldCh0aGlzLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faXNVVEMgPyBvZmZzZXQgOiB0aGlzLl9kYXRlVHpPZmZzZXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIHpvbmVBYmJyIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzVVRDID8gJ1VUQycgOiAnJztcbiAgICAgICAgfSxcblxuICAgICAgICB6b25lTmFtZSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc1VUQyA/ICdDb29yZGluYXRlZCBVbml2ZXJzYWwgVGltZScgOiAnJztcbiAgICAgICAgfSxcblxuICAgICAgICBwYXJzZVpvbmUgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fdHptKSB7XG4gICAgICAgICAgICAgICAgdGhpcy56b25lKHRoaXMuX3R6bSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLl9pID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRoaXMuem9uZSh0aGlzLl9pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhc0FsaWduZWRIb3VyT2Zmc2V0IDogZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgICAgICBpZiAoIWlucHV0KSB7XG4gICAgICAgICAgICAgICAgaW5wdXQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5wdXQgPSBtb21lbnQoaW5wdXQpLnpvbmUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuICh0aGlzLnpvbmUoKSAtIGlucHV0KSAlIDYwID09PSAwO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRheXNJbk1vbnRoIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGRheXNJbk1vbnRoKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRheU9mWWVhciA6IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICAgICAgdmFyIGRheU9mWWVhciA9IHJvdW5kKChtb21lbnQodGhpcykuc3RhcnRPZignZGF5JykgLSBtb21lbnQodGhpcykuc3RhcnRPZigneWVhcicpKSAvIDg2NGU1KSArIDE7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IGRheU9mWWVhciA6IHRoaXMuYWRkKChpbnB1dCAtIGRheU9mWWVhciksICdkJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcXVhcnRlciA6IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyBNYXRoLmNlaWwoKHRoaXMubW9udGgoKSArIDEpIC8gMykgOiB0aGlzLm1vbnRoKChpbnB1dCAtIDEpICogMyArIHRoaXMubW9udGgoKSAlIDMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHdlZWtZZWFyIDogZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgICAgICB2YXIgeWVhciA9IHdlZWtPZlllYXIodGhpcywgdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWsuZG93LCB0aGlzLmxvY2FsZURhdGEoKS5fd2Vlay5kb3kpLnllYXI7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHllYXIgOiB0aGlzLmFkZCgoaW5wdXQgLSB5ZWFyKSwgJ3knKTtcbiAgICAgICAgfSxcblxuICAgICAgICBpc29XZWVrWWVhciA6IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICAgICAgdmFyIHllYXIgPSB3ZWVrT2ZZZWFyKHRoaXMsIDEsIDQpLnllYXI7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHllYXIgOiB0aGlzLmFkZCgoaW5wdXQgLSB5ZWFyKSwgJ3knKTtcbiAgICAgICAgfSxcblxuICAgICAgICB3ZWVrIDogZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgICAgICB2YXIgd2VlayA9IHRoaXMubG9jYWxlRGF0YSgpLndlZWsodGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHdlZWsgOiB0aGlzLmFkZCgoaW5wdXQgLSB3ZWVrKSAqIDcsICdkJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNvV2VlayA6IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICAgICAgdmFyIHdlZWsgPSB3ZWVrT2ZZZWFyKHRoaXMsIDEsIDQpLndlZWs7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHdlZWsgOiB0aGlzLmFkZCgoaW5wdXQgLSB3ZWVrKSAqIDcsICdkJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgd2Vla2RheSA6IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICAgICAgdmFyIHdlZWtkYXkgPSAodGhpcy5kYXkoKSArIDcgLSB0aGlzLmxvY2FsZURhdGEoKS5fd2Vlay5kb3cpICUgNztcbiAgICAgICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gd2Vla2RheSA6IHRoaXMuYWRkKGlucHV0IC0gd2Vla2RheSwgJ2QnKTtcbiAgICAgICAgfSxcblxuICAgICAgICBpc29XZWVrZGF5IDogZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgICAgICAvLyBiZWhhdmVzIHRoZSBzYW1lIGFzIG1vbWVudCNkYXkgZXhjZXB0XG4gICAgICAgICAgICAvLyBhcyBhIGdldHRlciwgcmV0dXJucyA3IGluc3RlYWQgb2YgMCAoMS03IHJhbmdlIGluc3RlYWQgb2YgMC02KVxuICAgICAgICAgICAgLy8gYXMgYSBzZXR0ZXIsIHN1bmRheSBzaG91bGQgYmVsb25nIHRvIHRoZSBwcmV2aW91cyB3ZWVrLlxuICAgICAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyB0aGlzLmRheSgpIHx8IDcgOiB0aGlzLmRheSh0aGlzLmRheSgpICUgNyA/IGlucHV0IDogaW5wdXQgLSA3KTtcbiAgICAgICAgfSxcblxuICAgICAgICBpc29XZWVrc0luWWVhciA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB3ZWVrc0luWWVhcih0aGlzLnllYXIoKSwgMSwgNCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgd2Vla3NJblllYXIgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgd2Vla0luZm8gPSB0aGlzLmxvY2FsZURhdGEoKS5fd2VlaztcbiAgICAgICAgICAgIHJldHVybiB3ZWVrc0luWWVhcih0aGlzLnllYXIoKSwgd2Vla0luZm8uZG93LCB3ZWVrSW5mby5kb3kpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldCA6IGZ1bmN0aW9uICh1bml0cykge1xuICAgICAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1t1bml0c10oKTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXQgOiBmdW5jdGlvbiAodW5pdHMsIHZhbHVlKSB7XG4gICAgICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpc1t1bml0c10gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0aGlzW3VuaXRzXSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBJZiBwYXNzZWQgYSBsb2NhbGUga2V5LCBpdCB3aWxsIHNldCB0aGUgbG9jYWxlIGZvciB0aGlzXG4gICAgICAgIC8vIGluc3RhbmNlLiAgT3RoZXJ3aXNlLCBpdCB3aWxsIHJldHVybiB0aGUgbG9jYWxlIGNvbmZpZ3VyYXRpb25cbiAgICAgICAgLy8gdmFyaWFibGVzIGZvciB0aGlzIGluc3RhbmNlLlxuICAgICAgICBsb2NhbGUgOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICB2YXIgbmV3TG9jYWxlRGF0YTtcblxuICAgICAgICAgICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsZS5fYWJicjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3TG9jYWxlRGF0YSA9IG1vbWVudC5sb2NhbGVEYXRhKGtleSk7XG4gICAgICAgICAgICAgICAgaWYgKG5ld0xvY2FsZURhdGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2NhbGUgPSBuZXdMb2NhbGVEYXRhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBsYW5nIDogZGVwcmVjYXRlKFxuICAgICAgICAgICAgJ21vbWVudCgpLmxhbmcoKSBpcyBkZXByZWNhdGVkLiBJbnN0ZWFkLCB1c2UgbW9tZW50KCkubG9jYWxlRGF0YSgpIHRvIGdldCB0aGUgbGFuZ3VhZ2UgY29uZmlndXJhdGlvbi4gVXNlIG1vbWVudCgpLmxvY2FsZSgpIHRvIGNoYW5nZSBsYW5ndWFnZXMuJyxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZShrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgKSxcblxuICAgICAgICBsb2NhbGVEYXRhIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsZTtcbiAgICAgICAgfSxcblxuICAgICAgICBfZGF0ZVR6T2Zmc2V0IDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gT24gRmlyZWZveC4yNCBEYXRlI2dldFRpbWV6b25lT2Zmc2V0IHJldHVybnMgYSBmbG9hdGluZyBwb2ludC5cbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L3B1bGwvMTg3MVxuICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQodGhpcy5fZC5nZXRUaW1lem9uZU9mZnNldCgpIC8gMTUpICogMTU7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIHJhd01vbnRoU2V0dGVyKG1vbSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGRheU9mTW9udGg7XG5cbiAgICAgICAgLy8gVE9ETzogTW92ZSB0aGlzIG91dCBvZiBoZXJlIVxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdmFsdWUgPSBtb20ubG9jYWxlRGF0YSgpLm1vbnRoc1BhcnNlKHZhbHVlKTtcbiAgICAgICAgICAgIC8vIFRPRE86IEFub3RoZXIgc2lsZW50IGZhaWx1cmU/XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBtb207XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBkYXlPZk1vbnRoID0gTWF0aC5taW4obW9tLmRhdGUoKSxcbiAgICAgICAgICAgICAgICBkYXlzSW5Nb250aChtb20ueWVhcigpLCB2YWx1ZSkpO1xuICAgICAgICBtb20uX2RbJ3NldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgJ01vbnRoJ10odmFsdWUsIGRheU9mTW9udGgpO1xuICAgICAgICByZXR1cm4gbW9tO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJhd0dldHRlcihtb20sIHVuaXQpIHtcbiAgICAgICAgcmV0dXJuIG1vbS5fZFsnZ2V0JyArIChtb20uX2lzVVRDID8gJ1VUQycgOiAnJykgKyB1bml0XSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJhd1NldHRlcihtb20sIHVuaXQsIHZhbHVlKSB7XG4gICAgICAgIGlmICh1bml0ID09PSAnTW9udGgnKSB7XG4gICAgICAgICAgICByZXR1cm4gcmF3TW9udGhTZXR0ZXIobW9tLCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbW9tLl9kWydzZXQnICsgKG1vbS5faXNVVEMgPyAnVVRDJyA6ICcnKSArIHVuaXRdKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VBY2Nlc3Nvcih1bml0LCBrZWVwVGltZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJhd1NldHRlcih0aGlzLCB1bml0LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgbW9tZW50LnVwZGF0ZU9mZnNldCh0aGlzLCBrZWVwVGltZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiByYXdHZXR0ZXIodGhpcywgdW5pdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgbW9tZW50LmZuLm1pbGxpc2Vjb25kID0gbW9tZW50LmZuLm1pbGxpc2Vjb25kcyA9IG1ha2VBY2Nlc3NvcignTWlsbGlzZWNvbmRzJywgZmFsc2UpO1xuICAgIG1vbWVudC5mbi5zZWNvbmQgPSBtb21lbnQuZm4uc2Vjb25kcyA9IG1ha2VBY2Nlc3NvcignU2Vjb25kcycsIGZhbHNlKTtcbiAgICBtb21lbnQuZm4ubWludXRlID0gbW9tZW50LmZuLm1pbnV0ZXMgPSBtYWtlQWNjZXNzb3IoJ01pbnV0ZXMnLCBmYWxzZSk7XG4gICAgLy8gU2V0dGluZyB0aGUgaG91ciBzaG91bGQga2VlcCB0aGUgdGltZSwgYmVjYXVzZSB0aGUgdXNlciBleHBsaWNpdGx5XG4gICAgLy8gc3BlY2lmaWVkIHdoaWNoIGhvdXIgaGUgd2FudHMuIFNvIHRyeWluZyB0byBtYWludGFpbiB0aGUgc2FtZSBob3VyIChpblxuICAgIC8vIGEgbmV3IHRpbWV6b25lKSBtYWtlcyBzZW5zZS4gQWRkaW5nL3N1YnRyYWN0aW5nIGhvdXJzIGRvZXMgbm90IGZvbGxvd1xuICAgIC8vIHRoaXMgcnVsZS5cbiAgICBtb21lbnQuZm4uaG91ciA9IG1vbWVudC5mbi5ob3VycyA9IG1ha2VBY2Nlc3NvcignSG91cnMnLCB0cnVlKTtcbiAgICAvLyBtb21lbnQuZm4ubW9udGggaXMgZGVmaW5lZCBzZXBhcmF0ZWx5XG4gICAgbW9tZW50LmZuLmRhdGUgPSBtYWtlQWNjZXNzb3IoJ0RhdGUnLCB0cnVlKTtcbiAgICBtb21lbnQuZm4uZGF0ZXMgPSBkZXByZWNhdGUoJ2RhdGVzIGFjY2Vzc29yIGlzIGRlcHJlY2F0ZWQuIFVzZSBkYXRlIGluc3RlYWQuJywgbWFrZUFjY2Vzc29yKCdEYXRlJywgdHJ1ZSkpO1xuICAgIG1vbWVudC5mbi55ZWFyID0gbWFrZUFjY2Vzc29yKCdGdWxsWWVhcicsIHRydWUpO1xuICAgIG1vbWVudC5mbi55ZWFycyA9IGRlcHJlY2F0ZSgneWVhcnMgYWNjZXNzb3IgaXMgZGVwcmVjYXRlZC4gVXNlIHllYXIgaW5zdGVhZC4nLCBtYWtlQWNjZXNzb3IoJ0Z1bGxZZWFyJywgdHJ1ZSkpO1xuXG4gICAgLy8gYWRkIHBsdXJhbCBtZXRob2RzXG4gICAgbW9tZW50LmZuLmRheXMgPSBtb21lbnQuZm4uZGF5O1xuICAgIG1vbWVudC5mbi5tb250aHMgPSBtb21lbnQuZm4ubW9udGg7XG4gICAgbW9tZW50LmZuLndlZWtzID0gbW9tZW50LmZuLndlZWs7XG4gICAgbW9tZW50LmZuLmlzb1dlZWtzID0gbW9tZW50LmZuLmlzb1dlZWs7XG4gICAgbW9tZW50LmZuLnF1YXJ0ZXJzID0gbW9tZW50LmZuLnF1YXJ0ZXI7XG5cbiAgICAvLyBhZGQgYWxpYXNlZCBmb3JtYXQgbWV0aG9kc1xuICAgIG1vbWVudC5mbi50b0pTT04gPSBtb21lbnQuZm4udG9JU09TdHJpbmc7XG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgIER1cmF0aW9uIFByb3RvdHlwZVxuICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXG4gICAgZnVuY3Rpb24gZGF5c1RvWWVhcnMgKGRheXMpIHtcbiAgICAgICAgLy8gNDAwIHllYXJzIGhhdmUgMTQ2MDk3IGRheXMgKHRha2luZyBpbnRvIGFjY291bnQgbGVhcCB5ZWFyIHJ1bGVzKVxuICAgICAgICByZXR1cm4gZGF5cyAqIDQwMCAvIDE0NjA5NztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB5ZWFyc1RvRGF5cyAoeWVhcnMpIHtcbiAgICAgICAgLy8geWVhcnMgKiAzNjUgKyBhYnNSb3VuZCh5ZWFycyAvIDQpIC1cbiAgICAgICAgLy8gICAgIGFic1JvdW5kKHllYXJzIC8gMTAwKSArIGFic1JvdW5kKHllYXJzIC8gNDAwKTtcbiAgICAgICAgcmV0dXJuIHllYXJzICogMTQ2MDk3IC8gNDAwO1xuICAgIH1cblxuICAgIGV4dGVuZChtb21lbnQuZHVyYXRpb24uZm4gPSBEdXJhdGlvbi5wcm90b3R5cGUsIHtcblxuICAgICAgICBfYnViYmxlIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG1pbGxpc2Vjb25kcyA9IHRoaXMuX21pbGxpc2Vjb25kcyxcbiAgICAgICAgICAgICAgICBkYXlzID0gdGhpcy5fZGF5cyxcbiAgICAgICAgICAgICAgICBtb250aHMgPSB0aGlzLl9tb250aHMsXG4gICAgICAgICAgICAgICAgZGF0YSA9IHRoaXMuX2RhdGEsXG4gICAgICAgICAgICAgICAgc2Vjb25kcywgbWludXRlcywgaG91cnMsIHllYXJzID0gMDtcblxuICAgICAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBjb2RlIGJ1YmJsZXMgdXAgdmFsdWVzLCBzZWUgdGhlIHRlc3RzIGZvclxuICAgICAgICAgICAgLy8gZXhhbXBsZXMgb2Ygd2hhdCB0aGF0IG1lYW5zLlxuICAgICAgICAgICAgZGF0YS5taWxsaXNlY29uZHMgPSBtaWxsaXNlY29uZHMgJSAxMDAwO1xuXG4gICAgICAgICAgICBzZWNvbmRzID0gYWJzUm91bmQobWlsbGlzZWNvbmRzIC8gMTAwMCk7XG4gICAgICAgICAgICBkYXRhLnNlY29uZHMgPSBzZWNvbmRzICUgNjA7XG5cbiAgICAgICAgICAgIG1pbnV0ZXMgPSBhYnNSb3VuZChzZWNvbmRzIC8gNjApO1xuICAgICAgICAgICAgZGF0YS5taW51dGVzID0gbWludXRlcyAlIDYwO1xuXG4gICAgICAgICAgICBob3VycyA9IGFic1JvdW5kKG1pbnV0ZXMgLyA2MCk7XG4gICAgICAgICAgICBkYXRhLmhvdXJzID0gaG91cnMgJSAyNDtcblxuICAgICAgICAgICAgZGF5cyArPSBhYnNSb3VuZChob3VycyAvIDI0KTtcblxuICAgICAgICAgICAgLy8gQWNjdXJhdGVseSBjb252ZXJ0IGRheXMgdG8geWVhcnMsIGFzc3VtZSBzdGFydCBmcm9tIHllYXIgMC5cbiAgICAgICAgICAgIHllYXJzID0gYWJzUm91bmQoZGF5c1RvWWVhcnMoZGF5cykpO1xuICAgICAgICAgICAgZGF5cyAtPSBhYnNSb3VuZCh5ZWFyc1RvRGF5cyh5ZWFycykpO1xuXG4gICAgICAgICAgICAvLyAzMCBkYXlzIHRvIGEgbW9udGhcbiAgICAgICAgICAgIC8vIFRPRE8gKGlza3Jlbik6IFVzZSBhbmNob3IgZGF0ZSAobGlrZSAxc3QgSmFuKSB0byBjb21wdXRlIHRoaXMuXG4gICAgICAgICAgICBtb250aHMgKz0gYWJzUm91bmQoZGF5cyAvIDMwKTtcbiAgICAgICAgICAgIGRheXMgJT0gMzA7XG5cbiAgICAgICAgICAgIC8vIDEyIG1vbnRocyAtPiAxIHllYXJcbiAgICAgICAgICAgIHllYXJzICs9IGFic1JvdW5kKG1vbnRocyAvIDEyKTtcbiAgICAgICAgICAgIG1vbnRocyAlPSAxMjtcblxuICAgICAgICAgICAgZGF0YS5kYXlzID0gZGF5cztcbiAgICAgICAgICAgIGRhdGEubW9udGhzID0gbW9udGhzO1xuICAgICAgICAgICAgZGF0YS55ZWFycyA9IHllYXJzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFicyA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX21pbGxpc2Vjb25kcyA9IE1hdGguYWJzKHRoaXMuX21pbGxpc2Vjb25kcyk7XG4gICAgICAgICAgICB0aGlzLl9kYXlzID0gTWF0aC5hYnModGhpcy5fZGF5cyk7XG4gICAgICAgICAgICB0aGlzLl9tb250aHMgPSBNYXRoLmFicyh0aGlzLl9tb250aHMpO1xuXG4gICAgICAgICAgICB0aGlzLl9kYXRhLm1pbGxpc2Vjb25kcyA9IE1hdGguYWJzKHRoaXMuX2RhdGEubWlsbGlzZWNvbmRzKTtcbiAgICAgICAgICAgIHRoaXMuX2RhdGEuc2Vjb25kcyA9IE1hdGguYWJzKHRoaXMuX2RhdGEuc2Vjb25kcyk7XG4gICAgICAgICAgICB0aGlzLl9kYXRhLm1pbnV0ZXMgPSBNYXRoLmFicyh0aGlzLl9kYXRhLm1pbnV0ZXMpO1xuICAgICAgICAgICAgdGhpcy5fZGF0YS5ob3VycyA9IE1hdGguYWJzKHRoaXMuX2RhdGEuaG91cnMpO1xuICAgICAgICAgICAgdGhpcy5fZGF0YS5tb250aHMgPSBNYXRoLmFicyh0aGlzLl9kYXRhLm1vbnRocyk7XG4gICAgICAgICAgICB0aGlzLl9kYXRhLnllYXJzID0gTWF0aC5hYnModGhpcy5fZGF0YS55ZWFycyk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIHdlZWtzIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGFic1JvdW5kKHRoaXMuZGF5cygpIC8gNyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdmFsdWVPZiA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9taWxsaXNlY29uZHMgK1xuICAgICAgICAgICAgICB0aGlzLl9kYXlzICogODY0ZTUgK1xuICAgICAgICAgICAgICAodGhpcy5fbW9udGhzICUgMTIpICogMjU5MmU2ICtcbiAgICAgICAgICAgICAgdG9JbnQodGhpcy5fbW9udGhzIC8gMTIpICogMzE1MzZlNjtcbiAgICAgICAgfSxcblxuICAgICAgICBodW1hbml6ZSA6IGZ1bmN0aW9uICh3aXRoU3VmZml4KSB7XG4gICAgICAgICAgICB2YXIgb3V0cHV0ID0gcmVsYXRpdmVUaW1lKHRoaXMsICF3aXRoU3VmZml4LCB0aGlzLmxvY2FsZURhdGEoKSk7XG5cbiAgICAgICAgICAgIGlmICh3aXRoU3VmZml4KSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gdGhpcy5sb2NhbGVEYXRhKCkucGFzdEZ1dHVyZSgrdGhpcywgb3V0cHV0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLnBvc3Rmb3JtYXQob3V0cHV0KTtcbiAgICAgICAgfSxcblxuICAgICAgICBhZGQgOiBmdW5jdGlvbiAoaW5wdXQsIHZhbCkge1xuICAgICAgICAgICAgLy8gc3VwcG9ydHMgb25seSAyLjAtc3R5bGUgYWRkKDEsICdzJykgb3IgYWRkKG1vbWVudClcbiAgICAgICAgICAgIHZhciBkdXIgPSBtb21lbnQuZHVyYXRpb24oaW5wdXQsIHZhbCk7XG5cbiAgICAgICAgICAgIHRoaXMuX21pbGxpc2Vjb25kcyArPSBkdXIuX21pbGxpc2Vjb25kcztcbiAgICAgICAgICAgIHRoaXMuX2RheXMgKz0gZHVyLl9kYXlzO1xuICAgICAgICAgICAgdGhpcy5fbW9udGhzICs9IGR1ci5fbW9udGhzO1xuXG4gICAgICAgICAgICB0aGlzLl9idWJibGUoKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc3VidHJhY3QgOiBmdW5jdGlvbiAoaW5wdXQsIHZhbCkge1xuICAgICAgICAgICAgdmFyIGR1ciA9IG1vbWVudC5kdXJhdGlvbihpbnB1dCwgdmFsKTtcblxuICAgICAgICAgICAgdGhpcy5fbWlsbGlzZWNvbmRzIC09IGR1ci5fbWlsbGlzZWNvbmRzO1xuICAgICAgICAgICAgdGhpcy5fZGF5cyAtPSBkdXIuX2RheXM7XG4gICAgICAgICAgICB0aGlzLl9tb250aHMgLT0gZHVyLl9tb250aHM7XG5cbiAgICAgICAgICAgIHRoaXMuX2J1YmJsZSgpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBnZXQgOiBmdW5jdGlvbiAodW5pdHMpIHtcbiAgICAgICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbdW5pdHMudG9Mb3dlckNhc2UoKSArICdzJ10oKTtcbiAgICAgICAgfSxcblxuICAgICAgICBhcyA6IGZ1bmN0aW9uICh1bml0cykge1xuICAgICAgICAgICAgdmFyIGRheXMsIG1vbnRocztcbiAgICAgICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuXG4gICAgICAgICAgICBpZiAodW5pdHMgPT09ICdtb250aCcgfHwgdW5pdHMgPT09ICd5ZWFyJykge1xuICAgICAgICAgICAgICAgIGRheXMgPSB0aGlzLl9kYXlzICsgdGhpcy5fbWlsbGlzZWNvbmRzIC8gODY0ZTU7XG4gICAgICAgICAgICAgICAgbW9udGhzID0gdGhpcy5fbW9udGhzICsgZGF5c1RvWWVhcnMoZGF5cykgKiAxMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5pdHMgPT09ICdtb250aCcgPyBtb250aHMgOiBtb250aHMgLyAxMjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gaGFuZGxlIG1pbGxpc2Vjb25kcyBzZXBhcmF0ZWx5IGJlY2F1c2Ugb2YgZmxvYXRpbmcgcG9pbnQgbWF0aCBlcnJvcnMgKGlzc3VlICMxODY3KVxuICAgICAgICAgICAgICAgIGRheXMgPSB0aGlzLl9kYXlzICsgTWF0aC5yb3VuZCh5ZWFyc1RvRGF5cyh0aGlzLl9tb250aHMgLyAxMikpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnd2Vlayc6IHJldHVybiBkYXlzIC8gNyArIHRoaXMuX21pbGxpc2Vjb25kcyAvIDYwNDhlNTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZGF5JzogcmV0dXJuIGRheXMgKyB0aGlzLl9taWxsaXNlY29uZHMgLyA4NjRlNTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnaG91cic6IHJldHVybiBkYXlzICogMjQgKyB0aGlzLl9taWxsaXNlY29uZHMgLyAzNmU1O1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdtaW51dGUnOiByZXR1cm4gZGF5cyAqIDI0ICogNjAgKyB0aGlzLl9taWxsaXNlY29uZHMgLyA2ZTQ7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3NlY29uZCc6IHJldHVybiBkYXlzICogMjQgKiA2MCAqIDYwICsgdGhpcy5fbWlsbGlzZWNvbmRzIC8gMTAwMDtcbiAgICAgICAgICAgICAgICAgICAgLy8gTWF0aC5mbG9vciBwcmV2ZW50cyBmbG9hdGluZyBwb2ludCBtYXRoIGVycm9ycyBoZXJlXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ21pbGxpc2Vjb25kJzogcmV0dXJuIE1hdGguZmxvb3IoZGF5cyAqIDI0ICogNjAgKiA2MCAqIDEwMDApICsgdGhpcy5fbWlsbGlzZWNvbmRzO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gdW5pdCAnICsgdW5pdHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBsYW5nIDogbW9tZW50LmZuLmxhbmcsXG4gICAgICAgIGxvY2FsZSA6IG1vbWVudC5mbi5sb2NhbGUsXG5cbiAgICAgICAgdG9Jc29TdHJpbmcgOiBkZXByZWNhdGUoXG4gICAgICAgICAgICAndG9Jc29TdHJpbmcoKSBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIHRvSVNPU3RyaW5nKCkgaW5zdGVhZCAnICtcbiAgICAgICAgICAgICcobm90aWNlIHRoZSBjYXBpdGFscyknLFxuICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRvSVNPU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICksXG5cbiAgICAgICAgdG9JU09TdHJpbmcgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBpbnNwaXJlZCBieSBodHRwczovL2dpdGh1Yi5jb20vZG9yZGlsbGUvbW9tZW50LWlzb2R1cmF0aW9uL2Jsb2IvbWFzdGVyL21vbWVudC5pc29kdXJhdGlvbi5qc1xuICAgICAgICAgICAgdmFyIHllYXJzID0gTWF0aC5hYnModGhpcy55ZWFycygpKSxcbiAgICAgICAgICAgICAgICBtb250aHMgPSBNYXRoLmFicyh0aGlzLm1vbnRocygpKSxcbiAgICAgICAgICAgICAgICBkYXlzID0gTWF0aC5hYnModGhpcy5kYXlzKCkpLFxuICAgICAgICAgICAgICAgIGhvdXJzID0gTWF0aC5hYnModGhpcy5ob3VycygpKSxcbiAgICAgICAgICAgICAgICBtaW51dGVzID0gTWF0aC5hYnModGhpcy5taW51dGVzKCkpLFxuICAgICAgICAgICAgICAgIHNlY29uZHMgPSBNYXRoLmFicyh0aGlzLnNlY29uZHMoKSArIHRoaXMubWlsbGlzZWNvbmRzKCkgLyAxMDAwKTtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLmFzU2Vjb25kcygpKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBpcyB0aGUgc2FtZSBhcyBDIydzIChOb2RhKSBhbmQgcHl0aG9uIChpc29kYXRlKS4uLlxuICAgICAgICAgICAgICAgIC8vIGJ1dCBub3Qgb3RoZXIgSlMgKGdvb2cuZGF0ZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1AwRCc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiAodGhpcy5hc1NlY29uZHMoKSA8IDAgPyAnLScgOiAnJykgK1xuICAgICAgICAgICAgICAgICdQJyArXG4gICAgICAgICAgICAgICAgKHllYXJzID8geWVhcnMgKyAnWScgOiAnJykgK1xuICAgICAgICAgICAgICAgIChtb250aHMgPyBtb250aHMgKyAnTScgOiAnJykgK1xuICAgICAgICAgICAgICAgIChkYXlzID8gZGF5cyArICdEJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgKChob3VycyB8fCBtaW51dGVzIHx8IHNlY29uZHMpID8gJ1QnIDogJycpICtcbiAgICAgICAgICAgICAgICAoaG91cnMgPyBob3VycyArICdIJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgKG1pbnV0ZXMgPyBtaW51dGVzICsgJ00nIDogJycpICtcbiAgICAgICAgICAgICAgICAoc2Vjb25kcyA/IHNlY29uZHMgKyAnUycgOiAnJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgbG9jYWxlRGF0YSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sb2NhbGU7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIG1vbWVudC5kdXJhdGlvbi5mbi50b1N0cmluZyA9IG1vbWVudC5kdXJhdGlvbi5mbi50b0lTT1N0cmluZztcblxuICAgIGZ1bmN0aW9uIG1ha2VEdXJhdGlvbkdldHRlcihuYW1lKSB7XG4gICAgICAgIG1vbWVudC5kdXJhdGlvbi5mbltuYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhW25hbWVdO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZvciAoaSBpbiB1bml0TWlsbGlzZWNvbmRGYWN0b3JzKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wKHVuaXRNaWxsaXNlY29uZEZhY3RvcnMsIGkpKSB7XG4gICAgICAgICAgICBtYWtlRHVyYXRpb25HZXR0ZXIoaS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG1vbWVudC5kdXJhdGlvbi5mbi5hc01pbGxpc2Vjb25kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXMoJ21zJyk7XG4gICAgfTtcbiAgICBtb21lbnQuZHVyYXRpb24uZm4uYXNTZWNvbmRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcygncycpO1xuICAgIH07XG4gICAgbW9tZW50LmR1cmF0aW9uLmZuLmFzTWludXRlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXMoJ20nKTtcbiAgICB9O1xuICAgIG1vbWVudC5kdXJhdGlvbi5mbi5hc0hvdXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcygnaCcpO1xuICAgIH07XG4gICAgbW9tZW50LmR1cmF0aW9uLmZuLmFzRGF5cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXMoJ2QnKTtcbiAgICB9O1xuICAgIG1vbWVudC5kdXJhdGlvbi5mbi5hc1dlZWtzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcygnd2Vla3MnKTtcbiAgICB9O1xuICAgIG1vbWVudC5kdXJhdGlvbi5mbi5hc01vbnRocyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXMoJ00nKTtcbiAgICB9O1xuICAgIG1vbWVudC5kdXJhdGlvbi5mbi5hc1llYXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcygneScpO1xuICAgIH07XG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgIERlZmF1bHQgTG9jYWxlXG4gICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cbiAgICAvLyBTZXQgZGVmYXVsdCBsb2NhbGUsIG90aGVyIGxvY2FsZSB3aWxsIGluaGVyaXQgZnJvbSBFbmdsaXNoLlxuICAgIG1vbWVudC5sb2NhbGUoJ2VuJywge1xuICAgICAgICBvcmRpbmFsUGFyc2U6IC9cXGR7MSwyfSh0aHxzdHxuZHxyZCkvLFxuICAgICAgICBvcmRpbmFsIDogZnVuY3Rpb24gKG51bWJlcikge1xuICAgICAgICAgICAgdmFyIGIgPSBudW1iZXIgJSAxMCxcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSAodG9JbnQobnVtYmVyICUgMTAwIC8gMTApID09PSAxKSA/ICd0aCcgOlxuICAgICAgICAgICAgICAgIChiID09PSAxKSA/ICdzdCcgOlxuICAgICAgICAgICAgICAgIChiID09PSAyKSA/ICduZCcgOlxuICAgICAgICAgICAgICAgIChiID09PSAzKSA/ICdyZCcgOiAndGgnO1xuICAgICAgICAgICAgcmV0dXJuIG51bWJlciArIG91dHB1dDtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyogRU1CRURfTE9DQUxFUyAqL1xuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICBFeHBvc2luZyBNb21lbnRcbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICBmdW5jdGlvbiBtYWtlR2xvYmFsKHNob3VsZERlcHJlY2F0ZSkge1xuICAgICAgICAvKmdsb2JhbCBlbmRlcjpmYWxzZSAqL1xuICAgICAgICBpZiAodHlwZW9mIGVuZGVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG9sZEdsb2JhbE1vbWVudCA9IGdsb2JhbFNjb3BlLm1vbWVudDtcbiAgICAgICAgaWYgKHNob3VsZERlcHJlY2F0ZSkge1xuICAgICAgICAgICAgZ2xvYmFsU2NvcGUubW9tZW50ID0gZGVwcmVjYXRlKFxuICAgICAgICAgICAgICAgICAgICAnQWNjZXNzaW5nIE1vbWVudCB0aHJvdWdoIHRoZSBnbG9iYWwgc2NvcGUgaXMgJyArXG4gICAgICAgICAgICAgICAgICAgICdkZXByZWNhdGVkLCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGFuIHVwY29taW5nICcgK1xuICAgICAgICAgICAgICAgICAgICAncmVsZWFzZS4nLFxuICAgICAgICAgICAgICAgICAgICBtb21lbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2xvYmFsU2NvcGUubW9tZW50ID0gbW9tZW50O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ29tbW9uSlMgbW9kdWxlIGlzIGRlZmluZWRcbiAgICBpZiAoaGFzTW9kdWxlKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gbW9tZW50O1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZSgnbW9tZW50JywgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuICAgICAgICAgICAgaWYgKG1vZHVsZS5jb25maWcgJiYgbW9kdWxlLmNvbmZpZygpICYmIG1vZHVsZS5jb25maWcoKS5ub0dsb2JhbCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIC8vIHJlbGVhc2UgdGhlIGdsb2JhbCB2YXJpYWJsZVxuICAgICAgICAgICAgICAgIGdsb2JhbFNjb3BlLm1vbWVudCA9IG9sZEdsb2JhbE1vbWVudDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG1vbWVudDtcbiAgICAgICAgfSk7XG4gICAgICAgIG1ha2VHbG9iYWwodHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbWFrZUdsb2JhbCgpO1xuICAgIH1cbn0pLmNhbGwodGhpcyk7XG4iLCIvLyBDb3B5cmlnaHQgKGMpIEp1cHl0ZXIgRGV2ZWxvcG1lbnQgVGVhbS5cbi8vIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgTW9kaWZpZWQgQlNEIExpY2Vuc2UuXG5cbiAgICB2YXIgSVB5dGhvbiA9IHJlcXVpcmUoJ2Jhc2UvanMvbmFtZXNwYWNlJyk7XG4gICAgdmFyIHBhZ2UgPSByZXF1aXJlKCdiYXNlL2pzL3BhZ2UnKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbG9naW5NYWluKCkge1xuICAgICAgICB2YXIgcGFnZV9pbnN0YW5jZSA9IG5ldyBwYWdlLlBhZ2UoKTtcbiAgICAgICAgJCgnYnV0dG9uI2xvZ2luX3N1Ym1pdCcpLmFkZENsYXNzKFwiYnRuIGJ0bi1kZWZhdWx0XCIpO1xuICAgICAgICBwYWdlX2luc3RhbmNlLnNob3coKTtcbiAgICAgICAgJCgnaW5wdXQjcGFzc3dvcmRfaW5wdXQnKS5mb2N1cygpO1xuXG4gICAgICAgIElQeXRob24ucGFnZSA9IHBhZ2VfaW5zdGFuY2U7XG4gICAgfTtcbiIsIi8vIENvcHlyaWdodCAoYykgSnVweXRlciBEZXZlbG9wbWVudCBUZWFtLlxuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBNb2RpZmllZCBCU0QgTGljZW5zZS5cblxuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgdmFyIHV0aWxzID0gcmVxdWlyZSgnYmFzZS9qcy91dGlscycpO1xuXG4gICAgdmFyIExvZ2luV2lkZ2V0ID0gZnVuY3Rpb24gKHNlbGVjdG9yLCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICB0aGlzLmJhc2VfdXJsID0gb3B0aW9ucy5iYXNlX3VybCB8fCB1dGlscy5nZXRfYm9keV9kYXRhKFwiYmFzZVVybFwiKTtcbiAgICAgICAgdGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yO1xuICAgICAgICBpZiAodGhpcy5zZWxlY3RvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQgPSAkKHNlbGVjdG9yKTtcbiAgICAgICAgICAgIHRoaXMuYmluZF9ldmVudHMoKTtcbiAgICAgICAgfVxuICAgIH07XG5cblxuICAgIExvZ2luV2lkZ2V0LnByb3RvdHlwZS5iaW5kX2V2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICB0aGlzLmVsZW1lbnQuZmluZChcImJ1dHRvbiNsb2dvdXRcIikuY2xpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uID0gdXRpbHMudXJsX2pvaW5fZW5jb2RlKFxuICAgICAgICAgICAgICAgIHRoYXQuYmFzZV91cmwsXG4gICAgICAgICAgICAgICAgXCJsb2dvdXRcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZWxlbWVudC5maW5kKFwiYnV0dG9uI2xvZ2luXCIpLmNsaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbiA9IHV0aWxzLnVybF9qb2luX2VuY29kZShcbiAgICAgICAgICAgICAgICB0aGF0LmJhc2VfdXJsLFxuICAgICAgICAgICAgICAgIFwibG9naW5cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGV4cG9ydHMuTG9naW5XaWRnZXQgPSBMb2dpbldpZGdldDtcbiIsIi8vIENvcHlyaWdodCAoYykgSnVweXRlciBEZXZlbG9wbWVudCBUZWFtLlxuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBNb2RpZmllZCBCU0QgTGljZW5zZS5cblxuICAgIHZhciBJUHl0aG9uID0gcmVxdWlyZSgnYmFzZS9qcy9uYW1lc3BhY2UnKTtcbiAgICB2YXIgcGFnZSA9IHJlcXVpcmUoJ2Jhc2UvanMvcGFnZScpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBsb2dvdXRNYWluKCkge1xuICAgICAgICB2YXIgcGFnZV9pbnN0YW5jZSA9IG5ldyBwYWdlLlBhZ2UoKTtcbiAgICAgICAgcGFnZV9pbnN0YW5jZS5zaG93KCk7XG5cbiAgICAgICAgSVB5dGhvbi5wYWdlID0gcGFnZV9pbnN0YW5jZTtcbiAgICB9O1xuIiwiLy8gQ29weXJpZ2h0IChjKSBKdXB5dGVyIERldmVsb3BtZW50IFRlYW0uXG4vLyBEaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIE1vZGlmaWVkIEJTRCBMaWNlbnNlLlxuXG5leHBvcnRzLmxvZ2luX21haW4gPSByZXF1aXJlKCcuL2xvZ2lubWFpbicpO1xuZXhwb3J0cy5sb2dvdXRfbWFpbiA9IHJlcXVpcmUoJy4vbG9nb3V0bWFpbicpO1xuIiwiLy8gQ29weXJpZ2h0IChjKSBKdXB5dGVyIERldmVsb3BtZW50IFRlYW0uXG4vLyBEaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIE1vZGlmaWVkIEJTRCBMaWNlbnNlLlxuXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgXG4gICAgLyoqXG4gICAgICogQSB3cmFwcGVyIGFyb3VuZCBib290c3RyYXAgbW9kYWwgZm9yIGVhc2llciB1c2VcbiAgICAgKiBQYXNzIGl0IGFuIG9wdGlvbiBkaWN0aW9uYXJ5IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgICAqXG4gICAgICogICAgLSBib2R5IDogPHN0cmluZz4gb3IgPERPTSBub2RlPiwgbWFpbiBjb250ZW50IG9mIHRoZSBkaWFsb2dcbiAgICAgKiAgICAgICAgICAgIGlmIHBhc3MgYSA8c3RyaW5nPiBpdCB3aWxsIGJlIHdyYXBwZWQgaW4gYSBwIHRhZyBhbmRcbiAgICAgKiAgICAgICAgICAgIGh0bWwgZWxlbWVudCBlc2NhcGVkLCB1bmxlc3MgeW91IHNwZWNpZnkgc2FuaXRpemU9ZmFsc2VcbiAgICAgKiAgICAgICAgICAgIG9wdGlvbi5cbiAgICAgKiAgICAtIHRpdGxlIDogRGlhbG9nIHRpdGxlLCBkZWZhdWx0IHRvIGVtcHR5IHN0cmluZy5cbiAgICAgKiAgICAtIGJ1dHRvbnMgOiBkaWN0IG9mIGJ0bl9vcHRpb25zIHdobyBrZXlzIGFyZSBidXR0b24gbGFiZWwuXG4gICAgICogICAgICAgICAgICBzZWUgYnRuX29wdGlvbnMgYmVsb3cgZm9yIGRlc2NyaXB0aW9uXG4gICAgICogICAgLSBvcGVuIDogY2FsbGJhY2sgdG8gdHJpZ2dlciBvbiBkaWFsb2cgb3Blbi5cbiAgICAgKiAgICAtIGRlc3Ryb3k6XG4gICAgICogICAgLSBub3RlYm9vayA6IG5vdGVib29rIGluc3RhbmNlXG4gICAgICogICAgLSBrZXlib2FyZF9tYW5hZ2VyOiBrZXlib2FyZCBtYW5hZ2VyIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogIFVubGlrZSBib290c3RyYXAgbW9kYWxzLCB0aGUgYmFja2Ryb3Agb3B0aW9ucyBpcyBzZXQgYnkgZGVmYXVsdCBcbiAgICAgKiAgdG8gJ3N0YXRpYycuXG4gICAgICpcbiAgICAgKiAgVGhlIHJlc3Qgb2YgdGhlIG9wdGlvbnMgYXJlIHBhc3NlZCBhcyBpcyB0byBib290c3RyYXAgbW9kYWxzLiBcbiAgICAgKlxuICAgICAqICBidG5fb3B0aW9uczogZGljdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydHk6XG4gICAgICogIFxuICAgICAqICAgIC0gY2xpY2sgOiBjYWxsYmFjayB0byB0cmlnZ2VyIG9uIGNsaWNrXG4gICAgICogICAgLSBjbGFzcyA6IGNzcyBjbGFzc2VzIHRvIGFkZCB0byBidXR0b24uXG4gICAgICpcbiAgICAgKlxuICAgICAqXG4gICAgICoqL1xuICAgIHZhciBtb2RhbCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHZhciBtb2RhbCA9ICQoXCI8ZGl2Lz5cIilcbiAgICAgICAgICAgIC5hZGRDbGFzcyhcIm1vZGFsXCIpXG4gICAgICAgICAgICAuYWRkQ2xhc3MoXCJmYWRlXCIpXG4gICAgICAgICAgICAuYXR0cihcInJvbGVcIiwgXCJkaWFsb2dcIik7XG4gICAgICAgIHZhciBkaWFsb2cgPSAkKFwiPGRpdi8+XCIpXG4gICAgICAgICAgICAuYWRkQ2xhc3MoXCJtb2RhbC1kaWFsb2dcIilcbiAgICAgICAgICAgIC5hcHBlbmRUbyhtb2RhbCk7XG4gICAgICAgIHZhciBkaWFsb2dfY29udGVudCA9ICQoXCI8ZGl2Lz5cIilcbiAgICAgICAgICAgIC5hZGRDbGFzcyhcIm1vZGFsLWNvbnRlbnRcIilcbiAgICAgICAgICAgIC5hcHBlbmRUbyhkaWFsb2cpO1xuICAgICAgICBpZih0eXBlb2Yob3B0aW9ucy5ib2R5KSA9PT0gJ3N0cmluZycgJiYgb3B0aW9ucy5zYW5pdGl6ZSAhPT0gZmFsc2Upe1xuICAgICAgICAgICAgb3B0aW9ucy5ib2R5ID0gJChcIjxwLz5cIikudGV4dChvcHRpb25zLmJvZHkpO1xuICAgICAgICB9XG4gICAgICAgIGRpYWxvZ19jb250ZW50LmFwcGVuZChcbiAgICAgICAgICAgICQoXCI8ZGl2Lz5cIilcbiAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoXCJtb2RhbC1oZWFkZXJcIilcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCQoXCI8YnV0dG9uPlwiKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcInR5cGVcIiwgXCJidXR0b25cIilcbiAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKFwiY2xvc2VcIilcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJkYXRhLWRpc21pc3NcIiwgXCJtb2RhbFwiKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcImFyaWEtaGlkZGVuXCIsIFwidHJ1ZVwiKVxuICAgICAgICAgICAgICAgICAgICAuaHRtbChcIiZ0aW1lcztcIilcbiAgICAgICAgICAgICAgICApLmFwcGVuZChcbiAgICAgICAgICAgICAgICAgICAgJChcIjxoNC8+XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoJ21vZGFsLXRpdGxlJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC50ZXh0KG9wdGlvbnMudGl0bGUgfHwgXCJcIilcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICkuYXBwZW5kKFxuICAgICAgICAgICAgJChcIjxkaXYvPlwiKS5hZGRDbGFzcyhcIm1vZGFsLWJvZHlcIikuYXBwZW5kKFxuICAgICAgICAgICAgICAgIG9wdGlvbnMuYm9keSB8fCAkKFwiPHAvPlwiKVxuICAgICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgICBcbiAgICAgICAgdmFyIGZvb3RlciA9ICQoXCI8ZGl2Lz5cIikuYWRkQ2xhc3MoXCJtb2RhbC1mb290ZXJcIik7XG4gICAgICAgIFxuICAgICAgICBmb3IgKHZhciBsYWJlbCBpbiBvcHRpb25zLmJ1dHRvbnMpIHtcbiAgICAgICAgICAgIHZhciBidG5fb3B0cyA9IG9wdGlvbnMuYnV0dG9uc1tsYWJlbF07XG4gICAgICAgICAgICB2YXIgYnV0dG9uID0gJChcIjxidXR0b24vPlwiKVxuICAgICAgICAgICAgICAgIC5hZGRDbGFzcyhcImJ0biBidG4tZGVmYXVsdCBidG4tc21cIilcbiAgICAgICAgICAgICAgICAuYXR0cihcImRhdGEtZGlzbWlzc1wiLCBcIm1vZGFsXCIpXG4gICAgICAgICAgICAgICAgLnRleHQobGFiZWwpO1xuICAgICAgICAgICAgaWYgKGJ0bl9vcHRzLmNsaWNrKSB7XG4gICAgICAgICAgICAgICAgYnV0dG9uLmNsaWNrKCQucHJveHkoYnRuX29wdHMuY2xpY2ssIGRpYWxvZ19jb250ZW50KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYnRuX29wdHMuY2xhc3MpIHtcbiAgICAgICAgICAgICAgICBidXR0b24uYWRkQ2xhc3MoYnRuX29wdHMuY2xhc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9vdGVyLmFwcGVuZChidXR0b24pO1xuICAgICAgICB9XG4gICAgICAgIGRpYWxvZ19jb250ZW50LmFwcGVuZChmb290ZXIpO1xuICAgICAgICAvLyBob29rIHVwIG9uLW9wZW4gZXZlbnRcbiAgICAgICAgbW9kYWwub24oXCJzaG93bi5icy5tb2RhbFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZm9vdGVyLmZpbmQoXCJidXR0b25cIikubGFzdCgpLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMub3Blbikge1xuICAgICAgICAgICAgICAgICAgICAkLnByb3h5KG9wdGlvbnMub3BlbiwgbW9kYWwpKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgLy8gZGVzdHJveSBtb2RhbCBvbiBoaWRlLCB1bmxlc3MgZXhwbGljaXRseSBhc2tlZCBub3QgdG9cbiAgICAgICAgaWYgKG9wdGlvbnMuZGVzdHJveSA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMuZGVzdHJveSkge1xuICAgICAgICAgICAgbW9kYWwub24oXCJoaWRkZW4uYnMubW9kYWxcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIG1vZGFsLnJlbW92ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbW9kYWwub24oXCJoaWRkZW4uYnMubW9kYWxcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMubm90ZWJvb2spIHtcbiAgICAgICAgICAgICAgICB2YXIgY2VsbCA9IG9wdGlvbnMubm90ZWJvb2suZ2V0X3NlbGVjdGVkX2NlbGwoKTtcbiAgICAgICAgICAgICAgICBpZiAoY2VsbCkgY2VsbC5zZWxlY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmtleWJvYXJkX21hbmFnZXIpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmtleWJvYXJkX21hbmFnZXIuZW5hYmxlKCk7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5rZXlib2FyZF9tYW5hZ2VyLmNvbW1hbmRfbW9kZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIGlmIChvcHRpb25zLmtleWJvYXJkX21hbmFnZXIpIHtcbiAgICAgICAgICAgIG9wdGlvbnMua2V5Ym9hcmRfbWFuYWdlci5kaXNhYmxlKCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmKG9wdGlvbnMuYmFja2Ryb3AgPT09IHVuZGVmaW5lZCl7XG4gICAgICAgICAgb3B0aW9ucy5iYWNrZHJvcCA9ICdzdGF0aWMnO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gbW9kYWwubW9kYWwob3B0aW9ucyk7XG4gICAgfTtcblxuICAgIHZhciBrZXJuZWxfbW9kYWwgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICAvKipcbiAgICAgICAgICogb25seSBvbmUga2VybmVsIGRpYWxvZyBzaG91bGQgYmUgb3BlbiBhdCBhIHRpbWUgLS0gYnV0XG4gICAgICAgICAqIG90aGVyIG1vZGFsIGRpYWxvZ3MgY2FuIHN0aWxsIGJlIG9wZW5cbiAgICAgICAgICovXG4gICAgICAgICQoJy5rZXJuZWwtbW9kYWwnKS5tb2RhbCgnaGlkZScpO1xuICAgICAgICB2YXIgZGlhbG9nID0gbW9kYWwob3B0aW9ucyk7XG4gICAgICAgIGRpYWxvZy5hZGRDbGFzcygna2VybmVsLW1vZGFsJyk7XG4gICAgICAgIHJldHVybiBkaWFsb2c7XG4gICAgfTtcblxuICAgIHZhciBlZGl0X21ldGFkYXRhID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucy5uYW1lID0gb3B0aW9ucy5uYW1lIHx8IFwiQ2VsbFwiO1xuICAgICAgICB2YXIgZXJyb3JfZGl2ID0gJCgnPGRpdi8+JykuY3NzKCdjb2xvcicsICdyZWQnKTtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBcbiAgICAgICAgICAgIFwiTWFudWFsbHkgZWRpdCB0aGUgSlNPTiBiZWxvdyB0byBtYW5pcHVsYXRlIHRoZSBtZXRhZGF0YSBmb3IgdGhpcyBcIiArIG9wdGlvbnMubmFtZSArIFwiLlwiICtcbiAgICAgICAgICAgIFwiIFdlIHJlY29tbWVuZCBwdXR0aW5nIGN1c3RvbSBtZXRhZGF0YSBhdHRyaWJ1dGVzIGluIGFuIGFwcHJvcHJpYXRlbHkgbmFtZWQgc3ViLXN0cnVjdHVyZSxcIiArXG4gICAgICAgICAgICBcIiBzbyB0aGV5IGRvbid0IGNvbmZsaWN0IHdpdGggdGhvc2Ugb2Ygb3RoZXJzLlwiO1xuXG4gICAgICAgIHZhciB0ZXh0YXJlYSA9ICQoJzx0ZXh0YXJlYS8+JylcbiAgICAgICAgICAgIC5hdHRyKCdyb3dzJywgJzEzJylcbiAgICAgICAgICAgIC5hdHRyKCdjb2xzJywgJzgwJylcbiAgICAgICAgICAgIC5hdHRyKCduYW1lJywgJ21ldGFkYXRhJylcbiAgICAgICAgICAgIC50ZXh0KEpTT04uc3RyaW5naWZ5KG9wdGlvbnMubWQgfHwge30sIG51bGwsIDIpKTtcbiAgICAgICAgXG4gICAgICAgIHZhciBkaWFsb2dmb3JtID0gJCgnPGRpdi8+JykuYXR0cigndGl0bGUnLCAnRWRpdCB0aGUgbWV0YWRhdGEnKVxuICAgICAgICAgICAgLmFwcGVuZChcbiAgICAgICAgICAgICAgICAkKCc8Zm9ybS8+JykuYXBwZW5kKFxuICAgICAgICAgICAgICAgICAgICAkKCc8ZmllbGRzZXQvPicpLmFwcGVuZChcbiAgICAgICAgICAgICAgICAgICAgICAgICQoJzxsYWJlbC8+JylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdmb3InLCdtZXRhZGF0YScpXG4gICAgICAgICAgICAgICAgICAgICAgICAudGV4dChtZXNzYWdlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZChlcnJvcl9kaXYpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCQoJzxici8+JykpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKHRleHRhcmVhKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuICAgICAgICB2YXIgZWRpdG9yID0gQ29kZU1pcnJvci5mcm9tVGV4dEFyZWEodGV4dGFyZWFbMF0sIHtcbiAgICAgICAgICAgIGxpbmVOdW1iZXJzOiB0cnVlLFxuICAgICAgICAgICAgbWF0Y2hCcmFja2V0czogdHJ1ZSxcbiAgICAgICAgICAgIGluZGVudFVuaXQ6IDIsXG4gICAgICAgICAgICBhdXRvSW5kZW50OiB0cnVlLFxuICAgICAgICAgICAgbW9kZTogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIG1vZGFsX29iaiA9IG1vZGFsKHtcbiAgICAgICAgICAgIHRpdGxlOiBcIkVkaXQgXCIgKyBvcHRpb25zLm5hbWUgKyBcIiBNZXRhZGF0YVwiLFxuICAgICAgICAgICAgYm9keTogZGlhbG9nZm9ybSxcbiAgICAgICAgICAgIGJ1dHRvbnM6IHtcbiAgICAgICAgICAgICAgICBPSzogeyBjbGFzcyA6IFwiYnRuLXByaW1hcnlcIixcbiAgICAgICAgICAgICAgICAgICAgY2xpY2s6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiB2YWxpZGF0ZSBqc29uIGFuZCBzZXQgaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld19tZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3X21kID0gSlNPTi5wYXJzZShlZGl0b3IuZ2V0VmFsdWUoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcl9kaXYudGV4dCgnV0FSTklORzogQ291bGQgbm90IHNhdmUgaW52YWxpZCBKU09OLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuY2FsbGJhY2sobmV3X21kKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgQ2FuY2VsOiB7fVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5vdGVib29rOiBvcHRpb25zLm5vdGVib29rLFxuICAgICAgICAgICAga2V5Ym9hcmRfbWFuYWdlcjogb3B0aW9ucy5rZXlib2FyZF9tYW5hZ2VyLFxuICAgICAgICB9KTtcblxuICAgICAgICBtb2RhbF9vYmoub24oJ3Nob3duLmJzLm1vZGFsJywgZnVuY3Rpb24oKXsgZWRpdG9yLnJlZnJlc2goKTsgfSk7XG4gICAgICAgICAgICBcbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIG1vZGFsIDogbW9kYWwsXG4gICAgICAgIGtlcm5lbF9tb2RhbCA6IGtlcm5lbF9tb2RhbCxcbiAgICAgICAgZWRpdF9tZXRhZGF0YSA6IGVkaXRfbWV0YWRhdGEsXG4gICAgfTtcbiIsIi8vIENvcHlyaWdodCAoYykgSnVweXRlciBEZXZlbG9wbWVudCBUZWFtLlxuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBNb2RpZmllZCBCU0QgTGljZW5zZS5cblxuLy8gR2l2ZSB1cyBhbiBvYmplY3QgdG8gYmluZCBhbGwgZXZlbnRzIHRvLiBUaGlzIG9iamVjdCBzaG91bGQgYmUgY3JlYXRlZFxuLy8gYmVmb3JlIGFsbCBvdGhlciBvYmplY3RzIHNvIGl0IGV4aXN0cyB3aGVuIG90aGVycyByZWdpc3RlciBldmVudCBoYW5kbGVycy5cbi8vIFRvIHJlZ2lzdGVyIGFuIGV2ZW50IGhhbmRsZXI6XG4vL1xuLy8gcmVxdWlyZShbJ2Jhc2UvanMvZXZlbnRzJ10sIGZ1bmN0aW9uIChldmVudHMpIHtcbi8vICAgICBldmVudHMub24oXCJldmVudC5OYW1lc3BhY2VcIiwgZnVuY3Rpb24gKCkgeyBkb19zdHVmZigpOyB9KTtcbi8vIH0pO1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbmlmICghd2luZG93Lmp1cHl0ZXJFdmVudHMpIHtcbiAgICB2YXIgRXZlbnRzID0gZnVuY3Rpb24gKCkge307XG4gICAgd2luZG93Lmp1cHl0ZXJFdmVudHMgPSAkKFtuZXcgRXZlbnRzKCldKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3aW5kb3cuanVweXRlckV2ZW50cztcbiIsIi8vIENvcHlyaWdodCAoYykgSnVweXRlciBEZXZlbG9wbWVudCBUZWFtLlxuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBNb2RpZmllZCBCU0QgTGljZW5zZS5cbi8qKlxuICpcbiAqXG4gKiBAbW9kdWxlIGtleWJvYXJkXG4gKiBAbmFtZXNwYWNlIGtleWJvYXJkXG4gKiBAY2xhc3MgU2hvcnRjdXRNYW5hZ2VyXG4gKi9cblxuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgdmFyIHV0aWxzID0gcmVxdWlyZSgnYmFzZS9qcy91dGlscycpO1xuXG5cbiAgICAvKipcbiAgICAgKiBTZXR1cCBnbG9iYWwga2V5Y29kZXMgYW5kIGludmVyc2Uga2V5Y29kZXMuXG4gICAgICpcbiAgICAgKiBTZWUgaHR0cDovL3VuaXhwYXBhLmNvbS9qcy9rZXkuaHRtbCBmb3IgYSBjb21wbGV0ZSBkZXNjcmlwdGlvbi4gVGhlIHNob3J0IG9mXG4gICAgICogaXQgaXMgdGhhdCB0aGVyZSBhcmUgZGlmZmVyZW50IGtleWNvZGUgc2V0cy4gRmlyZWZveCB1c2VzIHRoZSBcIk1vemlsbGEga2V5Y29kZXNcIlxuICAgICAqIGFuZCBXZWJraXQvSUUgdXNlIHRoZSBcIklFIGtleWNvZGVzXCIuIFRoZXNlIGtleWNvZGUgc2V0cyBhcmUgbW9zdGx5IHRoZSBzYW1lXG4gICAgICogYnV0IGhhdmUgbWlub3IgZGlmZmVyZW5jZXMuXG4gICAgICoqL1xuXG4gICAgIC8vIFRoZXNlIGFwcGx5IHRvIEZpcmVmb3gsIChXZWJraXQgYW5kIElFKVxuICAgICAvLyBUaGlzIGRvZXMgd29yayAqKm9ubHkqKiBvbiBVUyBrZXlib2FyZC5cbiAgICB2YXIgX2tleWNvZGVzID0ge1xuICAgICAgICAnYSc6IDY1LCAnYic6IDY2LCAnYyc6IDY3LCAnZCc6IDY4LCAnZSc6IDY5LCAnZic6IDcwLCAnZyc6IDcxLCAnaCc6IDcyLCAnaSc6IDczLFxuICAgICAgICAnaic6IDc0LCAnayc6IDc1LCAnbCc6IDc2LCAnbSc6IDc3LCAnbic6IDc4LCAnbyc6IDc5LCAncCc6IDgwLCAncSc6IDgxLCAncic6IDgyLFxuICAgICAgICAncyc6IDgzLCAndCc6IDg0LCAndSc6IDg1LCAndic6IDg2LCAndyc6IDg3LCAneCc6IDg4LCAneSc6IDg5LCAneic6IDkwLFxuICAgICAgICAnMSAhJzogNDksICcyIEAnOiA1MCwgJzMgIyc6IDUxLCAnNCAkJzogNTIsICc1ICUnOiA1MywgJzYgXic6IDU0LFxuICAgICAgICAnNyAmJzogNTUsICc4IConOiA1NiwgJzkgKCc6IDU3LCAnMCApJzogNDgsIFxuICAgICAgICAnWyB7JzogMjE5LCAnXSB9JzogMjIxLCAnYCB+JzogMTkyLCAgJywgPCc6IDE4OCwgJy4gPic6IDE5MCwgJy8gPyc6IDE5MSxcbiAgICAgICAgJ1xcXFwgfCc6IDIyMCwgJ1xcJyBcIic6IDIyMixcbiAgICAgICAgJ251bXBhZDAnOiA5NiwgJ251bXBhZDEnOiA5NywgJ251bXBhZDInOiA5OCwgJ251bXBhZDMnOiA5OSwgJ251bXBhZDQnOiAxMDAsXG4gICAgICAgICdudW1wYWQ1JzogMTAxLCAnbnVtcGFkNic6IDEwMiwgJ251bXBhZDcnOiAxMDMsICdudW1wYWQ4JzogMTA0LCAnbnVtcGFkOSc6IDEwNSxcbiAgICAgICAgJ211bHRpcGx5JzogMTA2LCAnYWRkJzogMTA3LCAnc3VidHJhY3QnOiAxMDksICdkZWNpbWFsJzogMTEwLCAnZGl2aWRlJzogMTExLFxuICAgICAgICAnZjEnOiAxMTIsICdmMic6IDExMywgJ2YzJzogMTE0LCAnZjQnOiAxMTUsICdmNSc6IDExNiwgJ2Y2JzogMTE3LCAnZjcnOiAxMTgsXG4gICAgICAgICdmOCc6IDExOSwgJ2Y5JzogMTIwLCAnZjExJzogMTIyLCAnZjEyJzogMTIzLCAnZjEzJzogMTI0LCAnZjE0JzogMTI1LCAnZjE1JzogMTI2LFxuICAgICAgICAnYmFja3NwYWNlJzogOCwgJ3RhYic6IDksICdlbnRlcic6IDEzLCAnc2hpZnQnOiAxNiwgJ2N0cmwnOiAxNywgJ2FsdCc6IDE4LFxuICAgICAgICAnbWV0YSc6IDkxLCAnY2Fwc2xvY2snOiAyMCwgJ2VzYyc6IDI3LCAnc3BhY2UnOiAzMiwgJ3BhZ2V1cCc6IDMzLCAncGFnZWRvd24nOiAzNCxcbiAgICAgICAgJ2VuZCc6IDM1LCAnaG9tZSc6IDM2LCAnbGVmdCc6IDM3LCAndXAnOiAzOCwgJ3JpZ2h0JzogMzksICdkb3duJzogNDAsXG4gICAgICAgICdpbnNlcnQnOiA0NSwgJ2RlbGV0ZSc6IDQ2LCAnbnVtbG9jayc6IDE0NCxcbiAgICB9O1xuXG4gICAgLy8gVGhlc2UgYXBwbHkgdG8gRmlyZWZveCBhbmQgT3BlcmFcbiAgICB2YXIgX21vemlsbGFfa2V5Y29kZXMgPSB7XG4gICAgICAgICc7IDonOiA1OSwgJz0gKyc6IDYxLCAnLSBfJzogMTczLCAnbWV0YSc6IDIyNCwgJ21pbnVzJzoxNzNcbiAgICB9O1xuXG4gICAgLy8gVGhpcyBhcHBseSB0byBXZWJraXQgYW5kIElFXG4gICAgdmFyIF9pZV9rZXljb2RlcyA9IHtcbiAgICAgICAgJzsgOic6IDE4NiwgJz0gKyc6IDE4NywgJy0gXyc6IDE4OSwgJ21pbnVzJzoxODlcbiAgICB9O1xuXG4gICAgdmFyIGJyb3dzZXIgPSB1dGlscy5icm93c2VyWzBdO1xuICAgIHZhciBwbGF0Zm9ybSA9IHV0aWxzLnBsYXRmb3JtO1xuXG4gICAgaWYgKGJyb3dzZXIgPT09ICdGaXJlZm94JyB8fCBicm93c2VyID09PSAnT3BlcmEnIHx8IGJyb3dzZXIgPT09ICdOZXRzY2FwZScpIHtcbiAgICAgICAgJC5leHRlbmQoX2tleWNvZGVzLCBfbW96aWxsYV9rZXljb2Rlcyk7XG4gICAgfSBlbHNlIGlmIChicm93c2VyID09PSAnU2FmYXJpJyB8fCBicm93c2VyID09PSAnQ2hyb21lJyB8fCBicm93c2VyID09PSAnTVNJRScpIHtcbiAgICAgICAgJC5leHRlbmQoX2tleWNvZGVzLCBfaWVfa2V5Y29kZXMpO1xuICAgIH1cblxuICAgIHZhciBrZXljb2RlcyA9IHt9O1xuICAgIHZhciBpbnZfa2V5Y29kZXMgPSB7fTtcbiAgICBmb3IgKHZhciBuYW1lIGluIF9rZXljb2Rlcykge1xuICAgICAgICB2YXIgbmFtZXMgPSBuYW1lLnNwbGl0KCcgJyk7XG4gICAgICAgIGlmIChuYW1lcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHZhciBuID0gbmFtZXNbMF07XG4gICAgICAgICAgICBrZXljb2Rlc1tuXSA9IF9rZXljb2Rlc1tuXTtcbiAgICAgICAgICAgIGludl9rZXljb2Rlc1tfa2V5Y29kZXNbbl1dID0gbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBwcmltYXJ5ID0gbmFtZXNbMF07XG4gICAgICAgICAgICB2YXIgc2Vjb25kYXJ5ID0gbmFtZXNbMV07XG4gICAgICAgICAgICBrZXljb2Rlc1twcmltYXJ5XSA9IF9rZXljb2Rlc1tuYW1lXTtcbiAgICAgICAgICAgIGtleWNvZGVzW3NlY29uZGFyeV0gPSBfa2V5Y29kZXNbbmFtZV07XG4gICAgICAgICAgICBpbnZfa2V5Y29kZXNbX2tleWNvZGVzW25hbWVdXSA9IHByaW1hcnk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbm9ybWFsaXplX2tleSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIGludl9rZXljb2Rlc1trZXljb2Rlc1trZXldXTtcbiAgICB9O1xuXG4gICAgdmFyIG5vcm1hbGl6ZV9zaG9ydGN1dCA9IGZ1bmN0aW9uIChzaG9ydGN1dCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQGZ1bmN0aW9uIF9ub3JtYWxpemVfc2hvcnRjdXRcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogcmV0dXJuIGEgZGljdCBjb250YWluaW5nIHRoZSBub3JtYWxpemVkIHNob3J0Y3V0IGFuZCB0aGUgbnVtYmVyIG9mIHRpbWUgaXQgc2hvdWxkIGJlIHByZXNzZWQ6XG4gICAgICAgICAqXG4gICAgICAgICAqIFB1dCBhIHNob3J0Y3V0IGludG8gbm9ybWFsaXplZCBmb3JtOlxuICAgICAgICAgKiAxLiBNYWtlIGxvd2VyY2FzZVxuICAgICAgICAgKiAyLiBSZXBsYWNlIGNtZCBieSBtZXRhXG4gICAgICAgICAqIDMuIFNvcnQgJy0nIHNlcGFyYXRlZCBtb2RpZmllcnMgaW50byB0aGUgb3JkZXIgYWx0LWN0cmwtbWV0YS1zaGlmdFxuICAgICAgICAgKiA0LiBOb3JtYWxpemUga2V5c1xuICAgICAgICAgKiovXG4gICAgICAgIGlmIChwbGF0Zm9ybSA9PT0gJ01hY09TJykge1xuICAgICAgICAgICAgc2hvcnRjdXQgPSBzaG9ydGN1dC50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoJ2NtZHRybC0nLCAnY21kLScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2hvcnRjdXQgPSBzaG9ydGN1dC50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoJ2NtZHRybC0nLCAnY3RybC0nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNob3J0Y3V0ID0gc2hvcnRjdXQudG9Mb3dlckNhc2UoKS5yZXBsYWNlKCdjbWQnLCAnbWV0YScpO1xuICAgICAgICBzaG9ydGN1dCA9IHNob3J0Y3V0LnJlcGxhY2UoLy0kLywgJ21pbnVzJyk7ICAvLyBjYXRjaCBzaG9ydGN1dHMgdXNpbmcgJy0nIGtleVxuICAgICAgICBzaG9ydGN1dCA9IHNob3J0Y3V0LnJlcGxhY2UoLywkLywgJ2NvbW1hJyk7ICAvLyBjYXRjaCBzaG9ydGN1dHMgdXNpbmcgJy0nIGtleVxuICAgICAgICBpZihzaG9ydGN1dC5pbmRleE9mKCcsJykgIT09IC0xKXtcbiAgICAgICAgICAgIHZhciBzaHQgPSBzaG9ydGN1dC5zcGxpdCgnLCcpO1xuICAgICAgICAgICAgc2h0ID0gXy5tYXAoc2h0LCBub3JtYWxpemVfc2hvcnRjdXQpO1xuICAgICAgICAgICAgcmV0dXJuIHNob3J0Y3V0O1xuICAgICAgICB9XG4gICAgICAgIHNob3J0Y3V0ID0gc2hvcnRjdXQucmVwbGFjZSgvY29tbWEvZywgJywnKTsgIC8vIGNhdGNoIHNob3J0Y3V0cyB1c2luZyAnLScga2V5XG4gICAgICAgIHZhciB2YWx1ZXMgPSBzaG9ydGN1dC5zcGxpdChcIi1cIik7XG4gICAgICAgIGlmICh2YWx1ZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplX2tleSh2YWx1ZXNbMF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIG1vZGlmaWVycyA9IHZhbHVlcy5zbGljZSgwLC0xKTtcbiAgICAgICAgICAgIHZhciBrZXkgPSBub3JtYWxpemVfa2V5KHZhbHVlc1t2YWx1ZXMubGVuZ3RoLTFdKTtcbiAgICAgICAgICAgIG1vZGlmaWVycy5zb3J0KCk7XG4gICAgICAgICAgICByZXR1cm4gbW9kaWZpZXJzLmpvaW4oJy0nKSArICctJyArIGtleTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgc2hvcnRjdXRfdG9fZXZlbnQgPSBmdW5jdGlvbiAoc2hvcnRjdXQsIHR5cGUpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnQgYSBzaG9ydGN1dCAoc2hpZnQtcikgdG8gYSBqUXVlcnkgRXZlbnQgb2JqZWN0XG4gICAgICAgICAqKi9cbiAgICAgICAgdHlwZSA9IHR5cGUgfHwgJ2tleWRvd24nO1xuICAgICAgICBzaG9ydGN1dCA9IG5vcm1hbGl6ZV9zaG9ydGN1dChzaG9ydGN1dCk7XG4gICAgICAgIHNob3J0Y3V0ID0gc2hvcnRjdXQucmVwbGFjZSgvLSQvLCAnbWludXMnKTsgIC8vIGNhdGNoIHNob3J0Y3V0cyB1c2luZyAnLScga2V5XG4gICAgICAgIHZhciB2YWx1ZXMgPSBzaG9ydGN1dC5zcGxpdChcIi1cIik7XG4gICAgICAgIHZhciBtb2RpZmllcnMgPSB2YWx1ZXMuc2xpY2UoMCwtMSk7XG4gICAgICAgIHZhciBrZXkgPSB2YWx1ZXNbdmFsdWVzLmxlbmd0aC0xXTtcbiAgICAgICAgdmFyIG9wdHMgPSB7d2hpY2g6IGtleWNvZGVzW2tleV19O1xuICAgICAgICBpZiAobW9kaWZpZXJzLmluZGV4T2YoJ2FsdCcpICE9PSAtMSkge29wdHMuYWx0S2V5ID0gdHJ1ZTt9XG4gICAgICAgIGlmIChtb2RpZmllcnMuaW5kZXhPZignY3RybCcpICE9PSAtMSkge29wdHMuY3RybEtleSA9IHRydWU7fVxuICAgICAgICBpZiAobW9kaWZpZXJzLmluZGV4T2YoJ21ldGEnKSAhPT0gLTEpIHtvcHRzLm1ldGFLZXkgPSB0cnVlO31cbiAgICAgICAgaWYgKG1vZGlmaWVycy5pbmRleE9mKCdzaGlmdCcpICE9PSAtMSkge29wdHMuc2hpZnRLZXkgPSB0cnVlO31cbiAgICAgICAgcmV0dXJuICQuRXZlbnQodHlwZSwgb3B0cyk7XG4gICAgfTtcblxuICAgIHZhciBvbmx5X21vZGlmaWVyX2V2ZW50ID0gZnVuY3Rpb24oZXZlbnQpe1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJuIGB0cnVlYCBpZiB0aGUgZXZlbnQgb25seSBjb250YWlucyBtb2RpZmllcnMga2V5cy5cbiAgICAgICAgICogZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICAgICAqKi9cbiAgICAgICAgdmFyIGtleSA9IGludl9rZXljb2Rlc1tldmVudC53aGljaF07XG4gICAgICAgIHJldHVybiAoKGV2ZW50LmFsdEtleSB8fCBldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkgfHwgZXZlbnQuc2hpZnRLZXkpICYmXG4gICAgICAgICAoa2V5ID09PSAnYWx0J3x8IGtleSA9PT0gJ2N0cmwnfHwga2V5ID09PSAnbWV0YSd8fCBrZXkgPT09ICdzaGlmdCcpKTtcblxuICAgIH07XG5cbiAgICB2YXIgZXZlbnRfdG9fc2hvcnRjdXQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnQgYSBqUXVlcnkgRXZlbnQgb2JqZWN0IHRvIGEgbm9ybWFsaXplZCBzaG9ydGN1dCBzdHJpbmcgKHNoaWZ0LXIpXG4gICAgICAgICAqKi9cbiAgICAgICAgdmFyIHNob3J0Y3V0ID0gJyc7XG4gICAgICAgIHZhciBrZXkgPSBpbnZfa2V5Y29kZXNbZXZlbnQud2hpY2hdO1xuICAgICAgICBpZiAoZXZlbnQuYWx0S2V5ICYmIGtleSAhPT0gJ2FsdCcpIHtzaG9ydGN1dCArPSAnYWx0LSc7fVxuICAgICAgICBpZiAoZXZlbnQuY3RybEtleSAmJiBrZXkgIT09ICdjdHJsJykge3Nob3J0Y3V0ICs9ICdjdHJsLSc7fVxuICAgICAgICBpZiAoZXZlbnQubWV0YUtleSAmJiBrZXkgIT09ICdtZXRhJykge3Nob3J0Y3V0ICs9ICdtZXRhLSc7fVxuICAgICAgICBpZiAoZXZlbnQuc2hpZnRLZXkgJiYga2V5ICE9PSAnc2hpZnQnKSB7c2hvcnRjdXQgKz0gJ3NoaWZ0LSc7fVxuICAgICAgICBzaG9ydGN1dCArPSBrZXk7XG4gICAgICAgIHJldHVybiBzaG9ydGN1dDtcbiAgICB9O1xuXG4gICAgLy8gU2hvcnRjdXQgbWFuYWdlciBjbGFzc1xuXG4gICAgdmFyIFNob3J0Y3V0TWFuYWdlciA9IGZ1bmN0aW9uIChkZWxheSwgZXZlbnRzLCBhY3Rpb25zLCBlbnYpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgY2xhc3MgdG8gZGVhbCB3aXRoIGtleWJvYXJkIGV2ZW50IGFuZCBzaG9ydGN1dFxuICAgICAgICAgKlxuICAgICAgICAgKiBAY2xhc3MgU2hvcnRjdXRNYW5hZ2VyXG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fc2hvcnRjdXRzID0ge307XG4gICAgICAgIHRoaXMuZGVsYXkgPSBkZWxheSB8fCA4MDA7IC8vIGRlbGF5IGluIG1pbGxpc2Vjb25kc1xuICAgICAgICB0aGlzLmV2ZW50cyA9IGV2ZW50cztcbiAgICAgICAgdGhpcy5hY3Rpb25zID0gYWN0aW9ucztcbiAgICAgICAgdGhpcy5hY3Rpb25zLmV4dGVuZF9lbnYoZW52KTtcbiAgICAgICAgdGhpcy5fcXVldWUgPSBbXTtcbiAgICAgICAgdGhpcy5fY2xlYXJ0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgT2JqZWN0LnNlYWwodGhpcyk7XG4gICAgfTtcblxuICAgIFNob3J0Y3V0TWFuYWdlci5wcm90b3R5cGUuY2xlYXJzb29uID0gZnVuY3Rpb24oKXtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENsZWFyIHRoZSBwZW5kaW5nIHNob3J0Y3V0IHNvb24sIGFuZCBjYW5jZWwgcHJldmlvdXMgY2xlYXJpbmdcbiAgICAgICAgICogdGhhdCBtaWdodCBiZSByZWdpc3RlcmVkLlxuICAgICAgICAgKiovXG4gICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fY2xlYXJ0aW1lb3V0KTtcbiAgICAgICAgIHRoaXMuX2NsZWFydGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXt0aGF0LmNsZWFycXVldWUoKTt9LCB0aGlzLmRlbGF5KTtcbiAgICB9O1xuXG5cbiAgICBTaG9ydGN1dE1hbmFnZXIucHJvdG90eXBlLmNsZWFycXVldWUgPSBmdW5jdGlvbigpe1xuICAgICAgICAvKipcbiAgICAgICAgICogY2xlYXIgdGhlIHBlbmRpbmcgc2hvcnRjdXQgc2VxdWVuY2Ugbm93LiBcbiAgICAgICAgICoqL1xuICAgICAgICB0aGlzLl9xdWV1ZSA9IFtdO1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fY2xlYXJ0aW1lb3V0KTtcbiAgICB9O1xuXG5cbiAgICB2YXIgZmxhdHRlbl9zaG9ydHRyZWUgPSBmdW5jdGlvbih0cmVlKXtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZsYXR0ZW4gYSB0cmVlIG9mIHNob3J0Y3V0IHNlcXVlbmNlcy4gXG4gICAgICAgICAqIHVzZSBmdWxsIHRvIGl0ZXJhdGUgb3ZlciBhbGwgdGhlIGtleS92YWx1ZXMgb2YgYXZhaWxhYmxlIHNob3J0Y3V0cy5cbiAgICAgICAgICoqL1xuICAgICAgICB2YXIgIGRjdCA9IHt9O1xuICAgICAgICBmb3IodmFyIGtleSBpbiB0cmVlKXtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRyZWVba2V5XTtcbiAgICAgICAgICAgIGlmKHR5cGVvZih2YWx1ZSkgPT09ICdzdHJpbmcnKXtcbiAgICAgICAgICAgICAgICBkY3Rba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgZnRyZWU9ZmxhdHRlbl9zaG9ydHRyZWUodmFsdWUpO1xuICAgICAgICAgICAgICAgIGZvcih2YXIgc3Via2V5IGluIGZ0cmVlKXtcbiAgICAgICAgICAgICAgICAgICAgZGN0W2tleSsnLCcrc3Via2V5XSA9IGZ0cmVlW3N1YmtleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGN0O1xuICAgIH07XG4gICAgXG4gICAgU2hvcnRjdXRNYW5hZ2VyLnByb3RvdHlwZS5nZXRfYWN0aW9uX3Nob3J0Y3V0ID0gZnVuY3Rpb24obmFtZSl7XG4gICAgICB2YXIgZnRyZWUgPSBmbGF0dGVuX3Nob3J0dHJlZSh0aGlzLl9zaG9ydGN1dHMpO1xuICAgICAgdmFyIHJlcyA9IHt9O1xuICAgICAgZm9yICh2YXIgc2h0IGluIGZ0cmVlICl7XG4gICAgICAgIGlmKGZ0cmVlW3NodF0gPT09IG5hbWUpe1xuICAgICAgICAgIHJldHVybiBzaHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfTtcblxuICAgIFNob3J0Y3V0TWFuYWdlci5wcm90b3R5cGUuaGVscCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGhlbHAgPSBbXTtcbiAgICAgICAgdmFyIGZ0cmVlID0gZmxhdHRlbl9zaG9ydHRyZWUodGhpcy5fc2hvcnRjdXRzKTtcbiAgICAgICAgZm9yICh2YXIgc2hvcnRjdXQgaW4gZnRyZWUpIHtcbiAgICAgICAgICAgIHZhciBhY3Rpb24gPSB0aGlzLmFjdGlvbnMuZ2V0KGZ0cmVlW3Nob3J0Y3V0XSk7XG4gICAgICAgICAgICB2YXIgaGVscF9zdHJpbmcgPSBhY3Rpb24uaGVscHx8Jz09IG5vIGhlbHAgPT0nO1xuICAgICAgICAgICAgdmFyIGhlbHBfaW5kZXggPSBhY3Rpb24uaGVscF9pbmRleDtcbiAgICAgICAgICAgIGlmIChoZWxwX3N0cmluZykge1xuICAgICAgICAgICAgICAgIHZhciBzaG9ydHN0cmluZyA9IChhY3Rpb24uc2hvcnRzdHJpbmd8fHNob3J0Y3V0KTtcbiAgICAgICAgICAgICAgICBoZWxwLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBzaG9ydGN1dDogc2hvcnRzdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgIGhlbHA6IGhlbHBfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICBoZWxwX2luZGV4OiBoZWxwX2luZGV4fVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaGVscC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICBpZiAoYS5oZWxwX2luZGV4ID09PSBiLmhlbHBfaW5kZXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhLmhlbHBfaW5kZXggPT09IHVuZGVmaW5lZCB8fCBhLmhlbHBfaW5kZXggPiBiLmhlbHBfaW5kZXgpe1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGhlbHA7XG4gICAgfTtcblxuICAgIFNob3J0Y3V0TWFuYWdlci5wcm90b3R5cGUuY2xlYXJfc2hvcnRjdXRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9zaG9ydGN1dHMgPSB7fTtcbiAgICB9O1xuXG4gICAgU2hvcnRjdXRNYW5hZ2VyLnByb3RvdHlwZS5nZXRfc2hvcnRjdXQgPSBmdW5jdGlvbiAoc2hvcnRjdXQpe1xuICAgICAgICAvKipcbiAgICAgICAgICogcmV0dXJuIGEgbm9kZSBvZiB0aGUgc2hvcnRjdXQgdHJlZSB3aGljaCBhbiBhY3Rpb24gbmFtZSAoc3RyaW5nKSBpZiBsZWFmLFxuICAgICAgICAgKiBhbmQgYW4gb2JqZWN0IHdpdGggYG9iamVjdC5zdWJ0cmVlPT09dHJ1ZWBcbiAgICAgICAgICoqL1xuICAgICAgICBpZih0eXBlb2Yoc2hvcnRjdXQpID09PSAnc3RyaW5nJyl7XG4gICAgICAgICAgICBzaG9ydGN1dCA9IHNob3J0Y3V0LnNwbGl0KCcsJyk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRfbGVhZihzaG9ydGN1dCwgdGhpcy5fc2hvcnRjdXRzKTtcbiAgICB9O1xuXG5cbiAgICBTaG9ydGN1dE1hbmFnZXIucHJvdG90eXBlLl9nZXRfbGVhZiA9IGZ1bmN0aW9uKHNob3J0Y3V0X2FycmF5LCB0cmVlKXtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIGZpbmQgYSBsZWFmL25vZGUgaW4gYSBzdWJ0cmVlIG9mIHRoZSBrZXlib2FyZCBzaG9ydGN1dFxuICAgICAgICAgKlxuICAgICAgICAgKiovXG4gICAgICAgIGlmKHNob3J0Y3V0X2FycmF5Lmxlbmd0aCA9PT0gMSl7XG4gICAgICAgICAgICByZXR1cm4gdHJlZVtzaG9ydGN1dF9hcnJheVswXV07XG4gICAgICAgIH0gZWxzZSBpZiggIHR5cGVvZih0cmVlW3Nob3J0Y3V0X2FycmF5WzBdXSkgIT09ICdzdHJpbmcnKXtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRfbGVhZihzaG9ydGN1dF9hcnJheS5zbGljZSgxKSwgdHJlZVtzaG9ydGN1dF9hcnJheVswXV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICBTaG9ydGN1dE1hbmFnZXIucHJvdG90eXBlLnNldF9zaG9ydGN1dCA9IGZ1bmN0aW9uKCBzaG9ydGN1dCwgYWN0aW9uX25hbWUpe1xuICAgICAgICBpZiggdHlwZW9mKGFjdGlvbl9uYW1lKSAhPT0gJ3N0cmluZycpe3Rocm93IG5ldyBFcnJvcignYWN0aW9uIGlzIG5vdCBhIHN0cmluZycsIGFjdGlvbl9uYW1lKTt9XG4gICAgICAgIGlmKCB0eXBlb2Yoc2hvcnRjdXQpID09PSAnc3RyaW5nJyl7XG4gICAgICAgICAgICBzaG9ydGN1dCA9IHNob3J0Y3V0LnNwbGl0KCcsJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3NldF9sZWFmKHNob3J0Y3V0LCBhY3Rpb25fbmFtZSwgdGhpcy5fc2hvcnRjdXRzKTtcbiAgICB9O1xuXG4gICAgU2hvcnRjdXRNYW5hZ2VyLnByb3RvdHlwZS5faXNfbGVhZiA9IGZ1bmN0aW9uKHNob3J0Y3V0X2FycmF5LCB0cmVlKXtcbiAgICAgICAgaWYoc2hvcnRjdXRfYXJyYXkubGVuZ3RoID09PSAxKXtcbiAgICAgICAgICAgcmV0dXJuKHR5cGVvZih0cmVlW3Nob3J0Y3V0X2FycmF5WzBdXSkgPT09ICdzdHJpbmcnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBzdWJ0cmVlID0gdHJlZVtzaG9ydGN1dF9hcnJheVswXV07XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faXNfbGVhZihzaG9ydGN1dF9hcnJheS5zbGljZSgxKSwgc3VidHJlZSApO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIFNob3J0Y3V0TWFuYWdlci5wcm90b3R5cGUuX3JlbW92ZV9sZWFmID0gZnVuY3Rpb24oc2hvcnRjdXRfYXJyYXksIHRyZWUsIGFsbG93X25vZGUpe1xuICAgICAgICBpZihzaG9ydGN1dF9hcnJheS5sZW5ndGggPT09IDEpe1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRfbm9kZSA9IHRyZWVbc2hvcnRjdXRfYXJyYXlbMF1dO1xuICAgICAgICAgICAgaWYodHlwZW9mKGN1cnJlbnRfbm9kZSkgPT09ICdzdHJpbmcnKXtcbiAgICAgICAgICAgICAgICBkZWxldGUgdHJlZVtzaG9ydGN1dF9hcnJheVswXV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93KCd0cnkgdG8gZGVsZXRlIG5vbi1sZWFmJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdmVfbGVhZihzaG9ydGN1dF9hcnJheS5zbGljZSgxKSwgIHRyZWVbc2hvcnRjdXRfYXJyYXlbMF1dLCBhbGxvd19ub2RlKTtcbiAgICAgICAgICAgIGlmKF8ua2V5cyh0cmVlW3Nob3J0Y3V0X2FycmF5WzBdXSkubGVuZ3RoID09PSAwKXtcbiAgICAgICAgICAgICAgICBkZWxldGUgdHJlZVtzaG9ydGN1dF9hcnJheVswXV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgU2hvcnRjdXRNYW5hZ2VyLnByb3RvdHlwZS5fc2V0X2xlYWYgPSBmdW5jdGlvbihzaG9ydGN1dF9hcnJheSwgYWN0aW9uX25hbWUsIHRyZWUpe1xuICAgICAgICB2YXIgY3VycmVudF9ub2RlID0gdHJlZVtzaG9ydGN1dF9hcnJheVswXV07XG4gICAgICAgIGlmKHNob3J0Y3V0X2FycmF5Lmxlbmd0aCA9PT0gMSl7XG4gICAgICAgICAgICBpZihjdXJyZW50X25vZGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YoY3VycmVudF9ub2RlKSAhPT0gJ3N0cmluZycpe1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignW3dhcm5pbmddLCB5b3UgYXJlIG92ZXJyaXRpbmcgYSBsb25nIHNob3J0Y3V0IHdpdGggYSBzaG9ydGVyIG9uZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJlZVtzaG9ydGN1dF9hcnJheVswXV0gPSBhY3Rpb25fbmFtZTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYodHlwZW9mKGN1cnJlbnRfbm9kZSkgPT09ICdzdHJpbmcnKXtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ3lvdSBhcmUgdHJ5aW5nIHRvIHNldCBhIHNob3J0Y3V0IHRoYXQgd2lsbCBiZSBzaGFkb3dlZCcrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICdieSBhIG1vcmUgc3BlY2lmaWMgb25lLiBBYm9ydGluZyBmb3IgOicsIGFjdGlvbl9uYW1lLCAndGhlIGZvbGx3aW5nICcrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICd3aWxsIHRha2UgcHJlY2VkZW5jZScsIGN1cnJlbnRfbm9kZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0cmVlW3Nob3J0Y3V0X2FycmF5WzBdXSA9IHRyZWVbc2hvcnRjdXRfYXJyYXlbMF1dfHx7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3NldF9sZWFmKHNob3J0Y3V0X2FycmF5LnNsaWNlKDEpLCBhY3Rpb25fbmFtZSwgdHJlZVtzaG9ydGN1dF9hcnJheVswXV0pO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgU2hvcnRjdXRNYW5hZ2VyLnByb3RvdHlwZS5hZGRfc2hvcnRjdXQgPSBmdW5jdGlvbiAoc2hvcnRjdXQsIGRhdGEsIHN1cHByZXNzX2hlbHBfdXBkYXRlKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGQgYSBhY3Rpb24gdG8gYmUgaGFuZGxlZCBieSBzaG9ydGN1dCBtYW5hZ2VyLiBcbiAgICAgICAgICogXG4gICAgICAgICAqIC0gYHNob3J0Y3V0YCBzaG91bGQgYmUgYSBgU2hvcnRjdXQgU2VxdWVuY2VgIG9mIHRoZSBmb3IgYEN0cmwtQWx0LUMsTWV0YS1YYC4uLlxuICAgICAgICAgKiAtIGBkYXRhYCBjb3VsZCBiZSBhbiBgYWN0aW9uIG5hbWVgLCBhbiBgYWN0aW9uYCBvciBhIGBmdW5jdGlvbmAuXG4gICAgICAgICAqICAgaWYgYSBgZnVuY3Rpb25gIGlzIHBhc3NlZCBpdCB3aWxsIGJlIGNvbnZlcnRlZCB0byBhbiBhbm9ueW1vdXMgYGFjdGlvbmAuIFxuICAgICAgICAgKlxuICAgICAgICAgKiovXG4gICAgICAgIHZhciBhY3Rpb25fbmFtZSA9IHRoaXMuYWN0aW9ucy5nZXRfbmFtZShkYXRhKTtcbiAgICAgICAgaWYgKCEgYWN0aW9uX25hbWUpe1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZG9lcyBub3Qga25vdyBob3cgdG8gZGVhbCB3aXRoJywgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgc2hvcnRjdXQgPSBub3JtYWxpemVfc2hvcnRjdXQoc2hvcnRjdXQpO1xuICAgICAgICB0aGlzLnNldF9zaG9ydGN1dChzaG9ydGN1dCwgYWN0aW9uX25hbWUpO1xuXG4gICAgICAgIGlmICghc3VwcHJlc3NfaGVscF91cGRhdGUpIHtcbiAgICAgICAgICAgIC8vIHVwZGF0ZSB0aGUga2V5Ym9hcmQgc2hvcnRjdXRzIG5vdGVib29rIGhlbHBcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzLnRyaWdnZXIoJ3JlYnVpbGQuUXVpY2tIZWxwJyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgU2hvcnRjdXRNYW5hZ2VyLnByb3RvdHlwZS5hZGRfc2hvcnRjdXRzID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlbmllbnQgbWV0aG9kcyB0byBjYWxsIGBhZGRfc2hvcnRjdXQoa2V5LCB2YWx1ZSlgIG9uIHNldmVyYWwgaXRlbXNcbiAgICAgICAgICogXG4gICAgICAgICAqICBkYXRhIDogRGljdCBvZiB0aGUgZm9ybSB7a2V5OnZhbHVlLCAuLi59XG4gICAgICAgICAqKi9cbiAgICAgICAgZm9yICh2YXIgc2hvcnRjdXQgaW4gZGF0YSkge1xuICAgICAgICAgICAgdGhpcy5hZGRfc2hvcnRjdXQoc2hvcnRjdXQsIGRhdGFbc2hvcnRjdXRdLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB1cGRhdGUgdGhlIGtleWJvYXJkIHNob3J0Y3V0cyBub3RlYm9vayBoZWxwXG4gICAgICAgIHRoaXMuZXZlbnRzLnRyaWdnZXIoJ3JlYnVpbGQuUXVpY2tIZWxwJyk7XG4gICAgfTtcblxuICAgIFNob3J0Y3V0TWFuYWdlci5wcm90b3R5cGUucmVtb3ZlX3Nob3J0Y3V0ID0gZnVuY3Rpb24gKHNob3J0Y3V0LCBzdXBwcmVzc19oZWxwX3VwZGF0ZSkge1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3ZlIHRoZSBiaW5kaW5nIG9mIHNob3J0Y3V0IGBzb3J0Y3V0YCB3aXRoIGl0cyBhY3Rpb24uXG4gICAgICAgICAqIHRocm93IGFuIGVycm9yIGlmIHRyeWluZyB0byByZW1vdmUgYSBub24tZXhpdGluZyBzaG9ydGN1dFxuICAgICAgICAgKiovXG4gICAgICAgIHNob3J0Y3V0ID0gbm9ybWFsaXplX3Nob3J0Y3V0KHNob3J0Y3V0KTtcbiAgICAgICAgaWYoIHR5cGVvZihzaG9ydGN1dCkgPT09ICdzdHJpbmcnKXtcbiAgICAgICAgICAgIHNob3J0Y3V0ID0gc2hvcnRjdXQuc3BsaXQoJywnKTtcbiAgICAgICAgfVxuICAgICAgICAvKlxuICAgICAgICAgKiAgVGhlIHNob3J0Y3V0IGVycm9yIHNob3VsZCBiZSBleHBsaWNpdCBoZXJlLCBiZWNhdXNlIGl0IHdpbGwgYmVcbiAgICAgICAgICogIHNlZW4gYnkgdXNlcnMuXG4gICAgICAgICAqL1xuICAgICAgICB0cnlcbiAgICAgICAge1xuICAgICAgICAgIHRoaXMuX3JlbW92ZV9sZWFmKHNob3J0Y3V0LCB0aGlzLl9zaG9ydGN1dHMpO1xuICAgICAgICAgIGlmICghc3VwcHJlc3NfaGVscF91cGRhdGUpIHtcbiAgICAgICAgICAgIC8vIHVwZGF0ZSB0aGUga2V5Ym9hcmQgc2hvcnRjdXRzIG5vdGVib29rIGhlbHBcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzLnRyaWdnZXIoJ3JlYnVpbGQuUXVpY2tIZWxwJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndHJ5aW5nIHRvIHJlbW92ZSBhIG5vbi1leGlzdGVudCBzaG9ydGN1dCcsIHNob3J0Y3V0KTtcbiAgICAgICAgfVxuICAgIH07XG5cblxuXG4gICAgU2hvcnRjdXRNYW5hZ2VyLnByb3RvdHlwZS5jYWxsX2hhbmRsZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGwgdGhlIGNvcnJlc3BvbmRpbmcgc2hvcnRjdXQgaGFuZGxlciBmb3IgYSBrZXlib2FyZCBldmVudFxuICAgICAgICAgKiBAbWV0aG9kIGNhbGxfaGFuZGxlclxuICAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZXxmYWxzZWAsIGBmYWxzZWAgaWYgbm8gaGFuZGxlciB3YXMgZm91bmQsIG90aGVyd2lzZSB0aGUgIHZhbHVlIHJldHVybiBieSB0aGUgaGFuZGxlci4gXG4gICAgICAgICAqIEBwYXJhbSBldmVudCB7ZXZlbnR9XG4gICAgICAgICAqXG4gICAgICAgICAqIGdpdmVuIGFuIGV2ZW50LCBjYWxsIHRoZSBjb3JyZXNwb25kaW5nIHNob3J0Y3V0LiBcbiAgICAgICAgICogcmV0dXJuIGZhbHNlIGlzIGV2ZW50IHdhbiBoYW5kbGVkLCB0cnVlIG90aGVyd2lzZSBcbiAgICAgICAgICogaW4gYW55IGNhc2UgcmV0dXJuaW5nIGZhbHNlIHN0b3AgZXZlbnQgcHJvcGFnYXRpb25cbiAgICAgICAgICoqL1xuXG5cbiAgICAgICAgdGhpcy5jbGVhcnNvb24oKTtcbiAgICAgICAgaWYob25seV9tb2RpZmllcl9ldmVudChldmVudCkpe1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNob3J0Y3V0ID0gZXZlbnRfdG9fc2hvcnRjdXQoZXZlbnQpO1xuICAgICAgICB0aGlzLl9xdWV1ZS5wdXNoKHNob3J0Y3V0KTtcbiAgICAgICAgdmFyIGFjdGlvbl9uYW1lID0gdGhpcy5nZXRfc2hvcnRjdXQodGhpcy5fcXVldWUpO1xuXG4gICAgICAgIGlmICh0eXBlb2YoYWN0aW9uX25hbWUpID09PSAndW5kZWZpbmVkJ3x8IGFjdGlvbl9uYW1lID09PSBudWxsKXtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJxdWV1ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmICh0aGlzLmFjdGlvbnMuZXhpc3RzKGFjdGlvbl9uYW1lKSkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJxdWV1ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWN0aW9ucy5jYWxsKGFjdGlvbl9uYW1lLCBldmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuXG4gICAgU2hvcnRjdXRNYW5hZ2VyLnByb3RvdHlwZS5oYW5kbGVzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBzaG9ydGN1dCA9IGV2ZW50X3RvX3Nob3J0Y3V0KGV2ZW50KTtcbiAgICAgICAgdmFyIGFjdGlvbl9uYW1lID0gdGhpcy5nZXRfc2hvcnRjdXQodGhpcy5fcXVldWUuY29uY2F0KHNob3J0Y3V0KSk7XG4gICAgICAgIHJldHVybiAodHlwZW9mKGFjdGlvbl9uYW1lKSAhPT0gJ3VuZGVmaW5lZCcpO1xuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAga2V5Y29kZXMgOiBrZXljb2RlcyxcbiAgICAgICAgaW52X2tleWNvZGVzIDogaW52X2tleWNvZGVzLFxuICAgICAgICBTaG9ydGN1dE1hbmFnZXIgOiBTaG9ydGN1dE1hbmFnZXIsXG4gICAgICAgIG5vcm1hbGl6ZV9rZXkgOiBub3JtYWxpemVfa2V5LFxuICAgICAgICBub3JtYWxpemVfc2hvcnRjdXQgOiBub3JtYWxpemVfc2hvcnRjdXQsXG4gICAgICAgIHNob3J0Y3V0X3RvX2V2ZW50IDogc2hvcnRjdXRfdG9fZXZlbnQsXG4gICAgICAgIGV2ZW50X3RvX3Nob3J0Y3V0IDogZXZlbnRfdG9fc2hvcnRjdXQsXG4gICAgfTtcbiIsIi8vIENvcHlyaWdodCAoYykgSnVweXRlciBEZXZlbG9wbWVudCBUZWFtLlxuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBNb2RpZmllZCBCU0QgTGljZW5zZS5cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbmlmICghd2luZG93Lkp1cHl0ZXIpIHtcbiAgICB2YXIgSnVweXRlciA9IHt9O1xuICAgIEp1cHl0ZXIudmVyc2lvbiA9IFwiNC4xLjAuZGV2XCI7XG4gICAgd2luZG93Lkp1cHl0ZXIgPSBKdXB5dGVyO1xufVxuXG52YXIganByb3AgPSBmdW5jdGlvbihuYW1lLCBsb2FkZWQsIG1vZHVsZV9wYXRoLCBnbG9iYWxfbW9kKSB7XG4gICAgaWYgKCEod2luZG93Lkp1cHl0ZXIpLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3cuSnVweXRlciwgbmFtZSwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ2FjY2Vzc2luZyBgJytuYW1lKydgIGlzIGRlcHJlY2F0ZWQuIFVzZSBgcmVxdWlyZShcXCcnICsgbW9kdWxlX3BhdGggKyAnXFwnKScgKyAoZ2xvYmFsX21vZCA/ICdbXFwnJyArIG5hbWUgKyAnXFwnXScgOiAnJykgKyAnYCcpO1xuICAgICAgICAgICAgICAgIHJldHVybiBnbG9iYWxfbW9kID8gbG9hZGVkW25hbWVdIDogbG9hZGVkOyBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZVxuICAgICAgICB9KTsgICAgXG4gICAgfVxufTtcblxuLy8gZXhwb3NlIG1vZHVsZXNcbmpwcm9wKCdldmVudHMnLCByZXF1aXJlKCdiYXNlL2pzL2V2ZW50cycpLCAnYmFzZS9qcy9ldmVudHMnKTtcbmpwcm9wKCd1dGlscycsIHJlcXVpcmUoJ2Jhc2UvanMvdXRpbHMnKSwgJ2Jhc2UvanMvdXRpbHMnKTtcbmpwcm9wKCdzZWN1cml0eScsIHJlcXVpcmUoJ2Jhc2UvanMvc2VjdXJpdHknKSwgJ2Jhc2UvanMvc2VjdXJpdHknKTtcbmpwcm9wKCdrZXlib2FyZCcsIHJlcXVpcmUoJ2Jhc2UvanMva2V5Ym9hcmQnKSwgJ2Jhc2UvanMva2V5Ym9hcmQnKTtcbmpwcm9wKCdkaWFsb2cnLCByZXF1aXJlKCdiYXNlL2pzL2RpYWxvZycpLCAnYmFzZS9qcy9kaWFsb2cnKTtcbmpwcm9wKCdtYXRoamF4dXRpbHMnLCByZXF1aXJlKCdub3RlYm9vay9qcy9tYXRoamF4dXRpbHMnKSwgJ25vdGVib29rL2pzL21hdGhqYXh1dGlscycpO1xuXG4vLy8vIGV4cG9zZWQgY29uc3RydWN0b3JzXG5qcHJvcCgnQ29tbU1hbmFnZXInLCByZXF1aXJlKCdzZXJ2aWNlcy9rZXJuZWxzL2NvbW0nKSwgJ3NlcnZpY2VzL2tlcm5lbHMvY29tbScsIHRydWUpO1xuanByb3AoJ0NvbW0nLCByZXF1aXJlKCdzZXJ2aWNlcy9rZXJuZWxzL2NvbW0nKSwgJ3NlcnZpY2VzL2tlcm5lbHMvY29tbScsIHRydWUpO1xuXG5qcHJvcCgnTm90aWZpY2F0aW9uV2lkZ2V0JywgcmVxdWlyZSgnYmFzZS9qcy9ub3RpZmljYXRpb253aWRnZXQnKSwgJ2Jhc2UvanMvbm90aWZpY2F0aW9ud2lkZ2V0JywgdHJ1ZSk7XG5qcHJvcCgnS2VybmVsJywgcmVxdWlyZSgnc2VydmljZXMva2VybmVscy9rZXJuZWwnKSwgJ3NlcnZpY2VzL2tlcm5lbHMva2VybmVsJywgdHJ1ZSk7XG5qcHJvcCgnU2Vzc2lvbicsIHJlcXVpcmUoJ3NlcnZpY2VzL3Nlc3Npb25zL3Nlc3Npb24nKSwgJ3NlcnZpY2VzL3Nlc3Npb25zL3Nlc3Npb24nLCB0cnVlKTtcbmpwcm9wKCdMb2dpbldpZGdldCcsIHJlcXVpcmUoJ2F1dGgvanMvbG9naW53aWRnZXQnKSwgJ2F1dGgvanMvbG9naW53aWRnZXQnLCB0cnVlKTtcbmpwcm9wKCdQYWdlJywgcmVxdWlyZSgnYmFzZS9qcy9wYWdlJyksICdiYXNlL2pzL3BhZ2UnLCB0cnVlKTtcblxuLy8gbm90ZWJvb2tcbmpwcm9wKCdUZXh0Q2VsbCcsIHJlcXVpcmUoJ25vdGVib29rL2pzL3RleHRjZWxsJyksICdub3RlYm9vay9qcy90ZXh0Y2VsbCcsIHRydWUpO1xuanByb3AoJ091dHB1dEFyZWEnLCByZXF1aXJlKCdub3RlYm9vay9qcy9vdXRwdXRhcmVhJyksICdub3RlYm9vay9qcy9vdXRwdXRhcmVhJywgdHJ1ZSk7XG5qcHJvcCgnS2V5Ym9hcmRNYW5hZ2VyJywgcmVxdWlyZSgnbm90ZWJvb2svanMva2V5Ym9hcmRtYW5hZ2VyJyksICdub3RlYm9vay9qcy9rZXlib2FyZG1hbmFnZXInLCB0cnVlKTtcbmpwcm9wKCdDb21wbGV0ZXInLCByZXF1aXJlKCdub3RlYm9vay9qcy9jb21wbGV0ZXInKSwgJ25vdGVib29rL2pzL2NvbXBsZXRlcicsIHRydWUpO1xuanByb3AoJ05vdGVib29rJywgcmVxdWlyZSgnbm90ZWJvb2svanMvbm90ZWJvb2snKSwgJ25vdGVib29rL2pzL25vdGVib29rJywgdHJ1ZSk7XG5qcHJvcCgnVG9vbHRpcCcsIHJlcXVpcmUoJ25vdGVib29rL2pzL3Rvb2x0aXAnKSwgJ25vdGVib29rL2pzL3Rvb2x0aXAnLCB0cnVlKTtcbmpwcm9wKCdUb29sQmFyJywgcmVxdWlyZSgnbm90ZWJvb2svanMvdG9vbGJhcicpLCAnbm90ZWJvb2svanMvdG9vbGJhcicsIHRydWUpO1xuanByb3AoJ1NhdmVXaWRnZXQnLCByZXF1aXJlKCdub3RlYm9vay9qcy9zYXZld2lkZ2V0JyksICdub3RlYm9vay9qcy9zYXZld2lkZ2V0JywgdHJ1ZSk7XG5qcHJvcCgnUGFnZXInLCByZXF1aXJlKCdub3RlYm9vay9qcy9wYWdlcicpLCAnbm90ZWJvb2svanMvcGFnZXInLCB0cnVlKTtcbmpwcm9wKCdRdWlja0hlbHAnLCByZXF1aXJlKCdub3RlYm9vay9qcy9xdWlja2hlbHAnKSwgJ25vdGVib29rL2pzL3F1aWNraGVscCcsIHRydWUpO1xuanByb3AoJ01hcmtkb3duQ2VsbCcsIHJlcXVpcmUoJ25vdGVib29rL2pzL3RleHRjZWxsJyksICdub3RlYm9vay9qcy90ZXh0Y2VsbCcsIHRydWUpO1xuanByb3AoJ1Jhd0NlbGwnLCByZXF1aXJlKCdub3RlYm9vay9qcy90ZXh0Y2VsbCcpLCAnbm90ZWJvb2svanMvdGV4dGNlbGwnLCB0cnVlKTtcbmpwcm9wKCdDZWxsJywgcmVxdWlyZSgnbm90ZWJvb2svanMvY2VsbCcpLCAnbm90ZWJvb2svanMvY2VsbCcsIHRydWUpO1xuanByb3AoJ01haW5Ub29sQmFyJywgcmVxdWlyZSgnbm90ZWJvb2svanMvbWFpbnRvb2xiYXInKSwgJ25vdGVib29rL2pzL21haW50b29sYmFyJywgdHJ1ZSk7XG5qcHJvcCgnTm90ZWJvb2tOb3RpZmljYXRpb25BcmVhJywgcmVxdWlyZSgnbm90ZWJvb2svanMvbm90aWZpY2F0aW9uYXJlYScpLCAnbm90ZWJvb2svanMvbm90aWZpY2F0aW9uYXJlYScsIHRydWUpO1xuanByb3AoJ05vdGVib29rVG91cicsIHJlcXVpcmUoICdub3RlYm9vay9qcy90b3VyJyksICAnbm90ZWJvb2svanMvdG91cicsIHRydWUpO1xuanByb3AoJ01lbnVCYXInLCByZXF1aXJlKCAnbm90ZWJvb2svanMvbWVudWJhcicpLCAgJ25vdGVib29rL2pzL21lbnViYXInLCB0cnVlKTtcblxuLy8gdHJlZVxuanByb3AoJ1Nlc3Npb25MaXN0JywgcmVxdWlyZSgndHJlZS9qcy9zZXNzaW9ubGlzdCcpLCAndHJlZS9qcy9zZXNzaW9ubGlzdCcsIHRydWUpO1xuXG53aW5kb3cuSnVweXRlci5fdGFyZ2V0ID0gJ19ibGFuayc7XG5cbi8vIGRlcHJlY2F0ZWQgc2luY2UgNC4wLCByZW1vdmUgaW4gNStcbndpbmRvdy5JUHl0aG9uID0gd2luZG93Lkp1cHl0ZXI7XG4gICAgXG5tb2R1bGUuZXhwb3J0cyA9IHdpbmRvdy5KdXB5dGVyO1xuIiwiLy8gQ29weXJpZ2h0IChjKSBKdXB5dGVyIERldmVsb3BtZW50IFRlYW0uXG4vLyBEaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIE1vZGlmaWVkIEJTRCBMaWNlbnNlLlxuXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICB2YXIgbm90aWZpY2F0aW9ud2lkZ2V0ID0gcmVxdWlyZSgnYmFzZS9qcy9ub3RpZmljYXRpb253aWRnZXQnKTtcblxuICAgIC8vIHN0b3JlIHJlZmVyZW5jZSB0byB0aGUgTm90aWZpY2F0aW9uV2lkZ2V0IGNsYXNzXG4gICAgdmFyIE5vdGlmaWNhdGlvbldpZGdldCA9IG5vdGlmaWNhdGlvbndpZGdldC5Ob3RpZmljYXRpb25XaWRnZXQ7XG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgdGhlIE5vdGlmaWNhdGlvbkFyZWEgb2JqZWN0LiBPcHRpb25zIGFyZTpcbiAgICAgKiAgICAgZXZlbnRzOiAkKEV2ZW50cykgaW5zdGFuY2VcbiAgICAgKiAgICAgc2F2ZV93aWRnZXQ6IFNhdmVXaWRnZXQgaW5zdGFuY2VcbiAgICAgKiAgICAgbm90ZWJvb2s6IE5vdGVib29rIGluc3RhbmNlXG4gICAgICogICAgIGtleWJvYXJkX21hbmFnZXI6IEtleWJvYXJkTWFuYWdlciBpbnN0YW5jZVxuICAgICAqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yIC0gYSBqUXVlcnkgc2VsZWN0b3Igc3RyaW5nIGZvciB0aGVcbiAgICAgKiBub3RpZmljYXRpb24gYXJlYSBlbGVtZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIGEgZGljdGlvbmFyeSBvZiBrZXl3b3JkIGFyZ3VtZW50cy5cbiAgICAgKi9cbiAgICB2YXIgTm90aWZpY2F0aW9uQXJlYSA9IGZ1bmN0aW9uIChzZWxlY3Rvciwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLnNlbGVjdG9yID0gc2VsZWN0b3I7XG4gICAgICAgIHRoaXMuZXZlbnRzID0gb3B0aW9ucy5ldmVudHM7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudCA9ICQoc2VsZWN0b3IpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud2lkZ2V0X2RpY3QgPSB7fTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IGEgd2lkZ2V0IGJ5IG5hbWUsIGNyZWF0aW5nIGl0IGlmIGl0IGRvZXNuJ3QgZXhpc3QuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHdpZGdldFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gdGhlIHdpZGdldCBuYW1lXG4gICAgICovXG4gICAgTm90aWZpY2F0aW9uQXJlYS5wcm90b3R5cGUud2lkZ2V0ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgaWYgKHRoaXMud2lkZ2V0X2RpY3RbbmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubmV3X25vdGlmaWNhdGlvbl93aWRnZXQobmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0X3dpZGdldChuYW1lKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IGEgd2lkZ2V0IGJ5IG5hbWUsIHRocm93aW5nIGFuIGVycm9yIGlmIGl0IGRvZXNuJ3QgZXhpc3QuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGdldF93aWRnZXRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIHRoZSB3aWRnZXQgbmFtZVxuICAgICAqL1xuICAgIE5vdGlmaWNhdGlvbkFyZWEucHJvdG90eXBlLmdldF93aWRnZXQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBpZih0aGlzLndpZGdldF9kaWN0W25hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93KCdubyB3aWRnZXRzIHdpdGggdGhpcyBuYW1lJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMud2lkZ2V0X2RpY3RbbmFtZV07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBub3RpZmljYXRpb24gd2lkZ2V0IHdpdGggdGhlIGdpdmVuIG5hbWUuIFRoZVxuICAgICAqIHdpZGdldCBtdXN0IG5vdCBhbHJlYWR5IGV4aXN0LlxuICAgICAqXG4gICAgICogQG1ldGhvZCBuZXdfbm90aWZpY2F0aW9uX3dpZGdldFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gdGhlIHdpZGdldCBuYW1lXG4gICAgICovXG4gICAgTm90aWZpY2F0aW9uQXJlYS5wcm90b3R5cGUubmV3X25vdGlmaWNhdGlvbl93aWRnZXQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBpZiAodGhpcy53aWRnZXRfZGljdFtuYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdygnd2lkZ2V0IHdpdGggdGhhdCBuYW1lIGFscmVhZHkgZXhpc3RzIScpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY3JlYXRlIHRoZSBlbGVtZW50IGZvciB0aGUgbm90aWZpY2F0aW9uIHdpZGdldCBhbmQgYWRkIGl0XG4gICAgICAgIC8vIHRvIHRoZSBub3RpZmljYXRpb24gYXJlYWQgZWxlbWVudFxuICAgICAgICB2YXIgZGl2ID0gJCgnPGRpdi8+JykuYXR0cignaWQnLCAnbm90aWZpY2F0aW9uXycgKyBuYW1lKTtcbiAgICAgICAgJCh0aGlzLnNlbGVjdG9yKS5hcHBlbmQoZGl2KTtcblxuICAgICAgICAvLyBjcmVhdGUgdGhlIHdpZGdldCBvYmplY3QgYW5kIHJldHVybiBpdFxuICAgICAgICB0aGlzLndpZGdldF9kaWN0W25hbWVdID0gbmV3IE5vdGlmaWNhdGlvbldpZGdldCgnI25vdGlmaWNhdGlvbl8nICsgbmFtZSk7XG4gICAgICAgIHJldHVybiB0aGlzLndpZGdldF9kaWN0W25hbWVdO1xuICAgIH07XG5cbiAgICBleHBvcnRzLk5vdGlmaWNhdGlvbkFyZWEgPSBOb3RpZmljYXRpb25BcmVhO1xuIiwiLy8gQ29weXJpZ2h0IChjKSBKdXB5dGVyIERldmVsb3BtZW50IFRlYW0uXG4vLyBEaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIE1vZGlmaWVkIEJTRCBMaWNlbnNlLlxuXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSBOb3RpZmljYXRpb25XaWRnZXQgb2JqZWN0LlxuICAgICAqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yIC0gYSBqUXVlcnkgc2VsZWN0b3Igc3RyaW5nIGZvciB0aGVcbiAgICAgKiBub3RpZmljYXRpb24gd2lkZ2V0IGVsZW1lbnRcbiAgICAgKi9cbiAgICB2YXIgTm90aWZpY2F0aW9uV2lkZ2V0ID0gZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0b3IgPSBzZWxlY3RvcjtcbiAgICAgICAgdGhpcy50aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5idXN5ID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudCA9ICQoc2VsZWN0b3IpO1xuICAgICAgICAgICAgdGhpcy5zdHlsZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWxlbWVudC5oaWRlKCk7XG4gICAgICAgIHRoaXMuaW5uZXIgPSAkKCc8c3Bhbi8+Jyk7XG4gICAgICAgIHRoaXMuZWxlbWVudC5hcHBlbmQodGhpcy5pbm5lcik7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFkZCB0aGUgJ25vdGlmaWNhdGlvbl93aWRnZXQnIENTUyBjbGFzcyB0byB0aGUgd2lkZ2V0IGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHN0eWxlXG4gICAgICovXG4gICAgTm90aWZpY2F0aW9uV2lkZ2V0LnByb3RvdHlwZS5zdHlsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gdXNlIGV4cGxpY2l0IGJvb3RzdHJhcCBjbGFzc2VzIGhlcmUsXG4gICAgICAgIC8vIGJlY2F1c2UgbXVsdGlwbGUgaW5oZXJpdGFuY2UgaW4gTEVTUyBkb2Vzbid0IHdvcmtcbiAgICAgICAgLy8gZm9yIHRoaXMgcGFydGljdWxhciBjb21iaW5hdGlvblxuICAgICAgICB0aGlzLmVsZW1lbnQuYWRkQ2xhc3MoJ25vdGlmaWNhdGlvbl93aWRnZXQgYnRuIGJ0bi14cyBuYXZiYXItYnRuJyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGhpZGUgdGhlIHdpZGdldCBhbmQgZW1wdHkgdGhlIHRleHRcbiAgICAgKiovXG4gICAgTm90aWZpY2F0aW9uV2lkZ2V0LnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIHRoaXMuZWxlbWVudC5mYWRlT3V0KDEwMCwgZnVuY3Rpb24oKXt0aGF0LmlubmVyLnRleHQoJycpO30pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIG5vdGlmaWNhdGlvbiB3aWRnZXQgbWVzc2FnZSB0byBkaXNwbGF5IGZvciBhIGNlcnRhaW5cbiAgICAgKiBhbW91bnQgb2YgdGltZSAodGltZW91dCkuICBUaGUgd2lkZ2V0IHdpbGwgYmUgc2hvd24gZm9yZXZlciBpZlxuICAgICAqIHRpbWVvdXQgaXMgPD0gMCBvciB1bmRlZmluZWQuIElmIHRoZSB3aWRnZXQgaXMgY2xpY2tlZCB3aGlsZSBpdFxuICAgICAqIGlzIHN0aWxsIGRpc3BsYXllZCwgZXhlY3V0ZSBhbiBvcHRpb25hbCBjYWxsYmFja1xuICAgICAqIChjbGlja19jYWxsYmFjaykuIElmIHRoZSBjYWxsYmFjayByZXR1cm5zIGZhbHNlLCBpdCB3aWxsXG4gICAgICogcHJldmVudCB0aGUgbm90aWZpY2F0aW9uIGZyb20gYmVpbmcgZGlzbWlzc2VkLlxuICAgICAqXG4gICAgICogT3B0aW9uczpcbiAgICAgKiAgICBjbGFzcyAtIENTUyBjbGFzcyBuYW1lIGZvciBzdHlsaW5nXG4gICAgICogICAgaWNvbiAtIENTUyBjbGFzcyBuYW1lIGZvciB0aGUgd2lkZ2V0IGljb25cbiAgICAgKiAgICB0aXRsZSAtIEhUTUwgdGl0bGUgYXR0cmlidXRlIGZvciB0aGUgd2lkZ2V0XG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHNldF9tZXNzYWdlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1zZyAtIFRoZSBub3RpZmljYXRpb24gdG8gZGlzcGxheVxuICAgICAqIEBwYXJhbSB7aW50ZWdlcn0gW3RpbWVvdXRdIC0gVGhlIGFtb3VudCBvZiB0aW1lIGluIG1pbGxpc2Vjb25kcyB0byBkaXNwbGF5IHRoZSB3aWRnZXRcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY2xpY2tfY2FsbGJhY2tdIC0gVGhlIGZ1bmN0aW9uIHRvIHJ1biB3aGVuIHRoZSB3aWRnZXQgaXMgY2xpY2tlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBBZGRpdGlvbmFsIG9wdGlvbnNcbiAgICAgKi9cbiAgICBOb3RpZmljYXRpb25XaWRnZXQucHJvdG90eXBlLnNldF9tZXNzYWdlID0gZnVuY3Rpb24gKG1zZywgdGltZW91dCwgY2xpY2tfY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgLy8gdW5iaW5kIHBvdGVudGlhbCBwcmV2aW91cyBjYWxsYmFja1xuICAgICAgICB0aGlzLmVsZW1lbnQudW5iaW5kKCdjbGljaycpO1xuICAgICAgICB0aGlzLmlubmVyLmF0dHIoJ2NsYXNzJywgb3B0aW9ucy5pY29uKTtcbiAgICAgICAgdGhpcy5pbm5lci5hdHRyKCd0aXRsZScsIG9wdGlvbnMudGl0bGUpO1xuICAgICAgICB0aGlzLmlubmVyLnRleHQobXNnKTtcbiAgICAgICAgdGhpcy5lbGVtZW50LmZhZGVJbigxMDApO1xuXG4gICAgICAgIC8vIHJlc2V0IHByZXZpb3VzIHNldCBzdHlsZVxuICAgICAgICB0aGlzLmVsZW1lbnQucmVtb3ZlQ2xhc3MoKTtcbiAgICAgICAgdGhpcy5zdHlsZSgpO1xuICAgICAgICBpZiAob3B0aW9ucy5jbGFzcykge1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LmFkZENsYXNzKG9wdGlvbnMuY2xhc3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2xlYXIgcHJldmlvdXMgdGltZXJcbiAgICAgICAgaWYgKHRoaXMudGltZW91dCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dCk7XG4gICAgICAgICAgICB0aGlzLnRpbWVvdXQgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2V0IHRoZSB0aW1lciBpZiBhIHRpbWVvdXQgaXMgZ2l2ZW5cbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICBpZiAodGltZW91dCAhPT0gdW5kZWZpbmVkICYmIHRpbWVvdXQgPj0gMCkge1xuICAgICAgICAgICAgdGhpcy50aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhhdC5lbGVtZW50LmZhZGVPdXQoMTAwLCBmdW5jdGlvbiAoKSB7dGhhdC5pbm5lci50ZXh0KCcnKTt9KTtcbiAgICAgICAgICAgICAgICB0aGF0LmVsZW1lbnQudW5iaW5kKCdjbGljaycpO1xuICAgICAgICAgICAgICAgIHRoYXQudGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIG5vIGNsaWNrIGNhbGxiYWNrIGFzc3VtZSB3ZSB3aWxsIGp1c3QgZGlzbWlzcyB0aGUgbm90aWZpY2F0aW9uXG4gICAgICAgIGlmIChjbGlja19jYWxsYmFjayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjbGlja19jYWxsYmFjayA9IGZ1bmN0aW9uKCl7cmV0dXJuIHRydWV9O1xuICAgICAgICB9XG4gICAgICAgIC8vIG9uIGNsaWNrLCByZW1vdmUgd2lkZ2V0IGlmIGNsaWNrIGNhbGxiYWNrIHNheSBzb1xuICAgICAgICAvLyBhbmQgdW5iaW5kIGNsaWNrIGV2ZW50LlxuICAgICAgICB0aGlzLmVsZW1lbnQuY2xpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGNsaWNrX2NhbGxiYWNrKCkgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdGhhdC5lbGVtZW50LmZhZGVPdXQoMTAwLCBmdW5jdGlvbiAoKSB7dGhhdC5pbm5lci50ZXh0KCcnKTt9KTtcbiAgICAgICAgICAgICAgICB0aGF0LmVsZW1lbnQudW5iaW5kKCdjbGljaycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoYXQudGltZW91dCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGF0LnRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIHRoYXQudGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEaXNwbGF5IGFuIGluZm9ybWF0aW9uIG1lc3NhZ2UgKHN0eWxlZCB3aXRoIHRoZSAnaW5mbydcbiAgICAgKiBjbGFzcykuIEFyZ3VtZW50cyBhcmUgdGhlIHNhbWUgYXMgaW4gc2V0X21lc3NhZ2UuIERlZmF1bHRcbiAgICAgKiB0aW1lb3V0IGlzIDM1MDAgbWlsbGlzZWNvbmRzLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBpbmZvXG4gICAgICovXG4gICAgTm90aWZpY2F0aW9uV2lkZ2V0LnByb3RvdHlwZS5pbmZvID0gZnVuY3Rpb24gKG1zZywgdGltZW91dCwgY2xpY2tfY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIG9wdGlvbnMuY2xhc3MgPSBvcHRpb25zLmNsYXNzICsgJyBpbmZvJztcbiAgICAgICAgdGltZW91dCA9IHRpbWVvdXQgfHwgMzUwMDtcbiAgICAgICAgdGhpcy5zZXRfbWVzc2FnZShtc2csIHRpbWVvdXQsIGNsaWNrX2NhbGxiYWNrLCBvcHRpb25zKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGlzcGxheSBhIHdhcm5pbmcgbWVzc2FnZSAoc3R5bGVkIHdpdGggdGhlICd3YXJuaW5nJ1xuICAgICAqIGNsYXNzKS4gQXJndW1lbnRzIGFyZSB0aGUgc2FtZSBhcyBpbiBzZXRfbWVzc2FnZS4gTWVzc2FnZXMgYXJlXG4gICAgICogc3RpY2t5IGJ5IGRlZmF1bHQuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHdhcm5pbmdcbiAgICAgKi9cbiAgICBOb3RpZmljYXRpb25XaWRnZXQucHJvdG90eXBlLndhcm5pbmcgPSBmdW5jdGlvbiAobXNnLCB0aW1lb3V0LCBjbGlja19jYWxsYmFjaywgb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgb3B0aW9ucy5jbGFzcyA9IG9wdGlvbnMuY2xhc3MgKyAnIHdhcm5pbmcnO1xuICAgICAgICB0aGlzLnNldF9tZXNzYWdlKG1zZywgdGltZW91dCwgY2xpY2tfY2FsbGJhY2ssIG9wdGlvbnMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEaXNwbGF5IGEgZGFuZ2VyIG1lc3NhZ2UgKHN0eWxlZCB3aXRoIHRoZSAnZGFuZ2VyJ1xuICAgICAqIGNsYXNzKS4gQXJndW1lbnRzIGFyZSB0aGUgc2FtZSBhcyBpbiBzZXRfbWVzc2FnZS4gTWVzc2FnZXMgYXJlXG4gICAgICogc3RpY2t5IGJ5IGRlZmF1bHQuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGRhbmdlclxuICAgICAqL1xuICAgIE5vdGlmaWNhdGlvbldpZGdldC5wcm90b3R5cGUuZGFuZ2VyID0gZnVuY3Rpb24gKG1zZywgdGltZW91dCwgY2xpY2tfY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIG9wdGlvbnMuY2xhc3MgPSBvcHRpb25zLmNsYXNzICsgJyBkYW5nZXInO1xuICAgICAgICB0aGlzLnNldF9tZXNzYWdlKG1zZywgdGltZW91dCwgY2xpY2tfY2FsbGJhY2ssIG9wdGlvbnMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHRleHQgb2YgdGhlIHdpZGdldCBtZXNzYWdlLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBnZXRfbWVzc2FnZVxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gLSB0aGUgbWVzc2FnZSB0ZXh0XG4gICAgICovXG4gICAgTm90aWZpY2F0aW9uV2lkZ2V0LnByb3RvdHlwZS5nZXRfbWVzc2FnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5uZXIuaHRtbCgpO1xuICAgIH07XG5cbiAgICBleHBvcnRzLk5vdGlmaWNhdGlvbldpZGdldCA9IE5vdGlmaWNhdGlvbldpZGdldDtcbiIsIi8vIENvcHlyaWdodCAoYykgSnVweXRlciBEZXZlbG9wbWVudCBUZWFtLlxuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBNb2RpZmllZCBCU0QgTGljZW5zZS5cblxuICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICBcbiAgICB2YXIgZXZlbnRzID0gcmVxdWlyZSgnYmFzZS9qcy9ldmVudHMnKTtcblxuICAgIHZhciBQYWdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmJpbmRfZXZlbnRzKCk7XG4gICAgfTtcblxuICAgIFBhZ2UucHJvdG90eXBlLmJpbmRfZXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyByZXNpemUgc2l0ZSBvbjpcbiAgICAgICAgLy8gLSB3aW5kb3cgcmVzaXplXG4gICAgICAgIC8vIC0gaGVhZGVyIGNoYW5nZVxuICAgICAgICAvLyAtIHBhZ2UgbG9hZFxuICAgICAgICB2YXIgX2hhbmRsZV9yZXNpemUgPSAkLnByb3h5KHRoaXMuX3Jlc2l6ZV9zaXRlLCB0aGlzKTtcbiAgICAgICAgXG4gICAgICAgICQod2luZG93KS5yZXNpemUoX2hhbmRsZV9yZXNpemUpO1xuXG4gICAgICAgIC8vIE9uIGRvY3VtZW50IHJlYWR5LCByZXNpemUgY29kZW1pcnJvci5cbiAgICAgICAgJChkb2N1bWVudCkucmVhZHkoX2hhbmRsZV9yZXNpemUpO1xuICAgICAgICBldmVudHMub24oJ3Jlc2l6ZS1oZWFkZXIuUGFnZScsIF9oYW5kbGVfcmVzaXplKTtcbiAgICB9O1xuXG4gICAgUGFnZS5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBoZWFkZXIgYW5kIHNpdGUgZGl2cyBzdGFydCBvdXQgaGlkZGVuIHRvIHByZXZlbnQgRkxPVUMuXG4gICAgICAgICAqIE1haW4gc2NyaXB0cyBzaG91bGQgY2FsbCB0aGlzIG1ldGhvZCBhZnRlciBzdHlsaW5nIGV2ZXJ5dGhpbmcuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNob3dfaGVhZGVyKCk7XG4gICAgICAgIHRoaXMuc2hvd19zaXRlKCk7XG4gICAgfTtcblxuICAgIFBhZ2UucHJvdG90eXBlLnNob3dfaGVhZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGhlYWRlciBhbmQgc2l0ZSBkaXZzIHN0YXJ0IG91dCBoaWRkZW4gdG8gcHJldmVudCBGTE9VQy5cbiAgICAgICAgICogTWFpbiBzY3JpcHRzIHNob3VsZCBjYWxsIHRoaXMgbWV0aG9kIGFmdGVyIHN0eWxpbmcgZXZlcnl0aGluZy5cbiAgICAgICAgICogVE9ETzogc2VsZWN0b3IgYXJlIGhhcmRjb2RlZCwgcGFzcyBhcyBjb25zdHJ1Y3RvciBhcmd1bWVudFxuICAgICAgICAgKi9cbiAgICAgICAgJCgnZGl2I2hlYWRlcicpLmNzcygnZGlzcGxheScsJ2Jsb2NrJyk7XG4gICAgfTtcblxuICAgIFBhZ2UucHJvdG90eXBlLnNob3dfc2l0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBoZWFkZXIgYW5kIHNpdGUgZGl2cyBzdGFydCBvdXQgaGlkZGVuIHRvIHByZXZlbnQgRkxPVUMuXG4gICAgICAgICAqIE1haW4gc2NyaXB0cyBzaG91bGQgY2FsbCB0aGlzIG1ldGhvZCBhZnRlciBzdHlsaW5nIGV2ZXJ5dGhpbmcuXG4gICAgICAgICAqIFRPRE86IHNlbGVjdG9yIGFyZSBoYXJkY29kZWQsIHBhc3MgYXMgY29uc3RydWN0b3IgYXJndW1lbnRcbiAgICAgICAgICovXG4gICAgICAgICQoJ2RpdiNzaXRlJykuY3NzKCdkaXNwbGF5JywgJ2Jsb2NrJyk7XG4gICAgICAgIHRoaXMuX3Jlc2l6ZV9zaXRlKCk7XG4gICAgfTtcblxuICAgIFBhZ2UucHJvdG90eXBlLl9yZXNpemVfc2l0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBVcGRhdGUgdGhlIHNpdGUncyBzaXplLlxuICAgICAgICAkKCdkaXYjc2l0ZScpLmhlaWdodCgkKHdpbmRvdykuaGVpZ2h0KCkgLSAkKCcjaGVhZGVyJykuaGVpZ2h0KCkpO1xuICAgIH07XG5cbiAgICBleHBvcnRzLlBhZ2UgPSBQYWdlO1xuIiwiLy8gQ29weXJpZ2h0IChjKSBKdXB5dGVyIERldmVsb3BtZW50IFRlYW0uXG4vLyBEaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIE1vZGlmaWVkIEJTRCBMaWNlbnNlLlxuXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgICAgIFxuICAgIHZhciBjYWphID0gcmVxdWlyZSgnZ29vZ2xlLWNhamEvaHRtbC1jc3Mtc2FuaXRpemVyLW1pbmlmaWVkJyk7XG5cbiAgICB2YXIgbm9vcCA9IGZ1bmN0aW9uICh4KSB7IHJldHVybiB4OyB9O1xuXG4gICAgdmFyIGNhamE7XG4gICAgaWYgKHdpbmRvdyAmJiB3aW5kb3cuaHRtbCkge1xuICAgICAgICBjYWphID0gd2luZG93Lmh0bWw7XG4gICAgICAgIGNhamEuaHRtbDQgPSB3aW5kb3cuaHRtbDQ7XG4gICAgICAgIGNhamEuc2FuaXRpemVTdHlsZXNoZWV0ID0gd2luZG93LnNhbml0aXplU3R5bGVzaGVldDtcbiAgICB9XG5cbiAgICB2YXIgc2FuaXRpemVBdHRyaWJzID0gZnVuY3Rpb24gKHRhZ05hbWUsIGF0dHJpYnMsIG9wdF9uYWl2ZVVyaVJld3JpdGVyLCBvcHRfbm1Ub2tlblBvbGljeSwgb3B0X2xvZ2dlcikge1xuICAgICAgICAvKipcbiAgICAgICAgICogYWRkIHRydXN0aW5nIGRhdGEtYXR0cmlidXRlcyB0byB0aGUgZGVmYXVsdCBzYW5pdGl6ZUF0dHJpYnMgZnJvbSBjYWphXG4gICAgICAgICAqIHRoaXMgZnVuY3Rpb24gaXMgbW9zdGx5IGNvcGllZCBmcm9tIHRoZSBjYWphIHNvdXJjZVxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIEFUVFJJQlMgPSBjYWphLmh0bWw0LkFUVFJJQlM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXR0cmlicy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgdmFyIGF0dHJpYk5hbWUgPSBhdHRyaWJzW2ldO1xuICAgICAgICAgICAgaWYgKGF0dHJpYk5hbWUuc3Vic3RyKDAsNSkgPT0gJ2RhdGEtJykge1xuICAgICAgICAgICAgICAgIHZhciBhdHRyaWJLZXkgPSAnKjo6JyArIGF0dHJpYk5hbWU7XG4gICAgICAgICAgICAgICAgaWYgKCFBVFRSSUJTLmhhc093blByb3BlcnR5KGF0dHJpYktleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgQVRUUklCU1thdHRyaWJLZXldID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhamEuc2FuaXRpemVBdHRyaWJzKHRhZ05hbWUsIGF0dHJpYnMsIG9wdF9uYWl2ZVVyaVJld3JpdGVyLCBvcHRfbm1Ub2tlblBvbGljeSwgb3B0X2xvZ2dlcik7XG4gICAgfTtcblxuICAgIHZhciBzYW5pdGl6ZV9jc3MgPSBmdW5jdGlvbiAoY3NzLCB0YWdQb2xpY3kpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHNhbml0aXplIENTU1xuICAgICAgICAgKiBsaWtlIHNhbml0aXplX2h0bWwsIGJ1dCBmb3IgQ1NTXG4gICAgICAgICAqIGNhbGxlZCBieSBzYW5pdGl6ZV9zdHlsZXNoZWV0c1xuICAgICAgICAgKi9cbiAgICAgICAgcmV0dXJuIGNhamEuc2FuaXRpemVTdHlsZXNoZWV0KFxuICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lLFxuICAgICAgICAgICAgY3NzLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lckNsYXNzOiBudWxsLFxuICAgICAgICAgICAgICAgIGlkU3VmZml4OiAnJyxcbiAgICAgICAgICAgICAgICB0YWdQb2xpY3k6IHRhZ1BvbGljeSxcbiAgICAgICAgICAgICAgICB2aXJ0dWFsaXplQXR0ck5hbWU6IG5vb3BcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBub29wXG4gICAgICAgICk7XG4gICAgfTtcblxuICAgIHZhciBzYW5pdGl6ZV9zdHlsZXNoZWV0cyA9IGZ1bmN0aW9uIChodG1sLCB0YWdQb2xpY3kpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHNhbml0aXplIGp1c3QgdGhlIGNzcyBpbiBzdHlsZSB0YWdzIGluIGEgYmxvY2sgb2YgaHRtbFxuICAgICAgICAgKiBjYWxsZWQgYnkgc2FuaXRpemVfaHRtbCwgaWYgYWxsb3dfY3NzIGlzIHRydWVcbiAgICAgICAgICovXG4gICAgICAgIHZhciBoID0gJChcIjxkaXYvPlwiKS5hcHBlbmQoaHRtbCk7XG4gICAgICAgIHZhciBzdHlsZV90YWdzID0gaC5maW5kKFwic3R5bGVcIik7XG4gICAgICAgIGlmICghc3R5bGVfdGFncy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIG5vIHN0eWxlIHRhZ3MgdG8gc2FuaXRpemVcbiAgICAgICAgICAgIHJldHVybiBodG1sO1xuICAgICAgICB9XG4gICAgICAgIHN0eWxlX3RhZ3MuZWFjaChmdW5jdGlvbihpLCBzdHlsZSkge1xuICAgICAgICAgICAgc3R5bGUuaW5uZXJIVE1MID0gc2FuaXRpemVfY3NzKHN0eWxlLmlubmVySFRNTCwgdGFnUG9saWN5KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBoLmh0bWwoKTtcbiAgICB9O1xuXG4gICAgdmFyIHNhbml0aXplX2h0bWwgPSBmdW5jdGlvbiAoaHRtbCwgYWxsb3dfY3NzKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBzYW5pdGl6ZSBIVE1MXG4gICAgICAgICAqIGlmIGFsbG93X2NzcyBpcyB0cnVlIChkZWZhdWx0OiBmYWxzZSksIENTUyBpcyBzYW5pdGl6ZWQgYXMgd2VsbC5cbiAgICAgICAgICogb3RoZXJ3aXNlLCBDU1MgZWxlbWVudHMgYW5kIGF0dHJpYnV0ZXMgYXJlIHNpbXBseSByZW1vdmVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIGh0bWw0ID0gY2FqYS5odG1sNDtcblxuICAgICAgICBpZiAoYWxsb3dfY3NzKSB7XG4gICAgICAgICAgICAvLyBhbGxvdyBzYW5pdGl6YXRpb24gb2Ygc3R5bGUgdGFncyxcbiAgICAgICAgICAgIC8vIG5vdCBqdXN0IHNjcnViYmluZ1xuICAgICAgICAgICAgaHRtbDQuRUxFTUVOVFMuc3R5bGUgJj0gfmh0bWw0LmVmbGFncy5VTlNBRkU7XG4gICAgICAgICAgICBodG1sNC5BVFRSSUJTLnN0eWxlID0gaHRtbDQuYXR5cGUuU1RZTEU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBzY3J1YiBhbGwgQ1NTXG4gICAgICAgICAgICBodG1sNC5FTEVNRU5UUy5zdHlsZSB8PSBodG1sNC5lZmxhZ3MuVU5TQUZFO1xuICAgICAgICAgICAgaHRtbDQuQVRUUklCUy5zdHlsZSA9IGh0bWw0LmF0eXBlLlNDUklQVDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdmFyIHJlY29yZF9tZXNzYWdlcyA9IGZ1bmN0aW9uIChtc2csIG9wdHMpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiSFRNTCBTYW5pdGl6ZXJcIiwgbXNnLCBvcHRzKTtcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIHZhciBwb2xpY3kgPSBmdW5jdGlvbiAodGFnTmFtZSwgYXR0cmlicykge1xuICAgICAgICAgICAgaWYgKCEoaHRtbDQuRUxFTUVOVFNbdGFnTmFtZV0gJiBodG1sNC5lZmxhZ3MuVU5TQUZFKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICdhdHRyaWJzJzogc2FuaXRpemVBdHRyaWJzKHRhZ05hbWUsIGF0dHJpYnMsXG4gICAgICAgICAgICAgICAgICAgICAgICBub29wLCBub29wLCByZWNvcmRfbWVzc2FnZXMpXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlY29yZF9tZXNzYWdlcyh0YWdOYW1lICsgXCIgcmVtb3ZlZFwiLCB7XG4gICAgICAgICAgICAgICAgICBjaGFuZ2U6IFwicmVtb3ZlZFwiLFxuICAgICAgICAgICAgICAgICAgdGFnTmFtZTogdGFnTmFtZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgdmFyIHNhbml0aXplZCA9IGNhamEuc2FuaXRpemVXaXRoUG9saWN5KGh0bWwsIHBvbGljeSk7XG4gICAgICAgIFxuICAgICAgICBpZiAoYWxsb3dfY3NzKSB7XG4gICAgICAgICAgICAvLyBzYW5pdGl6ZSBzdHlsZSB0YWdzIGFzIHN0eWxlc2hlZXRzXG4gICAgICAgICAgICBzYW5pdGl6ZWQgPSBzYW5pdGl6ZV9zdHlsZXNoZWV0cyhyZXN1bHQuc2FuaXRpemVkLCBwb2xpY3kpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gc2FuaXRpemVkO1xuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgY2FqYTogY2FqYSxcbiAgICAgICAgc2FuaXRpemVfaHRtbDogc2FuaXRpemVfaHRtbFxuICAgIH07XG4iLCIvLyBDb3B5cmlnaHQgKGMpIEp1cHl0ZXIgRGV2ZWxvcG1lbnQgVGVhbS5cbi8vIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgTW9kaWZpZWQgQlNEIExpY2Vuc2UuXG5cbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgXG4gICAgdmFyIG1vbWVudCA9IHJlcXVpcmUoJ21vbWVudCcpO1xuXG4gICAgLyoqXG4gICAgICogTG9hZCBhIHNpbmdsZSBleHRlbnNpb24uXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBleHRlbnNpb24gLSBleHRlbnNpb24gcGF0aC5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSB0aGF0IHJlc29sdmVzIHRvIGFuIGV4dGVuc2lvbiBtb2R1bGUgaGFuZGxlXG4gICAgICovXG4gICAgdmFyIGxvYWRfZXh0ZW5zaW9uID0gZnVuY3Rpb24gKGV4dGVuc2lvbikge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICByZXF1aXJlanMoW1wibmJleHRlbnNpb25zL1wiICsgZXh0ZW5zaW9uXSwgZnVuY3Rpb24obW9kdWxlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJMb2FkZWQgZXh0ZW5zaW9uOiBcIiArIGV4dGVuc2lvbik7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlLmxvYWRfaXB5dGhvbl9leHRlbnNpb24oKTtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG1vZHVsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIExvYWQgbXVsdGlwbGUgZXh0ZW5zaW9ucy5cbiAgICAgKiBUYWtlcyBuLWFyZ3MsIHdoZXJlIGVhY2ggYXJnIGlzIGEgc3RyaW5nIHBhdGggdG8gdGhlIGV4dGVuc2lvbi5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSB0aGF0IHJlc29sdmVzIHRvIGEgbGlzdCBvZiBsb2FkZWQgbW9kdWxlIGhhbmRsZXMuXG4gICAgICovXG4gICAgdmFyIGxvYWRfZXh0ZW5zaW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKEFycmF5LnByb3RvdHlwZS5tYXAuY2FsbChhcmd1bWVudHMsIGxvYWRfZXh0ZW5zaW9uKSkuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIGxvYWQgZXh0ZW5zaW9uXCIgKyAoZXJyLnJlcXVpcmVNb2R1bGVzLmxlbmd0aD4xPydzJzonJykgKyBcIjpcIiwgZXJyLnJlcXVpcmVNb2R1bGVzLCBlcnIpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogV2FpdCBmb3IgYSBjb25maWcgc2VjdGlvbiB0byBsb2FkLCBhbmQgdGhlbiBsb2FkIHRoZSBleHRlbnNpb25zIHNwZWNpZmllZFxuICAgICAqIGluIGEgJ2xvYWRfZXh0ZW5zaW9ucycga2V5IGluc2lkZSBpdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsb2FkX2V4dGVuc2lvbnNfZnJvbV9jb25maWcoc2VjdGlvbikge1xuICAgICAgICBzZWN0aW9uLmxvYWRlZC50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHNlY3Rpb24uZGF0YS5sb2FkX2V4dGVuc2lvbnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmJleHRlbnNpb25fcGF0aHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VjdGlvbi5kYXRhLmxvYWRfZXh0ZW5zaW9ucyk7XG4gICAgICAgICAgICAgICAgbG9hZF9leHRlbnNpb25zLmFwcGx5KHRoaXMsIG5iZXh0ZW5zaW9uX3BhdGhzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gQ3Jvc3MtYnJvd3NlciBSZWdFeCBTcGxpdFxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgLy8gVGhpcyBjb2RlIGhhcyBiZWVuIE1PRElGSUVEIGZyb20gdGhlIGNvZGUgbGljZW5zZWQgYmVsb3cgdG8gbm90IHJlcGxhY2UgdGhlXG4gICAgLy8gZGVmYXVsdCBicm93c2VyIHNwbGl0LiAgVGhlIGxpY2Vuc2UgaXMgcmVwcm9kdWNlZCBoZXJlLlxuXG4gICAgLy8gc2VlIGh0dHA6Ly9ibG9nLnN0ZXZlbmxldml0aGFuLmNvbS9hcmNoaXZlcy9jcm9zcy1icm93c2VyLXNwbGl0IGZvciBtb3JlIGluZm86XG4gICAgLyohXG4gICAgICogQ3Jvc3MtQnJvd3NlciBTcGxpdCAxLjEuMVxuICAgICAqIENvcHlyaWdodCAyMDA3LTIwMTIgU3RldmVuIExldml0aGFuIDxzdGV2ZW5sZXZpdGhhbi5jb20+XG4gICAgICogQXZhaWxhYmxlIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICAgICAqIEVDTUFTY3JpcHQgY29tcGxpYW50LCB1bmlmb3JtIGNyb3NzLWJyb3dzZXIgc3BsaXQgbWV0aG9kXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBTcGxpdHMgYSBzdHJpbmcgaW50byBhbiBhcnJheSBvZiBzdHJpbmdzIHVzaW5nIGEgcmVnZXggb3Igc3RyaW5nXG4gICAgICogc2VwYXJhdG9yLiBNYXRjaGVzIG9mIHRoZSBzZXBhcmF0b3IgYXJlIG5vdCBpbmNsdWRlZCBpbiB0aGUgcmVzdWx0IGFycmF5LlxuICAgICAqIEhvd2V2ZXIsIGlmIGBzZXBhcmF0b3JgIGlzIGEgcmVnZXggdGhhdCBjb250YWlucyBjYXB0dXJpbmcgZ3JvdXBzLFxuICAgICAqIGJhY2tyZWZlcmVuY2VzIGFyZSBzcGxpY2VkIGludG8gdGhlIHJlc3VsdCBlYWNoIHRpbWUgYHNlcGFyYXRvcmAgaXNcbiAgICAgKiBtYXRjaGVkLiBGaXhlcyBicm93c2VyIGJ1Z3MgY29tcGFyZWQgdG8gdGhlIG5hdGl2ZVxuICAgICAqIGBTdHJpbmcucHJvdG90eXBlLnNwbGl0YCBhbmQgY2FuIGJlIHVzZWQgcmVsaWFibHkgY3Jvc3MtYnJvd3Nlci5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIFN0cmluZyB0byBzcGxpdC5cbiAgICAgKiBAcGFyYW0ge1JlZ0V4cH0gc2VwYXJhdG9yIFJlZ2V4IHRvIHVzZSBmb3Igc2VwYXJhdGluZ1xuICAgICAqICAgICB0aGUgc3RyaW5nLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbbGltaXRdIE1heGltdW0gbnVtYmVyIG9mIGl0ZW1zIHRvIGluY2x1ZGUgaW4gdGhlIHJlc3VsdFxuICAgICAqICAgICBhcnJheS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IEFycmF5IG9mIHN1YnN0cmluZ3MuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIEJhc2ljIHVzZVxuICAgICAqIHJlZ2V4X3NwbGl0KCdhIGIgYyBkJywgJyAnKTtcbiAgICAgKiAvLyAtPiBbJ2EnLCAnYicsICdjJywgJ2QnXVxuICAgICAqXG4gICAgICogLy8gV2l0aCBsaW1pdFxuICAgICAqIHJlZ2V4X3NwbGl0KCdhIGIgYyBkJywgJyAnLCAyKTtcbiAgICAgKiAvLyAtPiBbJ2EnLCAnYiddXG4gICAgICpcbiAgICAgKiAvLyBCYWNrcmVmZXJlbmNlcyBpbiByZXN1bHQgYXJyYXlcbiAgICAgKiByZWdleF9zcGxpdCgnLi53b3JkMSB3b3JkMi4uJywgLyhbYS16XSspKFxcZCspL2kpO1xuICAgICAqIC8vIC0+IFsnLi4nLCAnd29yZCcsICcxJywgJyAnLCAnd29yZCcsICcyJywgJy4uJ11cbiAgICAgKi9cbiAgICB2YXIgcmVnZXhfc3BsaXQgPSBmdW5jdGlvbiAoc3RyLCBzZXBhcmF0b3IsIGxpbWl0KSB7XG4gICAgICAgIHZhciBvdXRwdXQgPSBbXSxcbiAgICAgICAgICAgIGZsYWdzID0gKHNlcGFyYXRvci5pZ25vcmVDYXNlID8gXCJpXCIgOiBcIlwiKSArXG4gICAgICAgICAgICAgICAgICAgIChzZXBhcmF0b3IubXVsdGlsaW5lICA/IFwibVwiIDogXCJcIikgK1xuICAgICAgICAgICAgICAgICAgICAoc2VwYXJhdG9yLmV4dGVuZGVkICAgPyBcInhcIiA6IFwiXCIpICsgLy8gUHJvcG9zZWQgZm9yIEVTNlxuICAgICAgICAgICAgICAgICAgICAoc2VwYXJhdG9yLnN0aWNreSAgICAgPyBcInlcIiA6IFwiXCIpLCAvLyBGaXJlZm94IDMrXG4gICAgICAgICAgICBsYXN0TGFzdEluZGV4ID0gMCxcbiAgICAgICAgICAgIHNlcGFyYXRvcjIsIG1hdGNoLCBsYXN0SW5kZXgsIGxhc3RMZW5ndGg7XG4gICAgICAgIC8vIE1ha2UgYGdsb2JhbGAgYW5kIGF2b2lkIGBsYXN0SW5kZXhgIGlzc3VlcyBieSB3b3JraW5nIHdpdGggYSBjb3B5XG4gICAgICAgIHNlcGFyYXRvciA9IG5ldyBSZWdFeHAoc2VwYXJhdG9yLnNvdXJjZSwgZmxhZ3MgKyBcImdcIik7XG5cbiAgICAgICAgdmFyIGNvbXBsaWFudEV4ZWNOcGNnID0gdHlwZW9mKC8oKT8/Ly5leGVjKFwiXCIpWzFdKSA9PT0gXCJ1bmRlZmluZWRcIjtcbiAgICAgICAgaWYgKCFjb21wbGlhbnRFeGVjTnBjZykge1xuICAgICAgICAgICAgLy8gRG9lc24ndCBuZWVkIGZsYWdzIGd5LCBidXQgdGhleSBkb24ndCBodXJ0XG4gICAgICAgICAgICBzZXBhcmF0b3IyID0gbmV3IFJlZ0V4cChcIl5cIiArIHNlcGFyYXRvci5zb3VyY2UgKyBcIiQoPyFcXFxccylcIiwgZmxhZ3MpO1xuICAgICAgICB9XG4gICAgICAgIC8qIFZhbHVlcyBmb3IgYGxpbWl0YCwgcGVyIHRoZSBzcGVjOlxuICAgICAgICAgKiBJZiB1bmRlZmluZWQ6IDQyOTQ5NjcyOTUgLy8gTWF0aC5wb3coMiwgMzIpIC0gMVxuICAgICAgICAgKiBJZiAwLCBJbmZpbml0eSwgb3IgTmFOOiAwXG4gICAgICAgICAqIElmIHBvc2l0aXZlIG51bWJlcjogbGltaXQgPSBNYXRoLmZsb29yKGxpbWl0KTsgaWYgKGxpbWl0ID4gNDI5NDk2NzI5NSkgbGltaXQgLT0gNDI5NDk2NzI5NjtcbiAgICAgICAgICogSWYgbmVnYXRpdmUgbnVtYmVyOiA0Mjk0OTY3Mjk2IC0gTWF0aC5mbG9vcihNYXRoLmFicyhsaW1pdCkpXG4gICAgICAgICAqIElmIG90aGVyOiBUeXBlLWNvbnZlcnQsIHRoZW4gdXNlIHRoZSBhYm92ZSBydWxlc1xuICAgICAgICAgKi9cbiAgICAgICAgbGltaXQgPSB0eXBlb2YobGltaXQpID09PSBcInVuZGVmaW5lZFwiID9cbiAgICAgICAgICAgIC0xID4+PiAwIDogLy8gTWF0aC5wb3coMiwgMzIpIC0gMVxuICAgICAgICAgICAgbGltaXQgPj4+IDA7IC8vIFRvVWludDMyKGxpbWl0KVxuICAgICAgICBmb3IgKG1hdGNoID0gc2VwYXJhdG9yLmV4ZWMoc3RyKTsgbWF0Y2g7IG1hdGNoID0gc2VwYXJhdG9yLmV4ZWMoc3RyKSkge1xuICAgICAgICAgICAgLy8gYHNlcGFyYXRvci5sYXN0SW5kZXhgIGlzIG5vdCByZWxpYWJsZSBjcm9zcy1icm93c2VyXG4gICAgICAgICAgICBsYXN0SW5kZXggPSBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChsYXN0SW5kZXggPiBsYXN0TGFzdEluZGV4KSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goc3RyLnNsaWNlKGxhc3RMYXN0SW5kZXgsIG1hdGNoLmluZGV4KSk7XG4gICAgICAgICAgICAgICAgLy8gRml4IGJyb3dzZXJzIHdob3NlIGBleGVjYCBtZXRob2RzIGRvbid0IGNvbnNpc3RlbnRseSByZXR1cm4gYHVuZGVmaW5lZGAgZm9yXG4gICAgICAgICAgICAgICAgLy8gbm9ucGFydGljaXBhdGluZyBjYXB0dXJpbmcgZ3JvdXBzXG4gICAgICAgICAgICAgICAgaWYgKCFjb21wbGlhbnRFeGVjTnBjZyAmJiBtYXRjaC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoWzBdLnJlcGxhY2Uoc2VwYXJhdG9yMiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoIC0gMjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZihhcmd1bWVudHNbaV0pID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoW2ldID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChtYXRjaC5sZW5ndGggPiAxICYmIG1hdGNoLmluZGV4IDwgc3RyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShvdXRwdXQsIG1hdGNoLnNsaWNlKDEpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGFzdExlbmd0aCA9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBsYXN0TGFzdEluZGV4ID0gbGFzdEluZGV4O1xuICAgICAgICAgICAgICAgIGlmIChvdXRwdXQubGVuZ3RoID49IGxpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZXBhcmF0b3IubGFzdEluZGV4ID09PSBtYXRjaC5pbmRleCkge1xuICAgICAgICAgICAgICAgIHNlcGFyYXRvci5sYXN0SW5kZXgrKzsgLy8gQXZvaWQgYW4gaW5maW5pdGUgbG9vcFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChsYXN0TGFzdEluZGV4ID09PSBzdHIubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAobGFzdExlbmd0aCB8fCAhc2VwYXJhdG9yLnRlc3QoXCJcIikpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChcIlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG91dHB1dC5wdXNoKHN0ci5zbGljZShsYXN0TGFzdEluZGV4KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dC5sZW5ndGggPiBsaW1pdCA/IG91dHB1dC5zbGljZSgwLCBsaW1pdCkgOiBvdXRwdXQ7XG4gICAgfTtcblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIEVuZCBjb250cmlidXRlZCBDcm9zcy1icm93c2VyIFJlZ0V4IFNwbGl0XG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cblxuICAgIHZhciB1dWlkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogaHR0cDovL3d3dy5pZXRmLm9yZy9yZmMvcmZjNDEyMi50eHRcbiAgICAgICAgICovXG4gICAgICAgIHZhciBzID0gW107XG4gICAgICAgIHZhciBoZXhEaWdpdHMgPSBcIjAxMjM0NTY3ODlBQkNERUZcIjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzMjsgaSsrKSB7XG4gICAgICAgICAgICBzW2ldID0gaGV4RGlnaXRzLnN1YnN0cihNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAweDEwKSwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgc1sxMl0gPSBcIjRcIjsgIC8vIGJpdHMgMTItMTUgb2YgdGhlIHRpbWVfaGlfYW5kX3ZlcnNpb24gZmllbGQgdG8gMDAxMFxuICAgICAgICBzWzE2XSA9IGhleERpZ2l0cy5zdWJzdHIoKHNbMTZdICYgMHgzKSB8IDB4OCwgMSk7ICAvLyBiaXRzIDYtNyBvZiB0aGUgY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZCB0byAwMVxuXG4gICAgICAgIHZhciB1dWlkID0gcy5qb2luKFwiXCIpO1xuICAgICAgICByZXR1cm4gdXVpZDtcbiAgICB9O1xuXG5cbiAgICAvL0ZpeCByYXcgdGV4dCB0byBwYXJzZSBjb3JyZWN0bHkgaW4gY3JhenkgWE1MXG4gICAgZnVuY3Rpb24geG1sZW5jb2RlKHN0cmluZykge1xuICAgICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL1xcJi9nLCcmJysnYW1wOycpXG4gICAgICAgICAgICAucmVwbGFjZSgvPC9nLCcmJysnbHQ7JylcbiAgICAgICAgICAgIC5yZXBsYWNlKC8+L2csJyYnKydndDsnKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcJy9nLCcmJysnYXBvczsnKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcXCIvZywnJicrJ3F1b3Q7JylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9gL2csJyYnKycjOTY7Jyk7XG4gICAgfVxuXG5cbiAgICAvL01hcCBmcm9tIHRlcm1pbmFsIGNvbW1hbmRzIHRvIENTUyBjbGFzc2VzXG4gICAgdmFyIGFuc2lfY29sb3JtYXAgPSB7XG4gICAgICAgIFwiMDFcIjpcImFuc2lib2xkXCIsXG4gICAgICAgIFxuICAgICAgICBcIjMwXCI6XCJhbnNpYmxhY2tcIixcbiAgICAgICAgXCIzMVwiOlwiYW5zaXJlZFwiLFxuICAgICAgICBcIjMyXCI6XCJhbnNpZ3JlZW5cIixcbiAgICAgICAgXCIzM1wiOlwiYW5zaXllbGxvd1wiLFxuICAgICAgICBcIjM0XCI6XCJhbnNpYmx1ZVwiLFxuICAgICAgICBcIjM1XCI6XCJhbnNpcHVycGxlXCIsXG4gICAgICAgIFwiMzZcIjpcImFuc2ljeWFuXCIsXG4gICAgICAgIFwiMzdcIjpcImFuc2lncmF5XCIsXG4gICAgICAgIFxuICAgICAgICBcIjQwXCI6XCJhbnNpYmdibGFja1wiLFxuICAgICAgICBcIjQxXCI6XCJhbnNpYmdyZWRcIixcbiAgICAgICAgXCI0MlwiOlwiYW5zaWJnZ3JlZW5cIixcbiAgICAgICAgXCI0M1wiOlwiYW5zaWJneWVsbG93XCIsXG4gICAgICAgIFwiNDRcIjpcImFuc2liZ2JsdWVcIixcbiAgICAgICAgXCI0NVwiOlwiYW5zaWJncHVycGxlXCIsXG4gICAgICAgIFwiNDZcIjpcImFuc2liZ2N5YW5cIixcbiAgICAgICAgXCI0N1wiOlwiYW5zaWJnZ3JheVwiXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIF9wcm9jZXNzX251bWJlcnMoYXR0cnMsIG51bWJlcnMpIHtcbiAgICAgICAgLy8gcHJvY2VzcyBhbnNpIGVzY2FwZXNcbiAgICAgICAgdmFyIG4gPSBudW1iZXJzLnNoaWZ0KCk7XG4gICAgICAgIGlmIChhbnNpX2NvbG9ybWFwW25dKSB7XG4gICAgICAgICAgICBpZiAoICEgYXR0cnNbXCJjbGFzc1wiXSApIHtcbiAgICAgICAgICAgICAgICBhdHRyc1tcImNsYXNzXCJdID0gYW5zaV9jb2xvcm1hcFtuXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYXR0cnNbXCJjbGFzc1wiXSArPSBcIiBcIiArIGFuc2lfY29sb3JtYXBbbl07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobiA9PSBcIjM4XCIgfHwgbiA9PSBcIjQ4XCIpIHtcbiAgICAgICAgICAgIC8vIFZUMTAwIDI1NiBjb2xvciBvciAyNCBiaXQgUkdCXG4gICAgICAgICAgICBpZiAobnVtYmVycy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJOb3QgZW5vdWdoIGZpZWxkcyBmb3IgVlQxMDAgY29sb3JcIiwgbnVtYmVycyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgaW5kZXhfb3JfcmdiID0gbnVtYmVycy5zaGlmdCgpO1xuICAgICAgICAgICAgdmFyIHIsZyxiO1xuICAgICAgICAgICAgaWYgKGluZGV4X29yX3JnYiA9PSBcIjVcIikge1xuICAgICAgICAgICAgICAgIC8vIDI1NiBjb2xvclxuICAgICAgICAgICAgICAgIHZhciBpZHggPSBwYXJzZUludChudW1iZXJzLnNoaWZ0KCksIDEwKTtcbiAgICAgICAgICAgICAgICBpZiAoaWR4IDwgMTYpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaW5kZXhlZCBBTlNJXG4gICAgICAgICAgICAgICAgICAgIC8vIGlnbm9yZSBicmlnaHQgLyBub24tYnJpZ2h0IGRpc3RpbmN0aW9uXG4gICAgICAgICAgICAgICAgICAgIGlkeCA9IGlkeCAlIDg7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhbnNpY2xhc3MgPSBhbnNpX2NvbG9ybWFwW25bMF0gKyAoaWR4ICUgOCkudG9TdHJpbmcoKV07XG4gICAgICAgICAgICAgICAgICAgIGlmICggISBhdHRyc1tcImNsYXNzXCJdICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cnNbXCJjbGFzc1wiXSA9IGFuc2ljbGFzcztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzW1wiY2xhc3NcIl0gKz0gXCIgXCIgKyBhbnNpY2xhc3M7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaWR4IDwgMjMyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIDIxNiBjb2xvciA2eDZ4NiBSR0JcbiAgICAgICAgICAgICAgICAgICAgaWR4ID0gaWR4IC0gMTY7XG4gICAgICAgICAgICAgICAgICAgIGIgPSBpZHggJSA2O1xuICAgICAgICAgICAgICAgICAgICBnID0gTWF0aC5mbG9vcihpZHggLyA2KSAlIDY7XG4gICAgICAgICAgICAgICAgICAgIHIgPSBNYXRoLmZsb29yKGlkeCAvIDM2KSAlIDY7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnZlcnQgdG8gcmdiXG4gICAgICAgICAgICAgICAgICAgIHIgPSAociAqIDUxKTtcbiAgICAgICAgICAgICAgICAgICAgZyA9IChnICogNTEpO1xuICAgICAgICAgICAgICAgICAgICBiID0gKGIgKiA1MSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZ3JheXNjYWxlXG4gICAgICAgICAgICAgICAgICAgIGlkeCA9IGlkeCAtIDIzMTtcbiAgICAgICAgICAgICAgICAgICAgLy8gaXQncyAxLTI0IGFuZCBzaG91bGQgKm5vdCogaW5jbHVkZSBibGFjayBvciB3aGl0ZSxcbiAgICAgICAgICAgICAgICAgICAgLy8gc28gYSAyNiBwb2ludCBzY2FsZVxuICAgICAgICAgICAgICAgICAgICByID0gZyA9IGIgPSBNYXRoLmZsb29yKGlkeCAqIDI1NiAvIDI2KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGluZGV4X29yX3JnYiA9PSBcIjJcIikge1xuICAgICAgICAgICAgICAgIC8vIFNpbXBsZSAyNCBiaXQgUkdCXG4gICAgICAgICAgICAgICAgaWYgKG51bWJlcnMubGVuZ3RoID4gMykge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIk5vdCBlbm91Z2ggZmllbGRzIGZvciBSR0JcIiwgbnVtYmVycyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgciA9IG51bWJlcnMuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICBnID0gbnVtYmVycy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIGIgPSBudW1iZXJzLnNoaWZ0KCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwidW5yZWNvZ25pemVkIGNvbnRyb2xcIiwgbnVtYmVycyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIGFwcGx5IHRoZSByZ2IgY29sb3JcbiAgICAgICAgICAgICAgICB2YXIgbGluZTtcbiAgICAgICAgICAgICAgICBpZiAobiA9PSBcIjM4XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZSA9IFwiY29sb3I6IFwiO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmUgPSBcImJhY2tncm91bmQtY29sb3I6IFwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsaW5lID0gbGluZSArIFwicmdiKFwiICsgciArIFwiLFwiICsgZyArIFwiLFwiICsgYiArIFwiKTtcIjtcbiAgICAgICAgICAgICAgICBpZiAoICFhdHRycy5zdHlsZSApIHtcbiAgICAgICAgICAgICAgICAgICAgYXR0cnMuc3R5bGUgPSBsaW5lO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGF0dHJzLnN0eWxlICs9IFwiIFwiICsgbGluZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhbnNpc3BhbihzdHIpIHtcbiAgICAgICAgLy8gYW5zaXNwYW4gZnVuY3Rpb24gYWRhcHRlZCBmcm9tIGdpdGh1Yi5jb20vbW1hbGVja2kvYW5zaXNwYW4gKE1JVCBMaWNlbnNlKVxuICAgICAgICAvLyByZWd1bGFyIGFuc2kgZXNjYXBlcyAodXNpbmcgdGhlIHRhYmxlIGFib3ZlKVxuICAgICAgICB2YXIgaXNfb3BlbiA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoL1xcMDMzXFxbKDA/WzAxXXwyMnwzOSk/KFs7XFxkXSspP20vZywgZnVuY3Rpb24obWF0Y2gsIHByZWZpeCwgcGF0dGVybikge1xuICAgICAgICAgICAgaWYgKCFwYXR0ZXJuKSB7XG4gICAgICAgICAgICAgICAgLy8gWygwMXwyMnwzOXwpbSBjbG9zZSBzcGFuc1xuICAgICAgICAgICAgICAgIGlmIChpc19vcGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIGlzX29wZW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiPC9zcGFuPlwiO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaXNfb3BlbiA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAvLyBjb25zdW1lIHNlcXVlbmNlIG9mIGNvbG9yIGVzY2FwZXNcbiAgICAgICAgICAgICAgICB2YXIgbnVtYmVycyA9IHBhdHRlcm4ubWF0Y2goL1xcZCsvZyk7XG4gICAgICAgICAgICAgICAgdmFyIGF0dHJzID0ge307XG4gICAgICAgICAgICAgICAgd2hpbGUgKG51bWJlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBfcHJvY2Vzc19udW1iZXJzKGF0dHJzLCBudW1iZXJzKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgc3BhbiA9IFwiPHNwYW4gXCI7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoYXR0cnMpLm1hcChmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICAgICAgICAgICAgICBzcGFuID0gc3BhbiArIFwiIFwiICsgYXR0ciArICc9XCInICsgYXR0cnNbYXR0cl0gKyAnXCInO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBzcGFuICsgXCI+XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFRyYW5zZm9ybSBBTlNJIGNvbG9yIGVzY2FwZSBjb2RlcyBpbnRvIEhUTUwgPHNwYW4+IHRhZ3Mgd2l0aCBjc3NcbiAgICAvLyBjbGFzc2VzIGxpc3RlZCBpbiB0aGUgYWJvdmUgYW5zaV9jb2xvcm1hcCBvYmplY3QuIFRoZSBhY3R1YWwgY29sb3IgdXNlZFxuICAgIC8vIGFyZSBzZXQgaW4gdGhlIGNzcyBmaWxlLlxuICAgIGZ1bmN0aW9uIGZpeENvbnNvbGUodHh0KSB7XG4gICAgICAgIHR4dCA9IHhtbGVuY29kZSh0eHQpO1xuXG4gICAgICAgIC8vIFN0cmlwIGFsbCBBTlNJIGNvZGVzIHRoYXQgYXJlIG5vdCBjb2xvciByZWxhdGVkLiAgTWF0Y2hlc1xuICAgICAgICAvLyBhbGwgQU5TSSBjb2RlcyB0aGF0IGRvIG5vdCBlbmQgd2l0aCBcIm1cIi5cbiAgICAgICAgdmFyIGlnbm9yZWRfcmUgPSAvKD89KFxcMDMzXFxbW1xcZDs9XSpbYS1sbi16QS1aXXsxfSkpXFwxKD8hbSkvZztcbiAgICAgICAgdHh0ID0gdHh0LnJlcGxhY2UoaWdub3JlZF9yZSwgXCJcIik7XG4gICAgICAgIFxuICAgICAgICAvLyBjb2xvciBhbnNpIGNvZGVzXG4gICAgICAgIHR4dCA9IGFuc2lzcGFuKHR4dCk7XG4gICAgICAgIHJldHVybiB0eHQ7XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIGNodW5rcyB0aGF0IHNob3VsZCBiZSBvdmVycmlkZGVuIGJ5IHRoZSBlZmZlY3Qgb2ZcbiAgICAvLyBjYXJyaWFnZSByZXR1cm4gY2hhcmFjdGVyc1xuICAgIGZ1bmN0aW9uIGZpeENhcnJpYWdlUmV0dXJuKHR4dCkge1xuICAgICAgICB2YXIgdG1wID0gdHh0O1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICB0eHQgPSB0bXA7XG4gICAgICAgICAgICB0bXAgPSB0eHQucmVwbGFjZSgvXFxyK1xcbi9nbSwgJ1xcbicpOyAvLyBcXHIgZm9sbG93ZWQgYnkgXFxuIC0tPiBuZXdsaW5lXG4gICAgICAgICAgICB0bXAgPSB0bXAucmVwbGFjZSgvXi4qXFxyKy9nbSwgJycpOyAgLy8gT3RoZXIgXFxyIC0tPiBjbGVhciBsaW5lXG4gICAgICAgIH0gd2hpbGUgKHRtcC5sZW5ndGggPCB0eHQubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIHR4dDtcbiAgICB9XG5cbiAgICAvLyBMb2NhdGUgYW55IFVSTHMgYW5kIGNvbnZlcnQgdGhlbSB0byBhIGFuY2hvciB0YWdcbiAgICBmdW5jdGlvbiBhdXRvTGlua1VybHModHh0KSB7XG4gICAgICAgIHJldHVybiB0eHQucmVwbGFjZSgvKF58XFxzKShodHRwcz98ZnRwKSg6W14nXCI+XFxzXSspL2dpLFxuICAgICAgICAgICAgXCIkMTxhIHRhcmdldD1cXFwiX2JsYW5rXFxcIiBocmVmPVxcXCIkMiQzXFxcIj4kMiQzPC9hPlwiKTtcbiAgICB9XG5cbiAgICB2YXIgcG9pbnRzX3RvX3BpeGVscyA9IGZ1bmN0aW9uIChwb2ludHMpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgcmVhc29uYWJseSBnb29kIHdheSBvZiBjb252ZXJ0aW5nIGJldHdlZW4gcG9pbnRzIGFuZCBwaXhlbHMuXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgdGVzdCA9ICQoJzxkaXYgc3R5bGU9XCJkaXNwbGF5OiBub25lOyB3aWR0aDogMTAwMDBwdDsgcGFkZGluZzowOyBib3JkZXI6MDtcIj48L2Rpdj4nKTtcbiAgICAgICAgJCgnYm9keScpLmFwcGVuZCh0ZXN0KTtcbiAgICAgICAgdmFyIHBpeGVsX3Blcl9wb2ludCA9IHRlc3Qud2lkdGgoKS8xMDAwMDtcbiAgICAgICAgdGVzdC5yZW1vdmUoKTtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IocG9pbnRzKnBpeGVsX3Blcl9wb2ludCk7XG4gICAgfTtcblxuICAgIHZhciBhbHdheXNfbmV3ID0gZnVuY3Rpb24gKGNvbnN0cnVjdG9yKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiB3cmFwcGVyIGFyb3VuZCBjb250cnVjdG9yIHRvIGF2b2lkIHJlcXVpcmluZyBgdmFyIGEgPSBuZXcgY29uc3RydWN0b3IoKWBcbiAgICAgICAgICogdXNlZnVsIGZvciBwYXNzaW5nIGNvbnN0cnVjdG9ycyBhcyBjYWxsYmFja3MsXG4gICAgICAgICAqIG5vdCBmb3IgcHJvZ3JhbW1lciBsYXppbmVzcy5cbiAgICAgICAgICogZnJvbSBodHRwOi8vcHJvZ3JhbW1lcnMuc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzExODc5OFxuICAgICAgICAgKi9cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvYmogPSBPYmplY3QuY3JlYXRlKGNvbnN0cnVjdG9yLnByb3RvdHlwZSk7XG4gICAgICAgICAgICBjb25zdHJ1Y3Rvci5hcHBseShvYmosIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgdXJsX3BhdGhfam9pbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGpvaW4gYSBzZXF1ZW5jZSBvZiB1cmwgY29tcG9uZW50cyB3aXRoICcvJ1xuICAgICAgICAgKi9cbiAgICAgICAgdmFyIHVybCA9ICcnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50c1tpXSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1cmwubGVuZ3RoID4gMCAmJiB1cmxbdXJsLmxlbmd0aC0xXSAhPSAnLycpIHtcbiAgICAgICAgICAgICAgICB1cmwgPSB1cmwgKyAnLycgKyBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHVybCA9IHVybCArIGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB1cmwgPSB1cmwucmVwbGFjZSgvXFwvXFwvKy8sICcvJyk7XG4gICAgICAgIHJldHVybiB1cmw7XG4gICAgfTtcblxuICAgIHZhciB1cmxfcGF0aF9zcGxpdCA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaWtlIG9zLnBhdGguc3BsaXQgZm9yIFVSTHMuXG4gICAgICAgICAqIEFsd2F5cyByZXR1cm5zIHR3byBzdHJpbmdzLCB0aGUgZGlyZWN0b3J5IHBhdGggYW5kIHRoZSBiYXNlIGZpbGVuYW1lXG4gICAgICAgICAqL1xuICAgICAgICBcbiAgICAgICAgdmFyIGlkeCA9IHBhdGgubGFzdEluZGV4T2YoJy8nKTtcbiAgICAgICAgaWYgKGlkeCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBbJycsIHBhdGhdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFsgcGF0aC5zbGljZSgwLCBpZHgpLCBwYXRoLnNsaWNlKGlkeCArIDEpIF07XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHBhcnNlX3VybCA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGFuIGBhYCBlbGVtZW50IHdpdGggYW4gaHJlZiBhbGxvd3MgYXR0ci1hY2Nlc3MgdG8gdGhlIHBhcnNlZCBzZWdtZW50cyBvZiBhIFVSTFxuICAgICAgICAgKiBhID0gcGFyc2VfdXJsKFwiaHR0cDovL2xvY2FsaG9zdDo4ODg4L3BhdGgvbmFtZSNoYXNoXCIpXG4gICAgICAgICAqIGEucHJvdG9jb2wgPSBcImh0dHA6XCJcbiAgICAgICAgICogYS5ob3N0ICAgICA9IFwibG9jYWxob3N0Ojg4ODhcIlxuICAgICAgICAgKiBhLmhvc3RuYW1lID0gXCJsb2NhbGhvc3RcIlxuICAgICAgICAgKiBhLnBvcnQgICAgID0gODg4OFxuICAgICAgICAgKiBhLnBhdGhuYW1lID0gXCIvcGF0aC9uYW1lXCJcbiAgICAgICAgICogYS5oYXNoICAgICA9IFwiI2hhc2hcIlxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIGEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtcbiAgICAgICAgYS5ocmVmID0gdXJsO1xuICAgICAgICByZXR1cm4gYTtcbiAgICB9O1xuXG4gICAgdmFyIGVuY29kZV91cmlfY29tcG9uZW50cyA9IGZ1bmN0aW9uICh1cmkpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGVuY29kZSBqdXN0IHRoZSBjb21wb25lbnRzIG9mIGEgbXVsdGktc2VnbWVudCB1cmksXG4gICAgICAgICAqIGxlYXZpbmcgJy8nIHNlcGFyYXRvcnNcbiAgICAgICAgICovXG4gICAgICAgIHJldHVybiB1cmkuc3BsaXQoJy8nKS5tYXAoZW5jb2RlVVJJQ29tcG9uZW50KS5qb2luKCcvJyk7XG4gICAgfTtcblxuICAgIHZhciB1cmxfam9pbl9lbmNvZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBqb2luIGEgc2VxdWVuY2Ugb2YgdXJsIGNvbXBvbmVudHMgd2l0aCAnLycsXG4gICAgICAgICAqIGVuY29kaW5nIGVhY2ggY29tcG9uZW50IHdpdGggZW5jb2RlVVJJQ29tcG9uZW50XG4gICAgICAgICAqL1xuICAgICAgICByZXR1cm4gZW5jb2RlX3VyaV9jb21wb25lbnRzKHVybF9wYXRoX2pvaW4uYXBwbHkobnVsbCwgYXJndW1lbnRzKSk7XG4gICAgfTtcblxuXG4gICAgdmFyIHNwbGl0ZXh0ID0gZnVuY3Rpb24gKGZpbGVuYW1lKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBtaW1pYyBQeXRob24gb3MucGF0aC5zcGxpdGV4dFxuICAgICAgICAgKiBSZXR1cm5zIFsnYmFzZScsICcuZXh0J11cbiAgICAgICAgICovXG4gICAgICAgIHZhciBpZHggPSBmaWxlbmFtZS5sYXN0SW5kZXhPZignLicpO1xuICAgICAgICBpZiAoaWR4ID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFtmaWxlbmFtZS5zbGljZSgwLCBpZHgpLCBmaWxlbmFtZS5zbGljZShpZHgpXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBbZmlsZW5hbWUsICcnXTtcbiAgICAgICAgfVxuICAgIH07XG5cblxuICAgIHZhciBlc2NhcGVfaHRtbCA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBlc2NhcGUgdGV4dCB0byBIVE1MXG4gICAgICAgICAqL1xuICAgICAgICByZXR1cm4gJChcIjxkaXYvPlwiKS50ZXh0KHRleHQpLmh0bWwoKTtcbiAgICB9O1xuXG5cbiAgICB2YXIgZ2V0X2JvZHlfZGF0YSA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAvKipcbiAgICAgICAgICogZ2V0IGEgdXJsLWVuY29kZWQgaXRlbSBmcm9tIGJvZHkuZGF0YSBhbmQgZGVjb2RlIGl0XG4gICAgICAgICAqIHdlIHNob3VsZCBuZXZlciBoYXZlIGFueSBlbmNvZGVkIFVSTHMgYW55d2hlcmUgZWxzZSBpbiBjb2RlXG4gICAgICAgICAqIHVudGlsIHdlIGFyZSBidWlsZGluZyBhbiBhY3R1YWwgcmVxdWVzdFxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIHZhbCA9ICQoJ2JvZHknKS5kYXRhKGtleSk7XG4gICAgICAgIGlmICghdmFsKVxuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudCh2YWwpO1xuICAgIH07XG5cbiAgICB2YXIgdG9fYWJzb2x1dGVfY3Vyc29yX3BvcyA9IGZ1bmN0aW9uIChjbSwgY3Vyc29yKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBnZXQgdGhlIGFic29sdXRlIGN1cnNvciBwb3NpdGlvbiBmcm9tIENvZGVNaXJyb3IncyBjb2wsIGNoXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoIWN1cnNvcikge1xuICAgICAgICAgICAgY3Vyc29yID0gY20uZ2V0Q3Vyc29yKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGN1cnNvcl9wb3MgPSBjdXJzb3IuY2g7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY3Vyc29yLmxpbmU7IGkrKykge1xuICAgICAgICAgICAgY3Vyc29yX3BvcyArPSBjbS5nZXRMaW5lKGkpLmxlbmd0aCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1cnNvcl9wb3M7XG4gICAgfTtcblxuICAgIHZhciBmcm9tX2Fic29sdXRlX2N1cnNvcl9wb3MgPSBmdW5jdGlvbiAoY20sIGN1cnNvcl9wb3MpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHR1cm4gYWJzb2x1dGUgY3Vyc29yIHBvc2l0aW9uIGludG8gQ29kZU1pcnJvciBjb2wsIGNoIGN1cnNvclxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIGksIGxpbmUsIG5leHRfbGluZTtcbiAgICAgICAgdmFyIG9mZnNldCA9IDA7XG4gICAgICAgIGZvciAoaSA9IDAsIG5leHRfbGluZT1jbS5nZXRMaW5lKGkpOyBuZXh0X2xpbmUgIT09IHVuZGVmaW5lZDsgaSsrLCBuZXh0X2xpbmU9Y20uZ2V0TGluZShpKSkge1xuICAgICAgICAgICAgbGluZSA9IG5leHRfbGluZTtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgKyBuZXh0X2xpbmUubGVuZ3RoIDwgY3Vyc29yX3Bvcykge1xuICAgICAgICAgICAgICAgIG9mZnNldCArPSBuZXh0X2xpbmUubGVuZ3RoICsgMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZSA6IGksXG4gICAgICAgICAgICAgICAgICAgIGNoIDogY3Vyc29yX3BvcyAtIG9mZnNldCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHJlYWNoZWQgZW5kLCByZXR1cm4gZW5kcG9pbnRcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxpbmUgOiBpIC0gMSxcbiAgICAgICAgICAgIGNoIDogbGluZS5sZW5ndGggLSAxLFxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzI0MDA5MzUvYnJvd3Nlci1kZXRlY3Rpb24taW4tamF2YXNjcmlwdFxuICAgIHZhciBicm93c2VyID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodHlwZW9mIG5hdmlnYXRvciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIC8vIG5hdmlnYXRvciB1bmRlZmluZWQgaW4gbm9kZVxuICAgICAgICAgICAgcmV0dXJuICdOb25lJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgTj0gbmF2aWdhdG9yLmFwcE5hbWUsIHVhPSBuYXZpZ2F0b3IudXNlckFnZW50LCB0ZW07XG4gICAgICAgIHZhciBNPSB1YS5tYXRjaCgvKG9wZXJhfGNocm9tZXxzYWZhcml8ZmlyZWZveHxtc2llKVxcLz9cXHMqKFxcLj9cXGQrKFxcLlxcZCspKikvaSk7XG4gICAgICAgIGlmIChNICYmICh0ZW09IHVhLm1hdGNoKC92ZXJzaW9uXFwvKFtcXC5cXGRdKykvaSkpICE9PSBudWxsKSBNWzJdPSB0ZW1bMV07XG4gICAgICAgIE09IE0/IFtNWzFdLCBNWzJdXTogW04sIG5hdmlnYXRvci5hcHBWZXJzaW9uLCctPyddO1xuICAgICAgICByZXR1cm4gTTtcbiAgICB9KSgpO1xuXG4gICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMTIxOTU4Mi9ob3ctdG8tZGV0ZWN0LW15LWJyb3dzZXItdmVyc2lvbi1hbmQtb3BlcmF0aW5nLXN5c3RlbS11c2luZy1qYXZhc2NyaXB0XG4gICAgdmFyIHBsYXRmb3JtID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAvLyBuYXZpZ2F0b3IgdW5kZWZpbmVkIGluIG5vZGVcbiAgICAgICAgICAgIHJldHVybiAnTm9uZSc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIE9TTmFtZT1cIk5vbmVcIjtcbiAgICAgICAgaWYgKG5hdmlnYXRvci5hcHBWZXJzaW9uLmluZGV4T2YoXCJXaW5cIikhPS0xKSBPU05hbWU9XCJXaW5kb3dzXCI7XG4gICAgICAgIGlmIChuYXZpZ2F0b3IuYXBwVmVyc2lvbi5pbmRleE9mKFwiTWFjXCIpIT0tMSkgT1NOYW1lPVwiTWFjT1NcIjtcbiAgICAgICAgaWYgKG5hdmlnYXRvci5hcHBWZXJzaW9uLmluZGV4T2YoXCJYMTFcIikhPS0xKSBPU05hbWU9XCJVTklYXCI7XG4gICAgICAgIGlmIChuYXZpZ2F0b3IuYXBwVmVyc2lvbi5pbmRleE9mKFwiTGludXhcIikhPS0xKSBPU05hbWU9XCJMaW51eFwiO1xuICAgICAgICByZXR1cm4gT1NOYW1lO1xuICAgIH0pKCk7XG5cbiAgICB2YXIgZ2V0X3VybF9wYXJhbSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIC8vIGdldCBhIFVSTCBwYXJhbWV0ZXIuIEkgY2Fubm90IGJlbGlldmUgd2UgYWN0dWFsbHkgbmVlZCB0aGlzLlxuICAgICAgICAvLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNTM1OTI2NC85Mzg5NDlcbiAgICAgICAgdmFyIG1hdGNoID0gbmV3IFJlZ0V4cCgnWz8mXScgKyBuYW1lICsgJz0oW14mXSopJykuZXhlYyh3aW5kb3cubG9jYXRpb24uc2VhcmNoKTtcbiAgICAgICAgaWYgKG1hdGNoKXtcbiAgICAgICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQobWF0Y2hbMV0gfHwgJycpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBpc19vcl9oYXMgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAvKipcbiAgICAgICAgICogSXMgYiBhIGNoaWxkIG9mIGEgb3IgYSBpdHNlbGY/XG4gICAgICAgICAqL1xuICAgICAgICByZXR1cm4gYS5oYXMoYikubGVuZ3RoICE9PTAgfHwgYS5pcyhiKTtcbiAgICB9O1xuXG4gICAgdmFyIGlzX2ZvY3VzZWQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAvKipcbiAgICAgICAgICogSXMgZWxlbWVudCBlLCBvciBvbmUgb2YgaXRzIGNoaWxkcmVuIGZvY3VzZWQ/XG4gICAgICAgICAqL1xuICAgICAgICBlID0gJChlKTtcbiAgICAgICAgdmFyIHRhcmdldCA9ICQoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCk7XG4gICAgICAgIGlmICh0YXJnZXQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaWYgKGlzX29yX2hhcyhlLCB0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgbWVyZ2VvcHQgPSBmdW5jdGlvbihfY2xhc3MsIG9wdGlvbnMsIG92ZXJ3cml0ZSl7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICBvdmVyd3JpdGUgPSBvdmVyd3JpdGUgfHwge307XG4gICAgICAgIHJldHVybiAkLmV4dGVuZCh0cnVlLCB7fSwgX2NsYXNzLm9wdGlvbnNfZGVmYXVsdCwgb3B0aW9ucywgb3ZlcndyaXRlKTtcbiAgICB9O1xuXG4gICAgdmFyIGFqYXhfZXJyb3JfbXNnID0gZnVuY3Rpb24gKGpxWEhSKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm4gYSBKU09OIGVycm9yIG1lc3NhZ2UgaWYgdGhlcmUgaXMgb25lLFxuICAgICAgICAgKiBvdGhlcndpc2UgdGhlIGJhc2ljIEhUVFAgc3RhdHVzIHRleHQuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoanFYSFIucmVzcG9uc2VKU09OICYmIGpxWEhSLnJlc3BvbnNlSlNPTi50cmFjZWJhY2spIHtcbiAgICAgICAgICAgIHJldHVybiBqcVhIUi5yZXNwb25zZUpTT04udHJhY2ViYWNrO1xuICAgICAgICB9IGVsc2UgaWYgKGpxWEhSLnJlc3BvbnNlSlNPTiAmJiBqcVhIUi5yZXNwb25zZUpTT04ubWVzc2FnZSkge1xuICAgICAgICAgICAgcmV0dXJuIGpxWEhSLnJlc3BvbnNlSlNPTi5tZXNzYWdlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGpxWEhSLnN0YXR1c1RleHQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBsb2dfYWpheF9lcnJvciA9IGZ1bmN0aW9uIChqcVhIUiwgc3RhdHVzLCBlcnJvcikge1xuICAgICAgICAvKipcbiAgICAgICAgICogbG9nIGFqYXggZmFpbHVyZXMgd2l0aCBpbmZvcm1hdGl2ZSBtZXNzYWdlc1xuICAgICAgICAgKi9cbiAgICAgICAgdmFyIG1zZyA9IFwiQVBJIHJlcXVlc3QgZmFpbGVkIChcIiArIGpxWEhSLnN0YXR1cyArIFwiKTogXCI7XG4gICAgICAgIGNvbnNvbGUubG9nKGpxWEhSKTtcbiAgICAgICAgbXNnICs9IGFqYXhfZXJyb3JfbXNnKGpxWEhSKTtcbiAgICAgICAgY29uc29sZS5sb2cobXNnKTtcbiAgICB9O1xuXG4gICAgdmFyIHJlcXVpcmVDb2RlTWlycm9yTW9kZSA9IGZ1bmN0aW9uIChtb2RlLCBjYWxsYmFjaywgZXJyYmFjaykge1xuICAgICAgICAvKiogXG4gICAgICAgICAqIGZpbmQgYSBwcmVkZWZpbmVkIG1vZGUgb3IgZGV0ZWN0IGZyb20gQ00gbWV0YWRhdGEgdGhlblxuICAgICAgICAgKiByZXF1aXJlIGFuZCBjYWxsYmFjayB3aXRoIHRoZSByZXNvbHZlYWJsZSBtb2RlIHN0cmluZzogbWltZSBvclxuICAgICAgICAgKiBjdXN0b20gbmFtZVxuICAgICAgICAgKi9cblxuICAgICAgICB2YXIgbW9kZW5hbWUgPSAodHlwZW9mIG1vZGUgPT0gXCJzdHJpbmdcIikgPyBtb2RlIDpcbiAgICAgICAgICAgIG1vZGUubW9kZSB8fCBtb2RlLm5hbWU7XG5cbiAgICAgICAgICAgIFxuICAgICAgICAvLyBzaW1wbGVzdCwgY2hlYXBlc3QgY2hlY2sgYnkgbW9kZSBuYW1lOiBtb2RlIG1heSBhbHNvIGhhdmUgY29uZmlnXG4gICAgICAgIGlmIChDb2RlTWlycm9yLm1vZGVzLmhhc093blByb3BlcnR5KG1vZGVuYW1lKSkge1xuICAgICAgICAgICAgLy8gcmV0dXJuIHRoZSBmdWxsIG1vZGUgb2JqZWN0LCBpZiBpdCBoYXMgYSBuYW1lXG4gICAgICAgICAgICBjYWxsYmFjayhtb2RlLm5hbWUgPyBtb2RlIDogbW9kZW5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gKnNvbWVob3cqIGdldCBiYWNrIGEgQ00ubW9kZUluZm8tbGlrZSBvYmplY3QgdGhhdCBoYXMgLm1vZGUgYW5kXG4gICAgICAgIC8vIC5taW1lXG4gICAgICAgIHZhciBpbmZvID0gKG1vZGUgJiYgbW9kZS5tb2RlICYmIG1vZGUubWltZSAmJiBtb2RlKSB8fFxuICAgICAgICAgICAgQ29kZU1pcnJvci5maW5kTW9kZUJ5TmFtZShtb2RlbmFtZSkgfHxcbiAgICAgICAgICAgIENvZGVNaXJyb3IuZmluZE1vZGVCeUV4dGVuc2lvbihtb2RlbmFtZS5zcGxpdChcIi5cIikuc2xpY2UoLTEpKSB8fFxuICAgICAgICAgICAgQ29kZU1pcnJvci5maW5kTW9kZUJ5TUlNRShtb2RlbmFtZSkgfHxcbiAgICAgICAgICAgIHttb2RlOiBtb2RlbmFtZSwgbWltZTogbW9kZW5hbWV9O1xuXG4gICAgICAgIHJlcXVpcmVqcyhbXG4gICAgICAgICAgICAgICAgLy8gbWlnaHQgd2FudCB0byB1c2UgQ29kZU1pcnJvci5tb2RlVVJMIGhlcmVcbiAgICAgICAgICAgICAgICBbJ2NvZGVtaXJyb3IvbW9kZScsIGluZm8ubW9kZSwgaW5mby5tb2RlXS5qb2luKCcvJyksXG4gICAgICAgICAgICBdLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgLy8gcmV0dXJuIHRoZSBvcmlnaW5hbCBtb2RlLCBhcyBmcm9tIGEga2VybmVsc3BlYyBvbiBmaXJzdCBsb2FkXG4gICAgICAgICAgICAgIC8vIG9yIHRoZSBtaW1ldHlwZSwgYXMgZm9yIG1vc3QgaGlnaGxpZ2h0aW5nXG4gICAgICAgICAgICAgIGNhbGxiYWNrKG1vZGUubmFtZSA/IG1vZGUgOiBpbmZvLm1pbWUpO1xuICAgICAgICAgICAgfSwgZXJyYmFja1xuICAgICAgICApO1xuICAgIH07XG5cbiAgICAvKiogRXJyb3IgdHlwZSBmb3Igd3JhcHBlZCBYSFIgZXJyb3JzLiAqL1xuICAgIHZhciBYSFJfRVJST1IgPSAnWGhyRXJyb3InO1xuXG4gICAgLyoqXG4gICAgICogV3JhcHMgYW4gQUpBWCBlcnJvciBhcyBhbiBFcnJvciBvYmplY3QuXG4gICAgICovXG4gICAgdmFyIHdyYXBfYWpheF9lcnJvciA9IGZ1bmN0aW9uIChqcVhIUiwgc3RhdHVzLCBlcnJvcikge1xuICAgICAgICB2YXIgd3JhcHBlZF9lcnJvciA9IG5ldyBFcnJvcihhamF4X2Vycm9yX21zZyhqcVhIUikpO1xuICAgICAgICB3cmFwcGVkX2Vycm9yLm5hbWUgPSAgWEhSX0VSUk9SO1xuICAgICAgICAvLyBwcm92aWRlIHhociByZXNwb25zZVxuICAgICAgICB3cmFwcGVkX2Vycm9yLnhociA9IGpxWEhSO1xuICAgICAgICB3cmFwcGVkX2Vycm9yLnhocl9zdGF0dXMgPSBzdGF0dXM7XG4gICAgICAgIHdyYXBwZWRfZXJyb3IueGhyX2Vycm9yID0gZXJyb3I7XG4gICAgICAgIHJldHVybiB3cmFwcGVkX2Vycm9yO1xuICAgIH07XG5cbiAgICB2YXIgcHJvbWlzaW5nX2FqYXggPSBmdW5jdGlvbih1cmwsIHNldHRpbmdzKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaWtlICQuYWpheCwgYnV0IHJldHVybmluZyBhbiBFUzYgcHJvbWlzZS4gc3VjY2VzcyBhbmQgZXJyb3Igc2V0dGluZ3NcbiAgICAgICAgICogd2lsbCBiZSBpZ25vcmVkLlxuICAgICAgICAgKi9cbiAgICAgICAgc2V0dGluZ3MgPSBzZXR0aW5ncyB8fCB7fTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgc2V0dGluZ3Muc3VjY2VzcyA9IGZ1bmN0aW9uKGRhdGEsIHN0YXR1cywganFYSFIpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKGRhdGEpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHNldHRpbmdzLmVycm9yID0gZnVuY3Rpb24oanFYSFIsIHN0YXR1cywgZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBsb2dfYWpheF9lcnJvcihqcVhIUiwgc3RhdHVzLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgcmVqZWN0KHdyYXBfYWpheF9lcnJvcihqcVhIUiwgc3RhdHVzLCBlcnJvcikpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICQuYWpheCh1cmwsIHNldHRpbmdzKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHZhciBXcmFwcGVkRXJyb3IgPSBmdW5jdGlvbihtZXNzYWdlLCBlcnJvcil7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXcmFwcGFibGUgRXJyb3IgY2xhc3NcbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIEVycm9yIGNsYXNzIGRvZXNuJ3QgYWN0dWFsbHkgYWN0IG9uIGB0aGlzYC4gIEluc3RlYWQgaXQgYWx3YXlzXG4gICAgICAgICAqIHJldHVybnMgYSBuZXcgaW5zdGFuY2Ugb2YgRXJyb3IuICBIZXJlIHdlIGNhcHR1cmUgdGhhdCBpbnN0YW5jZSBzbyB3ZVxuICAgICAgICAgKiBjYW4gYXBwbHkgaXQncyBwcm9wZXJ0aWVzIHRvIGB0aGlzYC5cbiAgICAgICAgICovXG4gICAgICAgIHZhciB0bXAgPSBFcnJvci5hcHBseSh0aGlzLCBbbWVzc2FnZV0pO1xuXG4gICAgICAgIC8vIENvcHkgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGVycm9yIG92ZXIgdG8gdGhpcy5cbiAgICAgICAgdmFyIHByb3BlcnRpZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0bXApO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXNbcHJvcGVydGllc1tpXV0gPSB0bXBbcHJvcGVydGllc1tpXV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBLZWVwIGEgc3RhY2sgb2YgdGhlIG9yaWdpbmFsIGVycm9yIG1lc3NhZ2VzLlxuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBXcmFwcGVkRXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3Jfc3RhY2sgPSBlcnJvci5lcnJvcl9zdGFjaztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3Jfc3RhY2sgPSBbZXJyb3JdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXJyb3Jfc3RhY2sucHVzaCh0bXApO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBXcmFwcGVkRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUsIHt9KTtcblxuXG4gICAgdmFyIGxvYWRfY2xhc3MgPSBmdW5jdGlvbihjbGFzc19uYW1lLCBtb2R1bGVfbmFtZSwgcmVnaXN0cnkpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRyaWVzIHRvIGxvYWQgYSBjbGFzc1xuICAgICAgICAgKlxuICAgICAgICAgKiBUcmllcyB0byBsb2FkIGEgY2xhc3MgZnJvbSBhIG1vZHVsZSB1c2luZyByZXF1aXJlLmpzLCBpZiBhIG1vZHVsZSBcbiAgICAgICAgICogaXMgc3BlY2lmaWVkLCBvdGhlcndpc2UgdHJpZXMgdG8gbG9hZCBhIGNsYXNzIGZyb20gdGhlIGdsb2JhbCBcbiAgICAgICAgICogcmVnaXN0cnksIGlmIHRoZSBnbG9iYWwgcmVnaXN0cnkgaXMgcHJvdmlkZWQuXG4gICAgICAgICAqL1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG5cbiAgICAgICAgICAgIC8vIFRyeSBsb2FkaW5nIHRoZSB2aWV3IG1vZHVsZSB1c2luZyByZXF1aXJlLmpzXG4gICAgICAgICAgICBpZiAobW9kdWxlX25hbWUpIHtcbiAgICAgICAgICAgICAgICByZXF1aXJlanMoW21vZHVsZV9uYW1lXSwgZnVuY3Rpb24obW9kdWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb2R1bGVbY2xhc3NfbmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignQ2xhc3MgJytjbGFzc19uYW1lKycgbm90IGZvdW5kIGluIG1vZHVsZSAnK21vZHVsZV9uYW1lKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG1vZHVsZVtjbGFzc19uYW1lXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCByZWplY3QpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAocmVnaXN0cnkgJiYgcmVnaXN0cnlbY2xhc3NfbmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZWdpc3RyeVtjbGFzc19uYW1lXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignQ2xhc3MgJytjbGFzc19uYW1lKycgbm90IGZvdW5kIGluIHJlZ2lzdHJ5ICcpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICB2YXIgcmVzb2x2ZV9wcm9taXNlc19kaWN0ID0gZnVuY3Rpb24oZCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVzb2x2ZSBhIHByb21pc2VmdWwgZGljdGlvbmFyeS5cbiAgICAgICAgICogUmV0dXJucyBhIHNpbmdsZSBQcm9taXNlLlxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhkKTtcbiAgICAgICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgICAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICB2YWx1ZXMucHVzaChkW2tleV0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHZhbHVlcykudGhlbihmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICBkID0ge307XG4gICAgICAgICAgICBmb3IodmFyIGk9MDsgaTxrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZFtrZXlzW2ldXSA9IHZbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHZhciByZWplY3QgPSBmdW5jdGlvbihtZXNzYWdlLCBsb2cpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSB3cmFwcGFibGUgUHJvbWlzZSByZWplY3Rpb24gZnVuY3Rpb24uXG4gICAgICAgICAqIFxuICAgICAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgUHJvbWlzZS5yZWplY3Qgd2l0aCBhIG5ldyBXcmFwcGVkRXJyb3JcbiAgICAgICAgICogdGhhdCBoYXMgdGhlIHByb3ZpZGVkIG1lc3NhZ2UgYW5kIHdyYXBzIHRoZSBvcmlnaW5hbCBlcnJvciB0aGF0IFxuICAgICAgICAgKiBjYXVzZWQgdGhlIHByb21pc2UgdG8gcmVqZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGVycm9yKSB7IFxuICAgICAgICAgICAgdmFyIHdyYXBwZWRfZXJyb3IgPSBuZXcgV3JhcHBlZEVycm9yKG1lc3NhZ2UsIGVycm9yKTtcbiAgICAgICAgICAgIGlmIChsb2cpIGNvbnNvbGUuZXJyb3Iod3JhcHBlZF9lcnJvcik7IFxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHdyYXBwZWRfZXJyb3IpOyBcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIHR5cGVzZXQgPSBmdW5jdGlvbihlbGVtZW50LCB0ZXh0KSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBcHBseSBNYXRoSmF4IHJlbmRlcmluZyB0byBhbiBlbGVtZW50LCBhbmQgb3B0aW9uYWxseSBzZXQgaXRzIHRleHRcbiAgICAgICAgICpcbiAgICAgICAgICogSWYgTWF0aEpheCBpcyBub3QgYXZhaWxhYmxlLCBtYWtlIG5vIGNoYW5nZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIFJldHVybnMgdGhlIG91dHB1dCBhbnkgbnVtYmVyIG9mIHR5cGVzZXQgZWxlbWVudHMsIG9yIHVuZGVmaW5lZCBpZlxuICAgICAgICAgKiBNYXRoSmF4IHdhcyBub3QgYXZhaWxhYmxlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBQYXJhbWV0ZXJzXG4gICAgICAgICAqIC0tLS0tLS0tLS1cbiAgICAgICAgICogZWxlbWVudDogTm9kZSwgTm9kZUxpc3QsIG9yIGpRdWVyeSBzZWxlY3Rpb25cbiAgICAgICAgICogdGV4dDogb3B0aW9uIHN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgdmFyICRlbCA9IGVsZW1lbnQuanF1ZXJ5ID8gZWxlbWVudCA6ICQoZWxlbWVudCk7XG4gICAgICAgIGlmKGFyZ3VtZW50cy5sZW5ndGggPiAxKXtcbiAgICAgICAgICAgICRlbC50ZXh0KHRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmKCF3aW5kb3cuTWF0aEpheCl7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICRlbC5tYXAoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIC8vIE1hdGhKYXggdGFrZXMgYSBET00gbm9kZTogJC5tYXAgbWFrZXMgYHRoaXNgIHRoZSBjb250ZXh0XG4gICAgICAgICAgICByZXR1cm4gTWF0aEpheC5IdWIuUXVldWUoW1wiVHlwZXNldFwiLCBNYXRoSmF4Lkh1YiwgdGhpc10pO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIHRpbWUgPSB7fTtcbiAgICB0aW1lLm1pbGxpc2Vjb25kcyA9IHt9O1xuICAgIHRpbWUubWlsbGlzZWNvbmRzLnMgPSAxMDAwO1xuICAgIHRpbWUubWlsbGlzZWNvbmRzLm0gPSA2MCAqIHRpbWUubWlsbGlzZWNvbmRzLnM7XG4gICAgdGltZS5taWxsaXNlY29uZHMuaCA9IDYwICogdGltZS5taWxsaXNlY29uZHMubTtcbiAgICB0aW1lLm1pbGxpc2Vjb25kcy5kID0gMjQgKiB0aW1lLm1pbGxpc2Vjb25kcy5oO1xuXG4gICAgdGltZS50aHJlc2hvbGRzID0ge1xuICAgICAgICAvLyBtb21lbnQuanMgdGhyZXNob2xkcyBpbiBtaWxsaXNlY29uZHNcbiAgICAgICAgczogbW9tZW50LnJlbGF0aXZlVGltZVRocmVzaG9sZCgncycpICogdGltZS5taWxsaXNlY29uZHMucyxcbiAgICAgICAgbTogbW9tZW50LnJlbGF0aXZlVGltZVRocmVzaG9sZCgnbScpICogdGltZS5taWxsaXNlY29uZHMubSxcbiAgICAgICAgaDogbW9tZW50LnJlbGF0aXZlVGltZVRocmVzaG9sZCgnaCcpICogdGltZS5taWxsaXNlY29uZHMuaCxcbiAgICAgICAgZDogbW9tZW50LnJlbGF0aXZlVGltZVRocmVzaG9sZCgnZCcpICogdGltZS5taWxsaXNlY29uZHMuZCxcbiAgICB9O1xuXG4gICAgdGltZS50aW1lb3V0X2Zyb21fZHQgPSBmdW5jdGlvbiAoZHQpIHtcbiAgICAgICAgLyoqIGNvbXB1dGUgYSB0aW1lb3V0IGJhc2VkIG9uIGR0XG4gICAgICAgIFxuICAgICAgICBpbnB1dCBhbmQgb3V0cHV0IGJvdGggaW4gbWlsbGlzZWNvbmRzXG4gICAgICAgIFxuICAgICAgICB1c2UgbW9tZW50J3MgcmVsYXRpdmUgdGltZSB0aHJlc2hvbGRzOlxuICAgICAgICBcbiAgICAgICAgLSAxMCBzZWNvbmRzIGlmIGluICdzZWNvbmRzIGFnbycgdGVycml0b3J5XG4gICAgICAgIC0gMSBtaW51dGUgaWYgaW4gJ21pbnV0ZXMgYWdvJ1xuICAgICAgICAtIDEgaG91ciBvdGhlcndpc2VcbiAgICAgICAgKi9cbiAgICAgICAgaWYgKGR0IDwgdGltZS50aHJlc2hvbGRzLnMpIHtcbiAgICAgICAgICAgIHJldHVybiAxMCAqIHRpbWUubWlsbGlzZWNvbmRzLnM7XG4gICAgICAgIH0gZWxzZSBpZiAoZHQgPCB0aW1lLnRocmVzaG9sZHMubSkge1xuICAgICAgICAgICAgcmV0dXJuIHRpbWUubWlsbGlzZWNvbmRzLm07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGltZS5taWxsaXNlY29uZHMuaDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgbG9hZF9leHRlbnNpb246IGxvYWRfZXh0ZW5zaW9uLFxuICAgICAgICBsb2FkX2V4dGVuc2lvbnM6IGxvYWRfZXh0ZW5zaW9ucyxcbiAgICAgICAgbG9hZF9leHRlbnNpb25zX2Zyb21fY29uZmlnOiBsb2FkX2V4dGVuc2lvbnNfZnJvbV9jb25maWcsXG4gICAgICAgIHJlZ2V4X3NwbGl0IDogcmVnZXhfc3BsaXQsXG4gICAgICAgIHV1aWQgOiB1dWlkLFxuICAgICAgICBmaXhDb25zb2xlIDogZml4Q29uc29sZSxcbiAgICAgICAgZml4Q2FycmlhZ2VSZXR1cm4gOiBmaXhDYXJyaWFnZVJldHVybixcbiAgICAgICAgYXV0b0xpbmtVcmxzIDogYXV0b0xpbmtVcmxzLFxuICAgICAgICBwb2ludHNfdG9fcGl4ZWxzIDogcG9pbnRzX3RvX3BpeGVscyxcbiAgICAgICAgZ2V0X2JvZHlfZGF0YSA6IGdldF9ib2R5X2RhdGEsXG4gICAgICAgIHBhcnNlX3VybCA6IHBhcnNlX3VybCxcbiAgICAgICAgdXJsX3BhdGhfc3BsaXQgOiB1cmxfcGF0aF9zcGxpdCxcbiAgICAgICAgdXJsX3BhdGhfam9pbiA6IHVybF9wYXRoX2pvaW4sXG4gICAgICAgIHVybF9qb2luX2VuY29kZSA6IHVybF9qb2luX2VuY29kZSxcbiAgICAgICAgZW5jb2RlX3VyaV9jb21wb25lbnRzIDogZW5jb2RlX3VyaV9jb21wb25lbnRzLFxuICAgICAgICBzcGxpdGV4dCA6IHNwbGl0ZXh0LFxuICAgICAgICBlc2NhcGVfaHRtbCA6IGVzY2FwZV9odG1sLFxuICAgICAgICBhbHdheXNfbmV3IDogYWx3YXlzX25ldyxcbiAgICAgICAgdG9fYWJzb2x1dGVfY3Vyc29yX3BvcyA6IHRvX2Fic29sdXRlX2N1cnNvcl9wb3MsXG4gICAgICAgIGZyb21fYWJzb2x1dGVfY3Vyc29yX3BvcyA6IGZyb21fYWJzb2x1dGVfY3Vyc29yX3BvcyxcbiAgICAgICAgYnJvd3NlciA6IGJyb3dzZXIsXG4gICAgICAgIHBsYXRmb3JtOiBwbGF0Zm9ybSxcbiAgICAgICAgZ2V0X3VybF9wYXJhbTogZ2V0X3VybF9wYXJhbSxcbiAgICAgICAgaXNfb3JfaGFzIDogaXNfb3JfaGFzLFxuICAgICAgICBpc19mb2N1c2VkIDogaXNfZm9jdXNlZCxcbiAgICAgICAgbWVyZ2VvcHQ6IG1lcmdlb3B0LFxuICAgICAgICBhamF4X2Vycm9yX21zZyA6IGFqYXhfZXJyb3JfbXNnLFxuICAgICAgICBsb2dfYWpheF9lcnJvciA6IGxvZ19hamF4X2Vycm9yLFxuICAgICAgICByZXF1aXJlQ29kZU1pcnJvck1vZGUgOiByZXF1aXJlQ29kZU1pcnJvck1vZGUsXG4gICAgICAgIFhIUl9FUlJPUiA6IFhIUl9FUlJPUixcbiAgICAgICAgd3JhcF9hamF4X2Vycm9yIDogd3JhcF9hamF4X2Vycm9yLFxuICAgICAgICBwcm9taXNpbmdfYWpheCA6IHByb21pc2luZ19hamF4LFxuICAgICAgICBXcmFwcGVkRXJyb3I6IFdyYXBwZWRFcnJvcixcbiAgICAgICAgbG9hZF9jbGFzczogbG9hZF9jbGFzcyxcbiAgICAgICAgcmVzb2x2ZV9wcm9taXNlc19kaWN0OiByZXNvbHZlX3Byb21pc2VzX2RpY3QsXG4gICAgICAgIHJlamVjdDogcmVqZWN0LFxuICAgICAgICB0eXBlc2V0OiB0eXBlc2V0LFxuICAgICAgICB0aW1lOiB0aW1lLFxuICAgIH07XG4iLCIvLyBDb3B5cmlnaHQgKGMpIEp1cHl0ZXIgRGV2ZWxvcG1lbnQgVGVhbS5cbi8vIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgTW9kaWZpZWQgQlNEIExpY2Vuc2UuXG5cbi8qKlxuICpcbiAqXG4gKiBAbW9kdWxlIGNlbGxcbiAqIEBuYW1lc3BhY2UgY2VsbFxuICogQGNsYXNzIENlbGxcbiAqL1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgdmFyIHV0aWxzID0gcmVxdWlyZSgnYmFzZS9qcy91dGlscycpO1xuXG4gICAgdmFyIG92ZXJsYXlIYWNrID0gQ29kZU1pcnJvci5zY3JvbGxiYXJNb2RlbC5uYXRpdmUucHJvdG90eXBlLm92ZXJsYXlIYWNrO1xuXG4gICAgQ29kZU1pcnJvci5zY3JvbGxiYXJNb2RlbC5uYXRpdmUucHJvdG90eXBlLm92ZXJsYXlIYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBvdmVybGF5SGFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAvLyBSZXZlcnNlIGBtaW4taGVpZ2h0OiAxOHB4YCBzY3JvbGxiYXIgaGFjayBvbiBPUyBYXG4gICAgICAgIC8vIHdoaWNoIGNhdXNlcyBhIGRlYWQgYXJlYSwgbWFraW5nIGl0IGltcG9zc2libGUgdG8gY2xpY2sgb24gdGhlIGxhc3QgbGluZVxuICAgICAgICAvLyB3aGVuIHRoZXJlIGlzIGhvcml6b250YWwgc2Nyb2xsaW5nIHRvIGRvIGFuZCB0aGUgXCJzaG93IHNjcm9sbGJhciBvbmx5IHdoZW4gc2Nyb2xsaW5nXCIgYmVoYXZpb3JcbiAgICAgICAgLy8gaXMgZW5hYmxlZC5cbiAgICAgICAgLy8gVGhpcywgaW4gdHVybiwgaGFzIHRoZSB1bmRlc2lyYWJsZSBiZWhhdmlvciBvZiBuZXZlciBzaG93aW5nIHRoZSBob3Jpem9udGFsIHNjcm9sbGJhcixcbiAgICAgICAgLy8gZXZlbiB3aGVuIGl0IHNob3VsZCwgd2hpY2ggaXMgbGVzcyBwcm9ibGVtYXRpYywgYXQgbGVhc3QuXG4gICAgICAgIGlmICgvTWFjLy50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSkpIHtcbiAgICAgICAgICAgIHRoaXMuaG9yaXouc3R5bGUubWluSGVpZ2h0ID0gXCJcIjtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgQ2VsbCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIC8qIENvbnN0cnVjdG9yXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBCYXNlIGBDZWxsYCBjbGFzcyBmcm9tIHdoaWNoIHRvIGluaGVyaXQuXG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgKiBAcGFyYW06XG4gICAgICAgICAqICBvcHRpb25zOiBkaWN0aW9uYXJ5XG4gICAgICAgICAqICAgICAgRGljdGlvbmFyeSBvZiBrZXl3b3JkIGFyZ3VtZW50cy5cbiAgICAgICAgICogICAgICAgICAgZXZlbnRzOiAkKEV2ZW50cykgaW5zdGFuY2VcbiAgICAgICAgICogICAgICAgICAgY29uZmlnOiBkaWN0aW9uYXJ5XG4gICAgICAgICAqICAgICAgICAgIGtleWJvYXJkX21hbmFnZXI6IEtleWJvYXJkTWFuYWdlciBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIHRoaXMua2V5Ym9hcmRfbWFuYWdlciA9IG9wdGlvbnMua2V5Ym9hcmRfbWFuYWdlcjtcbiAgICAgICAgdGhpcy5ldmVudHMgPSBvcHRpb25zLmV2ZW50cztcbiAgICAgICAgdmFyIGNvbmZpZyA9IHV0aWxzLm1lcmdlb3B0KENlbGwsIG9wdGlvbnMuY29uZmlnKTtcbiAgICAgICAgLy8gc3VwZXJjbGFzcyBkZWZhdWx0IG92ZXJ3cml0ZSBvdXIgZGVmYXVsdFxuICAgICAgICBcbiAgICAgICAgdGhpcy5wbGFjZWhvbGRlciA9IGNvbmZpZy5wbGFjZWhvbGRlciB8fCAnJztcbiAgICAgICAgdGhpcy5zZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmluX3NlbGVjdGlvbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbl9hbmNob3IgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yZW5kZXJlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm1vZGUgPSAnY29tbWFuZCc7XG5cbiAgICAgICAgLy8gTWV0YWRhdGEgcHJvcGVydHlcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICB0aGlzLl9tZXRhZGF0YSA9IHt9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ21ldGFkYXRhJywge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoYXQuX21ldGFkYXRhOyB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoYXQuX21ldGFkYXRhID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHRoYXQuY2VsbHRvb2xiYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5jZWxsdG9vbGJhci5yZWJ1aWxkKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBiYWNrd2FyZCBjb21wYXQuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnY21fY29uZmlnJywge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJXYXJuaW5nOiBhY2Nlc3NpbmcgQ2VsbC5jbV9jb25maWcgZGlyZWN0bHkgaXMgZGVwcmVjYXRlLlwiKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGF0Ll9vcHRpb25zLmNtX2NvbmZpZztcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGxvYWQgdGhpcyBmcm9tIG1ldGFkYXRhIGxhdGVyID9cbiAgICAgICAgdGhpcy51c2VyX2hpZ2hsaWdodCA9ICdhdXRvJztcblxuXG4gICAgICAgIHZhciBfbG9jYWxfY21fY29uZmlnID0ge307XG4gICAgICAgIGlmKHRoaXMuY2xhc3NfY29uZmlnKXtcbiAgICAgICAgICAgIF9sb2NhbF9jbV9jb25maWcgPSB0aGlzLmNsYXNzX2NvbmZpZy5nZXRfc3luYygnY21fY29uZmlnJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uZmlnLmNtX2NvbmZpZyA9IHV0aWxzLm1lcmdlb3B0KHt9LCBjb25maWcuY21fY29uZmlnLCBfbG9jYWxfY21fY29uZmlnKTtcbiAgICAgICAgdGhpcy5jZWxsX2lkID0gdXRpbHMudXVpZCgpO1xuICAgICAgICB0aGlzLl9vcHRpb25zID0gY29uZmlnO1xuXG4gICAgICAgIC8vIEZvciBKUyBWTSBlbmdpbmVzIG9wdGltaXphdGlvbiwgYXR0cmlidXRlcyBzaG91bGQgYmUgYWxsIHNldCAoZXZlblxuICAgICAgICAvLyB0byBudWxsKSBpbiB0aGUgY29uc3RydWN0b3IsIGFuZCBpZiBwb3NzaWJsZSwgaWYgZGlmZmVyZW50IHN1YmNsYXNzXG4gICAgICAgIC8vIGhhdmUgbmV3IGF0dHJpYnV0ZXMgd2l0aCBzYW1lIG5hbWUsIHRoZXkgc2hvdWxkIGJlIGNyZWF0ZWQgaW4gdGhlXG4gICAgICAgIC8vIHNhbWUgb3JkZXIuIEVhc2llc3QgaXMgdG8gY3JlYXRlIGFuZCBzZXQgdG8gbnVsbCBpbiBwYXJlbnQgY2xhc3MuXG5cbiAgICAgICAgdGhpcy5lbGVtZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5jZWxsX3R5cGUgPSB0aGlzLmNlbGxfdHlwZSB8fCBudWxsO1xuICAgICAgICB0aGlzLmNvZGVfbWlycm9yID0gbnVsbDtcblxuICAgICAgICB0aGlzLmNyZWF0ZV9lbGVtZW50KCk7XG4gICAgICAgIGlmICh0aGlzLmVsZW1lbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5kYXRhKFwiY2VsbFwiLCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuYmluZF9ldmVudHMoKTtcbiAgICAgICAgICAgIHRoaXMuaW5pdF9jbGFzc2VzKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgQ2VsbC5vcHRpb25zX2RlZmF1bHQgPSB7XG4gICAgICAgIGNtX2NvbmZpZyA6IHtcbiAgICAgICAgICAgIGluZGVudFVuaXQgOiA0LFxuICAgICAgICAgICAgcmVhZE9ubHk6IGZhbHNlLFxuICAgICAgICAgICAgdGhlbWU6IFwiZGVmYXVsdFwiLFxuICAgICAgICAgICAgZXh0cmFLZXlzOiB7XG4gICAgICAgICAgICAgICAgXCJDbWQtUmlnaHRcIjpcImdvTGluZVJpZ2h0XCIsXG4gICAgICAgICAgICAgICAgXCJFbmRcIjpcImdvTGluZVJpZ2h0XCIsXG4gICAgICAgICAgICAgICAgXCJDbWQtTGVmdFwiOlwiZ29MaW5lTGVmdFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gRklYTUU6IFdvcmthcm91bmQgQ00gQnVnICMzMzIgKFNhZmFyaSBzZWdmYXVsdCBvbiBkcmFnKVxuICAgIC8vIGJ5IGRpc2FibGluZyBkcmFnL2Ryb3AgYWx0b2dldGhlciBvbiBTYWZhcmlcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY29kZW1pcnJvci9Db2RlTWlycm9yL2lzc3Vlcy8zMzIgICAgXG4gICAgaWYgKHV0aWxzLmJyb3dzZXJbMF0gPT0gXCJTYWZhcmlcIikge1xuICAgICAgICBDZWxsLm9wdGlvbnNfZGVmYXVsdC5jbV9jb25maWcuZHJhZ0Ryb3AgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbXB0eS4gU3ViY2xhc3NlcyBtdXN0IGltcGxlbWVudCBjcmVhdGVfZWxlbWVudC5cbiAgICAgKiBUaGlzIHNob3VsZCBjb250YWluIGFsbCB0aGUgY29kZSB0byBjcmVhdGUgdGhlIERPTSBlbGVtZW50IGluIG5vdGVib29rXG4gICAgICogYW5kIHdpbGwgYmUgY2FsbGVkIGJ5IEJhc2UgQ2xhc3MgY29uc3RydWN0b3IuXG4gICAgICogQG1ldGhvZCBjcmVhdGVfZWxlbWVudFxuICAgICAqL1xuICAgIENlbGwucHJvdG90eXBlLmNyZWF0ZV9lbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIH07XG5cbiAgICBDZWxsLnByb3RvdHlwZS5pbml0X2NsYXNzZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxsIGFmdGVyIHRoaXMuZWxlbWVudCBleGlzdHMgdG8gaW5pdGlhbGl6ZSB0aGUgY3NzIGNsYXNzZXNcbiAgICAgICAgICogcmVsYXRlZCB0byBzZWxlY3RlZCwgcmVuZGVyZWQgYW5kIG1vZGUuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAodGhpcy5pbl9zZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5hZGRDbGFzcygnc2VsZWN0ZWQnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5hZGRDbGFzcygndW5zZWxlY3RlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJlbmRlcmVkKSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuYWRkQ2xhc3MoJ3JlbmRlcmVkJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuYWRkQ2xhc3MoJ3VucmVuZGVyZWQnKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTdWJjbGFzc2VzIGNhbiBpbXBsZW1lbnQgb3ZlcnJpZGUgYmluZF9ldmVudHMuXG4gICAgICogQmUgY2FyZWZ1bGwgdG8gY2FsbCB0aGUgcGFyZW50IG1ldGhvZCB3aGVuIG92ZXJ3cml0aW5nIGFzIGl0IGZpcmVzIGV2ZW50LlxuICAgICAqIHRoaXMgd2lsbCBiZSB0cmlnZ2VyZCBhZnRlciBjcmVhdGVfZWxlbWVudCBpbiBjb25zdHJ1Y3Rvci5cbiAgICAgKiBAbWV0aG9kIGJpbmRfZXZlbnRzXG4gICAgICovXG4gICAgQ2VsbC5wcm90b3R5cGUuYmluZF9ldmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgLy8gV2UgdHJpZ2dlciBldmVudHMgc28gdGhhdCBDZWxsIGRvZXNuJ3QgaGF2ZSB0byBkZXBlbmQgb24gTm90ZWJvb2suXG4gICAgICAgIHRoYXQuZWxlbWVudC5jbGljayhmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGlmICghdGhhdC5zZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgIHRoYXQuZXZlbnRzLnRyaWdnZXIoJ3NlbGVjdC5DZWxsJywgeydjZWxsJzp0aGF0fSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGF0LmVsZW1lbnQuZm9jdXNpbihmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGlmICghdGhhdC5zZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgIHRoYXQuZXZlbnRzLnRyaWdnZXIoJ3NlbGVjdC5DZWxsJywgeydjZWxsJzp0aGF0fSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5jb2RlX21pcnJvcikge1xuICAgICAgICAgICAgdGhpcy5jb2RlX21pcnJvci5vbihcImNoYW5nZVwiLCBmdW5jdGlvbihjbSwgY2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgdGhhdC5ldmVudHMudHJpZ2dlcihcInNldF9kaXJ0eS5Ob3RlYm9va1wiLCB7dmFsdWU6IHRydWV9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNvZGVfbWlycm9yKSB7XG4gICAgICAgICAgICB0aGlzLmNvZGVfbWlycm9yLm9uKCdmb2N1cycsIGZ1bmN0aW9uKGNtLCBjaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICB0aGF0LmV2ZW50cy50cmlnZ2VyKCdlZGl0X21vZGUuQ2VsbCcsIHtjZWxsOiB0aGF0fSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jb2RlX21pcnJvcikge1xuICAgICAgICAgICAgdGhpcy5jb2RlX21pcnJvci5vbignYmx1cicsIGZ1bmN0aW9uKGNtLCBjaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICB0aGF0LmV2ZW50cy50cmlnZ2VyKCdjb21tYW5kX21vZGUuQ2VsbCcsIHtjZWxsOiB0aGF0fSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZWxlbWVudC5kYmxjbGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhhdC5zZWxlY3RlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cy50cmlnZ2VyKCdzZWxlY3QuQ2VsbCcsIHsnY2VsbCc6dGhhdH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNvbnQgPSB0aGF0LnVucmVuZGVyKCk7XG4gICAgICAgICAgICBpZiAoY29udCkge1xuICAgICAgICAgICAgICAgIHRoYXQuZm9jdXNfZWRpdG9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBnZXRzIGNhbGxlZCBpbiBDb2RlTWlycm9yJ3Mgb25LZXlEb3duL29uS2V5UHJlc3NcbiAgICAgKiBoYW5kbGVycyBhbmQgaXMgdXNlZCB0byBwcm92aWRlIGN1c3RvbSBrZXkgaGFuZGxpbmcuXG4gICAgICpcbiAgICAgKiBUbyBoYXZlIGN1c3RvbSBoYW5kbGluZywgc3ViY2xhc3NlcyBzaG91bGQgb3ZlcnJpZGUgdGhpcyBtZXRob2QsIGJ1dCBzdGlsbCBjYWxsIGl0XG4gICAgICogaW4gb3JkZXIgdG8gcHJvY2VzcyB0aGUgRWRpdCBtb2RlIGtleWJvYXJkIHNob3J0Y3V0cy5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgaGFuZGxlX2NvZGVtaXJyb3Jfa2V5ZXZlbnRcbiAgICAgKiBAcGFyYW0ge0NvZGVNaXJyb3J9IGVkaXRvciAtIFRoZSBjb2RlbWlycm9yIGluc3RhbmNlIGJvdW5kIHRvIHRoZSBjZWxsXG4gICAgICogQHBhcmFtIHtldmVudH0gZXZlbnQgLSBrZXkgcHJlc3MgZXZlbnQgd2hpY2ggZWl0aGVyIHNob3VsZCBvciBzaG91bGQgbm90IGJlIGhhbmRsZWQgYnkgQ29kZU1pcnJvclxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiBDb2RlTWlycm9yIHNob3VsZCBpZ25vcmUgdGhlIGV2ZW50LCBgZmFsc2VgIE90aGVyd2lzZVxuICAgICAqL1xuICAgIENlbGwucHJvdG90eXBlLmhhbmRsZV9jb2RlbWlycm9yX2tleWV2ZW50ID0gZnVuY3Rpb24gKGVkaXRvciwgZXZlbnQpIHtcbiAgICAgICAgdmFyIHNob3J0Y3V0cyA9IHRoaXMua2V5Ym9hcmRfbWFuYWdlci5lZGl0X3Nob3J0Y3V0cztcblxuICAgICAgICB2YXIgY3VyID0gZWRpdG9yLmdldEN1cnNvcigpO1xuICAgICAgICBpZigoY3VyLmxpbmUgIT09IDAgfHwgY3VyLmNoICE9PTApICYmIGV2ZW50LmtleUNvZGUgPT09IDM4KXtcbiAgICAgICAgICAgIGV2ZW50Ll9pcGttSWdub3JlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbkxhc3RMaW5lID0gZWRpdG9yLmxhc3RMaW5lKCk7XG4gICAgICAgIGlmICgoZXZlbnQua2V5Q29kZSA9PT0gNDApICYmXG4gICAgICAgICAgICAgKChjdXIubGluZSAhPT0gbkxhc3RMaW5lKSB8fFxuICAgICAgICAgICAgICAgKGN1ci5jaCAhPT0gZWRpdG9yLmdldExpbmVIYW5kbGUobkxhc3RMaW5lKS50ZXh0Lmxlbmd0aCkpXG4gICAgICAgICAgICkge1xuICAgICAgICAgICAgZXZlbnQuX2lwa21JZ25vcmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHRoaXMgaXMgYW4gZWRpdF9zaG9ydGN1dHMgc2hvcnRjdXQsIHRoZSBnbG9iYWwga2V5Ym9hcmQvc2hvcnRjdXRcbiAgICAgICAgLy8gbWFuYWdlciB3aWxsIGhhbmRsZSBpdFxuICAgICAgICBpZiAoc2hvcnRjdXRzLmhhbmRsZXMoZXZlbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cblxuICAgIC8qKlxuICAgICAqIFRyaWdlciB0eXBzZXR0aW5nIG9mIG1hdGggYnkgbWF0aGpheCBvbiBjdXJyZW50IGNlbGwgZWxlbWVudFxuICAgICAqIEBtZXRob2QgdHlwZXNldFxuICAgICAqL1xuICAgIENlbGwucHJvdG90eXBlLnR5cGVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHV0aWxzLnR5cGVzZXQodGhpcy5lbGVtZW50KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogaGFuZGxlIGNlbGwgbGV2ZWwgbG9naWMgd2hlbiBhIGNlbGwgaXMgc2VsZWN0ZWRcbiAgICAgKiBAbWV0aG9kIHNlbGVjdFxuICAgICAqIEByZXR1cm4gaXMgdGhlIGFjdGlvbiBiZWluZyB0YWtlblxuICAgICAqL1xuICAgIENlbGwucHJvdG90eXBlLnNlbGVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuYWRkQ2xhc3MoJ3NlbGVjdGVkJyk7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQucmVtb3ZlQ2xhc3MoJ3Vuc2VsZWN0ZWQnKTtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5pbl9zZWxlY3Rpb24gPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogaGFuZGxlIGNlbGwgbGV2ZWwgbG9naWMgd2hlbiB0aGUgY3Vyc29yIG1vdmVzIGF3YXkgZnJvbSBhIGNlbGxcbiAgICAgKiBAbWV0aG9kIHVuc2VsZWN0XG4gICAgICogQHBhcmFtIHtib29sfSBsZWF2ZV9zZWxlY3RlZCAtIHRydWUgdG8gbW92ZSBjdXJzb3IgYXdheSBhbmQgZXh0ZW5kIHNlbGVjdGlvblxuICAgICAqIEByZXR1cm4gaXMgdGhlIGFjdGlvbiBiZWluZyB0YWtlblxuICAgICAqL1xuICAgIENlbGwucHJvdG90eXBlLnVuc2VsZWN0ID0gZnVuY3Rpb24gKGxlYXZlX3NlbGVjdGVkKSB7XG4gICAgICAgIHZhciB3YXNfc2VsZWN0ZWRfY2VsbCA9IHRoaXMuc2VsZWN0ZWQ7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKCghbGVhdmVfc2VsZWN0ZWQpICYmIHRoaXMuaW5fc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmluX3NlbGVjdGlvbiA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25fYW5jaG9yID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuYWRkQ2xhc3MoJ3Vuc2VsZWN0ZWQnKTtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5yZW1vdmVDbGFzcygnc2VsZWN0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd2FzX3NlbGVjdGVkX2NlbGw7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHNob3VsZCBiZSBvdmVycml0dGVuIGJ5IHN1YmNsYXNzXG4gICAgICogQG1ldGhvZCBleGVjdXRlXG4gICAgICovXG4gICAgQ2VsbC5wcm90b3R5cGUuZXhlY3V0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBoYW5kbGUgY2VsbCBsZXZlbCBsb2dpYyB3aGVuIGEgY2VsbCBpcyByZW5kZXJlZFxuICAgICAqIEBtZXRob2QgcmVuZGVyXG4gICAgICogQHJldHVybiBpcyB0aGUgYWN0aW9uIGJlaW5nIHRha2VuXG4gICAgICovXG4gICAgQ2VsbC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMucmVuZGVyZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5hZGRDbGFzcygncmVuZGVyZWQnKTtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5yZW1vdmVDbGFzcygndW5yZW5kZXJlZCcpO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlZCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBoYW5kbGUgY2VsbCBsZXZlbCBsb2dpYyB3aGVuIGEgY2VsbCBpcyB1bnJlbmRlcmVkXG4gICAgICogQG1ldGhvZCB1bnJlbmRlclxuICAgICAqIEByZXR1cm4gaXMgdGhlIGFjdGlvbiBiZWluZyB0YWtlblxuICAgICAqL1xuICAgIENlbGwucHJvdG90eXBlLnVucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5yZW5kZXJlZCkge1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LmFkZENsYXNzKCd1bnJlbmRlcmVkJyk7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQucmVtb3ZlQ2xhc3MoJ3JlbmRlcmVkJyk7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVkID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZWxlZ2F0ZXMga2V5Ym9hcmQgc2hvcnRjdXQgaGFuZGxpbmcgdG8gZWl0aGVyIEp1cHl0ZXIga2V5Ym9hcmRcbiAgICAgKiBtYW5hZ2VyIHdoZW4gaW4gY29tbWFuZCBtb2RlLCBvciBDb2RlTWlycm9yIHdoZW4gaW4gZWRpdCBtb2RlXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGhhbmRsZV9rZXlldmVudFxuICAgICAqIEBwYXJhbSB7Q29kZU1pcnJvcn0gZWRpdG9yIC0gVGhlIGNvZGVtaXJyb3IgaW5zdGFuY2UgYm91bmQgdG8gdGhlIGNlbGxcbiAgICAgKiBAcGFyYW0ge2V2ZW50fSAtIGtleSBldmVudCB0byBiZSBoYW5kbGVkXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIENvZGVNaXJyb3Igc2hvdWxkIGlnbm9yZSB0aGUgZXZlbnQsIGBmYWxzZWAgT3RoZXJ3aXNlXG4gICAgICovXG4gICAgQ2VsbC5wcm90b3R5cGUuaGFuZGxlX2tleWV2ZW50ID0gZnVuY3Rpb24gKGVkaXRvciwgZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMubW9kZSA9PT0gJ2NvbW1hbmQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm1vZGUgPT09ICdlZGl0Jykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlX2NvZGVtaXJyb3Jfa2V5ZXZlbnQoZWRpdG9yLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQG1ldGhvZCBhdF90b3BcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIENlbGwucHJvdG90eXBlLmF0X3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNtID0gdGhpcy5jb2RlX21pcnJvcjtcbiAgICAgICAgdmFyIGN1cnNvciA9IGNtLmdldEN1cnNvcigpO1xuICAgICAgICBpZiAoY3Vyc29yLmxpbmUgPT09IDAgJiYgY3Vyc29yLmNoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBtZXRob2QgYXRfYm90dG9tXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKiAqL1xuICAgIENlbGwucHJvdG90eXBlLmF0X2JvdHRvbSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNtID0gdGhpcy5jb2RlX21pcnJvcjtcbiAgICAgICAgdmFyIGN1cnNvciA9IGNtLmdldEN1cnNvcigpO1xuICAgICAgICBpZiAoY3Vyc29yLmxpbmUgPT09IChjbS5saW5lQ291bnQoKS0xKSAmJiBjdXJzb3IuY2ggPT09IGNtLmdldExpbmUoY3Vyc29yLmxpbmUpLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBlbnRlciB0aGUgY29tbWFuZCBtb2RlIGZvciB0aGUgY2VsbFxuICAgICAqIEBtZXRob2QgY29tbWFuZF9tb2RlXG4gICAgICogQHJldHVybiBpcyB0aGUgYWN0aW9uIGJlaW5nIHRha2VuXG4gICAgICovXG4gICAgQ2VsbC5wcm90b3R5cGUuY29tbWFuZF9tb2RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5tb2RlICE9PSAnY29tbWFuZCcpIHtcbiAgICAgICAgICAgIHRoaXMubW9kZSA9ICdjb21tYW5kJztcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGVudGVyIHRoZSBlZGl0IG1vZGUgZm9yIHRoZSBjZWxsXG4gICAgICogQG1ldGhvZCBjb21tYW5kX21vZGVcbiAgICAgKiBAcmV0dXJuIGlzIHRoZSBhY3Rpb24gYmVpbmcgdGFrZW5cbiAgICAgKi9cbiAgICBDZWxsLnByb3RvdHlwZS5lZGl0X21vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLm1vZGUgIT09ICdlZGl0Jykge1xuICAgICAgICAgICAgdGhpcy5tb2RlID0gJ2VkaXQnO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgQ2VsbC5wcm90b3R5cGUuZW5zdXJlX2ZvY3VzZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYodGhpcy5lbGVtZW50ICE9PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmICF0aGlzLmNvZGVfbWlycm9yLmhhc0ZvY3VzKCkpe1xuICAgICAgICAgICAgdGhpcy5mb2N1c19jZWxsKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGb2N1cyB0aGUgY2VsbCBpbiB0aGUgRE9NIHNlbnNlXG4gICAgICogQG1ldGhvZCBmb2N1c19jZWxsXG4gICAgICovXG4gICAgQ2VsbC5wcm90b3R5cGUuZm9jdXNfY2VsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50LmZvY3VzKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEZvY3VzIHRoZSBlZGl0b3IgYXJlYSBzbyBhIHVzZXIgY2FuIHR5cGVcbiAgICAgKlxuICAgICAqIE5PVEU6IElmIGNvZGVtaXJyb3IgaXMgZm9jdXNlZCB2aWEgYSBtb3VzZSBjbGljayBldmVudCwgeW91IGRvbid0IHdhbnQgdG9cbiAgICAgKiBjYWxsIHRoaXMgYmVjYXVzZSBpdCB3aWxsIGNhdXNlIGEgcGFnZSBqdW1wLlxuICAgICAqIEBtZXRob2QgZm9jdXNfZWRpdG9yXG4gICAgICovXG4gICAgQ2VsbC5wcm90b3R5cGUuZm9jdXNfZWRpdG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICAgICAgdGhpcy5jb2RlX21pcnJvci5mb2N1cygpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZWZyZXNoIGNvZGVtaXJyb3IgaW5zdGFuY2VcbiAgICAgKiBAbWV0aG9kIHJlZnJlc2hcbiAgICAgKi9cbiAgICBDZWxsLnByb3RvdHlwZS5yZWZyZXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5jb2RlX21pcnJvcikge1xuICAgICAgICAgICAgdGhpcy5jb2RlX21pcnJvci5yZWZyZXNoKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogc2hvdWxkIGJlIG92ZXJyaXR0ZW4gYnkgc3ViY2xhc3NcbiAgICAgKiBAbWV0aG9kIGdldF90ZXh0XG4gICAgICovXG4gICAgQ2VsbC5wcm90b3R5cGUuZ2V0X3RleHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHNob3VsZCBiZSBvdmVycml0dGVuIGJ5IHN1YmNsYXNzXG4gICAgICogQG1ldGhvZCBzZXRfdGV4dFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gICAgICovXG4gICAgQ2VsbC5wcm90b3R5cGUuc2V0X3RleHQgPSBmdW5jdGlvbiAodGV4dCkge1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBzaG91bGQgYmUgb3ZlcnJpdHRlbiBieSBzdWJjbGFzc1xuICAgICAqIHNlcmlhbGlzZSBjZWxsIHRvIGpzb24uXG4gICAgICogQG1ldGhvZCB0b0pTT05cbiAgICAgKiovXG4gICAgQ2VsbC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZGF0YSA9IHt9O1xuICAgICAgICAvLyBkZWVwY29weSB0aGUgbWV0YWRhdGEgc28gY29waWVkIGNlbGxzIGRvbid0IHNoYXJlIHRoZSBzYW1lIG9iamVjdFxuICAgICAgICBkYXRhLm1ldGFkYXRhID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0aGlzLm1ldGFkYXRhKSk7XG4gICAgICAgIGRhdGEuY2VsbF90eXBlID0gdGhpcy5jZWxsX3R5cGU7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBzaG91bGQgYmUgb3ZlcnJpdHRlbiBieSBzdWJjbGFzc1xuICAgICAqIEBtZXRob2QgZnJvbUpTT05cbiAgICAgKiovXG4gICAgQ2VsbC5wcm90b3R5cGUuZnJvbUpTT04gPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBpZiAoZGF0YS5tZXRhZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLm1ldGFkYXRhID0gZGF0YS5tZXRhZGF0YTtcbiAgICAgICAgfVxuICAgIH07XG5cblxuICAgIC8qKlxuICAgICAqIGNhbiB0aGUgY2VsbCBiZSBzcGxpdCBpbnRvIHR3byBjZWxscyAoZmFsc2UgaWYgbm90IGRlbGV0YWJsZSlcbiAgICAgKiBAbWV0aG9kIGlzX3NwbGl0dGFibGVcbiAgICAgKiovXG4gICAgQ2VsbC5wcm90b3R5cGUuaXNfc3BsaXR0YWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNfZGVsZXRhYmxlKCk7XG4gICAgfTtcblxuXG4gICAgLyoqXG4gICAgICogY2FuIHRoZSBjZWxsIGJlIG1lcmdlZCB3aXRoIG90aGVyIGNlbGxzIChmYWxzZSBpZiBub3QgZGVsZXRhYmxlKVxuICAgICAqIEBtZXRob2QgaXNfbWVyZ2VhYmxlXG4gICAgICoqL1xuICAgIENlbGwucHJvdG90eXBlLmlzX21lcmdlYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNfZGVsZXRhYmxlKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGlzIHRoZSBjZWxsIGRlbGV0YWJsZT8gb25seSBmYWxzZSAodW5kZWxldGFibGUpIGlmXG4gICAgICogbWV0YWRhdGEuZGVsZXRhYmxlIGlzIGV4cGxpY2l0bHkgZmFsc2UgLS0gZXZlcnl0aGluZyBlbHNlXG4gICAgICogY291bnRzIGFzIHRydWVcbiAgICAgKlxuICAgICAqIEBtZXRob2QgaXNfZGVsZXRhYmxlXG4gICAgICoqL1xuICAgIENlbGwucHJvdG90eXBlLmlzX2RlbGV0YWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMubWV0YWRhdGEuZGVsZXRhYmxlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IC0gdGhlIHRleHQgYmVmb3JlIHRoZSBjdXJzb3JcbiAgICAgKiBAbWV0aG9kIGdldF9wcmVfY3Vyc29yXG4gICAgICoqL1xuICAgIENlbGwucHJvdG90eXBlLmdldF9wcmVfY3Vyc29yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY3Vyc29yID0gdGhpcy5jb2RlX21pcnJvci5nZXRDdXJzb3IoKTtcbiAgICAgICAgdmFyIHRleHQgPSB0aGlzLmNvZGVfbWlycm9yLmdldFJhbmdlKHtsaW5lOjAsIGNoOjB9LCBjdXJzb3IpO1xuICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC9eXFxuKy8sICcnKS5yZXBsYWNlKC9cXG4rJC8sICcnKTtcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfTtcblxuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7U3RyaW5nfSAtIHRoZSB0ZXh0IGFmdGVyIHRoZSBjdXJzb3JcbiAgICAgKiBAbWV0aG9kIGdldF9wb3N0X2N1cnNvclxuICAgICAqKi9cbiAgICBDZWxsLnByb3RvdHlwZS5nZXRfcG9zdF9jdXJzb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjdXJzb3IgPSB0aGlzLmNvZGVfbWlycm9yLmdldEN1cnNvcigpO1xuICAgICAgICB2YXIgbGFzdF9saW5lX251bSA9IHRoaXMuY29kZV9taXJyb3IubGluZUNvdW50KCktMTtcbiAgICAgICAgdmFyIGxhc3RfbGluZV9sZW4gPSB0aGlzLmNvZGVfbWlycm9yLmdldExpbmUobGFzdF9saW5lX251bSkubGVuZ3RoO1xuICAgICAgICB2YXIgZW5kID0ge2xpbmU6bGFzdF9saW5lX251bSwgY2g6bGFzdF9saW5lX2xlbn07XG4gICAgICAgIHZhciB0ZXh0ID0gdGhpcy5jb2RlX21pcnJvci5nZXRSYW5nZShjdXJzb3IsIGVuZCk7XG4gICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoL15cXG4rLywgJycpLnJlcGxhY2UoL1xcbiskLywgJycpO1xuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2hvdy9IaWRlIENvZGVNaXJyb3IgTGluZU51bWJlclxuICAgICAqIEBtZXRob2Qgc2hvd19saW5lX251bWJlcnNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSB7Qm9vbH0gIHNob3cgKHRydWUpLCBvciBoaWRlIChmYWxzZSkgdGhlIGxpbmUgbnVtYmVyIGluIENvZGVNaXJyb3JcbiAgICAgKiovXG4gICAgQ2VsbC5wcm90b3R5cGUuc2hvd19saW5lX251bWJlcnMgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5jb2RlX21pcnJvci5zZXRPcHRpb24oJ2xpbmVOdW1iZXJzJywgdmFsdWUpO1xuICAgICAgICB0aGlzLmNvZGVfbWlycm9yLnJlZnJlc2goKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVG9nZ2xlICBDb2RlTWlycm9yIExpbmVOdW1iZXJcbiAgICAgKiBAbWV0aG9kIHRvZ2dsZV9saW5lX251bWJlcnNcbiAgICAgKiovXG4gICAgQ2VsbC5wcm90b3R5cGUudG9nZ2xlX2xpbmVfbnVtYmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHZhbCA9IHRoaXMuY29kZV9taXJyb3IuZ2V0T3B0aW9uKCdsaW5lTnVtYmVycycpO1xuICAgICAgICB0aGlzLnNob3dfbGluZV9udW1iZXJzKCF2YWwpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGb3JjZSBjb2RlbWlycm9yIGhpZ2hsaWdodCBtb2RlXG4gICAgICogQG1ldGhvZCBmb3JjZV9oaWdobGlnaHRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gLSBDb2RlTWlycm9yIG1vZGVcbiAgICAgKiovXG4gICAgQ2VsbC5wcm90b3R5cGUuZm9yY2VfaGlnaGxpZ2h0ID0gZnVuY3Rpb24obW9kZSkge1xuICAgICAgICB0aGlzLnVzZXJfaGlnaGxpZ2h0ID0gbW9kZTtcbiAgICAgICAgdGhpcy5hdXRvX2hpZ2hsaWdodCgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyIGF1dG9kZXRlY3Rpb24gb2YgaGlnaGxpZ2h0IHNjaGVtZSBmb3IgY3VycmVudCBjZWxsXG4gICAgICogQG1ldGhvZCBhdXRvX2hpZ2hsaWdodFxuICAgICAqL1xuICAgIENlbGwucHJvdG90eXBlLmF1dG9faGlnaGxpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9hdXRvX2hpZ2hsaWdodCh0aGlzLmNsYXNzX2NvbmZpZy5nZXRfc3luYygnaGlnaGxpZ2h0X21vZGVzJykpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUcnkgdG8gYXV0b2RldGVjdCBjZWxsIGhpZ2hsaWdodCBtb2RlLCBvciB1c2Ugc2VsZWN0ZWQgbW9kZVxuICAgICAqIEBtZXRob2RzIF9hdXRvX2hpZ2hsaWdodFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8b2JqZWN0fHVuZGVmaW5lZH0gLSBDb2RlTWlycm9yIG1vZGUgfCAnYXV0bydcbiAgICAgKiovXG4gICAgQ2VsbC5wcm90b3R5cGUuX2F1dG9faGlnaGxpZ2h0ID0gZnVuY3Rpb24gKG1vZGVzKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKkhlcmUgd2UgaGFuZGxlIG1hbnVhbGx5IHNlbGVjdGVkIG1vZGVzXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIHZhciBtb2RlO1xuICAgICAgICBpZiggdGhpcy51c2VyX2hpZ2hsaWdodCAhPT0gdW5kZWZpbmVkICYmICB0aGlzLnVzZXJfaGlnaGxpZ2h0ICE9ICdhdXRvJyApXG4gICAgICAgIHtcbiAgICAgICAgICAgIG1vZGUgPSB0aGlzLnVzZXJfaGlnaGxpZ2h0O1xuICAgICAgICAgICAgQ29kZU1pcnJvci5hdXRvTG9hZE1vZGUodGhpcy5jb2RlX21pcnJvciwgbW9kZSk7XG4gICAgICAgICAgICB0aGlzLmNvZGVfbWlycm9yLnNldE9wdGlvbignbW9kZScsIG1vZGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjdXJyZW50X21vZGUgPSB0aGlzLmNvZGVfbWlycm9yLmdldE9wdGlvbignbW9kZScsIG1vZGUpO1xuICAgICAgICB2YXIgZmlyc3RfbGluZSA9IHRoaXMuY29kZV9taXJyb3IuZ2V0TGluZSgwKTtcbiAgICAgICAgLy8gbG9vcCBvbiBldmVyeSBwYWlyc1xuICAgICAgICBmb3IobW9kZSBpbiBtb2Rlcykge1xuICAgICAgICAgICAgdmFyIHJlZ3MgPSBtb2Rlc1ttb2RlXS5yZWc7XG4gICAgICAgICAgICAvLyBvbmx5IG9uZSBrZXkgZXZlcnkgdGltZSBidXQgcmVnZXhwIGNhbid0IGJlIGtleXMuLi5cbiAgICAgICAgICAgIGZvcih2YXIgaT0wOyBpPHJlZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAvLyBoZXJlIHdlIGhhbmRsZSBub24gbWFnaWNfbW9kZXMuXG4gICAgICAgICAgICAgICAgLy8gVE9ETyA6XG4gICAgICAgICAgICAgICAgLy8gT24gMy4wIGFuZCBiZWxvdywgdGhlc2UgdGhpbmdzIHdlcmUgcmVnZXguXG4gICAgICAgICAgICAgICAgLy8gQnV0IG5vdyBzaG91bGQgYmUgc3RyaW5nIGZvciBqc29uLWFibGUgY29uZmlnLiBcbiAgICAgICAgICAgICAgICAvLyBXZSBzaG91bGQgZ2V0IHJpZCBvZiBhc3N1bWluZyB0aGV5IG1pZ2h0IGJlIGFscmVhZHkgXG4gICAgICAgICAgICAgICAgLy8gaW4gYSBsYXRlciB2ZXJzaW9uIG9mIEp1cHl0ZXIuXG4gICAgICAgICAgICAgICAgdmFyIHJlID0gcmVnc1tpXTtcbiAgICAgICAgICAgICAgICBpZih0eXBlb2YocmUpID09PSAnc3RyaW5nJyl7XG4gICAgICAgICAgICAgICAgICAgIHJlID0gbmV3IFJlZ0V4cChyZSkgXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmKGZpcnN0X2xpbmUubWF0Y2gocmUpICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKGN1cnJlbnRfbW9kZSA9PSBtb2RlKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobW9kZS5zZWFyY2goJ21hZ2ljXycpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1dGlscy5yZXF1aXJlQ29kZU1pcnJvck1vZGUobW9kZSwgZnVuY3Rpb24gKHNwZWMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmNvZGVfbWlycm9yLnNldE9wdGlvbignbW9kZScsIHNwZWMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wZW4gPSBtb2Rlc1ttb2RlXS5vcGVuIHx8IFwiJSVcIjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNsb3NlID0gbW9kZXNbbW9kZV0uY2xvc2UgfHwgXCIlJWVuZFwiO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWFnaWNfbW9kZSA9IG1vZGU7XG4gICAgICAgICAgICAgICAgICAgIG1vZGUgPSBtYWdpY19tb2RlLnN1YnN0cig2KTtcbiAgICAgICAgICAgICAgICAgICAgaWYoY3VycmVudF9tb2RlID09IG1hZ2ljX21vZGUpe1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHV0aWxzLnJlcXVpcmVDb2RlTWlycm9yTW9kZShtb2RlLCBmdW5jdGlvbiAoc3BlYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY3JlYXRlIG9uIHRoZSBmbHkgYSBtb2RlIHRoYXQgc3dpdGNoIGJldHdlZW5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBsYWluL3RleHQgYW5kIHNvbWV0aGluZyBlbHNlLCBvdGhlcndpc2UgYCUlYCBpc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc291cmNlIG9mIHNvbWUgaGlnaGxpZ2h0IGlzc3Vlcy5cbiAgICAgICAgICAgICAgICAgICAgICAgIENvZGVNaXJyb3IuZGVmaW5lTW9kZShtYWdpY19tb2RlLCBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gQ29kZU1pcnJvci5tdWx0aXBsZXhpbmdNb2RlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDb2RlTWlycm9yLmdldE1vZGUoY29uZmlnLCAndGV4dC9wbGFpbicpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbHdheXMgc2V0IHNvbWV0aGluZyBvbiBjbG9zZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7b3Blbjogb3BlbiwgY2xvc2U6IGNsb3NlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZTogQ29kZU1pcnJvci5nZXRNb2RlKGNvbmZpZywgc3BlYyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxpbVN0eWxlOiBcImRlbGltaXRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5jb2RlX21pcnJvci5zZXRPcHRpb24oJ21vZGUnLCBtYWdpY19tb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gZmFsbGJhY2sgb24gZGVmYXVsdFxuICAgICAgICB2YXIgZGVmYXVsdF9tb2RlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZGVmYXVsdF9tb2RlID0gdGhpcy5fb3B0aW9ucy5jbV9jb25maWcubW9kZTtcbiAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICBkZWZhdWx0X21vZGUgPSAndGV4dC9wbGFpbic7XG4gICAgICAgIH1cbiAgICAgICAgaWYoIGN1cnJlbnRfbW9kZSA9PT0gZGVmYXVsdF9tb2RlKXtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvZGVfbWlycm9yLnNldE9wdGlvbignbW9kZScsIGRlZmF1bHRfbW9kZSk7XG4gICAgfTtcblxuICAgIHZhciBVbnJlY29nbml6ZWRDZWxsID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgLyoqIENvbnN0cnVjdG9yIGZvciB1bnJlY29nbml6ZWQgY2VsbHMgKi9cbiAgICAgICAgQ2VsbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmNlbGxfdHlwZSA9ICd1bnJlY29nbml6ZWQnO1xuICAgICAgICB0aGlzLmNlbGx0b29sYmFyID0gbnVsbDtcbiAgICAgICAgdGhpcy5kYXRhID0ge307XG4gICAgICAgIFxuICAgICAgICBPYmplY3Quc2VhbCh0aGlzKTtcbiAgICB9O1xuXG4gICAgVW5yZWNvZ25pemVkQ2VsbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENlbGwucHJvdG90eXBlKTtcblxuXG4gICAgLy8gY2Fubm90IG1lcmdlIG9yIHNwbGl0IHVucmVjb2duaXplZCBjZWxsc1xuICAgIFVucmVjb2duaXplZENlbGwucHJvdG90eXBlLmlzX21lcmdlYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICBVbnJlY29nbml6ZWRDZWxsLnByb3RvdHlwZS5pc19zcGxpdHRhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIFVucmVjb2duaXplZENlbGwucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGRlZXBjb3B5IHRoZSBtZXRhZGF0YSBzbyBjb3BpZWQgY2VsbHMgZG9uJ3Qgc2hhcmUgdGhlIHNhbWUgb2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0aGlzLmRhdGEpKTtcbiAgICB9O1xuXG4gICAgVW5yZWNvZ25pemVkQ2VsbC5wcm90b3R5cGUuZnJvbUpTT04gPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICBpZiAoZGF0YS5tZXRhZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLm1ldGFkYXRhID0gZGF0YS5tZXRhZGF0YTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRhdGEubWV0YWRhdGEgPSB0aGlzLm1ldGFkYXRhO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWxlbWVudC5maW5kKCcuaW5uZXJfY2VsbCcpLmZpbmQoXCJhXCIpLnRleHQoXCJVbnJlY29nbml6ZWQgY2VsbCB0eXBlOiBcIiArIGRhdGEuY2VsbF90eXBlKTtcbiAgICB9O1xuXG4gICAgVW5yZWNvZ25pemVkQ2VsbC5wcm90b3R5cGUuY3JlYXRlX2VsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIENlbGwucHJvdG90eXBlLmNyZWF0ZV9lbGVtZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHZhciBjZWxsID0gdGhpcy5lbGVtZW50ID0gJChcIjxkaXY+XCIpLmFkZENsYXNzKCdjZWxsIHVucmVjb2duaXplZF9jZWxsJyk7XG4gICAgICAgIGNlbGwuYXR0cigndGFiaW5kZXgnLCcyJyk7XG5cbiAgICAgICAgdmFyIHByb21wdCA9ICQoJzxkaXYvPicpLmFkZENsYXNzKCdwcm9tcHQgaW5wdXRfcHJvbXB0Jyk7XG4gICAgICAgIGNlbGwuYXBwZW5kKHByb21wdCk7XG4gICAgICAgIHZhciBpbm5lcl9jZWxsID0gJCgnPGRpdi8+JykuYWRkQ2xhc3MoJ2lubmVyX2NlbGwnKTtcbiAgICAgICAgaW5uZXJfY2VsbC5hcHBlbmQoXG4gICAgICAgICAgICAkKFwiPGE+XCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJocmVmXCIsIFwiI1wiKVxuICAgICAgICAgICAgICAgIC50ZXh0KFwiVW5yZWNvZ25pemVkIGNlbGwgdHlwZVwiKVxuICAgICAgICApO1xuICAgICAgICBjZWxsLmFwcGVuZChpbm5lcl9jZWxsKTtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gY2VsbDtcbiAgICB9O1xuXG4gICAgVW5yZWNvZ25pemVkQ2VsbC5wcm90b3R5cGUuYmluZF9ldmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIENlbGwucHJvdG90eXBlLmJpbmRfZXZlbnRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHZhciBjZWxsID0gdGhpcztcbiAgICAgICAgXG4gICAgICAgIHRoaXMuZWxlbWVudC5maW5kKCcuaW5uZXJfY2VsbCcpLmZpbmQoXCJhXCIpLmNsaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNlbGwuZXZlbnRzLnRyaWdnZXIoJ3VucmVjb2duaXplZF9jZWxsLkNlbGwnLCB7Y2VsbDogY2VsbH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIENlbGw6IENlbGwsXG4gICAgICAgIFVucmVjb2duaXplZENlbGw6IFVucmVjb2duaXplZENlbGxcbiAgICB9O1xuIiwiLy8gQ29weXJpZ2h0IChjKSBKdXB5dGVyIERldmVsb3BtZW50IFRlYW0uXG4vLyBEaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIE1vZGlmaWVkIEJTRCBMaWNlbnNlLlxuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgdmFyIElQeXRob24gPSByZXF1aXJlKCdiYXNlL2pzL25hbWVzcGFjZScpO1xuICAgIHZhciBldmVudHMgPSByZXF1aXJlKCdiYXNlL2pzL2V2ZW50cycpO1xuXG4gICAgdmFyIENlbGxUb29sYmFyID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnN0cnVjdG9yXG4gICAgICAgICAqXG4gICAgICAgICAqIFBhcmFtZXRlcnM6XG4gICAgICAgICAqICBvcHRpb25zOiBkaWN0aW9uYXJ5XG4gICAgICAgICAqICAgICAgRGljdGlvbmFyeSBvZiBrZXl3b3JkIGFyZ3VtZW50cy5cbiAgICAgICAgICogICAgICAgICAgZXZlbnRzOiAkKEV2ZW50cykgaW5zdGFuY2UgXG4gICAgICAgICAqICAgICAgICAgIGNlbGw6IENlbGwgaW5zdGFuY2VcbiAgICAgICAgICogICAgICAgICAgbm90ZWJvb2s6IE5vdGVib29rIGluc3RhbmNlIFxuICAgICAgICAgKlxuICAgICAgICAgKiAgVE9ETzogVGhpcyBsZWFrcywgd2hlbiBjZWxsIGFyZSBkZWxldGVkXG4gICAgICAgICAqICBUaGVyZSBpcyBzdGlsbCBhIHJlZmVyZW5jZSB0byBlYWNoIGNlbGx0b29sYmFycy5cbiAgICAgICAgICovXG4gICAgICAgIENlbGxUb29sYmFyLl9pbnN0YW5jZXMucHVzaCh0aGlzKTtcbiAgICAgICAgdGhpcy5ub3RlYm9vayA9IG9wdGlvbnMubm90ZWJvb2s7XG4gICAgICAgIHRoaXMuY2VsbCA9IG9wdGlvbnMuY2VsbDtcbiAgICAgICAgdGhpcy5jcmVhdGVfZWxlbWVudCgpO1xuICAgICAgICB0aGlzLnJlYnVpbGQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuXG4gICAgQ2VsbFRvb2xiYXIucHJvdG90eXBlLmNyZWF0ZV9lbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlubmVyX2VsZW1lbnQgPSAkKCc8ZGl2Lz4nKS5hZGRDbGFzcygnY2VsbHRvb2xiYXInKTtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gJCgnPGRpdi8+JykuYWRkQ2xhc3MoJ2N0Yl9oaWRlc2hvdycpXG4gICAgICAgICAgICAuYXBwZW5kKHRoaXMuaW5uZXJfZWxlbWVudCk7XG4gICAgfTtcblxuXG4gICAgLy8gVGhlIGRlZmF1bHQgY3NzIHN0eWxlIGZvciB0aGUgb3V0ZXIgY2VsbHRvb2xiYXIgZGl2XG4gICAgLy8gKGN0Yl9oaWRlc2hvdykgaXMgZGlzcGxheTogbm9uZS5cbiAgICAvLyBUbyBzaG93IHRoZSBjZWxsIHRvb2xiYXIsICpib3RoKiBvZiB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgbXVzdCBiZSBtZXQ6XG4gICAgLy8gLSBBIHBhcmVudCBjb250YWluZXIgaGFzIGNsYXNzIGBjdGJfZ2xvYmFsX3Nob3dgXG4gICAgLy8gLSBUaGUgY2VsbHRvb2xiYXIgaGFzIHRoZSBjbGFzcyBgY3RiX3Nob3dgXG4gICAgLy8gVGhpcyBhbGxvd3MgZ2xvYmFsIHNob3cvaGlkZSwgYXMgd2VsbCBhcyBwZXItY2VsbCBzaG93L2hpZGUuXG5cbiAgICBDZWxsVG9vbGJhci5nbG9iYWxfaGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgJCgnYm9keScpLnJlbW92ZUNsYXNzKCdjdGJfZ2xvYmFsX3Nob3cnKTtcbiAgICB9O1xuXG5cbiAgICBDZWxsVG9vbGJhci5nbG9iYWxfc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgJCgnYm9keScpLmFkZENsYXNzKCdjdGJfZ2xvYmFsX3Nob3cnKTtcbiAgICB9O1xuXG5cbiAgICBDZWxsVG9vbGJhci5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50LnJlbW92ZUNsYXNzKCdjdGJfc2hvdycpO1xuICAgIH07XG5cblxuICAgIENlbGxUb29sYmFyLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmVsZW1lbnQuYWRkQ2xhc3MoJ2N0Yl9zaG93Jyk7XG4gICAgfTtcblxuXG4gICAgLyoqXG4gICAgICogQ2xhc3MgdmFyaWFibGUgdGhhdCBzaG91bGQgY29udGFpbiBhIGRpY3Qgb2YgYWxsIGF2YWlsYWJsZSBjYWxsYmFja1xuICAgICAqIHdlIG5lZWQgdG8gdGhpbmsgb2Ygd2V0aGVyIG9yIG5vdCB3ZSBhbGxvdyBuZXN0ZWQgbmFtZXNwYWNlXG4gICAgICogQHByb3BlcnR5IF9jYWxsYmFja19kaWN0XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHR5cGUgRGljdFxuICAgICAqL1xuICAgIENlbGxUb29sYmFyLl9jYWxsYmFja19kaWN0ID0ge307XG5cblxuICAgIC8qKlxuICAgICAqIENsYXNzIHZhcmlhYmxlIHRoYXQgc2hvdWxkIGNvbnRhaW4gdGhlIHJldmVyc2Ugb3JkZXIgbGlzdCBvZiB0aGUgYnV0dG9uXG4gICAgICogdG8gYWRkIHRvIHRoZSB0b29sYmFyIG9mIGVhY2ggY2VsbFxuICAgICAqIEBwcm9wZXJ0eSBfdWlfY29udHJvbHNfbGlzdFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHN0YXRpY1xuICAgICAqIEB0eXBlIExpc3RcbiAgICAgKi9cbiAgICBDZWxsVG9vbGJhci5fdWlfY29udHJvbHNfbGlzdCA9IFtdO1xuXG5cbiAgICAvKipcbiAgICAgKiBDbGFzcyB2YXJpYWJsZSB0aGF0IHNob3VsZCBjb250YWluIHRoZSBDZWxsVG9vbGJhciBpbnN0YW5jZXMgZm9yIGVhY2hcbiAgICAgKiBjZWxsIG9mIHRoZSBub3RlYm9va1xuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcHJvcGVydHkgX2luc3RhbmNlc1xuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAdHlwZSBMaXN0XG4gICAgICovXG4gICAgQ2VsbFRvb2xiYXIuX2luc3RhbmNlcyA9IFtdO1xuXG5cbiAgICAvKipcbiAgICAgKiBrZWVwIGEgbGlzdCBvZiBhbGwgdGhlIGF2YWlsYWJsZSBwcmVzZXRzIGZvciB0aGUgdG9vbGJhclxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHByb3BlcnR5IF9wcmVzZXRzXG4gICAgICogQHN0YXRpY1xuICAgICAqIEB0eXBlIERpY3RcbiAgICAgKi9cbiAgICBDZWxsVG9vbGJhci5fcHJlc2V0cyA9IHt9O1xuXG5cbiAgICAvLyB0aGlzIGlzIGJ5IGRlc2lnbiBub3QgYSBwcm90b3R5cGUuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgYSBjYWxsYmFjayB0byBjcmVhdGUgYW4gVUkgZWxlbWVudCBpbiBhIGNlbGwgdG9vbGJhci5cbiAgICAgKiBAbWV0aG9kIHJlZ2lzdGVyX2NhbGxiYWNrXG4gICAgICogQHBhcmFtIG5hbWUge1N0cmluZ30gbmFtZSB0byB1c2UgdG8gcmVmZXIgdG8gdGhlIGNhbGxiYWNrLiBJdCBpcyBhZHZpc2VkIHRvIHVzZSBhIHByZWZpeCB3aXRoIHRoZSBuYW1lXG4gICAgICogZm9yIGVhc2llciBzb3J0aW5nIGFuZCBhdm9pZCBjb2xsaXNpb25cbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sge2Z1bmN0aW9uKGRpdiwgY2VsbCl9IGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBjYWxsZWQgdG8gZ2VuZXJhdGUgdGhlIHVpIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gW2NlbGxfdHlwZXNdIHtMaXN0X29mX1N0cmluZ3x1bmRlZmluZWR9IG9wdGlvbmFsIGxpc3Qgb2YgY2VsbCB0eXBlcy4gSWYgcHJlc2VudCB0aGUgVUkgZWxlbWVudFxuICAgICAqIHdpbGwgYmUgYWRkZWQgb25seSB0byBjZWxscyBvZiB0eXBlcyBpbiB0aGUgbGlzdC5cbiAgICAgKlxuICAgICAqXG4gICAgICogVGhlIGNhbGxiYWNrIHdpbGwgcmVjZWl2ZSB0aGUgZm9sbG93aW5nIGVsZW1lbnQgOlxuICAgICAqXG4gICAgICogICAgKiBhIGRpdiBpbiB3aGljaCB0byBhZGQgZWxlbWVudC5cbiAgICAgKiAgICAqIHRoZSBjZWxsIGl0IGlzIHJlc3BvbnNpYmxlIGZyb21cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBFeGFtcGxlIHRoYXQgY3JlYXRlIGNhbGxiYWNrIGZvciBhIGJ1dHRvbiB0aGF0IHRvZ2dsZSBiZXR3ZWVuIGB0cnVlYCBhbmQgYGZhbHNlYCBsYWJlbCxcbiAgICAgKiB3aXRoIHRoZSBtZXRhZGF0YSB1bmRlciB0aGUga2V5ICdmb28nIHRvIHJlZmxlY3QgdGhlIHN0YXR1cyBvZiB0aGUgYnV0dG9uLlxuICAgICAqXG4gICAgICogICAgICAvLyBmaXJzdCBwYXJhbSByZWZlcmVuY2UgdG8gYSBET00gZGl2XG4gICAgICogICAgICAvLyBzZWNvbmQgcGFyYW0gcmVmZXJlbmNlIHRvIHRoZSBjZWxsLlxuICAgICAqICAgICAgdmFyIHRvZ2dsZSA9ICBmdW5jdGlvbihkaXYsIGNlbGwpIHtcbiAgICAgKiAgICAgICAgICB2YXIgYnV0dG9uX2NvbnRhaW5lciA9ICQoZGl2KVxuICAgICAqXG4gICAgICogICAgICAgICAgLy8gbGV0J3MgY3JlYXRlIGEgYnV0dG9uIHRoYXQgc2hvdyB0aGUgIGN1cnJlbnQgdmFsdWUgb2YgdGhlIG1ldGFkYXRhXG4gICAgICogICAgICAgICAgdmFyIGJ1dHRvbiA9ICQoJzxkaXYvPicpLmJ1dHRvbih7bGFiZWw6U3RyaW5nKGNlbGwubWV0YWRhdGEuZm9vKX0pO1xuICAgICAqXG4gICAgICogICAgICAgICAgLy8gT24gY2xpY2ssIGNoYW5nZSB0aGUgbWV0YWRhdGEgdmFsdWUgYW5kIHVwZGF0ZSB0aGUgYnV0dG9uIGxhYmVsXG4gICAgICogICAgICAgICAgYnV0dG9uLmNsaWNrKGZ1bmN0aW9uKCl7XG4gICAgICogICAgICAgICAgICAgICAgICAgICAgdmFyIHYgPSBjZWxsLm1ldGFkYXRhLmZvbztcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICBjZWxsLm1ldGFkYXRhLmZvbyA9ICF2O1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbi5idXR0b24oXCJvcHRpb25cIiwgXCJsYWJlbFwiLCBTdHJpbmcoIXYpKTtcbiAgICAgKiAgICAgICAgICAgICAgICAgIH0pXG4gICAgICpcbiAgICAgKiAgICAgICAgICAvLyBhZGQgdGhlIGJ1dHRvbiB0byB0aGUgRE9NIGRpdi5cbiAgICAgKiAgICAgICAgICBidXR0b25fY29udGFpbmVyLmFwcGVuZChidXR0b24pO1xuICAgICAqICAgICAgfVxuICAgICAqXG4gICAgICogICAgICAvLyBub3cgd2UgcmVnaXN0ZXIgdGhlIGNhbGxiYWNrIHVuZGVyIHRoZSBuYW1lIGBmb29gIHRvIGdpdmUgdGhlXG4gICAgICogICAgICAvLyB1c2VyIHRoZSBhYmlsaXR5IHRvIHVzZSBpdCBsYXRlclxuICAgICAqICAgICAgQ2VsbFRvb2xiYXIucmVnaXN0ZXJfY2FsbGJhY2soJ2ZvbycsIHRvZ2dsZSk7XG4gICAgICovXG4gICAgQ2VsbFRvb2xiYXIucmVnaXN0ZXJfY2FsbGJhY2sgPSBmdW5jdGlvbihuYW1lLCBjYWxsYmFjaywgY2VsbF90eXBlcykge1xuICAgICAgICAvLyBPdmVyd3JpdGUgaWYgaXQgYWxyZWFkeSBleGlzdHMuXG4gICAgICAgIENlbGxUb29sYmFyLl9jYWxsYmFja19kaWN0W25hbWVdID0gY2VsbF90eXBlcyA/IHtjYWxsYmFjazogY2FsbGJhY2ssIGNlbGxfdHlwZXM6IGNlbGxfdHlwZXN9IDogY2FsbGJhY2s7XG4gICAgfTtcblxuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgYSBwcmVzZXQgb2YgVUkgZWxlbWVudCBpbiBhIGNlbGwgdG9vbGJhci5cbiAgICAgKiBOb3Qgc3VwcG9ydGVkIFlldC5cbiAgICAgKiBAbWV0aG9kIHJlZ2lzdGVyX3ByZXNldFxuICAgICAqIEBwYXJhbSBuYW1lIHtTdHJpbmd9IG5hbWUgdG8gdXNlIHRvIHJlZmVyIHRvIHRoZSBwcmVzZXQuIEl0IGlzIGFkdmlzZWQgdG8gdXNlIGEgcHJlZml4IHdpdGggdGhlIG5hbWVcbiAgICAgKiBmb3IgZWFzaWVyIHNvcnRpbmcgYW5kIGF2b2lkIGNvbGxpc2lvblxuICAgICAqIEBwYXJhbSAgcHJlc2V0X2xpc3Qge0xpc3Rfb2ZfU3RyaW5nfSByZXZlcnNlIG9yZGVyIG9mIHRoZSBidXR0b24gaW4gdGhlIHRvb2xiYXIuIEVhY2ggU3RyaW5nIG9mIHRoZSBsaXN0XG4gICAgICogICAgICAgICAgc2hvdWxkIGNvcnJlc3BvbmQgdG8gYSBuYW1lIG9mIGEgcmVnaXN0ZXJkIGNhbGxiYWNrLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogICAgICBDZWxsVG9vbGJhci5yZWdpc3Rlcl9jYWxsYmFjaygnZm9vLmMxJywgZnVuY3Rpb24oZGl2LCBjZWxsKXsuLi59KTtcbiAgICAgKiAgICAgIENlbGxUb29sYmFyLnJlZ2lzdGVyX2NhbGxiYWNrKCdmb28uYzInLCBmdW5jdGlvbihkaXYsIGNlbGwpey4uLn0pO1xuICAgICAqICAgICAgQ2VsbFRvb2xiYXIucmVnaXN0ZXJfY2FsbGJhY2soJ2Zvby5jMycsIGZ1bmN0aW9uKGRpdiwgY2VsbCl7Li4ufSk7XG4gICAgICogICAgICBDZWxsVG9vbGJhci5yZWdpc3Rlcl9jYWxsYmFjaygnZm9vLmM0JywgZnVuY3Rpb24oZGl2LCBjZWxsKXsuLi59KTtcbiAgICAgKiAgICAgIENlbGxUb29sYmFyLnJlZ2lzdGVyX2NhbGxiYWNrKCdmb28uYzUnLCBmdW5jdGlvbihkaXYsIGNlbGwpey4uLn0pO1xuICAgICAqXG4gICAgICogICAgICBDZWxsVG9vbGJhci5yZWdpc3Rlcl9wcmVzZXQoJ2Zvby5mb29fcHJlc2V0MScsIFsnZm9vLmMxJywgJ2Zvby5jMicsICdmb28uYzUnXSlcbiAgICAgKiAgICAgIENlbGxUb29sYmFyLnJlZ2lzdGVyX3ByZXNldCgnZm9vLmZvb19wcmVzZXQyJywgWydmb28uYzQnLCAnZm9vLmM1J10pXG4gICAgICovXG4gICAgQ2VsbFRvb2xiYXIucmVnaXN0ZXJfcHJlc2V0ID0gZnVuY3Rpb24obmFtZSwgcHJlc2V0X2xpc3QsIG5vdGVib29rKSB7XG4gICAgICAgIENlbGxUb29sYmFyLl9wcmVzZXRzW25hbWVdID0gcHJlc2V0X2xpc3Q7XG4gICAgICAgIGV2ZW50cy50cmlnZ2VyKCdwcmVzZXRfYWRkZWQuQ2VsbFRvb2xiYXInLCB7bmFtZTogbmFtZX0pO1xuICAgICAgICAvLyBXaGVuIFwicmVnaXN0ZXJfY2FsbGJhY2tcIiBpcyBjYWxsZWQgYnkgYSBjdXN0b20gZXh0ZW5zaW9uLCBpdCBtYXkgYmUgZXhlY3V0ZWQgYWZ0ZXIgbm90ZWJvb2sgaXMgbG9hZGVkLlxuICAgICAgICAvLyBJbiB0aGF0IGNhc2UsIGFjdGl2YXRlIHRoZSBwcmVzZXQgaWYgbmVlZGVkLlxuICAgICAgICBpZiAobm90ZWJvb2sgJiYgbm90ZWJvb2subWV0YWRhdGEgJiYgbm90ZWJvb2subWV0YWRhdGEuY2VsbHRvb2xiYXIgPT09IG5hbWUpe1xuICAgICAgICAgICAgQ2VsbFRvb2xiYXIuYWN0aXZhdGVfcHJlc2V0KG5hbWUpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHVucmVnaXN0ZXIgdGhlIHNlbGVjdGVkIHByZXNldCwgXG4gICAgICpcbiAgICAgKiByZXR1cm4gdHJ1ZSBpZiBwcmVzZXQgc3VjY2Vzc2Z1bGx5IHVucmVnaXN0ZXJlZFxuICAgICAqIGZhbHNlIG90aGVyd2lzZVxuICAgICAqXG4gICAgICoqL1xuICAgIENlbGxUb29sYmFyLnVucmVnaXN0ZXJfcHJlc2V0ID0gZnVuY3Rpb24obmFtZSl7XG4gICAgICAgIGlmKENlbGxUb29sYmFyLl9wcmVzZXRzW25hbWVdKXtcbiAgICAgICAgICAgIGRlbGV0ZSBDZWxsVG9vbGJhci5fcHJlc2V0c1tuYW1lXTtcbiAgICAgICAgICAgIGV2ZW50cy50cmlnZ2VyKCd1bnJlZ2lzdGVyZWRfcHJlc2V0LkNlbGxUb29sYmFyJywge25hbWU6IG5hbWV9KTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBMaXN0IHRoZSBuYW1lcyBvZiB0aGUgcHJlc2V0cyB0aGF0IGFyZSBjdXJyZW50bHkgcmVnaXN0ZXJlZC5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgbGlzdF9wcmVzZXRzXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIENlbGxUb29sYmFyLmxpc3RfcHJlc2V0cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIga2V5cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBrIGluIENlbGxUb29sYmFyLl9wcmVzZXRzKSB7XG4gICAgICAgICAgICBrZXlzLnB1c2goayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGtleXM7XG4gICAgfTtcblxuXG4gICAgLyoqXG4gICAgICogQWN0aXZhdGUgYW4gVUkgcHJlc2V0IGZyb20gYHJlZ2lzdGVyX3ByZXNldGBcbiAgICAgKlxuICAgICAqIFRoaXMgZG9lcyBub3QgdXBkYXRlIHRoZSBzZWxlY3Rpb24gVUkuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIGFjdGl2YXRlX3ByZXNldFxuICAgICAqIEBwYXJhbSBwcmVzZXRfbmFtZSB7U3RyaW5nfSBzdHJpbmcgY29ycmVzcG9uZGluZyB0byB0aGUgcHJlc2V0IG5hbWVcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIENlbGxUb29sYmFyLmFjdGl2YXRlX3ByZXNldCgnZm9vLmZvb19wcmVzZXQxJyk7XG4gICAgICovXG4gICAgQ2VsbFRvb2xiYXIuYWN0aXZhdGVfcHJlc2V0ID0gZnVuY3Rpb24ocHJlc2V0X25hbWUpe1xuICAgICAgICB2YXIgcHJlc2V0ID0gQ2VsbFRvb2xiYXIuX3ByZXNldHNbcHJlc2V0X25hbWVdO1xuXG4gICAgICAgIGlmKHByZXNldCAhPT0gdW5kZWZpbmVkKXtcbiAgICAgICAgICAgIENlbGxUb29sYmFyLl91aV9jb250cm9sc19saXN0ID0gcHJlc2V0O1xuICAgICAgICAgICAgQ2VsbFRvb2xiYXIucmVidWlsZF9hbGwoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGV2ZW50cy50cmlnZ2VyKCdwcmVzZXRfYWN0aXZhdGVkLkNlbGxUb29sYmFyJywge25hbWU6IHByZXNldF9uYW1lfSk7XG4gICAgfTtcblxuXG4gICAgLyoqXG4gICAgICogVGhpcyBzaG91bGQgYmUgY2FsbGVkIG9uIHRoZSBjbGFzcyBhbmQgbm90IG9uIGEgaW5zdGFuY2UgYXMgaXQgd2lsbCB0cmlnZ2VyXG4gICAgICogcmVidWlsZCBvZiBhbGwgdGhlIGluc3RhbmNlcy5cbiAgICAgKiBAbWV0aG9kIHJlYnVpbGRfYWxsXG4gICAgICogQHN0YXRpY1xuICAgICAqXG4gICAgICovXG4gICAgQ2VsbFRvb2xiYXIucmVidWlsZF9hbGwgPSBmdW5jdGlvbigpe1xuICAgICAgICBmb3IodmFyIGk9MDsgaSA8IENlbGxUb29sYmFyLl9pbnN0YW5jZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgQ2VsbFRvb2xiYXIuX2luc3RhbmNlc1tpXS5yZWJ1aWxkKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVidWlsZCBhbGwgdGhlIGJ1dHRvbiBvbiB0aGUgdG9vbGJhciB0byB1cGRhdGUgaXRzIHN0YXRlLlxuICAgICAqIEBtZXRob2QgcmVidWlsZFxuICAgICAqL1xuICAgIENlbGxUb29sYmFyLnByb3RvdHlwZS5yZWJ1aWxkID0gZnVuY3Rpb24oKXtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHN0cmlwIGV2cnl0aGluZyBmcm9tIHRoZSBkaXZcbiAgICAgICAgICogd2hpY2ggaXMgcHJvYmFibHkgaW5uZXJfZWxlbWVudFxuICAgICAgICAgKiBvciB0aGlzLmVsZW1lbnQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlubmVyX2VsZW1lbnQuZW1wdHkoKTtcbiAgICAgICAgdGhpcy51aV9jb250cm9sc19saXN0ID0gW107XG5cbiAgICAgICAgdmFyIGNhbGxiYWNrcyA9IENlbGxUb29sYmFyLl9jYWxsYmFja19kaWN0O1xuICAgICAgICB2YXIgcHJlc2V0ID0gQ2VsbFRvb2xiYXIuX3VpX2NvbnRyb2xzX2xpc3Q7XG4gICAgICAgIC8vIFllcyB3ZSBpdGVyYXRlIG9uIHRoZSBjbGFzcyB2YXJpYWJsZSwgbm90IHRoZSBpbnN0YW5jZSBvbmUuXG4gICAgICAgIGZvciAodmFyIGk9MDsgaSA8IHByZXNldC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGtleSA9IHByZXNldFtpXTtcbiAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IGNhbGxiYWNrc1trZXldO1xuICAgICAgICAgICAgaWYgKCFjYWxsYmFjaykgY29udGludWU7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrLmNlbGxfdHlwZXMuaW5kZXhPZih0aGlzLmNlbGwuY2VsbF90eXBlKSA9PT0gLTEpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2suY2FsbGJhY2s7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciBsb2NhbF9kaXYgPSAkKCc8ZGl2Lz4nKS5hZGRDbGFzcygnYnV0dG9uX2NvbnRhaW5lcicpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhsb2NhbF9kaXYsIHRoaXMuY2VsbCwgdGhpcyk7XG4gICAgICAgICAgICAgICAgdGhpcy51aV9jb250cm9sc19saXN0LnB1c2goa2V5KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkVycm9yIGluIGNlbGwgdG9vbGJhciBjYWxsYmFjayBcIiArIGtleSwgZSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBvbmx5IGFwcGVuZCBpZiBjYWxsYmFjayBzdWNjZWVkZWQuXG4gICAgICAgICAgICB0aGlzLmlubmVyX2VsZW1lbnQuYXBwZW5kKGxvY2FsX2Rpdik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gY29udHJvbHMgb3IgdGhlIGNlbGwgaXMgYSByZW5kZXJlZCBUZXh0Q2VsbCBoaWRlIHRoZSB0b29sYmFyLlxuICAgICAgICBpZiAoIXRoaXMudWlfY29udHJvbHNfbGlzdC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zaG93KCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG5cbiAgICBDZWxsVG9vbGJhci51dGlscyA9IHt9O1xuXG5cbiAgICAvKipcbiAgICAgKiBBIHV0aWxpdHkgZnVuY3Rpb24gdG8gZ2VuZXJhdGUgYmluZGluZ3MgYmV0d2VlbiBhIGNoZWNrYm94IGFuZCBjZWxsL21ldGFkYXRhXG4gICAgICogQG1ldGhvZCB1dGlscy5jaGVja2JveF91aV9nZW5lcmF0b3JcbiAgICAgKiBAc3RhdGljXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmFtZSB7c3RyaW5nfSBMYWJlbCBpbiBmcm9udCBvZiB0aGUgY2hlY2tib3hcbiAgICAgKiBAcGFyYW0gc2V0dGVyIHtmdW5jdGlvbiggY2VsbCwgbmV3VmFsdWUgKX1cbiAgICAgKiAgICAgICAgQSBzZXR0ZXIgbWV0aG9kIHRvIHNldCB0aGUgbmV3VmFsdWVcbiAgICAgKiBAcGFyYW0gZ2V0dGVyIHtmdW5jdGlvbiggY2VsbCApfVxuICAgICAqICAgICAgICBBIGdldHRlciBtZXRob2RzIHdoaWNoIHJldHVybiB0aGUgY3VycmVudCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gY2FsbGJhY2sge2Z1bmN0aW9uKCBkaXYsIGNlbGwgKX0gQ2FsbGJhY2sgdG8gYmUgcGFzc2VkIHRvIGByZWdpc3Rlcl9jYWxsYmFja2BcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBBbiBleG1wbGUgdGhhdCBiaW5kIHRoZSBzdWJrZXkgYHNsaWRlc2hvdy5pc1NlY3Rpb25TdGFydGAgdG8gYSBjaGVja2JveCB3aXRoIGEgYE5ldyBTbGlkZWAgbGFiZWxcbiAgICAgKlxuICAgICAqICAgICB2YXIgbmV3U2xpZGUgPSBDZWxsVG9vbGJhci51dGlscy5jaGVja2JveF91aV9nZW5lcmF0b3IoJ05ldyBTbGlkZScsXG4gICAgICogICAgICAgICAgLy8gc2V0dGVyXG4gICAgICogICAgICAgICAgZnVuY3Rpb24oY2VsbCwgdmFsdWUpe1xuICAgICAqICAgICAgICAgICAgICAvLyB3ZSBjaGVjayB0aGF0IHRoZSBzbGlkZXNob3cgbmFtZXNwYWNlIGV4aXN0IGFuZCBjcmVhdGUgaXQgaWYgbmVlZGVkXG4gICAgICogICAgICAgICAgICAgIGlmIChjZWxsLm1ldGFkYXRhLnNsaWRlc2hvdyA9PSB1bmRlZmluZWQpe2NlbGwubWV0YWRhdGEuc2xpZGVzaG93ID0ge319XG4gICAgICogICAgICAgICAgICAgIC8vIHNldCB0aGUgdmFsdWVcbiAgICAgKiAgICAgICAgICAgICAgY2VsbC5tZXRhZGF0YS5zbGlkZXNob3cuaXNTZWN0aW9uU3RhcnQgPSB2YWx1ZVxuICAgICAqICAgICAgICAgICAgICB9LFxuICAgICAqICAgICAgICAgIC8vZ2V0ZXJcbiAgICAgKiAgICAgICAgICBmdW5jdGlvbihjZWxsKXsgdmFyIG5zID0gY2VsbC5tZXRhZGF0YS5zbGlkZXNob3c7XG4gICAgICogICAgICAgICAgICAgIC8vIGlmIHRoZSBzbGlkZXNob3cgbmFtZXNwYWNlIGRvZXMgbm90IGV4aXN0IHJldHVybiBgdW5kZWZpbmVkYFxuICAgICAqICAgICAgICAgICAgICAvLyAod2lsbCBiZSBpbnRlcnByZXRlZCBhcyBgZmFsc2VgIGJ5IGNoZWNrYm94KSBvdGhlcndpc2VcbiAgICAgKiAgICAgICAgICAgICAgLy8gcmV0dXJuIHRoZSB2YWx1ZVxuICAgICAqICAgICAgICAgICAgICByZXR1cm4gKG5zID09IHVuZGVmaW5lZCk/IHVuZGVmaW5lZDogbnMuaXNTZWN0aW9uU3RhcnRcbiAgICAgKiAgICAgICAgICAgICAgfVxuICAgICAqICAgICAgKTtcbiAgICAgKlxuICAgICAqICAgICAgQ2VsbFRvb2xiYXIucmVnaXN0ZXJfY2FsbGJhY2soJ25ld1NsaWRlJywgbmV3U2xpZGUpO1xuICAgICAqXG4gICAgICovXG4gICAgQ2VsbFRvb2xiYXIudXRpbHMuY2hlY2tib3hfdWlfZ2VuZXJhdG9yID0gZnVuY3Rpb24obmFtZSwgc2V0dGVyLCBnZXR0ZXIpe1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oZGl2LCBjZWxsLCBjZWxsdG9vbGJhcikge1xuICAgICAgICAgICAgdmFyIGJ1dHRvbl9jb250YWluZXIgPSAkKGRpdik7XG5cbiAgICAgICAgICAgIHZhciBjaGtiID0gJCgnPGlucHV0Lz4nKS5hdHRyKCd0eXBlJywgJ2NoZWNrYm94Jyk7XG4gICAgICAgICAgICB2YXIgbGJsID0gJCgnPGxhYmVsLz4nKS5hcHBlbmQoJCgnPHNwYW4vPicpLnRleHQobmFtZSkpO1xuICAgICAgICAgICAgbGJsLmFwcGVuZChjaGtiKTtcbiAgICAgICAgICAgIGNoa2IuYXR0cihcImNoZWNrZWRcIiwgZ2V0dGVyKGNlbGwpKTtcblxuICAgICAgICAgICAgY2hrYi5jbGljayhmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHYgPSBnZXR0ZXIoY2VsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0ZXIoY2VsbCwgIXYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hrYi5hdHRyKFwiY2hlY2tlZFwiLCAhdik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJ1dHRvbl9jb250YWluZXIuYXBwZW5kKCQoJzxzcGFuLz4nKS5hcHBlbmQobGJsKSk7XG4gICAgICAgIH07XG4gICAgfTtcblxuXG4gICAgLyoqXG4gICAgICogQSB1dGlsaXR5IGZ1bmN0aW9uIHRvIGdlbmVyYXRlIGJpbmRpbmdzIGJldHdlZW4gYSBpbnB1dCBmaWVsZCBhbmQgY2VsbC9tZXRhZGF0YVxuICAgICAqIEBtZXRob2QgdXRpbHMuaW5wdXRfdWlfZ2VuZXJhdG9yXG4gICAgICogQHN0YXRpY1xuICAgICAqXG4gICAgICogQHBhcmFtIG5hbWUge3N0cmluZ30gTGFiZWwgaW4gZnJvbnQgb2YgdGhlIGlucHV0IGZpZWxkXG4gICAgICogQHBhcmFtIHNldHRlciB7ZnVuY3Rpb24oIGNlbGwsIG5ld1ZhbHVlICl9XG4gICAgICogICAgICAgIEEgc2V0dGVyIG1ldGhvZCB0byBzZXQgdGhlIG5ld1ZhbHVlXG4gICAgICogQHBhcmFtIGdldHRlciB7ZnVuY3Rpb24oIGNlbGwgKX1cbiAgICAgKiAgICAgICAgQSBnZXR0ZXIgbWV0aG9kcyB3aGljaCByZXR1cm4gdGhlIGN1cnJlbnQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIGNhbGxiYWNrIHtmdW5jdGlvbiggZGl2LCBjZWxsICl9IENhbGxiYWNrIHRvIGJlIHBhc3NlZCB0byBgcmVnaXN0ZXJfY2FsbGJhY2tgXG4gICAgICpcbiAgICAgKi9cbiAgICBDZWxsVG9vbGJhci51dGlscy5pbnB1dF91aV9nZW5lcmF0b3IgPSBmdW5jdGlvbihuYW1lLCBzZXR0ZXIsIGdldHRlcil7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihkaXYsIGNlbGwsIGNlbGx0b29sYmFyKSB7XG4gICAgICAgICAgICB2YXIgYnV0dG9uX2NvbnRhaW5lciA9ICQoZGl2KTtcblxuICAgICAgICAgICAgdmFyIHRleHQgPSAkKCc8aW5wdXQvPicpLmF0dHIoJ3R5cGUnLCAndGV4dCcpO1xuICAgICAgICAgICAgdmFyIGxibCA9ICQoJzxsYWJlbC8+JykuYXBwZW5kKCQoJzxzcGFuLz4nKS50ZXh0KG5hbWUpKTtcbiAgICAgICAgICAgIGxibC5hcHBlbmQodGV4dCk7XG4gICAgICAgICAgICB0ZXh0LmF0dHIoXCJ2YWx1ZVwiLCBnZXR0ZXIoY2VsbCkpO1xuXG4gICAgICAgICAgICB0ZXh0LmtleXVwKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgc2V0dGVyKGNlbGwsIHRleHQudmFsKCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBidXR0b25fY29udGFpbmVyLmFwcGVuZCgkKCc8c3Bhbi8+JykuYXBwZW5kKGxibCkpO1xuICAgICAgICAgICAgSVB5dGhvbi5rZXlib2FyZF9tYW5hZ2VyLnJlZ2lzdGVyX2V2ZW50cyh0ZXh0KTtcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQSB1dGlsaXR5IGZ1bmN0aW9uIHRvIGdlbmVyYXRlIGJpbmRpbmdzIGJldHdlZW4gYSBkcm9wZG93biBsaXN0IGNlbGxcbiAgICAgKiBAbWV0aG9kIHV0aWxzLnNlbGVjdF91aV9nZW5lcmF0b3JcbiAgICAgKiBAc3RhdGljXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGlzdF9saXN0IHtsaXN0X29mX3N1Ymxpc3R9IExpc3Qgb2Ygc3VibGlzdCBvZiBtZXRhZGF0YSB2YWx1ZSBhbmQgbmFtZSBpbiB0aGUgZHJvcGRvd24gbGlzdC5cbiAgICAgKiAgICAgICAgc3Vic2xpdCBzaG91ZCBjb250YWluIDIgZWxlbWVudCBlYWNoLCBmaXJzdCBhIHN0cmluZyB0aGF0IHdvdWwgYmUgZGlzcGxheWVkIGluIHRoZSBkcm9wZG93biBsaXN0LFxuICAgICAqICAgICAgICBhbmQgc2Vjb25kIHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlIHRvICBiZSBwYXNzZWQgdG8gc2V0dGVyL3JldHVybiBieSBnZXR0ZXIuIHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlIFxuICAgICAqICAgICAgICBzaG91bGQgbm90IGJlIFwidW5kZWZpbmVkXCIgb3IgYmVoYXZpb3IgY2FuIGJlIHVuZXhwZWN0ZWQuXG4gICAgICogQHBhcmFtIHNldHRlciB7ZnVuY3Rpb24oIGNlbGwsIG5ld1ZhbHVlICl9XG4gICAgICogICAgICAgIEEgc2V0dGVyIG1ldGhvZCB0byBzZXQgdGhlIG5ld1ZhbHVlXG4gICAgICogQHBhcmFtIGdldHRlciB7ZnVuY3Rpb24oIGNlbGwgKX1cbiAgICAgKiAgICAgICAgQSBnZXR0ZXIgbWV0aG9kcyB3aGljaCByZXR1cm4gdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIG1ldGFkYXRhLlxuICAgICAqIEBwYXJhbSBbbGFiZWw9XCJcIl0ge1N0cmluZ30gb3B0aW9ubmFsIGxhYmVsIGZvciB0aGUgZHJvcGRvd24gbWVudVxuICAgICAqXG4gICAgICogQHJldHVybiBjYWxsYmFjayB7ZnVuY3Rpb24oIGRpdiwgY2VsbCApfSBDYWxsYmFjayB0byBiZSBwYXNzZWQgdG8gYHJlZ2lzdGVyX2NhbGxiYWNrYFxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqICAgICAgdmFyIHNlbGVjdF90eXBlID0gQ2VsbFRvb2xiYXIudXRpbHMuc2VsZWN0X3VpX2dlbmVyYXRvcihbXG4gICAgICogICAgICAgICAgICAgIFtcIjxOb25lPlwiICAgICAgICwgXCJOb25lXCIgICAgICBdLFxuICAgICAqICAgICAgICAgICAgICBbXCJIZWFkZXIgU2xpZGVcIiAsIFwiaGVhZGVyX3NsaWRlXCIgXSxcbiAgICAgKiAgICAgICAgICAgICAgW1wiU2xpZGVcIiAgICAgICAgLCBcInNsaWRlXCIgICAgICAgIF0sXG4gICAgICogICAgICAgICAgICAgIFtcIkZyYWdtZW50XCIgICAgICwgXCJmcmFnbWVudFwiICAgICBdLFxuICAgICAqICAgICAgICAgICAgICBbXCJTa2lwXCIgICAgICAgICAsIFwic2tpcFwiICAgICAgICAgXSxcbiAgICAgKiAgICAgICAgICAgICAgXSxcbiAgICAgKiAgICAgICAgICAgICAgLy8gc2V0dGVyXG4gICAgICogICAgICAgICAgICAgIGZ1bmN0aW9uKGNlbGwsIHZhbHVlKXtcbiAgICAgKiAgICAgICAgICAgICAgICAgIC8vIHdlIGNoZWNrIHRoYXQgdGhlIHNsaWRlc2hvdyBuYW1lc3BhY2UgZXhpc3QgYW5kIGNyZWF0ZSBpdCBpZiBuZWVkZWRcbiAgICAgKiAgICAgICAgICAgICAgICAgIGlmIChjZWxsLm1ldGFkYXRhLnNsaWRlc2hvdyA9PSB1bmRlZmluZWQpe2NlbGwubWV0YWRhdGEuc2xpZGVzaG93ID0ge319XG4gICAgICogICAgICAgICAgICAgICAgICAvLyBzZXQgdGhlIHZhbHVlXG4gICAgICogICAgICAgICAgICAgICAgICBjZWxsLm1ldGFkYXRhLnNsaWRlc2hvdy5zbGlkZV90eXBlID0gdmFsdWVcbiAgICAgKiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICogICAgICAgICAgICAgIC8vZ2V0ZXJcbiAgICAgKiAgICAgICAgICAgICAgZnVuY3Rpb24oY2VsbCl7IHZhciBucyA9IGNlbGwubWV0YWRhdGEuc2xpZGVzaG93O1xuICAgICAqICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIHNsaWRlc2hvdyBuYW1lc3BhY2UgZG9lcyBub3QgZXhpc3QgcmV0dXJuIGB1bmRlZmluZWRgXG4gICAgICogICAgICAgICAgICAgICAgICAvLyAod2lsbCBiZSBpbnRlcnByZXRlZCBhcyBgZmFsc2VgIGJ5IGNoZWNrYm94KSBvdGhlcndpc2VcbiAgICAgKiAgICAgICAgICAgICAgICAgIC8vIHJldHVybiB0aGUgdmFsdWVcbiAgICAgKiAgICAgICAgICAgICAgICAgIHJldHVybiAobnMgPT0gdW5kZWZpbmVkKT8gdW5kZWZpbmVkOiBucy5zbGlkZV90eXBlXG4gICAgICogICAgICAgICAgICAgICAgICB9XG4gICAgICogICAgICBDZWxsVG9vbGJhci5yZWdpc3Rlcl9jYWxsYmFjaygnc2xpZGVzaG93LnNlbGVjdCcsIHNlbGVjdF90eXBlKTtcbiAgICAgKlxuICAgICAqL1xuICAgIENlbGxUb29sYmFyLnV0aWxzLnNlbGVjdF91aV9nZW5lcmF0b3IgPSBmdW5jdGlvbihsaXN0X2xpc3QsIHNldHRlciwgZ2V0dGVyLCBsYWJlbCkge1xuICAgICAgICBsYWJlbCA9IGxhYmVsIHx8IFwiXCI7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihkaXYsIGNlbGwsIGNlbGx0b29sYmFyKSB7XG4gICAgICAgICAgICB2YXIgYnV0dG9uX2NvbnRhaW5lciA9ICQoZGl2KTtcbiAgICAgICAgICAgIHZhciBsYmwgPSAkKFwiPGxhYmVsLz5cIikuYXBwZW5kKCQoJzxzcGFuLz4nKS50ZXh0KGxhYmVsKSk7XG4gICAgICAgICAgICB2YXIgc2VsZWN0ID0gJCgnPHNlbGVjdC8+Jyk7XG4gICAgICAgICAgICBmb3IodmFyIGk9MDsgaSA8IGxpc3RfbGlzdC5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICAgICAgdmFyIG9wdCA9ICQoJzxvcHRpb24vPicpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd2YWx1ZScsIGxpc3RfbGlzdFtpXVsxXSlcbiAgICAgICAgICAgICAgICAgICAgLnRleHQobGlzdF9saXN0W2ldWzBdKTtcbiAgICAgICAgICAgICAgICBzZWxlY3QuYXBwZW5kKG9wdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxlY3QudmFsKGdldHRlcihjZWxsKSk7XG4gICAgICAgICAgICBzZWxlY3QuY2hhbmdlKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0ZXIoY2VsbCwgc2VsZWN0LnZhbCgpKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBidXR0b25fY29udGFpbmVyLmFwcGVuZCgkKCc8c3Bhbi8+JykuYXBwZW5kKGxibCkuYXBwZW5kKHNlbGVjdCkpO1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICAvLyBCYWNrd2FyZHMgY29tcGF0YWJpbGl0eS5cbiAgICBJUHl0aG9uLkNlbGxUb29sYmFyID0gQ2VsbFRvb2xiYXI7XG5cbiAgICBleHBvcnRzLkNlbGxUb29sYmFyID0gQ2VsbFRvb2xiYXI7XG4iLCIvLyBDb3B5cmlnaHQgKGMpIEp1cHl0ZXIgRGV2ZWxvcG1lbnQgVGVhbS5cbi8vIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgTW9kaWZpZWQgQlNEIExpY2Vuc2UuXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICB2YXIgY2VsbHRvb2xiYXIgPSByZXF1aXJlKCdub3RlYm9vay9qcy9jZWxsdG9vbGJhcicpO1xuICAgIHZhciBkaWFsb2cgPSByZXF1aXJlKCdiYXNlL2pzL2RpYWxvZycpO1xuXG4gICAgdmFyIENlbGxUb29sYmFyID0gY2VsbHRvb2xiYXIuQ2VsbFRvb2xiYXI7XG5cbiAgICB2YXIgcmF3X2VkaXQgPSBmdW5jdGlvbiAoY2VsbCkge1xuICAgICAgICBkaWFsb2cuZWRpdF9tZXRhZGF0YSh7XG4gICAgICAgICAgICBtZDogY2VsbC5tZXRhZGF0YSxcbiAgICAgICAgICAgIGNhbGxiYWNrOiBmdW5jdGlvbiAobWQpIHtcbiAgICAgICAgICAgICAgICBjZWxsLm1ldGFkYXRhID0gbWQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbmFtZTogJ0NlbGwnLFxuICAgICAgICAgICAgbm90ZWJvb2s6IHRoaXMubm90ZWJvb2ssXG4gICAgICAgICAgICBrZXlib2FyZF9tYW5hZ2VyOiB0aGlzLmtleWJvYXJkX21hbmFnZXJcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHZhciBhZGRfcmF3X2VkaXRfYnV0dG9uID0gZnVuY3Rpb24oZGl2LCBjZWxsKSB7XG4gICAgICAgIHZhciBidXR0b25fY29udGFpbmVyID0gJChkaXYpO1xuICAgICAgICB2YXIgYnV0dG9uID0gJCgnPGJ1dHRvbi8+JylcbiAgICAgICAgICAgIC5hZGRDbGFzcyhcImJ0biBidG4tZGVmYXVsdCBidG4teHNcIilcbiAgICAgICAgICAgIC50ZXh0KFwiRWRpdCBNZXRhZGF0YVwiKVxuICAgICAgICAgICAgLmNsaWNrKCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmF3X2VkaXQoY2VsbCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIGJ1dHRvbl9jb250YWluZXIuYXBwZW5kKGJ1dHRvbik7XG4gICAgfTtcblxuICAgIHZhciByZWdpc3RlciA9IGZ1bmN0aW9uIChub3RlYm9vaykge1xuICAgICAgICBDZWxsVG9vbGJhci5yZWdpc3Rlcl9jYWxsYmFjaygnZGVmYXVsdC5yYXdlZGl0JywgYWRkX3Jhd19lZGl0X2J1dHRvbik7XG4gICAgICAgIHJhd19lZGl0ID0gJC5wcm94eShyYXdfZWRpdCwge1xuICAgICAgICAgICAgbm90ZWJvb2s6IG5vdGVib29rLFxuICAgICAgICAgICAga2V5Ym9hcmRfbWFuYWdlcjogbm90ZWJvb2sua2V5Ym9hcmRfbWFuYWdlclxuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgZXhhbXBsZV9wcmVzZXQgPSBbXTtcbiAgICAgICAgZXhhbXBsZV9wcmVzZXQucHVzaCgnZGVmYXVsdC5yYXdlZGl0Jyk7XG5cbiAgICAgICAgQ2VsbFRvb2xiYXIucmVnaXN0ZXJfcHJlc2V0KCdFZGl0IE1ldGFkYXRhJywgZXhhbXBsZV9wcmVzZXQsIG5vdGVib29rKTtcbiAgICAgICAgY29uc29sZS5sb2coJ0RlZmF1bHQgZXh0ZW5zaW9uIGZvciBjZWxsIG1ldGFkYXRhIGVkaXRpbmcgbG9hZGVkLicpO1xuICAgIH07XG4gICAgZXhwb3J0cy5yZWdpc3RlciA9IHJlZ2lzdGVyO1xuIiwiLy8gQ29weXJpZ2h0IChjKSBKdXB5dGVyIERldmVsb3BtZW50IFRlYW0uXG4vLyBEaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIE1vZGlmaWVkIEJTRCBMaWNlbnNlLlxuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgdmFyIGNlbGx0b29sYmFyID0gcmVxdWlyZSgnbm90ZWJvb2svanMvY2VsbHRvb2xiYXInKTtcbiAgICB2YXIgZGlhbG9nID0gcmVxdWlyZSgnYmFzZS9qcy9kaWFsb2cnKTtcbiAgICB2YXIga2V5Ym9hcmQgPSByZXF1aXJlKCdiYXNlL2pzL2tleWJvYXJkJyk7XG5cbiAgICB2YXIgQ2VsbFRvb2xiYXIgPSBjZWxsdG9vbGJhci5DZWxsVG9vbGJhcjtcbiAgICB2YXIgcmF3X2NlbGxfcHJlc2V0ID0gW107XG5cbiAgICB2YXIgc2VsZWN0X3R5cGUgPSBDZWxsVG9vbGJhci51dGlscy5zZWxlY3RfdWlfZ2VuZXJhdG9yKFtcbiAgICBbXCJOb25lXCIsIFwiLVwiXSxcbiAgICBbXCJMYVRlWFwiLCBcInRleHQvbGF0ZXhcIl0sXG4gICAgW1wicmVTVFwiLCBcInRleHQvcmVzdHJ1Y3R1cmVkdGV4dFwiXSxcbiAgICBbXCJIVE1MXCIsIFwidGV4dC9odG1sXCJdLFxuICAgIFtcIk1hcmtkb3duXCIsIFwidGV4dC9tYXJrZG93blwiXSxcbiAgICBbXCJQeXRob25cIiwgXCJ0ZXh0L3gtcHl0aG9uXCJdLFxuICAgIFtcIkN1c3RvbVwiLCBcImRpYWxvZ1wiXSxcblxuICAgIF0sXG4gICAgICAvLyBzZXR0ZXJcbiAgICAgIGZ1bmN0aW9uKGNlbGwsIHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gXCItXCIpIHtcbiAgICAgICAgICBkZWxldGUgY2VsbC5tZXRhZGF0YS5yYXdfbWltZXR5cGU7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09ICdkaWFsb2cnKXtcbiAgICAgICAgICAgIHZhciBkaWFsb2cgPSAkKCc8ZGl2Lz4nKS5hcHBlbmQoXG4gICAgICAgICAgICAgICAgJChcIjxwLz5cIilcbiAgICAgICAgICAgICAgICAgICAgLnRleHQoXCJTZXQgdGhlIE1JTUUgdHlwZSBvZiB0aGUgcmF3IGNlbGw6XCIpXG4gICAgICAgICAgICApLmFwcGVuZChcbiAgICAgICAgICAgICAgICAkKFwiPGJyLz5cIilcbiAgICAgICAgICAgICkuYXBwZW5kKFxuICAgICAgICAgICAgICAgICQoJzxpbnB1dC8+JykuYXR0cigndHlwZScsJ3RleHQnKS5hdHRyKCdzaXplJywnMjUnKVxuICAgICAgICAgICAgICAgIC52YWwoY2VsbC5tZXRhZGF0YS5yYXdfbWltZXR5cGUgfHwgXCItXCIpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZGlhbG9nLm1vZGFsKHtcbiAgICAgICAgICAgICAgICB0aXRsZTogXCJSYXcgQ2VsbCBNSU1FIFR5cGVcIixcbiAgICAgICAgICAgICAgICBib2R5OiBkaWFsb2csXG4gICAgICAgICAgICAgICAgYnV0dG9ucyA6IHtcbiAgICAgICAgICAgICAgICAgICAgXCJDYW5jZWxcIjoge30sXG4gICAgICAgICAgICAgICAgICAgIFwiT0tcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M6IFwiYnRuLXByaW1hcnlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsaWNrOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coY2VsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbC5tZXRhZGF0YS5yYXdfbWltZXR5cGUgPSAkKHRoaXMpLmZpbmQoJ2lucHV0JykudmFsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coY2VsbC5tZXRhZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9wZW4gOiBmdW5jdGlvbiAoZXZlbnQsIHVpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0aGF0ID0gJCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVXBvbiBFTlRFUiwgY2xpY2sgdGhlIE9LIGJ1dHRvbi5cbiAgICAgICAgICAgICAgICAgICAgdGhhdC5maW5kKCdpbnB1dFt0eXBlPVwidGV4dFwiXScpLmtleWRvd24oZnVuY3Rpb24gKGV2ZW50LCB1aSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50LndoaWNoID09PSBrZXlib2FyZC5rZXljb2Rlcy5lbnRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuZmluZCgnLmJ0bi1wcmltYXJ5JykuZmlyc3QoKS5jbGljaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQuZmluZCgnaW5wdXRbdHlwZT1cInRleHRcIl0nKS5mb2N1cygpLnNlbGVjdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNlbGwubWV0YWRhdGEucmF3X21pbWV0eXBlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvL2dldHRlclxuICAgICAgZnVuY3Rpb24oY2VsbCkge1xuICAgICAgICByZXR1cm4gY2VsbC5tZXRhZGF0YS5yYXdfbWltZXR5cGUgfHwgXCJcIjtcbiAgICAgIH0sXG4gICAgICAvLyBuYW1lXG4gICAgICBcIlJhdyBOQkNvbnZlcnQgRm9ybWF0XCJcbiAgICApO1xuXG4gICAgdmFyIHJlZ2lzdGVyID0gZnVuY3Rpb24gKG5vdGVib29rKSB7XG4gICAgQ2VsbFRvb2xiYXIucmVnaXN0ZXJfY2FsbGJhY2soJ3Jhd19jZWxsLnNlbGVjdCcsIHNlbGVjdF90eXBlLCBbJ3JhdyddKTtcbiAgICByYXdfY2VsbF9wcmVzZXQucHVzaCgncmF3X2NlbGwuc2VsZWN0Jyk7XG5cbiAgICBDZWxsVG9vbGJhci5yZWdpc3Rlcl9wcmVzZXQoJ1JhdyBDZWxsIEZvcm1hdCcsIHJhd19jZWxsX3ByZXNldCwgbm90ZWJvb2spO1xuICAgIGNvbnNvbGUubG9nKCdSYXcgQ2VsbCBGb3JtYXQgdG9vbGJhciBwcmVzZXQgbG9hZGVkLicpO1xuICAgIH07XG4gICAgZXhwb3J0cy5yZWdpc3RlciA9IHJlZ2lzdGVyO1xuIiwiLy8gQ29weXJpZ2h0IChjKSBKdXB5dGVyIERldmVsb3BtZW50IFRlYW0uXG4vLyBEaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIE1vZGlmaWVkIEJTRCBMaWNlbnNlLlxuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgdmFyIGNlbGx0b29sYmFyID0gcmVxdWlyZSgnbm90ZWJvb2svanMvY2VsbHRvb2xiYXInKTtcblxuICAgIHZhciBDZWxsVG9vbGJhciA9IGNlbGx0b29sYmFyLkNlbGxUb29sYmFyO1xuICAgIHZhciBzbGlkZXNob3dfcHJlc2V0ID0gW107XG5cbiAgICB2YXIgc2VsZWN0X3R5cGUgPSBDZWxsVG9vbGJhci51dGlscy5zZWxlY3RfdWlfZ2VuZXJhdG9yKFtcbiAgICAgICAgICAgIFtcIi1cIiAgICAgICAgICAgICxcIi1cIiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbXCJTbGlkZVwiICAgICAgICAsXCJzbGlkZVwiICAgICAgICBdLFxuICAgICAgICAgICAgW1wiU3ViLVNsaWRlXCIgICAgLFwic3Vic2xpZGVcIiAgICAgXSxcbiAgICAgICAgICAgIFtcIkZyYWdtZW50XCIgICAgICxcImZyYWdtZW50XCIgICAgIF0sXG4gICAgICAgICAgICBbXCJTa2lwXCIgICAgICAgICAsXCJza2lwXCIgICAgICAgICBdLFxuICAgICAgICAgICAgW1wiTm90ZXNcIiAgICAgICAgLFwibm90ZXNcIiAgICAgICAgXSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAvLyBzZXR0ZXJcbiAgICAgICAgICAgIGZ1bmN0aW9uKGNlbGwsIHZhbHVlKXtcbiAgICAgICAgICAgICAgICAvLyB3ZSBjaGVjayB0aGF0IHRoZSBzbGlkZXNob3cgbmFtZXNwYWNlIGV4aXN0IGFuZCBjcmVhdGUgaXQgaWYgbmVlZGVkXG4gICAgICAgICAgICAgICAgaWYgKGNlbGwubWV0YWRhdGEuc2xpZGVzaG93ID09PSB1bmRlZmluZWQpe2NlbGwubWV0YWRhdGEuc2xpZGVzaG93ID0ge307fVxuICAgICAgICAgICAgICAgIC8vIHNldCB0aGUgdmFsdWVcbiAgICAgICAgICAgICAgICBjZWxsLm1ldGFkYXRhLnNsaWRlc2hvdy5zbGlkZV90eXBlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vZ2V0ZXJcbiAgICAgICAgICAgIGZ1bmN0aW9uKGNlbGwpeyB2YXIgbnMgPSBjZWxsLm1ldGFkYXRhLnNsaWRlc2hvdztcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgc2xpZGVzaG93IG5hbWVzcGFjZSBkb2VzIG5vdCBleGlzdCByZXR1cm4gYHVuZGVmaW5lZGBcbiAgICAgICAgICAgICAgICAvLyAod2lsbCBiZSBpbnRlcnByZXRlZCBhcyBgZmFsc2VgIGJ5IGNoZWNrYm94KSBvdGhlcndpc2VcbiAgICAgICAgICAgICAgICAvLyByZXR1cm4gdGhlIHZhbHVlXG4gICAgICAgICAgICAgICAgcmV0dXJuIChucyA9PT0gdW5kZWZpbmVkKT8gdW5kZWZpbmVkOiBucy5zbGlkZV90eXBlO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcIlNsaWRlIFR5cGVcIik7XG5cbiAgICB2YXIgcmVnaXN0ZXIgPSBmdW5jdGlvbiAobm90ZWJvb2spIHtcbiAgICAgICAgQ2VsbFRvb2xiYXIucmVnaXN0ZXJfY2FsbGJhY2soJ3NsaWRlc2hvdy5zZWxlY3QnLHNlbGVjdF90eXBlKTtcbiAgICAgICAgc2xpZGVzaG93X3ByZXNldC5wdXNoKCdzbGlkZXNob3cuc2VsZWN0Jyk7XG5cbiAgICAgICAgQ2VsbFRvb2xiYXIucmVnaXN0ZXJfcHJlc2V0KCdTbGlkZXNob3cnLHNsaWRlc2hvd19wcmVzZXQsIG5vdGVib29rKTtcbiAgICAgICAgY29uc29sZS5sb2coJ1NsaWRlc2hvdyBleHRlbnNpb24gZm9yIG1ldGFkYXRhIGVkaXRpbmcgbG9hZGVkLicpO1xuICAgIH07XG4gICAgZXhwb3J0cy5yZWdpc3RlciA9IHJlZ2lzdGVyO1xuIiwiLy8gQ29weXJpZ2h0IChjKSBKdXB5dGVyIERldmVsb3BtZW50IFRlYW0uXG4vLyBEaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIE1vZGlmaWVkIEJTRCBMaWNlbnNlLlxuLyoqXG4gKlxuICpcbiAqIEBtb2R1bGUgY29kZWNlbGxcbiAqIEBuYW1lc3BhY2UgY29kZWNlbGxcbiAqIEBjbGFzcyBDb2RlQ2VsbFxuICovXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICB2YXIgSVB5dGhvbiA9IHJlcXVpcmUoJ2Jhc2UvanMvbmFtZXNwYWNlJyk7XG4gICAgdmFyIHV0aWxzID0gcmVxdWlyZSgnYmFzZS9qcy91dGlscycpO1xuICAgIHZhciBrZXlib2FyZCA9IHJlcXVpcmUoJ2Jhc2UvanMva2V5Ym9hcmQnKTtcbiAgICB2YXIgY29uZmlnbW9kID0gcmVxdWlyZSgnc2VydmljZXMvY29uZmlnJyk7XG4gICAgdmFyIGNlbGwgPSByZXF1aXJlKCdub3RlYm9vay9qcy9jZWxsJyk7XG4gICAgdmFyIG91dHB1dGFyZWEgPSByZXF1aXJlKCdub3RlYm9vay9qcy9vdXRwdXRhcmVhJyk7XG4gICAgdmFyIGNvbXBsZXRlciA9IHJlcXVpcmUoJ25vdGVib29rL2pzL2NvbXBsZXRlcicpO1xuICAgIHZhciBjZWxsdG9vbGJhciA9IHJlcXVpcmUoJ25vdGVib29rL2pzL2NlbGx0b29sYmFyJyk7XG5cbiAgICB2YXIgQ2VsbCA9IGNlbGwuQ2VsbDtcblxuICAgIC8qIGxvY2FsIHV0aWwgZm9yIGNvZGVtaXJyb3IgKi9cbiAgICB2YXIgcG9zRXEgPSBmdW5jdGlvbihhLCBiKSB7cmV0dXJuIGEubGluZSA9PT0gYi5saW5lICYmIGEuY2ggPT09IGIuY2g7fTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogZnVuY3Rpb24gdG8gZGVsZXRlIHVudGlsIHByZXZpb3VzIG5vbiBibGFua2luZyBzcGFjZSBjaGFyYWN0ZXJcbiAgICAgKiBvciBmaXJzdCBtdWx0aXBsZSBvZiA0IHRhYnN0b3AuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBDb2RlTWlycm9yLmNvbW1hbmRzLmRlbFNwYWNlVG9QcmV2VGFiU3RvcCA9IGZ1bmN0aW9uKGNtKXtcbiAgICAgICAgdmFyIGZyb20gPSBjbS5nZXRDdXJzb3IodHJ1ZSksIHRvID0gY20uZ2V0Q3Vyc29yKGZhbHNlKSwgc2VsID0gIXBvc0VxKGZyb20sIHRvKTtcbiAgICAgICAgaWYgKCFwb3NFcShmcm9tLCB0bykpIHsgY20ucmVwbGFjZVJhbmdlKFwiXCIsIGZyb20sIHRvKTsgcmV0dXJuOyB9XG4gICAgICAgIHZhciBjdXIgPSBjbS5nZXRDdXJzb3IoKSwgbGluZSA9IGNtLmdldExpbmUoY3VyLmxpbmUpO1xuICAgICAgICB2YXIgdGFic2l6ZSA9IGNtLmdldE9wdGlvbigndGFiU2l6ZScpO1xuICAgICAgICB2YXIgY2hUb1ByZXZUYWJTdG9wID0gY3VyLmNoLShNYXRoLmNlaWwoY3VyLmNoL3RhYnNpemUpLTEpKnRhYnNpemU7XG4gICAgICAgIGZyb20gPSB7Y2g6Y3VyLmNoLWNoVG9QcmV2VGFiU3RvcCxsaW5lOmN1ci5saW5lfTtcbiAgICAgICAgdmFyIHNlbGVjdCA9IGNtLmdldFJhbmdlKGZyb20sY3VyKTtcbiAgICAgICAgaWYoIHNlbGVjdC5tYXRjaCgvXlxcICskLykgIT09IG51bGwpe1xuICAgICAgICAgICAgY20ucmVwbGFjZVJhbmdlKFwiXCIsZnJvbSxjdXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY20uZGVsZXRlSCgtMSxcImNoYXJcIik7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGtleWNvZGVzID0ga2V5Ym9hcmQua2V5Y29kZXM7XG5cbiAgICB2YXIgQ29kZUNlbGwgPSBmdW5jdGlvbiAoa2VybmVsLCBvcHRpb25zKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAgICAgKlxuICAgICAgICAgKiBBIENlbGwgY29uY2VpdmVkIHRvIHdyaXRlIGNvZGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIFBhcmFtZXRlcnM6XG4gICAgICAgICAqICBrZXJuZWw6IEtlcm5lbCBpbnN0YW5jZVxuICAgICAgICAgKiAgICAgIFRoZSBrZXJuZWwgZG9lc24ndCBoYXZlIHRvIGJlIHNldCBhdCBjcmVhdGlvbiB0aW1lLCBpbiB0aGF0IGNhc2VcbiAgICAgICAgICogICAgICBpdCB3aWxsIGJlIG51bGwgYW5kIHNldF9rZXJuZWwgaGFzIHRvIGJlIGNhbGxlZCBsYXRlci5cbiAgICAgICAgICogIG9wdGlvbnM6IGRpY3Rpb25hcnlcbiAgICAgICAgICogICAgICBEaWN0aW9uYXJ5IG9mIGtleXdvcmQgYXJndW1lbnRzLlxuICAgICAgICAgKiAgICAgICAgICBldmVudHM6ICQoRXZlbnRzKSBpbnN0YW5jZSBcbiAgICAgICAgICogICAgICAgICAgY29uZmlnOiBkaWN0aW9uYXJ5XG4gICAgICAgICAqICAgICAgICAgIGtleWJvYXJkX21hbmFnZXI6IEtleWJvYXJkTWFuYWdlciBpbnN0YW5jZSBcbiAgICAgICAgICogICAgICAgICAgbm90ZWJvb2s6IE5vdGVib29rIGluc3RhbmNlXG4gICAgICAgICAqICAgICAgICAgIHRvb2x0aXA6IFRvb2x0aXAgaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMua2VybmVsID0ga2VybmVsIHx8IG51bGw7XG4gICAgICAgIHRoaXMubm90ZWJvb2sgPSBvcHRpb25zLm5vdGVib29rO1xuICAgICAgICB0aGlzLmNvbGxhcHNlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmV2ZW50cyA9IG9wdGlvbnMuZXZlbnRzO1xuICAgICAgICB0aGlzLnRvb2x0aXAgPSBvcHRpb25zLnRvb2x0aXA7XG4gICAgICAgIHRoaXMuY29uZmlnID0gb3B0aW9ucy5jb25maWc7XG4gICAgICAgIHRoaXMuY2xhc3NfY29uZmlnID0gbmV3IGNvbmZpZ21vZC5Db25maWdXaXRoRGVmYXVsdHModGhpcy5jb25maWcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ29kZUNlbGwuY29uZmlnX2RlZmF1bHRzLCAnQ29kZUNlbGwnKTtcblxuICAgICAgICAvLyBjcmVhdGUgYWxsIGF0dHJpYnV0ZWQgaW4gY29uc3RydWN0b3IgZnVuY3Rpb25cbiAgICAgICAgLy8gZXZlbiBpZiBudWxsIGZvciBWOCBWTSBvcHRpbWlzYXRpb25cbiAgICAgICAgdGhpcy5pbnB1dF9wcm9tcHRfbnVtYmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5jZWxsdG9vbGJhciA9IG51bGw7XG4gICAgICAgIHRoaXMub3V0cHV0X2FyZWEgPSBudWxsO1xuXG4gICAgICAgIHRoaXMubGFzdF9tc2dfaWQgPSBudWxsO1xuICAgICAgICB0aGlzLmNvbXBsZXRlciA9IG51bGw7XG5cbiAgICAgICAgQ2VsbC5hcHBseSh0aGlzLFt7XG4gICAgICAgICAgICBjb25maWc6ICQuZXh0ZW5kKHt9LCBDb2RlQ2VsbC5vcHRpb25zX2RlZmF1bHQpLCBcbiAgICAgICAgICAgIGtleWJvYXJkX21hbmFnZXI6IG9wdGlvbnMua2V5Ym9hcmRfbWFuYWdlciwgXG4gICAgICAgICAgICBldmVudHM6IHRoaXMuZXZlbnRzfV0pO1xuXG4gICAgICAgIC8vIEF0dHJpYnV0ZXMgd2Ugd2FudCB0byBvdmVycmlkZSBpbiB0aGlzIHN1YmNsYXNzLlxuICAgICAgICB0aGlzLmNlbGxfdHlwZSA9IFwiY29kZVwiO1xuICAgICAgICB2YXIgdGhhdCAgPSB0aGlzO1xuICAgICAgICB0aGlzLmVsZW1lbnQuZm9jdXNvdXQoXG4gICAgICAgICAgICBmdW5jdGlvbigpIHsgdGhhdC5hdXRvX2hpZ2hsaWdodCgpOyB9XG4gICAgICAgICk7XG4gICAgfTtcblxuICAgIENvZGVDZWxsLm9wdGlvbnNfZGVmYXVsdCA9IHtcbiAgICAgICAgY21fY29uZmlnIDoge1xuICAgICAgICAgICAgZXh0cmFLZXlzOiB7XG4gICAgICAgICAgICAgICAgXCJUYWJcIiA6ICBcImluZGVudE1vcmVcIixcbiAgICAgICAgICAgICAgICBcIlNoaWZ0LVRhYlwiIDogXCJpbmRlbnRMZXNzXCIsXG4gICAgICAgICAgICAgICAgXCJCYWNrc3BhY2VcIiA6IFwiZGVsU3BhY2VUb1ByZXZUYWJTdG9wXCIsXG4gICAgICAgICAgICAgICAgXCJDbWQtL1wiIDogXCJ0b2dnbGVDb21tZW50XCIsXG4gICAgICAgICAgICAgICAgXCJDdHJsLS9cIiA6IFwidG9nZ2xlQ29tbWVudFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbW9kZTogJ3RleHQnLFxuICAgICAgICAgICAgdGhlbWU6ICdpcHl0aG9uJyxcbiAgICAgICAgICAgIG1hdGNoQnJhY2tldHM6IHRydWUsXG4gICAgICAgICAgICBhdXRvQ2xvc2VCcmFja2V0czogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBoaWdobGlnaHRfbW9kZXMgOiB7XG4gICAgICAgICAgICAnbWFnaWNfamF2YXNjcmlwdCcgICAgOnsncmVnJzpbJ14lJWphdmFzY3JpcHQnXX0sXG4gICAgICAgICAgICAnbWFnaWNfcGVybCcgICAgICAgICAgOnsncmVnJzpbJ14lJXBlcmwnXX0sXG4gICAgICAgICAgICAnbWFnaWNfcnVieScgICAgICAgICAgOnsncmVnJzpbJ14lJXJ1YnknXX0sXG4gICAgICAgICAgICAnbWFnaWNfcHl0aG9uJyAgICAgICAgOnsncmVnJzpbJ14lJXB5dGhvbjM/J119LFxuICAgICAgICAgICAgJ21hZ2ljX3NoZWxsJyAgICAgICAgIDp7J3JlZyc6WydeJSViYXNoJ119LFxuICAgICAgICAgICAgJ21hZ2ljX3InICAgICAgICAgICAgIDp7J3JlZyc6WydeJSVSJ119LFxuICAgICAgICAgICAgJ21hZ2ljX3RleHQveC1jeXRob24nIDp7J3JlZyc6WydeJSVjeXRob24nXX0sXG4gICAgICAgIH0sXG4gICAgfTtcblxuICAgIENvZGVDZWxsLmNvbmZpZ19kZWZhdWx0cyA9IENvZGVDZWxsLm9wdGlvbnNfZGVmYXVsdDtcblxuICAgIENvZGVDZWxsLm1zZ19jZWxscyA9IHt9O1xuXG4gICAgQ29kZUNlbGwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDZWxsLnByb3RvdHlwZSk7XG5cbiAgICAvKiogQG1ldGhvZCBjcmVhdGVfZWxlbWVudCAqL1xuICAgIENvZGVDZWxsLnByb3RvdHlwZS5jcmVhdGVfZWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgQ2VsbC5wcm90b3R5cGUuY3JlYXRlX2VsZW1lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgIHZhciBjZWxsID0gICQoJzxkaXY+PC9kaXY+JykuYWRkQ2xhc3MoJ2NlbGwgY29kZV9jZWxsJyk7XG4gICAgICAgIGNlbGwuYXR0cigndGFiaW5kZXgnLCcyJyk7XG5cbiAgICAgICAgdmFyIGlucHV0ID0gJCgnPGRpdj48L2Rpdj4nKS5hZGRDbGFzcygnaW5wdXQnKTtcbiAgICAgICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgICAgICB2YXIgcHJvbXB0ID0gJCgnPGRpdi8+JykuYWRkQ2xhc3MoJ3Byb21wdCBpbnB1dF9wcm9tcHQnKTtcbiAgICAgICAgdmFyIGlubmVyX2NlbGwgPSAkKCc8ZGl2Lz4nKS5hZGRDbGFzcygnaW5uZXJfY2VsbCcpO1xuICAgICAgICB0aGlzLmNlbGx0b29sYmFyID0gbmV3IGNlbGx0b29sYmFyLkNlbGxUb29sYmFyKHtcbiAgICAgICAgICAgIGNlbGw6IHRoaXMsIFxuICAgICAgICAgICAgbm90ZWJvb2s6IHRoaXMubm90ZWJvb2t9KTtcbiAgICAgICAgaW5uZXJfY2VsbC5hcHBlbmQodGhpcy5jZWxsdG9vbGJhci5lbGVtZW50KTtcbiAgICAgICAgdmFyIGlucHV0X2FyZWEgPSAkKCc8ZGl2Lz4nKS5hZGRDbGFzcygnaW5wdXRfYXJlYScpO1xuICAgICAgICB0aGlzLmNvZGVfbWlycm9yID0gbmV3IENvZGVNaXJyb3IoaW5wdXRfYXJlYS5nZXQoMCksIHRoaXMuX29wdGlvbnMuY21fY29uZmlnKTtcbiAgICAgICAgLy8gSW4gY2FzZSBvZiBidWdzIHRoYXQgcHV0IHRoZSBrZXlib2FyZCBtYW5hZ2VyIGludG8gYW4gaW5jb25zaXN0ZW50IHN0YXRlLFxuICAgICAgICAvLyBlbnN1cmUgS00gaXMgZW5hYmxlZCB3aGVuIENvZGVNaXJyb3IgaXMgZm9jdXNlZDpcbiAgICAgICAgdGhpcy5jb2RlX21pcnJvci5vbignZm9jdXMnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhhdC5rZXlib2FyZF9tYW5hZ2VyKSB7XG4gICAgICAgICAgICAgICAgdGhhdC5rZXlib2FyZF9tYW5hZ2VyLmVuYWJsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb2RlX21pcnJvci5vbigna2V5ZG93bicsICQucHJveHkodGhpcy5oYW5kbGVfa2V5ZXZlbnQsdGhpcykpO1xuICAgICAgICAkKHRoaXMuY29kZV9taXJyb3IuZ2V0SW5wdXRGaWVsZCgpKS5hdHRyKFwic3BlbGxjaGVja1wiLCBcImZhbHNlXCIpO1xuICAgICAgICBpbm5lcl9jZWxsLmFwcGVuZChpbnB1dF9hcmVhKTtcbiAgICAgICAgaW5wdXQuYXBwZW5kKHByb21wdCkuYXBwZW5kKGlubmVyX2NlbGwpO1xuXG4gICAgICAgIHZhciBvdXRwdXQgPSAkKCc8ZGl2PjwvZGl2PicpO1xuICAgICAgICBjZWxsLmFwcGVuZChpbnB1dCkuYXBwZW5kKG91dHB1dCk7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGNlbGw7XG4gICAgICAgIHRoaXMub3V0cHV0X2FyZWEgPSBuZXcgb3V0cHV0YXJlYS5PdXRwdXRBcmVhKHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiBvdXRwdXQsIFxuICAgICAgICAgICAgcHJvbXB0X2FyZWE6IHRydWUsIFxuICAgICAgICAgICAgZXZlbnRzOiB0aGlzLmV2ZW50cywgXG4gICAgICAgICAgICBrZXlib2FyZF9tYW5hZ2VyOiB0aGlzLmtleWJvYXJkX21hbmFnZXJ9KTtcbiAgICAgICAgdGhpcy5jb21wbGV0ZXIgPSBuZXcgY29tcGxldGVyLkNvbXBsZXRlcih0aGlzLCB0aGlzLmV2ZW50cyk7XG4gICAgfTtcblxuICAgIC8qKiBAbWV0aG9kIGJpbmRfZXZlbnRzICovXG4gICAgQ29kZUNlbGwucHJvdG90eXBlLmJpbmRfZXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBDZWxsLnByb3RvdHlwZS5iaW5kX2V2ZW50cy5hcHBseSh0aGlzKTtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgIHRoaXMuZWxlbWVudC5mb2N1c291dChcbiAgICAgICAgICAgIGZ1bmN0aW9uKCkgeyB0aGF0LmF1dG9faGlnaGxpZ2h0KCk7IH1cbiAgICAgICAgKTtcbiAgICB9O1xuXG5cbiAgICAvKipcbiAgICAgKiAgVGhpcyBtZXRob2QgZ2V0cyBjYWxsZWQgaW4gQ29kZU1pcnJvcidzIG9uS2V5RG93bi9vbktleVByZXNzXG4gICAgICogIGhhbmRsZXJzIGFuZCBpcyB1c2VkIHRvIHByb3ZpZGUgY3VzdG9tIGtleSBoYW5kbGluZy4gSXRzIHJldHVyblxuICAgICAqICB2YWx1ZSBpcyB1c2VkIHRvIGRldGVybWluZSBpZiBDb2RlTWlycm9yIHNob3VsZCBpZ25vcmUgdGhlIGV2ZW50OlxuICAgICAqICB0cnVlID0gaWdub3JlLCBmYWxzZSA9IGRvbid0IGlnbm9yZS5cbiAgICAgKiAgQG1ldGhvZCBoYW5kbGVfY29kZW1pcnJvcl9rZXlldmVudFxuICAgICAqL1xuXG4gICAgQ29kZUNlbGwucHJvdG90eXBlLmhhbmRsZV9jb2RlbWlycm9yX2tleWV2ZW50ID0gZnVuY3Rpb24gKGVkaXRvciwgZXZlbnQpIHtcblxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIC8vIHdoYXRldmVyIGtleSBpcyBwcmVzc2VkLCBmaXJzdCwgY2FuY2VsIHRoZSB0b29sdGlwIHJlcXVlc3QgYmVmb3JlXG4gICAgICAgIC8vIHRoZXkgYXJlIHNlbnQsIGFuZCByZW1vdmUgdG9vbHRpcCBpZiBhbnksIGV4Y2VwdCBmb3IgdGFiIGFnYWluXG4gICAgICAgIHZhciB0b29sdGlwX2Nsb3NlZCA9IG51bGw7XG4gICAgICAgIGlmIChldmVudC50eXBlID09PSAna2V5ZG93bicgJiYgZXZlbnQud2hpY2ggIT09IGtleWNvZGVzLnRhYiApIHtcbiAgICAgICAgICAgIHRvb2x0aXBfY2xvc2VkID0gdGhpcy50b29sdGlwLnJlbW92ZV9hbmRfY2FuY2VsX3Rvb2x0aXAoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjdXIgPSBlZGl0b3IuZ2V0Q3Vyc29yKCk7XG4gICAgICAgIGlmIChldmVudC5rZXlDb2RlID09PSBrZXljb2Rlcy5lbnRlcil7XG4gICAgICAgICAgICB0aGlzLmF1dG9faGlnaGxpZ2h0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXZlbnQud2hpY2ggPT09IGtleWNvZGVzLmRvd24gJiYgZXZlbnQudHlwZSA9PT0gJ2tleXByZXNzJyAmJiB0aGlzLnRvb2x0aXAudGltZV9iZWZvcmVfdG9vbHRpcCA+PSAwKSB7XG4gICAgICAgICAgICAvLyB0cmlnZXIgb24ga2V5cHJlc3MgKCEpIG90aGVyd2lzZSBpbmNvbnNpc3RlbnQgZXZlbnQud2hpY2ggZGVwZW5kaW5nIG9uIHBsYXRlZm9ybVxuICAgICAgICAgICAgLy8gYnJvd3NlciBhbmQga2V5Ym9hcmQgbGF5b3V0ICFcbiAgICAgICAgICAgIC8vIFByZXNzaW5nICcoJyAsIHJlcXVlc3QgdG9vbHRpcCwgZG9uJ3QgZm9yZ2V0IHRvIHJlYXBwZW5kIGl0XG4gICAgICAgICAgICAvLyBUaGUgc2Vjb25kIGFyZ3VtZW50IHNheXMgdG8gaGlkZSB0aGUgdG9vbHRpcCBpZiB0aGUgZG9jc3RyaW5nXG4gICAgICAgICAgICAvLyBpcyBhY3R1YWxseSBlbXB0eVxuICAgICAgICAgICAgdGhpcy50b29sdGlwLnBlbmRpbmcodGhhdCwgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoIHRvb2x0aXBfY2xvc2VkICYmIGV2ZW50LndoaWNoID09PSBrZXljb2Rlcy5lc2MgJiYgZXZlbnQudHlwZSA9PT0gJ2tleWRvd24nKSB7XG4gICAgICAgICAgICAvLyBJZiB0b29sdGlwIGlzIGFjdGl2ZSwgY2FuY2VsIGl0LiAgVGhlIGNhbGwgdG9cbiAgICAgICAgICAgIC8vIHJlbW92ZV9hbmRfY2FuY2VsX3Rvb2x0aXAgYWJvdmUgZG9lc24ndCBwYXNzLCBmb3JjZT10cnVlLlxuICAgICAgICAgICAgLy8gQmVjYXVzZSBvZiB0aGlzIGl0IHdvbid0IGFjdHVhbGx5IGNsb3NlIHRoZSB0b29sdGlwXG4gICAgICAgICAgICAvLyBpZiBpdCBpcyBpbiBzdGlja3kgbW9kZS4gVGh1cywgd2UgaGF2ZSB0byBjaGVjayBhZ2FpbiBpZiBpdCBpcyBvcGVuXG4gICAgICAgICAgICAvLyBhbmQgY2xvc2UgaXQgd2l0aCBmb3JjZT10cnVlLlxuICAgICAgICAgICAgaWYgKCF0aGlzLnRvb2x0aXAuX2hpZGRlbikge1xuICAgICAgICAgICAgICAgIHRoaXMudG9vbHRpcC5yZW1vdmVfYW5kX2NhbmNlbF90b29sdGlwKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgd2UgY2xvc2VkIHRoZSB0b29sdGlwLCBkb24ndCBsZXQgQ00gb3IgdGhlIGdsb2JhbCBoYW5kbGVyc1xuICAgICAgICAgICAgLy8gaGFuZGxlIHRoaXMgZXZlbnQuXG4gICAgICAgICAgICBldmVudC5jb2RlbWlycm9ySWdub3JlID0gdHJ1ZTtcbiAgICAgICAgICAgIGV2ZW50Ll9pcGttSWdub3JlID0gdHJ1ZTtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudC5rZXlDb2RlID09PSBrZXljb2Rlcy50YWIgJiYgZXZlbnQudHlwZSA9PT0gJ2tleWRvd24nICYmIGV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICAgICAgaWYgKGVkaXRvci5zb21ldGhpbmdTZWxlY3RlZCgpIHx8IGVkaXRvci5nZXRTZWxlY3Rpb25zKCkubGVuZ3RoICE9PSAxKXtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFuY2hvciA9IGVkaXRvci5nZXRDdXJzb3IoXCJhbmNob3JcIik7XG4gICAgICAgICAgICAgICAgICAgIHZhciBoZWFkID0gZWRpdG9yLmdldEN1cnNvcihcImhlYWRcIik7XG4gICAgICAgICAgICAgICAgICAgIGlmKCBhbmNob3IubGluZSAhPT0gaGVhZC5saW5lKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcHJlX2N1cnNvciA9IGVkaXRvci5nZXRSYW5nZSh7bGluZTpjdXIubGluZSxjaDowfSxjdXIpO1xuICAgICAgICAgICAgICAgIGlmIChwcmVfY3Vyc29yLnRyaW0oKSA9PT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBzaG93IHRvb2x0aXAgaWYgdGhlIHBhcnQgb2YgdGhlIGxpbmUgYmVmb3JlIHRoZSBjdXJzb3JcbiAgICAgICAgICAgICAgICAgICAgLy8gaXMgZW1wdHkuICBJbiB0aGlzIGNhc2UsIGxldCBDb2RlTWlycm9yIGhhbmRsZSBpbmRlbnRhdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0gXG4gICAgICAgICAgICAgICAgdGhpcy50b29sdGlwLnJlcXVlc3QodGhhdCk7XG4gICAgICAgICAgICAgICAgZXZlbnQuY29kZW1pcnJvcklnbm9yZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudC5rZXlDb2RlID09PSBrZXljb2Rlcy50YWIgJiYgZXZlbnQudHlwZSA9PT0gJ2tleWRvd24nKSB7XG4gICAgICAgICAgICAvLyBUYWIgY29tcGxldGlvbi5cbiAgICAgICAgICAgIHRoaXMudG9vbHRpcC5yZW1vdmVfYW5kX2NhbmNlbF90b29sdGlwKCk7XG5cbiAgICAgICAgICAgIC8vIGNvbXBsZXRpb24gZG9lcyBub3Qgd29yayBvbiBtdWx0aWN1cnNvciwgaXQgbWlnaHQgYmUgcG9zc2libGUgdGhvdWdoIGluIHNvbWUgY2FzZXNcbiAgICAgICAgICAgIGlmIChlZGl0b3Iuc29tZXRoaW5nU2VsZWN0ZWQoKSB8fCBlZGl0b3IuZ2V0U2VsZWN0aW9ucygpLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcHJlX2N1cnNvciA9IGVkaXRvci5nZXRSYW5nZSh7bGluZTpjdXIubGluZSxjaDowfSxjdXIpO1xuICAgICAgICAgICAgaWYgKHByZV9jdXJzb3IudHJpbSgpID09PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgLy8gRG9uJ3QgYXV0b2NvbXBsZXRlIGlmIHRoZSBwYXJ0IG9mIHRoZSBsaW5lIGJlZm9yZSB0aGUgY3Vyc29yXG4gICAgICAgICAgICAgICAgLy8gaXMgZW1wdHkuICBJbiB0aGlzIGNhc2UsIGxldCBDb2RlTWlycm9yIGhhbmRsZSBpbmRlbnRhdGlvbi5cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGV2ZW50LmNvZGVtaXJyb3JJZ25vcmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jb21wbGV0ZXIuc3RhcnRDb21wbGV0aW9uKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gXG4gICAgICAgIFxuICAgICAgICAvLyBrZXlib2FyZCBldmVudCB3YXNuJ3Qgb25lIG9mIHRob3NlIHVuaXF1ZSB0byBjb2RlIGNlbGxzLCBsZXQncyBzZWVcbiAgICAgICAgLy8gaWYgaXQncyBvbmUgb2YgdGhlIGdlbmVyaWMgb25lcyAoaS5lLiBjaGVjayBlZGl0IG1vZGUgc2hvcnRjdXRzKVxuICAgICAgICByZXR1cm4gQ2VsbC5wcm90b3R5cGUuaGFuZGxlX2NvZGVtaXJyb3Jfa2V5ZXZlbnQuYXBwbHkodGhpcywgW2VkaXRvciwgZXZlbnRdKTtcbiAgICB9O1xuXG4gICAgLy8gS2VybmVsIHJlbGF0ZWQgY2FsbHMuXG5cbiAgICBDb2RlQ2VsbC5wcm90b3R5cGUuc2V0X2tlcm5lbCA9IGZ1bmN0aW9uIChrZXJuZWwpIHtcbiAgICAgICAgdGhpcy5rZXJuZWwgPSBrZXJuZWw7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGUgY3VycmVudCBjb2RlIGNlbGwgdG8gdGhlIGtlcm5lbFxuICAgICAqIEBtZXRob2QgZXhlY3V0ZVxuICAgICAqL1xuICAgIENvZGVDZWxsLnByb3RvdHlwZS5leGVjdXRlID0gZnVuY3Rpb24gKHN0b3Bfb25fZXJyb3IpIHtcbiAgICAgICAgaWYgKCF0aGlzLmtlcm5lbCB8fCAhdGhpcy5rZXJuZWwuaXNfY29ubmVjdGVkKCkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiQ2FuJ3QgZXhlY3V0ZSwga2VybmVsIGlzIG5vdCBjb25uZWN0ZWQuXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5vdXRwdXRfYXJlYS5jbGVhcl9vdXRwdXQoZmFsc2UsIHRydWUpO1xuXG4gICAgICAgIGlmIChzdG9wX29uX2Vycm9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHN0b3Bfb25fZXJyb3IgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9sZF9tc2dfaWQgPSB0aGlzLmxhc3RfbXNnX2lkO1xuXG4gICAgICAgIGlmIChvbGRfbXNnX2lkKSB7XG4gICAgICAgICAgICB0aGlzLmtlcm5lbC5jbGVhcl9jYWxsYmFja3NfZm9yX21zZyhvbGRfbXNnX2lkKTtcbiAgICAgICAgICAgIGlmIChvbGRfbXNnX2lkKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIENvZGVDZWxsLm1zZ19jZWxsc1tvbGRfbXNnX2lkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5nZXRfdGV4dCgpLnRyaW0oKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIC8vIG5vdGhpbmcgdG8gZG9cbiAgICAgICAgICAgIHRoaXMuc2V0X2lucHV0X3Byb21wdChudWxsKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldF9pbnB1dF9wcm9tcHQoJyonKTtcbiAgICAgICAgdGhpcy5lbGVtZW50LmFkZENsYXNzKFwicnVubmluZ1wiKTtcbiAgICAgICAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuZ2V0X2NhbGxiYWNrcygpO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5sYXN0X21zZ19pZCA9IHRoaXMua2VybmVsLmV4ZWN1dGUodGhpcy5nZXRfdGV4dCgpLCBjYWxsYmFja3MsIHtzaWxlbnQ6IGZhbHNlLCBzdG9yZV9oaXN0b3J5OiB0cnVlLFxuICAgICAgICAgICAgc3RvcF9vbl9lcnJvciA6IHN0b3Bfb25fZXJyb3J9KTtcbiAgICAgICAgQ29kZUNlbGwubXNnX2NlbGxzW3RoaXMubGFzdF9tc2dfaWRdID0gdGhpcztcbiAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgdGhpcy5ldmVudHMudHJpZ2dlcignZXhlY3V0ZS5Db2RlQ2VsbCcsIHtjZWxsOiB0aGlzfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCB0aGUgZGVmYXVsdCBjYWxsYmFja3MgZm9yXG4gICAgICogQG1ldGhvZCBnZXRfY2FsbGJhY2tzXG4gICAgICovXG4gICAgQ29kZUNlbGwucHJvdG90eXBlLmdldF9jYWxsYmFja3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNoZWxsIDoge1xuICAgICAgICAgICAgICAgIHJlcGx5IDogJC5wcm94eSh0aGlzLl9oYW5kbGVfZXhlY3V0ZV9yZXBseSwgdGhpcyksXG4gICAgICAgICAgICAgICAgcGF5bG9hZCA6IHtcbiAgICAgICAgICAgICAgICAgICAgc2V0X25leHRfaW5wdXQgOiAkLnByb3h5KHRoaXMuX2hhbmRsZV9zZXRfbmV4dF9pbnB1dCwgdGhpcyksXG4gICAgICAgICAgICAgICAgICAgIHBhZ2UgOiAkLnByb3h5KHRoaXMuX29wZW5fd2l0aF9wYWdlciwgdGhpcylcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW9wdWIgOiB7XG4gICAgICAgICAgICAgICAgb3V0cHV0IDogZnVuY3Rpb24oKSB7IFxuICAgICAgICAgICAgICAgICAgICB0aGF0Lm91dHB1dF9hcmVhLmhhbmRsZV9vdXRwdXQuYXBwbHkodGhhdC5vdXRwdXRfYXJlYSwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB9LCBcbiAgICAgICAgICAgICAgICBjbGVhcl9vdXRwdXQgOiBmdW5jdGlvbigpIHsgXG4gICAgICAgICAgICAgICAgICAgIHRoYXQub3V0cHV0X2FyZWEuaGFuZGxlX2NsZWFyX291dHB1dC5hcHBseSh0aGF0Lm91dHB1dF9hcmVhLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIH0sIFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlucHV0IDogJC5wcm94eSh0aGlzLl9oYW5kbGVfaW5wdXRfcmVxdWVzdCwgdGhpcylcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgQ29kZUNlbGwucHJvdG90eXBlLl9vcGVuX3dpdGhfcGFnZXIgPSBmdW5jdGlvbiAocGF5bG9hZCkge1xuICAgICAgICB0aGlzLmV2ZW50cy50cmlnZ2VyKCdvcGVuX3dpdGhfdGV4dC5QYWdlcicsIHBheWxvYWQpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAbWV0aG9kIF9oYW5kbGVfZXhlY3V0ZV9yZXBseVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgQ29kZUNlbGwucHJvdG90eXBlLl9oYW5kbGVfZXhlY3V0ZV9yZXBseSA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgdGhpcy5zZXRfaW5wdXRfcHJvbXB0KG1zZy5jb250ZW50LmV4ZWN1dGlvbl9jb3VudCk7XG4gICAgICAgIHRoaXMuZWxlbWVudC5yZW1vdmVDbGFzcyhcInJ1bm5pbmdcIik7XG4gICAgICAgIHRoaXMuZXZlbnRzLnRyaWdnZXIoJ3NldF9kaXJ0eS5Ob3RlYm9vaycsIHt2YWx1ZTogdHJ1ZX0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAbWV0aG9kIF9oYW5kbGVfc2V0X25leHRfaW5wdXRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIENvZGVDZWxsLnByb3RvdHlwZS5faGFuZGxlX3NldF9uZXh0X2lucHV0ID0gZnVuY3Rpb24gKHBheWxvYWQpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB7J2NlbGwnOiB0aGlzLCAndGV4dCc6IHBheWxvYWQudGV4dCwgcmVwbGFjZTogcGF5bG9hZC5yZXBsYWNlfTtcbiAgICAgICAgdGhpcy5ldmVudHMudHJpZ2dlcignc2V0X25leHRfaW5wdXQuTm90ZWJvb2snLCBkYXRhKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQG1ldGhvZCBfaGFuZGxlX2lucHV0X3JlcXVlc3RcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIENvZGVDZWxsLnByb3RvdHlwZS5faGFuZGxlX2lucHV0X3JlcXVlc3QgPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgIHRoaXMub3V0cHV0X2FyZWEuYXBwZW5kX3Jhd19pbnB1dChtc2cpO1xuICAgIH07XG5cblxuICAgIC8vIEJhc2ljIGNlbGwgbWFuaXB1bGF0aW9uLlxuXG4gICAgQ29kZUNlbGwucHJvdG90eXBlLnNlbGVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbnQgPSBDZWxsLnByb3RvdHlwZS5zZWxlY3QuYXBwbHkodGhpcyk7XG4gICAgICAgIGlmIChjb250KSB7XG4gICAgICAgICAgICB0aGlzLmNvZGVfbWlycm9yLnJlZnJlc2goKTtcbiAgICAgICAgICAgIHRoaXMuYXV0b19oaWdobGlnaHQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29udDtcbiAgICB9O1xuXG4gICAgQ29kZUNlbGwucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbnQgPSBDZWxsLnByb3RvdHlwZS5yZW5kZXIuYXBwbHkodGhpcyk7XG4gICAgICAgIC8vIEFsd2F5cyBleGVjdXRlLCBldmVuIGlmIHdlIGFyZSBhbHJlYWR5IGluIHRoZSByZW5kZXJlZCBzdGF0ZVxuICAgICAgICByZXR1cm4gY29udDtcbiAgICB9O1xuXG4gICAgQ29kZUNlbGwucHJvdG90eXBlLnNlbGVjdF9hbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdGFydCA9IHtsaW5lOiAwLCBjaDogMH07XG4gICAgICAgIHZhciBubGluZXMgPSB0aGlzLmNvZGVfbWlycm9yLmxpbmVDb3VudCgpO1xuICAgICAgICB2YXIgbGFzdF9saW5lID0gdGhpcy5jb2RlX21pcnJvci5nZXRMaW5lKG5saW5lcy0xKTtcbiAgICAgICAgdmFyIGVuZCA9IHtsaW5lOiBubGluZXMtMSwgY2g6IGxhc3RfbGluZS5sZW5ndGh9O1xuICAgICAgICB0aGlzLmNvZGVfbWlycm9yLnNldFNlbGVjdGlvbihzdGFydCwgZW5kKTtcbiAgICB9O1xuXG5cbiAgICBDb2RlQ2VsbC5wcm90b3R5cGUuY29sbGFwc2Vfb3V0cHV0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm91dHB1dF9hcmVhLmNvbGxhcHNlKCk7XG4gICAgfTtcblxuXG4gICAgQ29kZUNlbGwucHJvdG90eXBlLmV4cGFuZF9vdXRwdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMub3V0cHV0X2FyZWEuZXhwYW5kKCk7XG4gICAgICAgIHRoaXMub3V0cHV0X2FyZWEudW5zY3JvbGxfYXJlYSgpO1xuICAgIH07XG5cbiAgICBDb2RlQ2VsbC5wcm90b3R5cGUuc2Nyb2xsX291dHB1dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5vdXRwdXRfYXJlYS5leHBhbmQoKTtcbiAgICAgICAgdGhpcy5vdXRwdXRfYXJlYS5zY3JvbGxfaWZfbG9uZygpO1xuICAgIH07XG5cbiAgICBDb2RlQ2VsbC5wcm90b3R5cGUudG9nZ2xlX291dHB1dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5vdXRwdXRfYXJlYS50b2dnbGVfb3V0cHV0KCk7XG4gICAgfTtcblxuICAgIENvZGVDZWxsLnByb3RvdHlwZS50b2dnbGVfb3V0cHV0X3Njcm9sbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5vdXRwdXRfYXJlYS50b2dnbGVfc2Nyb2xsKCk7XG4gICAgfTtcblxuXG4gICAgQ29kZUNlbGwuaW5wdXRfcHJvbXB0X2NsYXNzaWNhbCA9IGZ1bmN0aW9uIChwcm9tcHRfdmFsdWUsIGxpbmVzX251bWJlcikge1xuICAgICAgICB2YXIgbnM7XG4gICAgICAgIGlmIChwcm9tcHRfdmFsdWUgPT09IHVuZGVmaW5lZCB8fCBwcm9tcHRfdmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIG5zID0gXCImbmJzcDtcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5zID0gZW5jb2RlVVJJQ29tcG9uZW50KHByb21wdF92YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICdJbiZuYnNwO1snICsgbnMgKyAnXTonO1xuICAgIH07XG5cbiAgICBDb2RlQ2VsbC5pbnB1dF9wcm9tcHRfY29udGludWF0aW9uID0gZnVuY3Rpb24gKHByb21wdF92YWx1ZSwgbGluZXNfbnVtYmVyKSB7XG4gICAgICAgIHZhciBodG1sID0gW0NvZGVDZWxsLmlucHV0X3Byb21wdF9jbGFzc2ljYWwocHJvbXB0X3ZhbHVlLCBsaW5lc19udW1iZXIpXTtcbiAgICAgICAgZm9yKHZhciBpPTE7IGkgPCBsaW5lc19udW1iZXI7IGkrKykge1xuICAgICAgICAgICAgaHRtbC5wdXNoKFsnLi4uOiddKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaHRtbC5qb2luKCc8YnIvPicpO1xuICAgIH07XG5cbiAgICBDb2RlQ2VsbC5pbnB1dF9wcm9tcHRfZnVuY3Rpb24gPSBDb2RlQ2VsbC5pbnB1dF9wcm9tcHRfY2xhc3NpY2FsO1xuXG5cbiAgICBDb2RlQ2VsbC5wcm90b3R5cGUuc2V0X2lucHV0X3Byb21wdCA9IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgICAgICAgdmFyIG5saW5lID0gMTtcbiAgICAgICAgaWYgKHRoaXMuY29kZV9taXJyb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICBubGluZSA9IHRoaXMuY29kZV9taXJyb3IubGluZUNvdW50KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbnB1dF9wcm9tcHRfbnVtYmVyID0gbnVtYmVyO1xuICAgICAgICB2YXIgcHJvbXB0X2h0bWwgPSBDb2RlQ2VsbC5pbnB1dF9wcm9tcHRfZnVuY3Rpb24odGhpcy5pbnB1dF9wcm9tcHRfbnVtYmVyLCBubGluZSk7XG4gICAgICAgIC8vIFRoaXMgSFRNTCBjYWxsIGlzIG9rYXkgYmVjYXVzZSB0aGUgdXNlciBjb250ZW50cyBhcmUgZXNjYXBlZC5cbiAgICAgICAgdGhpcy5lbGVtZW50LmZpbmQoJ2Rpdi5pbnB1dF9wcm9tcHQnKS5odG1sKHByb21wdF9odG1sKTtcbiAgICB9O1xuXG5cbiAgICBDb2RlQ2VsbC5wcm90b3R5cGUuY2xlYXJfaW5wdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY29kZV9taXJyb3Iuc2V0VmFsdWUoJycpO1xuICAgIH07XG5cblxuICAgIENvZGVDZWxsLnByb3RvdHlwZS5nZXRfdGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29kZV9taXJyb3IuZ2V0VmFsdWUoKTtcbiAgICB9O1xuXG5cbiAgICBDb2RlQ2VsbC5wcm90b3R5cGUuc2V0X3RleHQgPSBmdW5jdGlvbiAoY29kZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2RlX21pcnJvci5zZXRWYWx1ZShjb2RlKTtcbiAgICB9O1xuXG5cbiAgICBDb2RlQ2VsbC5wcm90b3R5cGUuY2xlYXJfb3V0cHV0ID0gZnVuY3Rpb24gKHdhaXQpIHtcbiAgICAgICAgdGhpcy5vdXRwdXRfYXJlYS5jbGVhcl9vdXRwdXQod2FpdCk7XG4gICAgICAgIHRoaXMuc2V0X2lucHV0X3Byb21wdCgpO1xuICAgIH07XG5cblxuICAgIC8vIEpTT04gc2VyaWFsaXphdGlvblxuXG4gICAgQ29kZUNlbGwucHJvdG90eXBlLmZyb21KU09OID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgQ2VsbC5wcm90b3R5cGUuZnJvbUpTT04uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKGRhdGEuY2VsbF90eXBlID09PSAnY29kZScpIHtcbiAgICAgICAgICAgIGlmIChkYXRhLnNvdXJjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRfdGV4dChkYXRhLnNvdXJjZSk7XG4gICAgICAgICAgICAgICAgLy8gbWFrZSB0aGlzIHZhbHVlIHRoZSBzdGFydGluZyBwb2ludCwgc28gdGhhdCB3ZSBjYW4gb25seSB1bmRvXG4gICAgICAgICAgICAgICAgLy8gdG8gdGhpcyBzdGF0ZSwgaW5zdGVhZCBvZiBhIGJsYW5rIGNlbGxcbiAgICAgICAgICAgICAgICB0aGlzLmNvZGVfbWlycm9yLmNsZWFySGlzdG9yeSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuYXV0b19oaWdobGlnaHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2V0X2lucHV0X3Byb21wdChkYXRhLmV4ZWN1dGlvbl9jb3VudCk7XG4gICAgICAgICAgICB0aGlzLm91dHB1dF9hcmVhLnRydXN0ZWQgPSBkYXRhLm1ldGFkYXRhLnRydXN0ZWQgfHwgZmFsc2U7XG4gICAgICAgICAgICB0aGlzLm91dHB1dF9hcmVhLmZyb21KU09OKGRhdGEub3V0cHV0cywgZGF0YS5tZXRhZGF0YSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG5cbiAgICBDb2RlQ2VsbC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZGF0YSA9IENlbGwucHJvdG90eXBlLnRvSlNPTi5hcHBseSh0aGlzKTtcbiAgICAgICAgZGF0YS5zb3VyY2UgPSB0aGlzLmdldF90ZXh0KCk7XG4gICAgICAgIC8vIGlzIGZpbml0ZSBwcm90ZWN0IGFnYWluc3QgdW5kZWZpbmVkIGFuZCAnKicgdmFsdWVcbiAgICAgICAgaWYgKGlzRmluaXRlKHRoaXMuaW5wdXRfcHJvbXB0X251bWJlcikpIHtcbiAgICAgICAgICAgIGRhdGEuZXhlY3V0aW9uX2NvdW50ID0gdGhpcy5pbnB1dF9wcm9tcHRfbnVtYmVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGF0YS5leGVjdXRpb25fY291bnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvdXRwdXRzID0gdGhpcy5vdXRwdXRfYXJlYS50b0pTT04oKTtcbiAgICAgICAgZGF0YS5vdXRwdXRzID0gb3V0cHV0cztcbiAgICAgICAgZGF0YS5tZXRhZGF0YS50cnVzdGVkID0gdGhpcy5vdXRwdXRfYXJlYS50cnVzdGVkO1xuICAgICAgICBkYXRhLm1ldGFkYXRhLmNvbGxhcHNlZCA9IHRoaXMub3V0cHV0X2FyZWEuY29sbGFwc2VkO1xuICAgICAgICBpZiAodGhpcy5vdXRwdXRfYXJlYS5zY3JvbGxfc3RhdGUgPT09ICdhdXRvJykge1xuICAgICAgICAgICAgZGVsZXRlIGRhdGEubWV0YWRhdGEuc2Nyb2xsZWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRhLm1ldGFkYXRhLnNjcm9sbGVkID0gdGhpcy5vdXRwdXRfYXJlYS5zY3JvbGxfc3RhdGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGhhbmRsZSBjZWxsIGxldmVsIGxvZ2ljIHdoZW4gdGhlIGN1cnNvciBtb3ZlcyBhd2F5IGZyb20gYSBjZWxsXG4gICAgICogQG1ldGhvZCB1bnNlbGVjdFxuICAgICAqIEByZXR1cm4gaXMgdGhlIGFjdGlvbiBiZWluZyB0YWtlblxuICAgICAqL1xuICAgIENvZGVDZWxsLnByb3RvdHlwZS51bnNlbGVjdCA9IGZ1bmN0aW9uIChsZWF2ZV9zZWxlY3RlZCkge1xuICAgICAgICB2YXIgY29udCA9IENlbGwucHJvdG90eXBlLnVuc2VsZWN0LmFwcGx5KHRoaXMsIFtsZWF2ZV9zZWxlY3RlZF0pO1xuICAgICAgICBpZiAoY29udCkge1xuICAgICAgICAgICAgLy8gV2hlbiBhIGNvZGUgY2VsbCBpcyB1bnNlbGVjdGVkLCBtYWtlIHN1cmUgdGhhdCB0aGUgY29ycmVzcG9uZGluZ1xuICAgICAgICAgICAgLy8gdG9vbHRpcCBhbmQgY29tcGxldGVyIHRvIHRoYXQgY2VsbCBpcyBjbG9zZWQuXG4gICAgICAgICAgICB0aGlzLnRvb2x0aXAucmVtb3ZlX2FuZF9jYW5jZWxfdG9vbHRpcCh0cnVlKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbXBsZXRlciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29tcGxldGVyLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnQ7XG4gICAgfTtcblxuICAgIC8vIEJhY2t3YXJkcyBjb21wYXRhYmlsaXR5LlxuICAgIElQeXRob24uQ29kZUNlbGwgPSBDb2RlQ2VsbDtcblxuICAgIGV4cG9ydHMuQ29kZUNlbGwgPSBDb2RlQ2VsbDtcbiIsIi8vIENvcHlyaWdodCAoYykgSnVweXRlciBEZXZlbG9wbWVudCBUZWFtLlxuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBNb2RpZmllZCBCU0QgTGljZW5zZS5cblxuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgdmFyIFFIID0gcmVxdWlyZShcIm5vdGVib29rL2pzL3F1aWNraGVscFwiKTtcbiAgICBcbiAgICAvKipcbiAgICAgKiBIdW1hbml6ZSB0aGUgYWN0aW9uIG5hbWUgdG8gYmUgY29uc3VtZWQgYnkgdXNlci5cbiAgICAgKiBpbnRlcm5hbHkgdGhlIGFjdGlvbnMgYW5lbSBhcmUgb2YgdGhlIGZvcm1cbiAgICAgKiA8bmFtZXNwYWNlPi48ZGVzY3JpcHRpb24td2l0aC1kYXNoZXM+XG4gICAgICogd2UgZHJvcCA8bmFtZXNhcGNlPiBhbmQgcmVwbGFjZSBkYXNoZXMgZm9yIHNwYWNlLlxuICAgICAqL1xuICAgIHZhciBodW1hbml6ZV9hY3Rpb25faWQgPSBmdW5jdGlvbihzdHIpIHtcbiAgICAgIHJldHVybiBzdHIuc3BsaXQoJy4nKVsxXS5yZXBsYWNlKC8tL2csICcgJykucmVwbGFjZSgvXy9nLCAnLScpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBnaXZlbiBhbiBhY3Rpb24gaWQgcmV0dXJuICdjb21tYW5kLXNob3J0Y3V0JywgJ2VkaXQtc2hvcnRjdXQnIG9yICduby1zaG9ydGN1dCdcbiAgICAgKiBmb3IgdGhlIGFjdGlvbi4gVGhpcyBhbGxvd3MgdXMgdG8gdGFnIFVJIGluIG9yZGVyIHRvIHZpc3VhbGx5IGRpc3Rpbmd1aXNoXG4gICAgICogd2V0aGVyIGFuIGFjdGlvbiBoYXZlIGEga2V5YmluZGluZyBvciBub3QuXG4gICAgICoqL1xuICAgIHZhciBnZXRfbW9kZV9mb3JfYWN0aW9uX2lkID0gZnVuY3Rpb24obmFtZSwgbm90ZWJvb2spIHtcbiAgICAgIHZhciBzaG9ydGN1dCA9IG5vdGVib29rLmtleWJvYXJkX21hbmFnZXIuY29tbWFuZF9zaG9ydGN1dHMuZ2V0X2FjdGlvbl9zaG9ydGN1dChuYW1lKTtcbiAgICAgIGlmIChzaG9ydGN1dCkge1xuICAgICAgICByZXR1cm4gJ2NvbW1hbmQtc2hvcnRjdXQnO1xuICAgICAgfVxuICAgICAgc2hvcnRjdXQgPSBub3RlYm9vay5rZXlib2FyZF9tYW5hZ2VyLmVkaXRfc2hvcnRjdXRzLmdldF9hY3Rpb25fc2hvcnRjdXQobmFtZSk7XG4gICAgICBpZiAoc2hvcnRjdXQpIHtcbiAgICAgICAgcmV0dXJuICdlZGl0LXNob3J0Y3V0JztcbiAgICAgIH1cbiAgICAgIHJldHVybiAnbm8tc2hvcnRjdXQnO1xuICAgIH07XG5cbiAgICB2YXIgQ29tbWFuZFBhbGV0dGUgPSBmdW5jdGlvbihub3RlYm9vaykge1xuICAgICAgICBpZighbm90ZWJvb2spe1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvbW1hbmRQYWxldHRlIHRha2VzIGEgbm90ZWJvb2sgbm9uLW51bGwgbWFuZGF0b3J5IGFyZ3VlbWVudFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHR5cGVhaGVhZCBsaWIgbmVlZCBhIHNwZWNpZmljIGxheW91dCB3aXRoIHNwZWNpZmljIGNsYXNzIG5hbWVzLlxuICAgICAgICAvLyB0aGUgZm9sbG93aW5nIGp1c3QgZG9lcyB0aGF0XG4gICAgICAgIHZhciBmb3JtID0gJCgnPGZvcm0vPicpO1xuICAgICAgICB2YXIgY29udGFpbmVyID0gJCgnPGRpdi8+JykuYWRkQ2xhc3MoJ3R5cGVhaGVhZC1jb250YWluZXInKTtcbiAgICAgICAgdmFyIGZpZWxkID0gJCgnPGRpdi8+JykuYWRkQ2xhc3MoJ3R5cGVhaGVhZC1maWVsZCcpO1xuICAgICAgICB2YXIgaW5wdXQgPSAkKCc8aW5wdXQvPicpLmF0dHIoJ3R5cGUnLCAnc2VhcmNoJyk7XG5cbiAgICAgICAgZmllbGRcbiAgICAgICAgICAuYXBwZW5kKFxuICAgICAgICAgICAgJCgnPHNwYW4+JykuYWRkQ2xhc3MoJ3R5cGVhaGVhZC1xdWVyeScpLmFwcGVuZChcbiAgICAgICAgICAgICAgaW5wdXRcbiAgICAgICAgICAgIClcbiAgICAgICAgICApXG4gICAgICAgICAgLmFwcGVuZChcbiAgICAgICAgICAgICQoJzxzcGFuLz4nKS5hZGRDbGFzcygndHlwZWFoZWFkLWJ1dHRvbicpLmFwcGVuZChcbiAgICAgICAgICAgICAgJCgnPGJ1dHRvbi8+JykuYXR0cigndHlwZScsICdzdWJtaXQnKS5hcHBlbmQoXG4gICAgICAgICAgICAgICAgJCgnPHNwYW4vPicpLmFkZENsYXNzKCd0eXBlYWhlYWQtc2VhcmNoLWljb24nKVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcblxuICAgICAgICBjb250YWluZXIuYXBwZW5kKGZpZWxkKTtcbiAgICAgICAgZm9ybS5hcHBlbmQoY29udGFpbmVyKTtcblxuXG4gICAgICAgIHZhciBtb2QgPSAkKCc8ZGl2Lz4nKS5hZGRDbGFzcygnbW9kYWwgY21kLXBhbGV0dGUnKS5hcHBlbmQoXG4gICAgICAgICAgJCgnPGRpdi8+JykuYWRkQ2xhc3MoJ21vZGFsLWRpYWxvZycpXG4gICAgICAgICAgLmFwcGVuZChcbiAgICAgICAgICAgICQoJzxkaXYvPicpLmFkZENsYXNzKCdtb2RhbC1jb250ZW50JykuYXBwZW5kKFxuICAgICAgICAgICAgICAkKCc8ZGl2Lz4nKS5hZGRDbGFzcygnbW9kYWwtYm9keScpXG4gICAgICAgICAgICAgIC5hcHBlbmQoXG4gICAgICAgICAgICAgICAgZm9ybVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApXG4gICAgICAgICAgKVxuICAgICAgICApXG4gICAgICAgIC8vIGVuZCBzZXR0aW5nIHVwIHJpZ2h0IGxheW91dFxuICAgICAgICAubW9kYWwoe3Nob3c6IGZhbHNlLCBiYWNrZHJvcDp0cnVlfSlcbiAgICAgICAgLm9uKCdzaG93bi5icy5tb2RhbCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgLy8gY2xpY2sgb24gYnV0dG9uIHRyaWdnZXIgZGUtZm9jdXMgb24gbW91c2UgdXAuXG4gICAgICAgICAgICAgIC8vIG9yIHNvbWV0aGlnbiBsaWtlIHRoYXQuXG4gICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtpbnB1dC5mb2N1cygpO30sIDEwMCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG5vdGVib29rLmtleWJvYXJkX21hbmFnZXIuZGlzYWJsZSgpO1xuXG4gICAgICAgIHZhciBiZWZvcmVfY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAvLyBsaXR0bGUgdHJpY2sgdG8gdHJpZ2dlciBlYXJseSBpbiBvbnN1Ym1pdFxuICAgICAgICAgIC8vIHdoZW4gdGhlIGFjdGlvbiBjYWxsZWQgcG9wLXVwIGEgZGlhbG9nXG4gICAgICAgICAgLy8gaW5zdXJlIHRoaXMgZnVuY3Rpb24gaXMgb25seSBjYWxsZWQgb25jZVxuICAgICAgICAgIGlmIChiZWZvcmVfY2xvc2Uub2spIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGNlbGwgPSBub3RlYm9vay5nZXRfc2VsZWN0ZWRfY2VsbCgpO1xuICAgICAgICAgIGlmIChjZWxsKSB7XG4gICAgICAgICAgICBjZWxsLnNlbGVjdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobm90ZWJvb2sua2V5Ym9hcmRfbWFuYWdlcikge1xuICAgICAgICAgICAgbm90ZWJvb2sua2V5Ym9hcmRfbWFuYWdlci5lbmFibGUoKTtcbiAgICAgICAgICAgIG5vdGVib29rLmtleWJvYXJkX21hbmFnZXIuY29tbWFuZF9tb2RlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJlZm9yZV9jbG9zZS5vayA9IHRydWU7IC8vIGF2b2lkIGRvdWJsZSBjYWxsLlxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgbW9kLm9uKFwiaGlkZS5icy5tb2RhbFwiLCBiZWZvcmVfY2xvc2UpO1xuICAgICAgICBcblxuICAgICAgICAvLyB3aWxsIGJlIHRyaWdnZXIgd2hlbiB1c2VyIHNlbGVjdCBhY3Rpb25cbiAgICAgICAgdmFyIG9uU3VibWl0ID0gZnVuY3Rpb24obm9kZSwgcXVlcnksIHJlc3VsdCwgcmVzdWx0Q291bnQpIHtcbiAgICAgICAgICBpZiAoYWN0aW9ucy5pbmRleE9mKHJlc3VsdC5rZXkpID49IDApIHtcbiAgICAgICAgICAgIGJlZm9yZV9jbG9zZSgpO1xuICAgICAgICAgICAgbm90ZWJvb2sua2V5Ym9hcmRfbWFuYWdlci5hY3Rpb25zLmNhbGwocmVzdWx0LmtleSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybmluZyhcIk5vIGNvbW1hbmQgXCIgKyByZXN1bHQua2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbW9kLm1vZGFsKCdoaWRlJyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gZ2VuZXJhdGUgc3RydWN0dXJlIG5lZWRlZCBmb3IgdHlwZWFoZWFkIGxheW91dCBhbmQgYWJpbGl0eSB0byBzZWFyY2hcbiAgICAgICAgdmFyIHNyYyA9IHt9O1xuXG4gICAgICAgIHZhciBhY3Rpb25zID0gT2JqZWN0LmtleXMobm90ZWJvb2sua2V5Ym9hcmRfbWFuYWdlci5hY3Rpb25zLl9hY3Rpb25zKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgYWN0aW9uX2lkID0gYWN0aW9uc1tpXTtcbiAgICAgICAgICB2YXIgYWN0aW9uID0gbm90ZWJvb2sua2V5Ym9hcmRfbWFuYWdlci5hY3Rpb25zLmdldChhY3Rpb25faWQpO1xuICAgICAgICAgIHZhciBncm91cCA9IGFjdGlvbl9pZC5zcGxpdCgnLicpWzBdO1xuICAgICAgICAgIGlmIChncm91cCA9PT0gJ2lweXRob24nKSB7XG4gICAgICAgICAgICBncm91cCA9ICdidWlsdC1pbic7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3JjW2dyb3VwXSA9IHNyY1tncm91cF0gfHwge1xuICAgICAgICAgICAgZGF0YTogW10sXG4gICAgICAgICAgICBkaXNwbGF5OiAnZGlzcGxheSdcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgdmFyIHNob3J0ID0gbm90ZWJvb2sua2V5Ym9hcmRfbWFuYWdlci5jb21tYW5kX3Nob3J0Y3V0cy5nZXRfYWN0aW9uX3Nob3J0Y3V0KGFjdGlvbl9pZCkgfHxcbiAgICAgICAgICAgIG5vdGVib29rLmtleWJvYXJkX21hbmFnZXIuZWRpdF9zaG9ydGN1dHMuZ2V0X2FjdGlvbl9zaG9ydGN1dChhY3Rpb25faWQpO1xuICAgICAgICAgIGlmIChzaG9ydCkge1xuICAgICAgICAgICAgc2hvcnQgPSBRSC5odW1hbml6ZV9zZXF1ZW5jZShzaG9ydCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3JjW2dyb3VwXS5kYXRhLnB1c2goe1xuICAgICAgICAgICAgZGlzcGxheTogaHVtYW5pemVfYWN0aW9uX2lkKGFjdGlvbl9pZCksXG4gICAgICAgICAgICBzaG9ydGN1dDogc2hvcnQsXG4gICAgICAgICAgICBtb2RlX3Nob3J0Y3V0OiBnZXRfbW9kZV9mb3JfYWN0aW9uX2lkKGFjdGlvbl9pZCwgbm90ZWJvb2spLFxuICAgICAgICAgICAgZ3JvdXA6IGdyb3VwLFxuICAgICAgICAgICAgaWNvbjogYWN0aW9uLmljb24sXG4gICAgICAgICAgICBoZWxwOiBhY3Rpb24uaGVscCxcbiAgICAgICAgICAgIGtleTogYWN0aW9uX2lkLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbm93IHNyYyBpcyB0aGUgcmlnaHQgc3RydWN0dXJlIGZvciB0eXBlYWhlYWRcblxuICAgICAgICBpbnB1dC50eXBlYWhlYWQoe1xuICAgICAgICAgIGVtcHR5VGVtcGxhdGU6IFwiTm8gcmVzdWx0cyBmb3VuZCBmb3IgPHByZT57e3F1ZXJ5fX08L3ByZT5cIixcbiAgICAgICAgICBtYXhJdGVtOiAxZTMsXG4gICAgICAgICAgbWluTGVuZ3RoOiAwLFxuICAgICAgICAgIGhpbnQ6IHRydWUsXG4gICAgICAgICAgZ3JvdXA6IFtcImdyb3VwXCIsIFwie3tncm91cH19IGV4dGVuc2lvblwiXSxcbiAgICAgICAgICBzZWFyY2hPbkZvY3VzOiB0cnVlLFxuICAgICAgICAgIG11c3RTZWxlY3RJdGVtOiB0cnVlLFxuICAgICAgICAgIHRlbXBsYXRlOiAnPGkgY2xhc3M9XCJmYSBmYS1pY29uIHt7aWNvbn19XCI+PC9pPnt7ZGlzcGxheX19ICA8ZGl2IGNsYXNzPVwicHVsbC1yaWdodCB7e21vZGVfc2hvcnRjdXR9fVwiPnt7c2hvcnRjdXR9fTwvZGl2PicsXG4gICAgICAgICAgb3JkZXI6IFwiYXNjXCIsXG4gICAgICAgICAgc291cmNlOiBzcmMsXG4gICAgICAgICAgY2FsbGJhY2s6IHtcbiAgICAgICAgICAgIG9uU3VibWl0OiBvblN1Ym1pdCxcbiAgICAgICAgICAgIG9uQ2xpY2tBZnRlcjogb25TdWJtaXRcbiAgICAgICAgICB9LFxuICAgICAgICAgIGRlYnVnOiBmYWxzZSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbW9kLm1vZGFsKCdzaG93Jyk7XG4gICAgfTtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHsnQ29tbWFuZFBhbGV0dGUnOiBDb21tYW5kUGFsZXR0ZX07IFxuIiwiLy8gQ29weXJpZ2h0IChjKSBKdXB5dGVyIERldmVsb3BtZW50IFRlYW0uXG4vLyBEaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIE1vZGlmaWVkIEJTRCBMaWNlbnNlLlxuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgdmFyIHV0aWxzID0gcmVxdWlyZSgnYmFzZS9qcy91dGlscycpO1xuICAgIHZhciBrZXlib2FyZCA9IHJlcXVpcmUoJ2Jhc2UvanMva2V5Ym9hcmQnKTtcbiAgICByZXF1aXJlKCdub3RlYm9vay9qcy9jb250ZXh0aGludCcpO1xuXG4gICAgLy8gZWFzaWVyIGtleSBtYXBwaW5nXG4gICAgdmFyIGtleWNvZGVzID0ga2V5Ym9hcmQua2V5Y29kZXM7XG5cbiAgICB2YXIgcHJlcGVuZF9uX3ByYyA9IGZ1bmN0aW9uKHN0ciwgbikge1xuICAgICAgICBmb3IoIHZhciBpID0wIDsgaTwgbiA7IGkrKyl7XG4gICAgICAgICAgICBzdHIgPSAnJScrc3RyIDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH07XG5cbiAgICB2YXIgX2V4aXN0aW5nX2NvbXBsZXRpb24gPSBmdW5jdGlvbihpdGVtLCBjb21wbGV0aW9uX2FycmF5KXtcbiAgICAgICAgZm9yKCB2YXIgaT0wOyBpIDwgY29tcGxldGlvbl9hcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGNvbXBsZXRpb25fYXJyYXlbaV0udHJpbSgpLnN1YnN0cigtaXRlbS5sZW5ndGgpID09IGl0ZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIC8vIHdoYXQgaXMgdGhlIGNvbW1vbiBzdGFydCBvZiBhbGwgY29tcGxldGlvbnNcbiAgICBmdW5jdGlvbiBzaGFyZWRfc3RhcnQoQiwgZHJvcF9wcmN0KSB7XG4gICAgICAgIGlmIChCLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gQlswXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgQSA9IFtdO1xuICAgICAgICB2YXIgY29tbW9uO1xuICAgICAgICB2YXIgbWluX2xlYWRfcHJjdCA9IDEwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IEIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzdHIgPSBCW2ldLnN0cjtcbiAgICAgICAgICAgIHZhciBsb2NhbG1pbiA9IDA7XG4gICAgICAgICAgICBpZihkcm9wX3ByY3QgPT09IHRydWUpe1xuICAgICAgICAgICAgICAgIHdoaWxlICggc3RyLnN1YnN0cigwLCAxKSA9PSAnJScpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxtaW4gPSBsb2NhbG1pbisxO1xuICAgICAgICAgICAgICAgICAgICBzdHIgPSBzdHIuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1pbl9sZWFkX3ByY3QgPSBNYXRoLm1pbihtaW5fbGVhZF9wcmN0LCBsb2NhbG1pbik7XG4gICAgICAgICAgICBBLnB1c2goc3RyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChBLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHZhciB0ZW0xLCB0ZW0yLCBzO1xuICAgICAgICAgICAgQSA9IEEuc2xpY2UoMCkuc29ydCgpO1xuICAgICAgICAgICAgdGVtMSA9IEFbMF07XG4gICAgICAgICAgICBzID0gdGVtMS5sZW5ndGg7XG4gICAgICAgICAgICB0ZW0yID0gQS5wb3AoKTtcbiAgICAgICAgICAgIHdoaWxlIChzICYmIHRlbTIuaW5kZXhPZih0ZW0xKSA9PSAtMSkge1xuICAgICAgICAgICAgICAgIHRlbTEgPSB0ZW0xLnN1YnN0cmluZygwLCAtLXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRlbTEgPT09IFwiXCIgfHwgdGVtMi5pbmRleE9mKHRlbTEpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyOnByZXBlbmRfbl9wcmMoJycsIG1pbl9sZWFkX3ByY3QpLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImNvbXB1dGVkXCIsXG4gICAgICAgICAgICAgICAgICAgIGZyb206IEJbMF0uZnJvbSxcbiAgICAgICAgICAgICAgICAgICAgdG86IEJbMF0udG9cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3RyOiBwcmVwZW5kX25fcHJjKHRlbTEsIG1pbl9sZWFkX3ByY3QpLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiY29tcHV0ZWRcIixcbiAgICAgICAgICAgICAgICBmcm9tOiBCWzBdLmZyb20sXG4gICAgICAgICAgICAgICAgdG86IEJbMF0udG9cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG5cbiAgICB2YXIgQ29tcGxldGVyID0gZnVuY3Rpb24gKGNlbGwsIGV2ZW50cykge1xuICAgICAgICB0aGlzLmNlbGwgPSBjZWxsO1xuICAgICAgICB0aGlzLmVkaXRvciA9IGNlbGwuY29kZV9taXJyb3I7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgZXZlbnRzLm9uKCdrZXJuZWxfYnVzeS5LZXJuZWwnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGF0LnNraXBfa2VybmVsX2NvbXBsZXRpb24gPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgICAgZXZlbnRzLm9uKCdrZXJuZWxfaWRsZS5LZXJuZWwnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGF0LnNraXBfa2VybmVsX2NvbXBsZXRpb24gPSBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIENvbXBsZXRlci5wcm90b3R5cGUuc3RhcnRDb21wbGV0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogY2FsbCBmb3IgYSAnZmlyc3QnIGNvbXBsZXRpb24sIHRoYXQgd2lsbCBzZXQgdGhlIGVkaXRvciBhbmQgZG8gc29tZVxuICAgICAgICAgKiBzcGVjaWFsIGJlaGF2aW9yIGxpa2UgYXV0b3BpY2tpbmcgaWYgb25seSBvbmUgY29tcGxldGlvbiBhdmFpbGFibGUuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAodGhpcy5lZGl0b3Iuc29tZXRoaW5nU2VsZWN0ZWQoKXx8IHRoaXMuZWRpdG9yLmdldFNlbGVjdGlvbnMoKS5sZW5ndGggPiAxKSByZXR1cm47XG4gICAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgICAvLyB1c2UgdG8gZ2V0IGZvY3VzIGJhY2sgb24gb3BlcmFcbiAgICAgICAgdGhpcy5jYXJyeV9vbl9jb21wbGV0aW9uKHRydWUpO1xuICAgIH07XG5cblxuICAgIC8vIGVhc3kgYWNjZXNzIGZvciBqdWxpYSB0byBtb25rZXlwYXRjaFxuICAgIC8vXG4gICAgQ29tcGxldGVyLnJlaW52b2tlX3JlID0gL1slMC05YS16Ll8vXFxcXDp+LV0vaTtcblxuICAgIENvbXBsZXRlci5wcm90b3R5cGUucmVpbnZva2U9IGZ1bmN0aW9uKHByZV9jdXJzb3IsIGJsb2NrLCBjdXJzb3Ipe1xuICAgICAgICByZXR1cm4gQ29tcGxldGVyLnJlaW52b2tlX3JlLnRlc3QocHJlX2N1cnNvcik7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogcGFzcyB0cnVlIGFzIHBhcmFtZXRlciBpZiB0aGlzIGlzIHRoZSBmaXJzdCBpbnZvY2F0aW9uIG9mIHRoZSBjb21wbGV0ZXJcbiAgICAgKiB0aGlzIHdpbGwgcHJldmVudCB0aGUgY29tcGxldGVyIHRvIGRpc3NtaXNzIGl0c2VsZiBpZiBpdCBpcyBub3Qgb24gYVxuICAgICAqIHdvcmQgYm91bmRhcnkgbGlrZSBwcmVzc2luZyB0YWIgYWZ0ZXIgYSBzcGFjZSwgYW5kIG1ha2UgaXQgYXV0b3BpY2sgdGhlXG4gICAgICogb25seSBjaG9pY2UgaWYgdGhlcmUgaXMgb25seSBvbmUgd2hpY2ggcHJldmVudCBmcm9tIHBvcHBpbmcgdGhlIFVJLiAgYXNcbiAgICAgKiB3ZWxsIGFzIGZhc3QtZm9yd2FyZGluZyB0aGUgdHlwaW5nIGlmIGFsbCBjb21wbGV0aW9uIGhhdmUgYSBjb21tb25cbiAgICAgKiBzaGFyZWQgc3RhcnRcbiAgICAgKiovXG4gICAgQ29tcGxldGVyLnByb3RvdHlwZS5jYXJyeV9vbl9jb21wbGV0aW9uID0gZnVuY3Rpb24gKGZpcnN0X2ludm9jYXRpb24pIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBhc3MgdHJ1ZSBhcyBwYXJhbWV0ZXIgaWYgeW91IHdhbnQgdGhlIGNvbXBsZXRlciB0byBhdXRvcGljayB3aGVuXG4gICAgICAgICAqIG9ubHkgb25lIGNvbXBsZXRpb24uIFRoaXMgZnVuY3Rpb24gaXMgYXV0b21hdGljYWxseSByZWludm9rZWQgYXRcbiAgICAgICAgICogZWFjaCBrZXlzdHJva2Ugd2l0aCBmaXJzdF9pbnZvY2F0aW9uID0gZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHZhciBjdXIgPSB0aGlzLmVkaXRvci5nZXRDdXJzb3IoKTtcbiAgICAgICAgdmFyIGxpbmUgPSB0aGlzLmVkaXRvci5nZXRMaW5lKGN1ci5saW5lKTtcbiAgICAgICAgdmFyIHByZV9jdXJzb3IgPSB0aGlzLmVkaXRvci5nZXRSYW5nZSh7XG4gICAgICAgICAgICBsaW5lOiBjdXIubGluZSxcbiAgICAgICAgICAgIGNoOiBjdXIuY2ggLSAxXG4gICAgICAgIH0sIGN1cik7XG5cbiAgICAgICAgLy8gd2UgbmVlZCB0byBjaGVjayB0aGF0IHdlIGFyZSBzdGlsbCBvbiBhIHdvcmQgYm91bmRhcnlcbiAgICAgICAgLy8gYmVjYXVzZSB3aGlsZSB0eXBpbmcgdGhlIGNvbXBsZXRlciBpcyBzdGlsbCByZWludm9raW5nIGl0c2VsZlxuICAgICAgICAvLyBzbyBkaXNtaXNzIGlmIHdlIGFyZSBvbiBhIFwiYmFkXCIgY2FyYWN0ZXJcbiAgICAgICAgaWYgKCF0aGlzLnJlaW52b2tlKHByZV9jdXJzb3IpICYmICFmaXJzdF9pbnZvY2F0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmF1dG9waWNrID0gZmFsc2U7XG4gICAgICAgIGlmIChmaXJzdF9pbnZvY2F0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmF1dG9waWNrID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdlIHdhbnQgYSBzaW5nbGUgY3Vyc29yIHBvc2l0aW9uLlxuICAgICAgICBpZiAodGhpcy5lZGl0b3Iuc29tZXRoaW5nU2VsZWN0ZWQoKXx8IHRoaXMuZWRpdG9yLmdldFNlbGVjdGlvbnMoKS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBvbmUga2VybmVsIGNvbXBsZXRpb24gY2FtZSBiYWNrLCBmaW5pc2hfY29tcGxldGluZyB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZSByZXN1bHRzXG4gICAgICAgIC8vIHdlIGZvcmsgaGVyZSBhbmQgZGlyZWN0bHkgY2FsbCBmaW5pc2ggY29tcGxldGluZyBpZiBrZXJuZWwgaXMgYnVzeVxuICAgICAgICB2YXIgY3Vyc29yX3BvcyA9IHV0aWxzLnRvX2Fic29sdXRlX2N1cnNvcl9wb3ModGhpcy5lZGl0b3IsIGN1cik7XG4gICAgICAgIGlmICh0aGlzLnNraXBfa2VybmVsX2NvbXBsZXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoX2NvbXBsZXRpbmcoeyBjb250ZW50OiB7XG4gICAgICAgICAgICAgICAgbWF0Y2hlczogW10sXG4gICAgICAgICAgICAgICAgY3Vyc29yX3N0YXJ0OiBjdXJzb3JfcG9zLFxuICAgICAgICAgICAgICAgIGN1cnNvcl9lbmQ6IGN1cnNvcl9wb3MsXG4gICAgICAgICAgICB9fSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNlbGwua2VybmVsLmNvbXBsZXRlKHRoaXMuZWRpdG9yLmdldFZhbHVlKCksIGN1cnNvcl9wb3MsXG4gICAgICAgICAgICAgICAgJC5wcm94eSh0aGlzLmZpbmlzaF9jb21wbGV0aW5nLCB0aGlzKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBDb21wbGV0ZXIucHJvdG90eXBlLmZpbmlzaF9jb21wbGV0aW5nID0gZnVuY3Rpb24gKG1zZykge1xuICAgICAgICAvKipcbiAgICAgICAgICogbGV0J3MgYnVpbGQgYSBmdW5jdGlvbiB0aGF0IHdyYXAgYWxsIHRoYXQgc3R1ZmYgaW50byB3aGF0IGlzIG5lZWRlZFxuICAgICAgICAgKiBmb3IgdGhlIG5ldyBjb21wbGV0ZXI6XG4gICAgICAgICAqL1xuICAgICAgICB2YXIgY29udGVudCA9IG1zZy5jb250ZW50O1xuICAgICAgICB2YXIgc3RhcnQgPSBjb250ZW50LmN1cnNvcl9zdGFydDtcbiAgICAgICAgdmFyIGVuZCA9IGNvbnRlbnQuY3Vyc29yX2VuZDtcbiAgICAgICAgdmFyIG1hdGNoZXMgPSBjb250ZW50Lm1hdGNoZXM7XG5cbiAgICAgICAgdmFyIGN1ciA9IHRoaXMuZWRpdG9yLmdldEN1cnNvcigpO1xuICAgICAgICBpZiAoZW5kID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBhZGFwdGVkIG1lc3NhZ2Ugc3BlYyByZXBsaWVzIGRvbid0IGhhdmUgY3Vyc29yIHBvc2l0aW9uIGluZm8sXG4gICAgICAgICAgICAvLyBpbnRlcnByZXQgZW5kPW51bGwgYXMgY3VycmVudCBwb3NpdGlvbixcbiAgICAgICAgICAgIC8vIGFuZCBuZWdhdGl2ZSBzdGFydCByZWxhdGl2ZSB0byB0aGF0XG4gICAgICAgICAgICBlbmQgPSB1dGlscy50b19hYnNvbHV0ZV9jdXJzb3JfcG9zKHRoaXMuZWRpdG9yLCBjdXIpO1xuICAgICAgICAgICAgaWYgKHN0YXJ0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSBlbmQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0YXJ0IDwgMCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gZW5kICsgc3RhcnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdHMgPSBDb2RlTWlycm9yLmNvbnRleHRIaW50KHRoaXMuZWRpdG9yKTtcbiAgICAgICAgdmFyIGZpbHRlcmVkX3Jlc3VsdHMgPSBbXTtcbiAgICAgICAgLy9yZW1vdmUgcmVzdWx0cyBmcm9tIGNvbnRleHQgY29tcGxldGlvblxuICAgICAgICAvL3RoYXQgYXJlIGFscmVhZHkgaW4ga2VybmVsIGNvbXBsZXRpb25cbiAgICAgICAgdmFyIGk7XG4gICAgICAgIGZvciAoaT0wOyBpIDwgcmVzdWx0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKCFfZXhpc3RpbmdfY29tcGxldGlvbihyZXN1bHRzW2ldLnN0ciwgbWF0Y2hlcykpIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXJlZF9yZXN1bHRzLnB1c2gocmVzdWx0c1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhcHBlbmQgdGhlIGludHJvc3BlY3Rpb24gcmVzdWx0LCBpbiBvcmRlciwgYXQgYXQgdGhlIGJlZ2lubmluZyBvZlxuICAgICAgICAvLyB0aGUgdGFibGUgYW5kIGNvbXB1dGUgdGhlIHJlcGxhY2VtZW50IHJhbmdlIGZyb20gY3VycmVudCBjdXJzb3JcbiAgICAgICAgLy8gcG9zaXRvbiBhbmQgbWF0Y2hlZF90ZXh0IGxlbmd0aC5cbiAgICAgICAgdmFyIGZyb20gPSB1dGlscy5mcm9tX2Fic29sdXRlX2N1cnNvcl9wb3ModGhpcy5lZGl0b3IsIHN0YXJ0KTtcbiAgICAgICAgdmFyIHRvID0gdXRpbHMuZnJvbV9hYnNvbHV0ZV9jdXJzb3JfcG9zKHRoaXMuZWRpdG9yLCBlbmQpO1xuICAgICAgICBmb3IgKGkgPSBtYXRjaGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICBmaWx0ZXJlZF9yZXN1bHRzLnVuc2hpZnQoe1xuICAgICAgICAgICAgICAgIHN0cjogbWF0Y2hlc1tpXSxcbiAgICAgICAgICAgICAgICB0eXBlOiBcImludHJvc3BlY3Rpb25cIixcbiAgICAgICAgICAgICAgICBmcm9tOiBmcm9tLFxuICAgICAgICAgICAgICAgIHRvOiB0b1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBvbmUgdGhlIDIgc291cmNlcyByZXN1bHRzIGhhdmUgYmVlbiBtZXJnZSwgZGVhbCB3aXRoIGl0XG4gICAgICAgIHRoaXMucmF3X3Jlc3VsdCA9IGZpbHRlcmVkX3Jlc3VsdHM7XG5cbiAgICAgICAgLy8gaWYgZW1wdHkgcmVzdWx0IHJldHVyblxuICAgICAgICBpZiAoIXRoaXMucmF3X3Jlc3VsdCB8fCAhdGhpcy5yYXdfcmVzdWx0Lmxlbmd0aCkgcmV0dXJuO1xuXG4gICAgICAgIC8vIFdoZW4gdGhlcmUgaXMgb25seSBvbmUgY29tcGxldGlvbiwgdXNlIGl0IGRpcmVjdGx5LlxuICAgICAgICBpZiAodGhpcy5hdXRvcGljayAmJiB0aGlzLnJhd19yZXN1bHQubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgIHRoaXMuaW5zZXJ0KHRoaXMucmF3X3Jlc3VsdFswXSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5yYXdfcmVzdWx0Lmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICAvLyB0ZXN0IGlmIGZpcnN0IGFuZCBvbmx5IGNvbXBsZXRpb24gdG90YWxseSBtYXRjaGVzXG4gICAgICAgICAgICAvLyB3aGF0IGlzIHR5cGVkLCBpbiB0aGlzIGNhc2UgZGlzbWlzc1xuICAgICAgICAgICAgdmFyIHN0ciA9IHRoaXMucmF3X3Jlc3VsdFswXS5zdHI7XG4gICAgICAgICAgICB2YXIgcHJlX2N1cnNvciA9IHRoaXMuZWRpdG9yLmdldFJhbmdlKHtcbiAgICAgICAgICAgICAgICBsaW5lOiBjdXIubGluZSxcbiAgICAgICAgICAgICAgICBjaDogY3VyLmNoIC0gc3RyLmxlbmd0aFxuICAgICAgICAgICAgfSwgY3VyKTtcbiAgICAgICAgICAgIGlmIChwcmVfY3Vyc29yID09IHN0cikge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMudmlzaWJsZSkge1xuICAgICAgICAgICAgdGhpcy5jb21wbGV0ZSA9ICQoJzxkaXYvPicpLmFkZENsYXNzKCdjb21wbGV0aW9ucycpO1xuICAgICAgICAgICAgdGhpcy5jb21wbGV0ZS5hdHRyKCdpZCcsICdjb21wbGV0ZScpO1xuXG4gICAgICAgICAgICAvLyBDdXJyZW50bHkgd2Via2l0IGRvZXNuJ3QgdXNlIHRoZSBzaXplIGF0dHIgY29ycmVjdGx5LiBTZWU6XG4gICAgICAgICAgICAvLyBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDU3OVxuICAgICAgICAgICAgdGhpcy5zZWwgPSAkKCc8c2VsZWN0Lz4nKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd0YWJpbmRleCcsIC0xKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdtdWx0aXBsZScsICd0cnVlJyk7XG4gICAgICAgICAgICB0aGlzLmNvbXBsZXRlLmFwcGVuZCh0aGlzLnNlbCk7XG4gICAgICAgICAgICB0aGlzLnZpc2libGUgPSB0cnVlO1xuICAgICAgICAgICAgJCgnYm9keScpLmFwcGVuZCh0aGlzLmNvbXBsZXRlKTtcblxuICAgICAgICAgICAgLy9idWlsZCB0aGUgY29udGFpbmVyXG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLnNlbC5kYmxjbGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhhdC5waWNrKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuc2VsLmZvY3VzKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aGF0LmVkaXRvci5mb2N1cygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVfa2V5ZG93biA9IGZ1bmN0aW9uIChjbSwgZXZlbnQpIHtcbiAgICAgICAgICAgICAgICB0aGF0LmtleWRvd24oZXZlbnQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuZWRpdG9yLm9uKCdrZXlkb3duJywgdGhpcy5faGFuZGxlX2tleWRvd24pO1xuICAgICAgICAgICAgdGhpcy5faGFuZGxlX2tleXByZXNzID0gZnVuY3Rpb24gKGNtLCBldmVudCkge1xuICAgICAgICAgICAgICAgIHRoYXQua2V5cHJlc3MoZXZlbnQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuZWRpdG9yLm9uKCdrZXlwcmVzcycsIHRoaXMuX2hhbmRsZV9rZXlwcmVzcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZWwuYXR0cignc2l6ZScsIE1hdGgubWluKDEwLCB0aGlzLnJhd19yZXN1bHQubGVuZ3RoKSk7XG5cbiAgICAgICAgLy8gQWZ0ZXIgZXZlcnl0aGluZyBpcyBvbiB0aGUgcGFnZSwgY29tcHV0ZSB0aGUgcG9zdGlvbi5cbiAgICAgICAgLy8gV2UgcHV0IGl0IGFib3ZlIHRoZSBjb2RlIGlmIGl0IGlzIHRvbyBjbG9zZSB0byB0aGUgYm90dG9tIG9mIHRoZSBwYWdlLlxuICAgICAgICB2YXIgcG9zID0gdGhpcy5lZGl0b3IuY3Vyc29yQ29vcmRzKFxuICAgICAgICAgICAgdXRpbHMuZnJvbV9hYnNvbHV0ZV9jdXJzb3JfcG9zKHRoaXMuZWRpdG9yLCBzdGFydClcbiAgICAgICAgKTtcbiAgICAgICAgdmFyIGxlZnQgPSBwb3MubGVmdC0zO1xuICAgICAgICB2YXIgdG9wO1xuICAgICAgICB2YXIgY2hlaWdodCA9IHRoaXMuY29tcGxldGUuaGVpZ2h0KCk7XG4gICAgICAgIHZhciB3aGVpZ2h0ID0gJCh3aW5kb3cpLmhlaWdodCgpO1xuICAgICAgICBpZiAocG9zLmJvdHRvbStjaGVpZ2h0KzUgPiB3aGVpZ2h0KSB7XG4gICAgICAgICAgICB0b3AgPSBwb3MudG9wLWNoZWlnaHQtNDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRvcCA9IHBvcy5ib3R0b20rMTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbXBsZXRlLmNzcygnbGVmdCcsIGxlZnQgKyAncHgnKTtcbiAgICAgICAgdGhpcy5jb21wbGV0ZS5jc3MoJ3RvcCcsIHRvcCArICdweCcpO1xuXG4gICAgICAgIC8vIENsZWFyIGFuZCBmaWxsIHRoZSBsaXN0LlxuICAgICAgICB0aGlzLnNlbC50ZXh0KCcnKTtcbiAgICAgICAgdGhpcy5idWlsZF9ndWlfbGlzdCh0aGlzLnJhd19yZXN1bHQpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgQ29tcGxldGVyLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbiAoY29tcGxldGlvbikge1xuICAgICAgICB0aGlzLmVkaXRvci5yZXBsYWNlUmFuZ2UoY29tcGxldGlvbi5zdHIsIGNvbXBsZXRpb24uZnJvbSwgY29tcGxldGlvbi50byk7XG4gICAgfTtcblxuICAgIENvbXBsZXRlci5wcm90b3R5cGUuYnVpbGRfZ3VpX2xpc3QgPSBmdW5jdGlvbiAoY29tcGxldGlvbnMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb21wbGV0aW9ucy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIG9wdCA9ICQoJzxvcHRpb24vPicpLnRleHQoY29tcGxldGlvbnNbaV0uc3RyKS5hZGRDbGFzcyhjb21wbGV0aW9uc1tpXS50eXBlKTtcbiAgICAgICAgICAgIHRoaXMuc2VsLmFwcGVuZChvcHQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VsLmNoaWxkcmVuKCkuZmlyc3QoKS5hdHRyKCdzZWxlY3RlZCcsICd0cnVlJyk7XG4gICAgICAgIHRoaXMuc2VsLnNjcm9sbFRvcCgwKTtcbiAgICB9O1xuXG4gICAgQ29tcGxldGVyLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcbiAgICAgICAgJCgnI2NvbXBsZXRlJykucmVtb3ZlKCk7XG4gICAgICAgIHRoaXMuZWRpdG9yLm9mZigna2V5ZG93bicsIHRoaXMuX2hhbmRsZV9rZXlkb3duKTtcbiAgICAgICAgdGhpcy5lZGl0b3Iub2ZmKCdrZXlwcmVzcycsIHRoaXMuX2hhbmRsZV9rZXlwcmVzcyk7XG4gICAgICAgIHRoaXMudmlzaWJsZSA9IGZhbHNlO1xuICAgIH07XG5cbiAgICBDb21wbGV0ZXIucHJvdG90eXBlLnBpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaW5zZXJ0KHRoaXMucmF3X3Jlc3VsdFt0aGlzLnNlbFswXS5zZWxlY3RlZEluZGV4XSk7XG4gICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICB9O1xuXG4gICAgQ29tcGxldGVyLnByb3RvdHlwZS5rZXlkb3duID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBjb2RlID0gZXZlbnQua2V5Q29kZTtcblxuICAgICAgICAvLyBFbnRlclxuICAgICAgICB2YXIgb3B0aW9ucztcbiAgICAgICAgdmFyIGluZGV4O1xuICAgICAgICBpZiAoY29kZSA9PSBrZXljb2Rlcy5lbnRlcikge1xuICAgICAgICAgICAgZXZlbnQuY29kZW1pcnJvcklnbm9yZSA9IHRydWU7XG4gICAgICAgICAgICBldmVudC5faXBrbUlnbm9yZSA9IHRydWU7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgdGhpcy5waWNrKCk7XG4gICAgICAgIC8vIEVzY2FwZSBvciBiYWNrc3BhY2VcbiAgICAgICAgfSBlbHNlIGlmIChjb2RlID09IGtleWNvZGVzLmVzYyB8fCBjb2RlID09IGtleWNvZGVzLmJhY2tzcGFjZSkge1xuICAgICAgICAgICAgZXZlbnQuY29kZW1pcnJvcklnbm9yZSA9IHRydWU7XG4gICAgICAgICAgICBldmVudC5faXBrbUlnbm9yZSA9IHRydWU7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPT0ga2V5Y29kZXMudGFiKSB7XG4gICAgICAgICAgICAvL2FsbCB0aGUgZmFzdGZvcndhcmRpbmcgb3BlcmF0aW9uLFxuICAgICAgICAgICAgLy9DaGVjayB0aGF0IHNoYXJlZCBzdGFydCBpcyBub3QgbnVsbCB3aGljaCBjYW4gYXBwZW5kIHdpdGggcHJlZml4ZWQgY29tcGxldGlvblxuICAgICAgICAgICAgLy8gbGlrZSAlcHlsYWIgLCBweWxhYiBoYXZlIG5vIHNocmVkIHN0YXJ0LCBhbmQgZmYgd2lsbCByZXN1bHQgaW4gcHk8dGFiPjx0YWI+XG4gICAgICAgICAgICAvLyB0byBlcmFzZSBweVxuICAgICAgICAgICAgdmFyIHNoID0gc2hhcmVkX3N0YXJ0KHRoaXMucmF3X3Jlc3VsdCwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoc2guc3RyICE9PSAnJykge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5zZXJ0KHNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgICAgIHRoaXMuY2Fycnlfb25fY29tcGxldGlvbigpO1xuICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPT0ga2V5Y29kZXMudXAgfHwgY29kZSA9PSBrZXljb2Rlcy5kb3duKSB7XG4gICAgICAgICAgICAvLyBuZWVkIHRvIGRvIHRoYXQgdG8gYmUgYWJsZSB0byBtb3ZlIHRoZSBhcnJvd1xuICAgICAgICAgICAgLy8gd2hlbiBvbiB0aGUgZmlyc3Qgb3IgbGFzdCBsaW5lIG9mbyBhIGNvZGUgY2VsbFxuICAgICAgICAgICAgZXZlbnQuY29kZW1pcnJvcklnbm9yZSA9IHRydWU7XG4gICAgICAgICAgICBldmVudC5faXBrbUlnbm9yZSA9IHRydWU7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICBvcHRpb25zID0gdGhpcy5zZWwuZmluZCgnb3B0aW9uJyk7XG4gICAgICAgICAgICBpbmRleCA9IHRoaXMuc2VsWzBdLnNlbGVjdGVkSW5kZXg7XG4gICAgICAgICAgICBpZiAoY29kZSA9PSBrZXljb2Rlcy51cCkge1xuICAgICAgICAgICAgICAgIGluZGV4LS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29kZSA9PSBrZXljb2Rlcy5kb3duKSB7XG4gICAgICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluZGV4ID0gTWF0aC5taW4oTWF0aC5tYXgoaW5kZXgsIDApLCBvcHRpb25zLmxlbmd0aC0xKTtcbiAgICAgICAgICAgIHRoaXMuc2VsWzBdLnNlbGVjdGVkSW5kZXggPSBpbmRleDtcbiAgICAgICAgfSBlbHNlIGlmIChjb2RlID09IGtleWNvZGVzLnBhZ2V1cCB8fCBjb2RlID09IGtleWNvZGVzLnBhZ2Vkb3duKSB7XG4gICAgICAgICAgICBldmVudC5faXBrbUlnbm9yZSA9IHRydWU7XG5cbiAgICAgICAgICAgIG9wdGlvbnMgPSB0aGlzLnNlbC5maW5kKCdvcHRpb24nKTtcbiAgICAgICAgICAgIGluZGV4ID0gdGhpcy5zZWxbMF0uc2VsZWN0ZWRJbmRleDtcbiAgICAgICAgICAgIGlmIChjb2RlID09IGtleWNvZGVzLnBhZ2V1cCkge1xuICAgICAgICAgICAgICAgIGluZGV4IC09IDEwOyAvLyBBcyAxMCBpcyB0aGUgaGFyZCBjb2RlZCBzaXplIG9mIHRoZSBkcm9wIGRvd24gbWVudVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbmRleCArPSAxMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluZGV4ID0gTWF0aC5taW4oTWF0aC5tYXgoaW5kZXgsIDApLCBvcHRpb25zLmxlbmd0aC0xKTtcbiAgICAgICAgICAgIHRoaXMuc2VsWzBdLnNlbGVjdGVkSW5kZXggPSBpbmRleDtcbiAgICAgICAgfSBlbHNlIGlmIChjb2RlID09IGtleWNvZGVzLmxlZnQgfHwgY29kZSA9PSBrZXljb2Rlcy5yaWdodCkge1xuICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIENvbXBsZXRlci5wcm90b3R5cGUua2V5cHJlc3MgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZJWE1FOiBUaGlzIGlzIGEgYmFuZC1haWQuXG4gICAgICAgICAqIG9uIGtleXByZXNzLCB0cmlnZ2VyIGluc2VydGlvbiBvZiBhIHNpbmdsZSBjaGFyYWN0ZXIuXG4gICAgICAgICAqIFRoaXMgc2ltdWxhdGVzIHRoZSBvbGQgYmVoYXZpb3Igb2YgY29tcGxldGlvbiBhcyB5b3UgdHlwZSxcbiAgICAgICAgICogYmVmb3JlIGV2ZW50cyB3ZXJlIGRpc2Nvbm5lY3RlZCBhbmQgQ29kZU1pcnJvciBzdG9wcGVkXG4gICAgICAgICAqIHJlY2VpdmluZyBldmVudHMgd2hpbGUgdGhlIGNvbXBsZXRlciBpcyBmb2N1c2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgdmFyIGNvZGUgPSBldmVudC5rZXlDb2RlO1xuICAgICAgICBcbiAgICAgICAgLy8gZG9uJ3QgaGFuZGxlIGtleXByZXNzIGlmIGl0J3Mgbm90IGEgY2hhcmFjdGVyIChhcnJvd3Mgb24gRkYpXG4gICAgICAgIC8vIG9yIEVOVEVSL1RBQlxuICAgICAgICBpZiAoZXZlbnQuY2hhckNvZGUgPT09IDAgfHxcbiAgICAgICAgICAgIGNvZGUgPT0ga2V5Y29kZXMudGFiIHx8XG4gICAgICAgICAgICBjb2RlID09IGtleWNvZGVzLmVudGVyXG4gICAgICAgICkgcmV0dXJuO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICB0aGlzLmVkaXRvci5mb2N1cygpO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoYXQuY2Fycnlfb25fY29tcGxldGlvbigpO1xuICAgICAgICB9LCA1MCk7XG4gICAgfTtcblxuICAgIGV4cG9ydHMuQ29tcGxldGVyID0gQ29tcGxldGVyO1xuIiwiLy8gQ29weXJpZ2h0IChjKSBKdXB5dGVyIERldmVsb3BtZW50IFRlYW0uXG4vLyBEaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIE1vZGlmaWVkIEJTRCBMaWNlbnNlLlxuXG4vLyBoaWdobHkgYWRhcHRlZCBmb3IgY29kZW1pcm9yIGpzaGludFxuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgdmFyIGZvckVhY2ggPSBmdW5jdGlvbihhcnIsIGYpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGUgPSBhcnIubGVuZ3RoOyBpIDwgZTsgKytpKSBmKGFycltpXSk7XG4gICAgfTtcblxuICAgIHZhciBhcnJheUNvbnRhaW5zID0gZnVuY3Rpb24oYXJyLCBpdGVtKSB7XG4gICAgICAgIGlmICghQXJyYXkucHJvdG90eXBlLmluZGV4T2YpIHtcbiAgICAgICAgICAgIHZhciBpID0gYXJyLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgICBpZiAoYXJyW2ldID09PSBpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyLmluZGV4T2YoaXRlbSkgIT0gLTE7XG4gICAgfTtcblxuICAgIENvZGVNaXJyb3IuY29udGV4dEhpbnQgPSBmdW5jdGlvbiAoZWRpdG9yKSB7XG4gICAgICAgIC8vIEZpbmQgdGhlIHRva2VuIGF0IHRoZSBjdXJzb3JcbiAgICAgICAgdmFyIGN1ciA9IGVkaXRvci5nZXRDdXJzb3IoKSxcbiAgICAgICAgICAgIHRva2VuID0gZWRpdG9yLmdldFRva2VuQXQoY3VyKSxcbiAgICAgICAgICAgIHRwcm9wID0gdG9rZW47XG4gICAgICAgIC8vIElmIGl0J3Mgbm90IGEgJ3dvcmQtc3R5bGUnIHRva2VuLCBpZ25vcmUgdGhlIHRva2VuLlxuICAgICAgICAvLyBJZiBpdCBpcyBhIHByb3BlcnR5LCBmaW5kIG91dCB3aGF0IGl0IGlzIGEgcHJvcGVydHkgb2YuXG4gICAgICAgIHZhciBsaXN0ID0gW107XG4gICAgICAgIHZhciBjbGlzdCA9IGdldENvbXBsZXRpb25zKHRva2VuLCBlZGl0b3IpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsaXN0LnB1c2goe1xuICAgICAgICAgICAgICAgIHN0cjogY2xpc3RbaV0sXG4gICAgICAgICAgICAgICAgdHlwZTogXCJjb250ZXh0XCIsXG4gICAgICAgICAgICAgICAgZnJvbToge1xuICAgICAgICAgICAgICAgICAgICBsaW5lOiBjdXIubGluZSxcbiAgICAgICAgICAgICAgICAgICAgY2g6IHRva2VuLnN0YXJ0XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0bzoge1xuICAgICAgICAgICAgICAgICAgICBsaW5lOiBjdXIubGluZSxcbiAgICAgICAgICAgICAgICAgICAgY2g6IHRva2VuLmVuZFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaXN0O1xuICAgIH07XG5cbiAgICAvLyBmaW5kIGFsbCAnd29yZHMnIG9mIGN1cnJlbnQgY2VsbFxuICAgIHZhciBnZXRBbGxUb2tlbnMgPSBmdW5jdGlvbiAoZWRpdG9yKSB7XG4gICAgICAgIHZhciBmb3VuZCA9IFtdO1xuXG4gICAgICAgIC8vIGFkZCB0byBmb3VuZCBpZiBub3QgYWxyZWFkeSBpbiBpdFxuXG5cbiAgICAgICAgZnVuY3Rpb24gbWF5YmVBZGQoc3RyKSB7XG4gICAgICAgICAgICBpZiAoIWFycmF5Q29udGFpbnMoZm91bmQsIHN0cikpIGZvdW5kLnB1c2goc3RyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGxvb3AgdGhyb3VnaCBhbGwgdG9rZW4gb24gYWxsIGxpbmVzXG4gICAgICAgIHZhciBsaW5lQ291bnQgPSBlZGl0b3IubGluZUNvdW50KCk7XG4gICAgICAgIC8vIGxvb3Agb24gbGluZVxuICAgICAgICBmb3IgKHZhciBsID0gMDsgbCA8IGxpbmVDb3VudDsgbCsrKSB7XG4gICAgICAgICAgICB2YXIgbGluZSA9IGVkaXRvci5nZXRMaW5lKGwpO1xuICAgICAgICAgICAgLy9sb29wIG9uIGNoYXJcbiAgICAgICAgICAgIGZvciAodmFyIGMgPSAxOyBjIDwgbGluZS5sZW5ndGg7IGMrKykge1xuICAgICAgICAgICAgICAgIHZhciB0ayA9IGVkaXRvci5nZXRUb2tlbkF0KHtcbiAgICAgICAgICAgICAgICAgICAgbGluZTogbCxcbiAgICAgICAgICAgICAgICAgICAgY2g6IGNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyBpZiB0b2tlbiBoYXMgYSBjbGFzcywgaXQgaGFzIGdlYXQgY2hhbmNlcyBvZiBiZWVpbmdcbiAgICAgICAgICAgICAgICAvLyBvZiBpbnRlcmVzdC4gQWRkIGl0IHRvIHRoZSBsaXN0IG9mIHBvc3NpYmxlIGNvbXBsZXRpb25zLlxuICAgICAgICAgICAgICAgIC8vIHdlIGNvdWxkIHNraXAgdG9rZW4gb2YgQ2xhc3NOYW1lICdjb21tZW50J1xuICAgICAgICAgICAgICAgIC8vIG9yICdudW1iZXInIGFuZCAnb3BlcmF0b3InXG4gICAgICAgICAgICAgICAgaWYgKHRrLmNsYXNzTmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBtYXliZUFkZCh0ay5zdHJpbmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBqdW1wIHRvIGNoYXIgYWZ0ZXIgZW5kIG9mIGN1cnJlbnQgdG9rZW5cbiAgICAgICAgICAgICAgICBjID0gdGsuZW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3VuZDtcbiAgICB9O1xuXG4gICAgdmFyIGdldENvbXBsZXRpb25zID0gZnVuY3Rpb24odG9rZW4sIGVkaXRvcikge1xuICAgICAgICB2YXIgY2FuZGlkYXRlcyA9IGdldEFsbFRva2VucyhlZGl0b3IpO1xuICAgICAgICAvLyBmaWx0ZXIgYWxsIHRva2VuIHRoYXQgaGF2ZSBhIGNvbW1vbiBzdGFydCAoYnV0IG5veCBleGFjdGx5KSB0aGUgbGVuZ2h0IG9mIHRoZSBjdXJyZW50IHRva2VuXG4gICAgICAgIHZhciBsYW1iZGEgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoeC5pbmRleE9mKHRva2VuLnN0cmluZykgPT09IDAgJiYgeCAhPSB0b2tlbi5zdHJpbmcpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgdmFyIGZpbHRlcmQgPSBjYW5kaWRhdGVzLmZpbHRlcihsYW1iZGEpO1xuICAgICAgICByZXR1cm4gZmlsdGVyZDtcbiAgICB9O1xuXG4gICAgZXhwb3J0cy5jb250ZXh0SGludCA9IENvZGVNaXJyb3IuY29udGV4dEhpbnQ7XG4iLCIvLyBDb3B5cmlnaHQgKGMpIEp1cHl0ZXIgRGV2ZWxvcG1lbnQgVGVhbS5cbi8vIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgTW9kaWZpZWQgQlNEIExpY2Vuc2UuXG4vKipcbiAqXG4gKlxuICogQG1vZHVsZSBrZXlib2FyZG1hbmFnZXJcbiAqIEBuYW1lc3BhY2Uga2V5Ym9hcmRtYW5hZ2VyXG4gKiBAY2xhc3MgS2V5Ym9hcmRNYW5hZ2VyXG4gKi9cbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgdXRpbHMgPSByZXF1aXJlKCdiYXNlL2pzL3V0aWxzJyk7XG4gICAgdmFyIGtleWJvYXJkID0gcmVxdWlyZSgnYmFzZS9qcy9rZXlib2FyZCcpO1xuXG4gICAgLy8gTWFpbiBrZXlib2FyZCBtYW5hZ2VyIGZvciB0aGUgbm90ZWJvb2tcbiAgICB2YXIga2V5Y29kZXMgPSBrZXlib2FyZC5rZXljb2RlcztcblxuICAgIHZhciBLZXlib2FyZE1hbmFnZXIgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBjbGFzcyB0byBkZWFsIHdpdGgga2V5Ym9hcmQgZXZlbnQgYW5kIHNob3J0Y3V0XG4gICAgICAgICAqXG4gICAgICAgICAqIEBjbGFzcyBLZXlib2FyZE1hbmFnZXJcbiAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAqIEBwYXJhbSBvcHRpb25zIHtkaWN0fSBEaWN0aW9uYXJ5IG9mIGtleXdvcmQgYXJndW1lbnRzIDpcbiAgICAgICAgICogICAgQHBhcmFtIG9wdGlvbnMuZXZlbnRzIHskKEV2ZW50cyl9IGluc3RhbmNlIFxuICAgICAgICAgKiAgICBAcGFyYW0gb3B0aW9ucy5wYWdlcjoge1BhZ2VyfSAgcGFnZXIgaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubW9kZSA9ICdjb21tYW5kJztcbiAgICAgICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5wYWdlciA9IG9wdGlvbnMucGFnZXI7XG4gICAgICAgIHRoaXMucXVpY2tfaGVscCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5ub3RlYm9vayA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5sYXN0X21vZGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuYmluZF9ldmVudHMoKTtcbiAgICAgICAgdGhpcy5lbnYgPSB7cGFnZXI6dGhpcy5wYWdlcn07XG4gICAgICAgIHRoaXMuYWN0aW9ucyA9IG9wdGlvbnMuYWN0aW9ucztcbiAgICAgICAgdGhpcy5jb21tYW5kX3Nob3J0Y3V0cyA9IG5ldyBrZXlib2FyZC5TaG9ydGN1dE1hbmFnZXIodW5kZWZpbmVkLCBvcHRpb25zLmV2ZW50cywgdGhpcy5hY3Rpb25zLCB0aGlzLmVudiApO1xuICAgICAgICB0aGlzLmNvbW1hbmRfc2hvcnRjdXRzLmFkZF9zaG9ydGN1dHModGhpcy5nZXRfZGVmYXVsdF9jb21tb25fc2hvcnRjdXRzKCkpO1xuICAgICAgICB0aGlzLmNvbW1hbmRfc2hvcnRjdXRzLmFkZF9zaG9ydGN1dHModGhpcy5nZXRfZGVmYXVsdF9jb21tYW5kX3Nob3J0Y3V0cygpKTtcbiAgICAgICAgdGhpcy5lZGl0X3Nob3J0Y3V0cyA9IG5ldyBrZXlib2FyZC5TaG9ydGN1dE1hbmFnZXIodW5kZWZpbmVkLCBvcHRpb25zLmV2ZW50cywgdGhpcy5hY3Rpb25zLCB0aGlzLmVudik7XG4gICAgICAgIHRoaXMuZWRpdF9zaG9ydGN1dHMuYWRkX3Nob3J0Y3V0cyh0aGlzLmdldF9kZWZhdWx0X2NvbW1vbl9zaG9ydGN1dHMoKSk7XG4gICAgICAgIHRoaXMuZWRpdF9zaG9ydGN1dHMuYWRkX3Nob3J0Y3V0cyh0aGlzLmdldF9kZWZhdWx0X2VkaXRfc2hvcnRjdXRzKCkpO1xuICAgICAgICBPYmplY3Quc2VhbCh0aGlzKTtcbiAgICB9O1xuXG5cblxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgZGljdCBvZiBjb21tb24gc2hvcnRjdXRcbiAgICAgKiBAbWV0aG9kIGdldF9kZWZhdWx0X2NvbW1vbl9zaG9ydGN1dHNcbiAgICAgKlxuICAgICAqIEBleGFtcGxlIEV4YW1wbGUgb2YgcmV0dXJuZWQgc2hvcnRjdXRcbiAgICAgKiBgYGBcbiAgICAgKiAnc2hvcnRjdXQta2V5JzogJ2FjdGlvbi1uYW1lJ1xuICAgICAqIC8vIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgc2hvcnRjdXQgYXMgZGFzaCBzZXBhcmF0ZWQgdmFsdWUuXG4gICAgICogLy8gZS5nLiAnc2hpZnQnICwgJ3NoaWZ0LWVudGVyJywgJ2NtZC10J1xuICAgICAqYGBgXG4gICAgICovXG4gICAgS2V5Ym9hcmRNYW5hZ2VyLnByb3RvdHlwZS5nZXRfZGVmYXVsdF9jb21tb25fc2hvcnRjdXRzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnc2hpZnQnICAgICAgIDogJ2lweXRob24uaWdub3JlJyxcbiAgICAgICAgICAgICdzaGlmdC1lbnRlcicgOiAnaXB5dGhvbi5ydW4tc2VsZWN0LW5leHQnLFxuICAgICAgICAgICAgJ2N0cmwtZW50ZXInICA6ICdpcHl0aG9uLmV4ZWN1dGUtaW4tcGxhY2UnLFxuICAgICAgICAgICAgJ2FsdC1lbnRlcicgICA6ICdpcHl0aG9uLmV4ZWN1dGUtYW5kLWluc2VydC1hZnRlcicsXG4gICAgICAgICAgICAvLyBjbWQgb24gbWFjLCBjdHJsIG90aGVyd2lzZVxuICAgICAgICAgICAgJ2NtZHRybC1zJyAgICA6ICdpcHl0aG9uLnNhdmUtbm90ZWJvb2snLFxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICBLZXlib2FyZE1hbmFnZXIucHJvdG90eXBlLmdldF9kZWZhdWx0X2VkaXRfc2hvcnRjdXRzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnY21kdHJsLXNoaWZ0LXAnICAgICAgOiAnaXB5dGhvbi5jb21tYW5kLXBhbGV0dGUnLFxuICAgICAgICAgICAgJ2VzYycgICAgICAgICAgICAgICAgIDogJ2lweXRob24uZ28tdG8tY29tbWFuZC1tb2RlJyxcbiAgICAgICAgICAgICdjdHJsLW0nICAgICAgICAgICAgICA6ICdpcHl0aG9uLmdvLXRvLWNvbW1hbmQtbW9kZScsXG4gICAgICAgICAgICAndXAnICAgICAgICAgICAgICAgICAgOiAnaXB5dGhvbi5tb3ZlLWN1cnNvci11cC1vci1wcmV2aW91cy1jZWxsJyxcbiAgICAgICAgICAgICdkb3duJyAgICAgICAgICAgICAgICA6ICdpcHl0aG9uLm1vdmUtY3Vyc29yLWRvd24tb3ItbmV4dC1jZWxsJyxcbiAgICAgICAgICAgICdjdHJsLXNoaWZ0LS0nICAgICAgICA6ICdpcHl0aG9uLnNwbGl0LWNlbGwtYXQtY3Vyc29yJyxcbiAgICAgICAgICAgICdjdHJsLXNoaWZ0LXN1YnRyYWN0JyA6ICdpcHl0aG9uLnNwbGl0LWNlbGwtYXQtY3Vyc29yJyxcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgS2V5Ym9hcmRNYW5hZ2VyLnByb3RvdHlwZS5nZXRfZGVmYXVsdF9jb21tYW5kX3Nob3J0Y3V0cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2NtZHRybC1zaGlmdC1wJzogJ2lweXRob24uY29tbWFuZC1wYWxldHRlJyxcbiAgICAgICAgICAgICdzaGlmdC1zcGFjZSc6ICdpcHl0aG9uLnNjcm9sbC11cCcsXG4gICAgICAgICAgICAnc2hpZnQtdicgOiAnaXB5dGhvbi5wYXN0ZS1jZWxsLWJlZm9yZScsXG4gICAgICAgICAgICAnc2hpZnQtbScgOiAnaXB5dGhvbi5tZXJnZS1zZWxlY3RlZC1jZWxscycsXG4gICAgICAgICAgICAnc2hpZnQtbycgOiAnaXB5dGhvbi50b2dnbGUtb3V0cHV0LXNjcm9sbGluZy1zZWxlY3RlZC1jZWxsJyxcbiAgICAgICAgICAgICdlbnRlcicgOiAnaXB5dGhvbi5lbnRlci1lZGl0LW1vZGUnLFxuICAgICAgICAgICAgJ3NwYWNlJyA6ICdpcHl0aG9uLnNjcm9sbC1kb3duJyxcbiAgICAgICAgICAgICdkb3duJyA6ICdpcHl0aG9uLnNlbGVjdC1uZXh0LWNlbGwnLFxuICAgICAgICAgICAgJ2ksaScgOiAnaXB5dGhvbi5pbnRlcnJ1cHQta2VybmVsJyxcbiAgICAgICAgICAgICcwLDAnIDogJ2lweXRob24ucmVzdGFydC1rZXJuZWwnLFxuICAgICAgICAgICAgJ2QsZCcgOiAnaXB5dGhvbi5kZWxldGUtY2VsbCcsXG4gICAgICAgICAgICAnZXNjJzogJ2lweXRob24uY2xvc2UtcGFnZXInLFxuICAgICAgICAgICAgJ3VwJyA6ICdpcHl0aG9uLnNlbGVjdC1wcmV2aW91cy1jZWxsJyxcbiAgICAgICAgICAgICdrJyA6ICdpcHl0aG9uLnNlbGVjdC1wcmV2aW91cy1jZWxsJyxcbiAgICAgICAgICAgICdqJyA6ICdpcHl0aG9uLnNlbGVjdC1uZXh0LWNlbGwnLFxuICAgICAgICAgICAgJ3NoaWZ0LWsnOiAnaXB5dGhvbi5leHRlbmQtc2VsZWN0aW9uLXByZXZpb3VzJyxcbiAgICAgICAgICAgICdzaGlmdC1qJzogJ2lweXRob24uZXh0ZW5kLXNlbGVjdGlvbi1uZXh0JyxcbiAgICAgICAgICAgICd4JyA6ICdpcHl0aG9uLmN1dC1zZWxlY3RlZC1jZWxsJyxcbiAgICAgICAgICAgICdjJyA6ICdpcHl0aG9uLmNvcHktc2VsZWN0ZWQtY2VsbCcsXG4gICAgICAgICAgICAndicgOiAnaXB5dGhvbi5wYXN0ZS1jZWxsLWFmdGVyJyxcbiAgICAgICAgICAgICdhJyA6ICdpcHl0aG9uLmluc2VydC1jZWxsLWJlZm9yZScsXG4gICAgICAgICAgICAnYicgOiAnaXB5dGhvbi5pbnNlcnQtY2VsbC1hZnRlcicsXG4gICAgICAgICAgICAneScgOiAnaXB5dGhvbi5jaGFuZ2Utc2VsZWN0ZWQtY2VsbC10by1jb2RlLWNlbGwnLFxuICAgICAgICAgICAgJ20nIDogJ2lweXRob24uY2hhbmdlLXNlbGVjdGVkLWNlbGwtdG8tbWFya2Rvd24tY2VsbCcsXG4gICAgICAgICAgICAncicgOiAnaXB5dGhvbi5jaGFuZ2Utc2VsZWN0ZWQtY2VsbC10by1yYXctY2VsbCcsXG4gICAgICAgICAgICAnMScgOiAnaXB5dGhvbi5jaGFuZ2Utc2VsZWN0ZWQtY2VsbC10by1oZWFkaW5nLTEnLFxuICAgICAgICAgICAgJzInIDogJ2lweXRob24uY2hhbmdlLXNlbGVjdGVkLWNlbGwtdG8taGVhZGluZy0yJyxcbiAgICAgICAgICAgICczJyA6ICdpcHl0aG9uLmNoYW5nZS1zZWxlY3RlZC1jZWxsLXRvLWhlYWRpbmctMycsXG4gICAgICAgICAgICAnNCcgOiAnaXB5dGhvbi5jaGFuZ2Utc2VsZWN0ZWQtY2VsbC10by1oZWFkaW5nLTQnLFxuICAgICAgICAgICAgJzUnIDogJ2lweXRob24uY2hhbmdlLXNlbGVjdGVkLWNlbGwtdG8taGVhZGluZy01JyxcbiAgICAgICAgICAgICc2JyA6ICdpcHl0aG9uLmNoYW5nZS1zZWxlY3RlZC1jZWxsLXRvLWhlYWRpbmctNicsXG4gICAgICAgICAgICAnbycgOiAnaXB5dGhvbi50b2dnbGUtb3V0cHV0LXZpc2liaWxpdHktc2VsZWN0ZWQtY2VsbCcsXG4gICAgICAgICAgICAncycgOiAnaXB5dGhvbi5zYXZlLW5vdGVib29rJyxcbiAgICAgICAgICAgICdsJyA6ICdpcHl0aG9uLnRvZ2dsZS1saW5lLW51bWJlci1zZWxlY3RlZC1jZWxsJyxcbiAgICAgICAgICAgICdoJyA6ICdpcHl0aG9uLnNob3cta2V5Ym9hcmQtc2hvcnRjdXQtaGVscC1kaWFsb2cnLFxuICAgICAgICAgICAgJ3onIDogJ2lweXRob24udW5kby1sYXN0LWNlbGwtZGVsZXRpb24nLFxuICAgICAgICAgICAgJ3EnIDogJ2lweXRob24uY2xvc2UtcGFnZXInLFxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICBLZXlib2FyZE1hbmFnZXIucHJvdG90eXBlLmJpbmRfZXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgICQoZG9jdW1lbnQpLmtleWRvd24oZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBpZihldmVudC5faXBrbUlnbm9yZT09PXRydWV8fChldmVudC5vcmlnaW5hbEV2ZW50fHx7fSkuX2lwa21JZ25vcmU9PT10cnVlKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhhdC5oYW5kbGVfa2V5ZG93bihldmVudCk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBLZXlib2FyZE1hbmFnZXIucHJvdG90eXBlLnNldF9ub3RlYm9vayA9IGZ1bmN0aW9uIChub3RlYm9vaykge1xuICAgICAgICB0aGlzLm5vdGVib29rID0gbm90ZWJvb2s7XG4gICAgICAgIHRoaXMuYWN0aW9ucy5leHRlbmRfZW52KHtub3RlYm9vazpub3RlYm9va30pO1xuICAgIH07XG5cbiAgICBLZXlib2FyZE1hbmFnZXIucHJvdG90eXBlLnNldF9xdWlja2hlbHAgPSBmdW5jdGlvbiAobm90ZWJvb2spIHtcbiAgICAgICAgdGhpcy5hY3Rpb25zLmV4dGVuZF9lbnYoe3F1aWNrX2hlbHA6bm90ZWJvb2t9KTtcbiAgICB9O1xuXG5cbiAgICBLZXlib2FyZE1hbmFnZXIucHJvdG90eXBlLmhhbmRsZV9rZXlkb3duID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiAgcmV0dXJuaW5nIGZhbHNlIGZyb20gdGhpcyB3aWxsIHN0b3AgZXZlbnQgcHJvcGFnYXRpb25cbiAgICAgICAgICoqL1xuXG4gICAgICAgIGlmIChldmVudC53aGljaCA9PT0ga2V5Y29kZXMuZXNjKSB7XG4gICAgICAgICAgICAvLyBJbnRlcmNlcHQgZXNjYXBlIGF0IGhpZ2hlc3QgbGV2ZWwgdG8gYXZvaWQgY2xvc2luZ1xuICAgICAgICAgICAgLy8gd2Vic29ja2V0IGNvbm5lY3Rpb24gd2l0aCBmaXJlZm94XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlZCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LndoaWNoID09PSBrZXljb2Rlcy5lc2MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5vdGVib29rLmNvbW1hbmRfbW9kZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAodGhpcy5tb2RlID09PSAnZWRpdCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVkaXRfc2hvcnRjdXRzLmNhbGxfaGFuZGxlcihldmVudCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5tb2RlID09PSAnY29tbWFuZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbW1hbmRfc2hvcnRjdXRzLmNhbGxfaGFuZGxlcihldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIEtleWJvYXJkTWFuYWdlci5wcm90b3R5cGUuZWRpdF9tb2RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmxhc3RfbW9kZSA9IHRoaXMubW9kZTtcbiAgICAgICAgdGhpcy5tb2RlID0gJ2VkaXQnO1xuICAgIH07XG5cbiAgICBLZXlib2FyZE1hbmFnZXIucHJvdG90eXBlLmNvbW1hbmRfbW9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5sYXN0X21vZGUgPSB0aGlzLm1vZGU7XG4gICAgICAgIHRoaXMubW9kZSA9ICdjb21tYW5kJztcbiAgICB9O1xuXG4gICAgS2V5Ym9hcmRNYW5hZ2VyLnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gICAgfTtcblxuICAgIEtleWJvYXJkTWFuYWdlci5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5lbmFibGVkID0gZmFsc2U7XG4gICAgfTtcblxuICAgIEtleWJvYXJkTWFuYWdlci5wcm90b3R5cGUucmVnaXN0ZXJfZXZlbnRzID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZSA9ICQoZSk7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgdmFyIGhhbmRsZV9mb2N1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoYXQuZGlzYWJsZSgpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgaGFuZGxlX2JsdXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGF0LmVuYWJsZSgpO1xuICAgICAgICB9O1xuICAgICAgICBlLm9uKCdmb2N1c2luJywgaGFuZGxlX2ZvY3VzKTtcbiAgICAgICAgZS5vbignZm9jdXNvdXQnLCBoYW5kbGVfYmx1cik7XG4gICAgICAgIC8vIFRPRE86IFZlcnkgc3RyYW5nZS4gVGhlIGZvY3Vzb3V0IGV2ZW50IGRvZXMgbm90IHNlZW0gZmlyZSBmb3IgdGhlIFxuICAgICAgICAvLyBib290c3RyYXAgdGV4dGJveGVzIG9uIEZGMjUmMjYuLi4gIFRoaXMgd29ya3MgYXJvdW5kIHRoYXQgYnkgXG4gICAgICAgIC8vIHJlZ2lzdGVyaW5nIGZvY3VzIGFuZCBibHVyIGV2ZW50cyByZWN1cnNpdmVseSBvbiBhbGwgaW5wdXRzIHdpdGhpblxuICAgICAgICAvLyByZWdpc3RlcmVkIGVsZW1lbnQuXG4gICAgICAgIGUuZmluZCgnaW5wdXQnKS5ibHVyKGhhbmRsZV9ibHVyKTtcbiAgICAgICAgZS5vbignRE9NTm9kZUluc2VydGVkJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gJChldmVudC50YXJnZXQpO1xuICAgICAgICAgICAgaWYgKHRhcmdldC5pcygnaW5wdXQnKSkge1xuICAgICAgICAgICAgICAgIHRhcmdldC5ibHVyKGhhbmRsZV9ibHVyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LmZpbmQoJ2lucHV0JykuYmx1cihoYW5kbGVfYmx1cik7ICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAvLyBUaGVyZSBhcmUgdGltZXMgKHJhd19pbnB1dCkgd2hlcmUgd2UgcmVtb3ZlIHRoZSBlbGVtZW50IGZyb20gdGhlIERPTSBiZWZvcmVcbiAgICAgICAgLy8gZm9jdXNvdXQgaXMgY2FsbGVkLiBJbiB0aGlzIGNhc2Ugd2UgYmluZCB0byB0aGUgcmVtb3ZlIGV2ZW50IG9mIGpRdWVyeVVJLFxuICAgICAgICAvLyB3aGljaCBnZXRzIHRyaWdnZXJlZCB1cG9uIHJlbW92YWwsIGlmZiBpdCBpcyBmb2N1c2VkIGF0IHRoZSB0aW1lLlxuICAgICAgICAvLyBpc19mb2N1c2VkIG11c3QgYmUgdXNlZCB0byBjaGVjayBmb3IgdGhlIGNhc2Ugd2hlcmUgYW4gZWxlbWVudCB3aXRoaW5cbiAgICAgICAgLy8gdGhlIGVsZW1lbnQgYmVpbmcgcmVtb3ZlZCBpcyBmb2N1c2VkLlxuICAgICAgICBlLm9uKCdyZW1vdmUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodXRpbHMuaXNfZm9jdXNlZChlWzBdKSkge1xuICAgICAgICAgICAgICAgIHRoYXQuZW5hYmxlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBleHBvcnRzLktleWJvYXJkTWFuYWdlciA9IEtleWJvYXJkTWFuYWdlcjtcbiIsIi8vIENvcHlyaWdodCAoYykgSnVweXRlciBEZXZlbG9wbWVudCBUZWFtLlxuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBNb2RpZmllZCBCU0QgTGljZW5zZS5cbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIHZhciB0b29sYmFyID0gcmVxdWlyZSgnLi90b29sYmFyJyk7XG4gICAgdmFyIGNlbGx0b29sYmFyID0gcmVxdWlyZSgnLi9jZWxsdG9vbGJhcicpO1xuICAgIHZhciBNYWluVG9vbEJhciA9IGZ1bmN0aW9uIChzZWxlY3Rvciwgb3B0aW9ucykge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29uc3RydWN0b3JcbiAgICAgICAgICpcbiAgICAgICAgICogUGFyYW1ldGVyczpcbiAgICAgICAgICogIHNlbGVjdG9yOiBzdHJpbmdcbiAgICAgICAgICogIG9wdGlvbnM6IGRpY3Rpb25hcnlcbiAgICAgICAgICogICAgICBEaWN0aW9uYXJ5IG9mIGtleXdvcmQgYXJndW1lbnRzLlxuICAgICAgICAgKiAgICAgICAgICBldmVudHM6ICQoRXZlbnRzKSBpbnN0YW5jZVxuICAgICAgICAgKiAgICAgICAgICBub3RlYm9vazogTm90ZWJvb2sgaW5zdGFuY2VcbiAgICAgICAgICoqL1xuICAgICAgICB0b29sYmFyLlRvb2xCYXIuYXBwbHkodGhpcywgW3NlbGVjdG9yLCBvcHRpb25zXSApO1xuICAgICAgICB0aGlzLmV2ZW50cyA9IG9wdGlvbnMuZXZlbnRzO1xuICAgICAgICB0aGlzLm5vdGVib29rID0gb3B0aW9ucy5ub3RlYm9vaztcbiAgICAgICAgdGhpcy5fbWFrZSgpO1xuICAgICAgICBPYmplY3Quc2VhbCh0aGlzKTtcbiAgICB9O1xuXG4gICAgTWFpblRvb2xCYXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0b29sYmFyLlRvb2xCYXIucHJvdG90eXBlKTtcblxuICAgIE1haW5Ub29sQmFyLnByb3RvdHlwZS5fbWFrZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGdycHMgPSBbXG4gICAgICAgICAgW1xuICAgICAgICAgICAgWydpcHl0aG9uLnNhdmUtbm90ZWJvb2snXSxcbiAgICAgICAgICAgICdzYXZlLW5vdGJvb2snXG4gICAgICAgICAgXSxcbiAgICAgICAgICBbXG4gICAgICAgICAgICBbJ2lweXRob24uaW5zZXJ0LWNlbGwtYWZ0ZXInXSxcbiAgICAgICAgICAgICdpbnNlcnRfYWJvdmVfYmVsb3cnXSxcbiAgICAgICAgICBbXG4gICAgICAgICAgICBbJ2lweXRob24uY3V0LXNlbGVjdGVkLWNlbGwnLFxuICAgICAgICAgICAgICdpcHl0aG9uLmNvcHktc2VsZWN0ZWQtY2VsbCcsXG4gICAgICAgICAgICAgJ2lweXRob24ucGFzdGUtY2VsbC1hZnRlcidcbiAgICAgICAgICAgIF0gLFxuICAgICAgICAgICAgJ2N1dF9jb3B5X3Bhc3RlJ10sXG4gICAgICAgICAgW1xuICAgICAgICAgICAgWydpcHl0aG9uLm1vdmUtc2VsZWN0ZWQtY2VsbC11cCcsXG4gICAgICAgICAgICAgJ2lweXRob24ubW92ZS1zZWxlY3RlZC1jZWxsLWRvd24nXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgJ21vdmVfdXBfZG93biddLFxuICAgICAgICAgIFsgWydpcHl0aG9uLnJ1bi1zZWxlY3QtbmV4dCcsXG4gICAgICAgICAgICAgJ2lweXRob24uaW50ZXJydXB0LWtlcm5lbCcsXG4gICAgICAgICAgICAgJ2lweXRob24ucmVzdGFydC1rZXJuZWwnXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgJ3J1bl9pbnQnXSxcbiAgICAgICAgIFsnPGFkZF9jZWxsdHlwZV9saXN0PiddLFxuICAgICAgICAgWyc8YWRkX2NlbGx0b29sYmFyX2xpc3Q+J10sXG4gICAgICAgICBbWydpcHl0aG9uLmNvbW1hbmQtcGFsZXR0ZSddXVxuICAgICAgICBdO1xuICAgICAgICB0aGlzLmNvbnN0cnVjdChncnBzKTtcbiAgICB9O1xuXG4gICAgLy8gYWRkIGEgY2VsbCB0eXBlIGRyb3AgZG93biB0byB0aGUgbWFpbnRvb2xiYXIuXG4gICAgLy8gdHJpZ2dlcmVkIHdoZW4gdGhlIHBzZXVkbyBhY3Rpb24gYDxhZGRfY2VsbHR5cGVfbGlzdD5gIGlzXG4gICAgLy8gZW5jb3VudGVyZWQgd2hlbiBidWlsZGluZyBhIHRvb2xiYXIuXG4gICAgTWFpblRvb2xCYXIucHJvdG90eXBlLl9wc2V1ZG9fYWN0aW9ucy5hZGRfY2VsbHR5cGVfbGlzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICB2YXIgc2VsID0gJCgnPHNlbGVjdC8+JylcbiAgICAgICAgICAgIC5hdHRyKCdpZCcsJ2NlbGxfdHlwZScpXG4gICAgICAgICAgICAuYWRkQ2xhc3MoJ2Zvcm0tY29udHJvbCBzZWxlY3QteHMnKVxuICAgICAgICAgICAgLmFwcGVuZCgkKCc8b3B0aW9uLz4nKS5hdHRyKCd2YWx1ZScsJ2NvZGUnKS50ZXh0KCdDb2RlJykpXG4gICAgICAgICAgICAuYXBwZW5kKCQoJzxvcHRpb24vPicpLmF0dHIoJ3ZhbHVlJywnbWFya2Rvd24nKS50ZXh0KCdNYXJrZG93bicpKVxuICAgICAgICAgICAgLmFwcGVuZCgkKCc8b3B0aW9uLz4nKS5hdHRyKCd2YWx1ZScsJ3JhdycpLnRleHQoJ1JhdyBOQkNvbnZlcnQnKSlcbiAgICAgICAgICAgIC5hcHBlbmQoJCgnPG9wdGlvbi8+JykuYXR0cigndmFsdWUnLCdoZWFkaW5nJykudGV4dCgnSGVhZGluZycpKTtcbiAgICAgICAgdGhpcy5ub3RlYm9vay5rZXlib2FyZF9tYW5hZ2VyLnJlZ2lzdGVyX2V2ZW50cyhzZWwpO1xuICAgICAgICB0aGlzLmV2ZW50cy5vbignc2VsZWN0ZWRfY2VsbF90eXBlX2NoYW5nZWQuTm90ZWJvb2snLCBmdW5jdGlvbiAoZXZlbnQsIGRhdGEpIHtcbiAgICAgICAgICAgIGlmIChkYXRhLmNlbGxfdHlwZSA9PT0gJ2hlYWRpbmcnKSB7XG4gICAgICAgICAgICAgICAgc2VsLnZhbCgnTWFya2Rvd24nKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VsLnZhbChkYXRhLmNlbGxfdHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBzZWwuY2hhbmdlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjZWxsX3R5cGUgPSAkKHRoaXMpLnZhbCgpO1xuICAgICAgICAgICAgc3dpdGNoIChjZWxsX3R5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2NvZGUnOlxuICAgICAgICAgICAgICAgIHRoYXQubm90ZWJvb2sudG9fY29kZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbWFya2Rvd24nOlxuICAgICAgICAgICAgICAgIHRoYXQubm90ZWJvb2sudG9fbWFya2Rvd24oKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3Jhdyc6XG4gICAgICAgICAgICAgICAgdGhhdC5ub3RlYm9vay50b19yYXcoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2hlYWRpbmcnOlxuICAgICAgICAgICAgICAgIHRoYXQubm90ZWJvb2suX3dhcm5faGVhZGluZygpO1xuICAgICAgICAgICAgICAgIHRoYXQubm90ZWJvb2sudG9faGVhZGluZygpO1xuICAgICAgICAgICAgICAgIHNlbC52YWwoJ21hcmtkb3duJyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwidW5yZWNvZ25pemVkIGNlbGwgdHlwZTpcIiwgY2VsbF90eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoYXQubm90ZWJvb2suZm9jdXNfY2VsbCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHNlbDtcblxuICAgIH07XG5cbiAgICBNYWluVG9vbEJhci5wcm90b3R5cGUuX3BzZXVkb19hY3Rpb25zLmFkZF9jZWxsdG9vbGJhcl9saXN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbGFiZWwgPSAkKCc8c3Bhbi8+JykuYWRkQ2xhc3MoXCJuYXZiYXItdGV4dFwiKS50ZXh0KCdDZWxsIFRvb2xiYXI6Jyk7XG4gICAgICAgIHZhciBzZWxlY3QgPSAkKCc8c2VsZWN0Lz4nKVxuICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ2N0Yl9zZWxlY3QnKVxuICAgICAgICAgICAgLmFkZENsYXNzKCdmb3JtLWNvbnRyb2wgc2VsZWN0LXhzJylcbiAgICAgICAgICAgIC5hcHBlbmQoJCgnPG9wdGlvbi8+JykuYXR0cigndmFsdWUnLCAnJykudGV4dCgnTm9uZScpKTtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICBzZWxlY3QuY2hhbmdlKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciB2YWwgPSAkKHRoaXMpLnZhbCgpO1xuICAgICAgICAgICAgICAgIGlmICh2YWwgPT09JycpIHtcbiAgICAgICAgICAgICAgICAgICAgY2VsbHRvb2xiYXIuQ2VsbFRvb2xiYXIuZ2xvYmFsX2hpZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoYXQubm90ZWJvb2subWV0YWRhdGEuY2VsbHRvb2xiYXI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2VsbHRvb2xiYXIuQ2VsbFRvb2xiYXIuZ2xvYmFsX3Nob3coKTtcbiAgICAgICAgICAgICAgICAgICAgY2VsbHRvb2xiYXIuQ2VsbFRvb2xiYXIuYWN0aXZhdGVfcHJlc2V0KHZhbCwgdGhhdC5ldmVudHMpO1xuICAgICAgICAgICAgICAgICAgICB0aGF0Lm5vdGVib29rLm1ldGFkYXRhLmNlbGx0b29sYmFyID0gdmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGF0Lm5vdGVib29rLmZvY3VzX2NlbGwoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB0aGlzLm5vdGVib29rLmtleWJvYXJkX21hbmFnZXIucmVnaXN0ZXJfZXZlbnRzKHNlbGVjdCk7XG4gICAgICAgIC8vIFNldHVwIHRoZSBjdXJyZW50bHkgcmVnaXN0ZXJlZCBwcmVzZXRzLlxuICAgICAgICB2YXIgcHJlc2V0cyA9IGNlbGx0b29sYmFyLkNlbGxUb29sYmFyLmxpc3RfcHJlc2V0cygpO1xuICAgICAgICBmb3IgKHZhciBpPTA7IGk8cHJlc2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBwcmVzZXRzW2ldO1xuICAgICAgICAgICAgc2VsZWN0LmFwcGVuZCgkKCc8b3B0aW9uLz4nKS5hdHRyKCd2YWx1ZScsIG5hbWUpLnRleHQobmFtZSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNldHVwIGZ1dHVyZSBwcmVzZXQgcmVnaXN0cmF0aW9ucy5cbiAgICAgICAgdGhpcy5ldmVudHMub24oJ3ByZXNldF9hZGRlZC5DZWxsVG9vbGJhcicsIGZ1bmN0aW9uIChldmVudCwgZGF0YSkge1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBkYXRhLm5hbWU7XG4gICAgICAgICAgICBzZWxlY3QuYXBwZW5kKCQoJzxvcHRpb24vPicpLmF0dHIoJ3ZhbHVlJywgbmFtZSkudGV4dChuYW1lKSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmV2ZW50cy5vbigndW5yZWdpc3RlcmVkX3ByZXNldC5DZWxsVG9vbGJhcicsIGZ1bmN0aW9uIChldmVudCwgZGF0YSkge1xuICAgICAgICAgICAgaWYgKHNlbGVjdC52YWwoKSA9PT0gZGF0YS5uYW1lKXtcbiAgICAgICAgICAgICAgICBzZWxlY3QudmFsKCcnKTtcbiAgICAgICAgICAgICAgICBjZWxsdG9vbGJhci5DZWxsVG9vbGJhci5nbG9iYWxfaGlkZSgpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGF0Lm5vdGVib29rLm1ldGFkYXRhLmNlbGx0b29sYmFyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZWN0LmZpbmQoXCJvcHRpb25bdmFsdWU9J1wiK25hbWUrXCInXVwiICkucmVtb3ZlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBVcGRhdGUgc2VsZWN0IHZhbHVlIHdoZW4gYSBwcmVzZXQgaXMgYWN0aXZhdGVkLlxuICAgICAgICB0aGlzLmV2ZW50cy5vbigncHJlc2V0X2FjdGl2YXRlZC5DZWxsVG9vbGJhcicsIGZ1bmN0aW9uIChldmVudCwgZGF0YSkge1xuICAgICAgICAgICAgaWYgKHNlbGVjdC52YWwoKSAhPT0gZGF0YS5uYW1lKXtcbiAgICAgICAgICAgICAgICBzZWxlY3QudmFsKGRhdGEubmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciB3cmFwcGVyID0gJCgnPGRpdi8+JykuYWRkQ2xhc3MoJ2J0bi1ncm91cCcpO1xuICAgICAgICB3cmFwcGVyLmFwcGVuZChsYWJlbCkuYXBwZW5kKHNlbGVjdCk7XG4gICAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgIH07XG5cbiAgICBleHBvcnRzLk1haW5Ub29sQmFyID0gTWFpblRvb2xCYXI7XG4iLCIvLyBDb3B5cmlnaHQgKGMpIEp1cHl0ZXIgRGV2ZWxvcG1lbnQgVGVhbS5cbi8vIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgTW9kaWZpZWQgQlNEIExpY2Vuc2UuXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICB2YXIgdXRpbHMgPSByZXF1aXJlKCdiYXNlL2pzL3V0aWxzJyk7XG4gICAgdmFyIGRpYWxvZyA9IHJlcXVpcmUoJ2Jhc2UvanMvZGlhbG9nJyk7XG5cbiAgICB2YXIgaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHdpbmRvdy5NYXRoSmF4KSB7XG4gICAgICAgICAgICAvLyBNYXRoSmF4IGxvYWRlZFxuICAgICAgICAgICAgTWF0aEpheC5IdWIuQ29uZmlnKHtcbiAgICAgICAgICAgICAgICB0ZXgyamF4OiB7XG4gICAgICAgICAgICAgICAgICAgIGlubGluZU1hdGg6IFsgWyckJywnJCddLCBbXCJcXFxcKFwiLFwiXFxcXClcIl0gXSxcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheU1hdGg6IFsgWyckJCcsJyQkJ10sIFtcIlxcXFxbXCIsXCJcXFxcXVwiXSBdLFxuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzRXNjYXBlczogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc0Vudmlyb25tZW50czogdHJ1ZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgLy8gQ2VudGVyIGp1c3RpZnkgZXF1YXRpb25zIGluIGNvZGUgYW5kIG1hcmtkb3duIGNlbGxzLiBFbHNld2hlcmVcbiAgICAgICAgICAgICAgICAvLyB3ZSB1c2UgQ1NTIHRvIGxlZnQganVzdGlmeSBzaW5nbGUgbGluZSBlcXVhdGlvbnMgaW4gY29kZSBjZWxscy5cbiAgICAgICAgICAgICAgICBkaXNwbGF5QWxpZ246ICdjZW50ZXInLFxuICAgICAgICAgICAgICAgIFwiSFRNTC1DU1NcIjoge1xuICAgICAgICAgICAgICAgICAgICBhdmFpbGFibGVGb250czogW10sXG4gICAgICAgICAgICAgICAgICAgIGltYWdlRm9udDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgcHJlZmVycmVkRm9udDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgd2ViRm9udDogXCJTVElYLVdlYlwiLFxuICAgICAgICAgICAgICAgICAgICBzdHlsZXM6IHsnLk1hdGhKYXhfRGlzcGxheSc6IHtcIm1hcmdpblwiOiAwfX0sXG4gICAgICAgICAgICAgICAgICAgIGxpbmVicmVha3M6IHsgYXV0b21hdGljOiB0cnVlIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIE1hdGhKYXguSHViLkNvbmZpZ3VyZWQoKTtcbiAgICAgICAgfSBlbHNlIGlmICh3aW5kb3cubWF0aGpheF91cmwgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIC8vIERvbid0IGhhdmUgTWF0aEpheCwgYnV0IHNob3VsZC4gU2hvdyBkaWFsb2cuXG4gICAgICAgICAgICBkaWFsb2cubW9kYWwoe1xuICAgICAgICAgICAgICAgIHRpdGxlIDogXCJGYWlsZWQgdG8gcmV0cmlldmUgTWF0aEpheCBmcm9tICdcIiArIHdpbmRvdy5tYXRoamF4X3VybCArIFwiJ1wiLFxuICAgICAgICAgICAgICAgIGJvZHkgOiAkKFwiPHAvPlwiKS5hZGRDbGFzcygnZGlhbG9nJykudGV4dChcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiTWF0aC9MYVRlWCByZW5kZXJpbmcgd2lsbCBiZSBkaXNhYmxlZC5cIlxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGJ1dHRvbnMgOiB7XG4gICAgICAgICAgICAgICAgICAgIE9LIDoge2NsYXNzOiBcImJ0bi1kYW5nZXJcIn1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBTb21lIG1hZ2ljIGZvciBkZWZlcnJpbmcgbWF0aGVtYXRpY2FsIGV4cHJlc3Npb25zIHRvIE1hdGhKYXhcbiAgICAvLyBieSBoaWRpbmcgdGhlbSBmcm9tIHRoZSBNYXJrZG93biBwYXJzZXIuXG4gICAgLy8gU29tZSBvZiB0aGUgY29kZSBoZXJlIGlzIGFkYXB0ZWQgd2l0aCBwZXJtaXNzaW9uIGZyb20gRGF2aWRlIENlcnZvbmVcbiAgICAvLyB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEFwYWNoZTIgbGljZW5zZSBnb3Zlcm5pbmcgdGhlIE1hdGhKYXggcHJvamVjdC5cbiAgICAvLyBPdGhlciBtaW5vciBtb2RpZmljYXRpb25zIGFyZSBhbHNvIGR1ZSB0byBTdGFja0V4Y2hhbmdlIGFuZCBhcmUgdXNlZCB3aXRoXG4gICAgLy8gcGVybWlzc2lvbi5cblxuICAgIHZhciBpbmxpbmUgPSBcIiRcIjsgLy8gdGhlIGlubGluZSBtYXRoIGRlbGltaXRlclxuXG4gICAgLy8gTUFUSFNQTElUIGNvbnRhaW5zIHRoZSBwYXR0ZXJuIGZvciBtYXRoIGRlbGltaXRlcnMgYW5kIHNwZWNpYWwgc3ltYm9sc1xuICAgIC8vIG5lZWRlZCBmb3Igc2VhcmNoaW5nIGZvciBtYXRoIGluIHRoZSB0ZXh0IGlucHV0LlxuICAgIHZhciBNQVRIU1BMSVQgPSAvKFxcJFxcJD98XFxcXCg/OmJlZ2lufGVuZClcXHtbYS16XSpcXCo/XFx9fFxcXFxbXFxcXHt9JF18W3t9XXwoPzpcXG5cXHMqKSt8QEBcXGQrQEApL2k7XG5cbiAgICAvLyAgVGhlIG1hdGggaXMgaW4gYmxvY2tzIGkgdGhyb3VnaCBqLCBzb1xuICAgIC8vICAgIGNvbGxlY3QgaXQgaW50byBvbmUgYmxvY2sgYW5kIGNsZWFyIHRoZSBvdGhlcnMuXG4gICAgLy8gIFJlcGxhY2UgJiwgPCwgYW5kID4gYnkgbmFtZWQgZW50aXRpZXMuXG4gICAgLy8gIEZvciBJRSwgcHV0IDxicj4gYXQgdGhlIGVuZHMgb2YgY29tbWVudHMgc2luY2UgSUUgcmVtb3ZlcyBcXG4uXG4gICAgLy8gIENsZWFyIHRoZSBjdXJyZW50IG1hdGggcG9zaXRpb25zIGFuZCBzdG9yZSB0aGUgaW5kZXggb2YgdGhlXG4gICAgLy8gICAgbWF0aCwgdGhlbiBwdXNoIHRoZSBtYXRoIHN0cmluZyBvbnRvIHRoZSBzdG9yYWdlIGFycmF5LlxuICAgIC8vICBUaGUgcHJlUHJvY2VzcyBmdW5jdGlvbiBpcyBjYWxsZWQgb24gYWxsIGJsb2NrcyBpZiBpdCBoYXMgYmVlbiBwYXNzZWQgaW5cbiAgICB2YXIgcHJvY2Vzc19tYXRoID0gZnVuY3Rpb24gKGksIGosIHByZV9wcm9jZXNzLCBtYXRoLCBibG9ja3MpIHtcbiAgICAgICAgdmFyIGJsb2NrID0gYmxvY2tzLnNsaWNlKGksIGogKyAxKS5qb2luKFwiXCIpLnJlcGxhY2UoLyYvZywgXCImYW1wO1wiKSAvLyB1c2UgSFRNTCBlbnRpdHkgZm9yICZcbiAgICAgICAgLnJlcGxhY2UoLzwvZywgXCImbHQ7XCIpIC8vIHVzZSBIVE1MIGVudGl0eSBmb3IgPFxuICAgICAgICAucmVwbGFjZSgvPi9nLCBcIiZndDtcIikgLy8gdXNlIEhUTUwgZW50aXR5IGZvciA+XG4gICAgICAgIDtcbiAgICAgICAgaWYgKHV0aWxzLmJyb3dzZXIgPT09ICdtc2llJykge1xuICAgICAgICAgICAgYmxvY2sgPSBibG9jay5yZXBsYWNlKC8oJVteXFxuXSopXFxuL2csIFwiJDE8YnIvPlxcblwiKTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoaiA+IGkpIHtcbiAgICAgICAgICAgIGJsb2Nrc1tqXSA9IFwiXCI7XG4gICAgICAgICAgICBqLS07XG4gICAgICAgIH1cbiAgICAgICAgYmxvY2tzW2ldID0gXCJAQFwiICsgbWF0aC5sZW5ndGggKyBcIkBAXCI7IC8vIHJlcGxhY2UgdGhlIGN1cnJlbnQgYmxvY2sgdGV4dCB3aXRoIGEgdW5pcXVlIHRhZyB0byBmaW5kIGxhdGVyXG4gICAgICAgIGlmIChwcmVfcHJvY2Vzcyl7XG4gICAgICAgICAgICBibG9jayA9IHByZV9wcm9jZXNzKGJsb2NrKTtcbiAgICAgICAgfVxuICAgICAgICBtYXRoLnB1c2goYmxvY2spO1xuICAgICAgICByZXR1cm4gYmxvY2tzO1xuICAgIH07XG5cbiAgICAvLyAgQnJlYWsgdXAgdGhlIHRleHQgaW50byBpdHMgY29tcG9uZW50IHBhcnRzIGFuZCBzZWFyY2hcbiAgICAvLyAgICB0aHJvdWdoIHRoZW0gZm9yIG1hdGggZGVsaW1pdGVycywgYnJhY2VzLCBsaW5lYnJlYWtzLCBldGMuXG4gICAgLy8gIE1hdGggZGVsaW1pdGVycyBtdXN0IG1hdGNoIGFuZCBicmFjZXMgbXVzdCBiYWxhbmNlLlxuICAgIC8vICBEb24ndCBhbGxvdyBtYXRoIHRvIHBhc3MgdGhyb3VnaCBhIGRvdWJsZSBsaW5lYnJlYWtcbiAgICAvLyAgICAod2hpY2ggd2lsbCBiZSBhIHBhcmFncmFwaCkuXG4gICAgLy9cbiAgICB2YXIgcmVtb3ZlX21hdGggPSBmdW5jdGlvbiAodGV4dCkge1xuICAgICAgICB2YXIgbWF0aCA9IFtdOyAvLyBzdG9yZXMgbWF0aCBzdHJpbmdzIGZvciBsYXRlclxuICAgICAgICB2YXIgc3RhcnQ7XG4gICAgICAgIHZhciBlbmQ7XG4gICAgICAgIHZhciBsYXN0O1xuICAgICAgICB2YXIgYnJhY2VzO1xuXG4gICAgICAgIC8vIEV4Y2VwdCBmb3IgZXh0cmVtZSBlZGdlIGNhc2VzLCB0aGlzIHNob3VsZCBjYXRjaCBwcmVjaXNlbHkgdGhvc2UgcGllY2VzIG9mIHRoZSBtYXJrZG93blxuICAgICAgICAvLyBzb3VyY2UgdGhhdCB3aWxsIGxhdGVyIGJlIHR1cm5lZCBpbnRvIGNvZGUgc3BhbnMuIFdoaWxlIE1hdGhKYXggd2lsbCBub3QgVGVYaWZ5IGNvZGUgc3BhbnMsXG4gICAgICAgIC8vIHdlIHN0aWxsIGhhdmUgdG8gY29uc2lkZXIgdGhlbSBhdCB0aGlzIHBvaW50OyB0aGUgZm9sbG93aW5nIGlzc3VlIGhhcyBoYXBwZW5lZCBzZXZlcmFsIHRpbWVzOlxuICAgICAgICAvL1xuICAgICAgICAvLyAgICAgYCRmb29gIGFuZCBgJGJhcmAgYXJlIHZhcmliYWxlcy4gIC0tPiAgPGNvZGU+JGZvbyBgIGFuZCBgJGJhcjwvY29kZT4gYXJlIHZhcmlhYmxlcy5cblxuICAgICAgICB2YXIgaGFzQ29kZVNwYW5zID0gL2AvLnRlc3QodGV4dCksXG4gICAgICAgICAgICBkZV90aWxkZTtcbiAgICAgICAgaWYgKGhhc0NvZGVTcGFucykge1xuICAgICAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZSgvfi9nLCBcIn5UXCIpLnJlcGxhY2UoLyhefFteXFxcXF0pKGArKShbXlxcbl0qP1teYFxcbl0pXFwyKD8hYCkvZ20sIGZ1bmN0aW9uICh3aG9sZW1hdGNoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdob2xlbWF0Y2gucmVwbGFjZSgvXFwkL2csIFwifkRcIik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRlX3RpbGRlID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGV4dC5yZXBsYWNlKC9+KFtURF0pL2csIGZ1bmN0aW9uICh3aG9sZW1hdGNoLCBjaGFyYWN0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBUOiBcIn5cIiwgRDogXCIkXCIgfVtjaGFyYWN0ZXJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVfdGlsZGUgPSBmdW5jdGlvbiAodGV4dCkgeyByZXR1cm4gdGV4dDsgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBibG9ja3MgPSB1dGlscy5yZWdleF9zcGxpdCh0ZXh0LnJlcGxhY2UoL1xcclxcbj8vZywgXCJcXG5cIiksTUFUSFNQTElUKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMSwgbSA9IGJsb2Nrcy5sZW5ndGg7IGkgPCBtOyBpICs9IDIpIHtcbiAgICAgICAgICAgIHZhciBibG9jayA9IGJsb2Nrc1tpXTtcbiAgICAgICAgICAgIGlmIChibG9jay5jaGFyQXQoMCkgPT09IFwiQFwiKSB7XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyAgVGhpbmdzIHRoYXQgbG9vayBsaWtlIG91ciBtYXRoIG1hcmtlcnMgd2lsbCBnZXRcbiAgICAgICAgICAgICAgICAvLyAgc3RvcmVkIGFuZCB0aGVuIHJldHJpZXZlZCBhbG9uZyB3aXRoIHRoZSBtYXRoLlxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgYmxvY2tzW2ldID0gXCJAQFwiICsgbWF0aC5sZW5ndGggKyBcIkBAXCI7XG4gICAgICAgICAgICAgICAgbWF0aC5wdXNoKGJsb2NrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyAgSWYgd2UgYXJlIGluIG1hdGgsIGxvb2sgZm9yIHRoZSBlbmQgZGVsaW1pdGVyLFxuICAgICAgICAgICAgICAgIC8vICAgIGJ1dCBkb24ndCBnbyBwYXN0IGRvdWJsZSBsaW5lIGJyZWFrcywgYW5kXG4gICAgICAgICAgICAgICAgLy8gICAgYW5kIGJhbGFuY2UgYnJhY2VzIHdpdGhpbiB0aGUgbWF0aC5cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIGlmIChibG9jayA9PT0gZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChicmFjZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3QgPSBpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tzID0gcHJvY2Vzc19tYXRoKHN0YXJ0LCBpLCBkZV90aWxkZSwgbWF0aCwgYmxvY2tzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ICA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQgICAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdCAgID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChibG9jay5tYXRjaCgvXFxuLipcXG4vKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobGFzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaSA9IGxhc3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICBibG9ja3MgPSBwcm9jZXNzX21hdGgoc3RhcnQsIGksIGRlX3RpbGRlLCBtYXRoLCBibG9ja3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgZW5kID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgbGFzdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGJyYWNlcyA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGJsb2NrID09PSBcIntcIikge1xuICAgICAgICAgICAgICAgICAgICBicmFjZXMrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYmxvY2sgPT09IFwifVwiICYmIGJyYWNlcykge1xuICAgICAgICAgICAgICAgICAgICBicmFjZXMtLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vICBMb29rIGZvciBtYXRoIHN0YXJ0IGRlbGltaXRlcnMgYW5kIHdoZW5cbiAgICAgICAgICAgICAgICAvLyAgICBmb3VuZCwgc2V0IHVwIHRoZSBlbmQgZGVsaW1pdGVyLlxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgaWYgKGJsb2NrID09PSBpbmxpbmUgfHwgYmxvY2sgPT09IFwiJCRcIikge1xuICAgICAgICAgICAgICAgICAgICBzdGFydCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIGVuZCA9IGJsb2NrO1xuICAgICAgICAgICAgICAgICAgICBicmFjZXMgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChibG9jay5zdWJzdHIoMSwgNSkgPT09IFwiYmVnaW5cIikge1xuICAgICAgICAgICAgICAgICAgICBzdGFydCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIGVuZCA9IFwiXFxcXGVuZFwiICsgYmxvY2suc3Vic3RyKDYpO1xuICAgICAgICAgICAgICAgICAgICBicmFjZXMgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobGFzdCkge1xuICAgICAgICAgICAgYmxvY2tzID0gcHJvY2Vzc19tYXRoKHN0YXJ0LCBsYXN0LCBkZV90aWxkZSwgbWF0aCwgYmxvY2tzKTtcbiAgICAgICAgICAgIHN0YXJ0ICA9IG51bGw7XG4gICAgICAgICAgICBlbmQgICAgPSBudWxsO1xuICAgICAgICAgICAgbGFzdCAgID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW2RlX3RpbGRlKGJsb2Nrcy5qb2luKFwiXCIpKSwgbWF0aF07XG4gICAgfTtcblxuICAgIC8vXG4gICAgLy8gIFB1dCBiYWNrIHRoZSBtYXRoIHN0cmluZ3MgdGhhdCB3ZXJlIHNhdmVkLFxuICAgIC8vICAgIGFuZCBjbGVhciB0aGUgbWF0aCBhcnJheSAobm8gbmVlZCB0byBrZWVwIGl0IGFyb3VuZCkuXG4gICAgLy9cbiAgICB2YXIgcmVwbGFjZV9tYXRoID0gZnVuY3Rpb24gKHRleHQsIG1hdGgpIHtcbiAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZSgvQEAoXFxkKylAQC9nLCBmdW5jdGlvbiAobWF0Y2gsIG4pIHtcbiAgICAgICAgICAgIHJldHVybiBtYXRoW25dO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBpbml0IDogaW5pdCxcbiAgICAgICAgcmVtb3ZlX21hdGggOiByZW1vdmVfbWF0aCxcbiAgICAgICAgcmVwbGFjZV9tYXRoIDogcmVwbGFjZV9tYXRoXG4gICAgfTtcbiIsIi8vIENvcHlyaWdodCAoYykgSnVweXRlciBEZXZlbG9wbWVudCBUZWFtLlxuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBNb2RpZmllZCBCU0QgTGljZW5zZS5cbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIHZhciBJUHl0aG9uID0gcmVxdWlyZSgnYmFzZS9qcy9uYW1lc3BhY2UnKTtcbiAgICB2YXIgZGlhbG9nID0gcmVxdWlyZSgnYmFzZS9qcy9kaWFsb2cnKTtcbiAgICB2YXIgdXRpbHMgPSByZXF1aXJlKCdiYXNlL2pzL3V0aWxzJyk7XG4gICAgdmFyIHRvdXIgPSByZXF1aXJlKCdub3RlYm9vay9qcy90b3VyJyk7XG4gICAgdmFyIG1vbWVudCA9IHJlcXVpcmUoJ21vbWVudCcpO1xuXG4gICAgdmFyIE1lbnVCYXIgPSBmdW5jdGlvbiAoc2VsZWN0b3IsIG9wdGlvbnMpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnN0cnVjdG9yXG4gICAgICAgICAqXG4gICAgICAgICAqIEEgTWVudUJhciBDbGFzcyB0byBnZW5lcmF0ZSB0aGUgbWVudWJhciBvZiBKdXB5dGVyIG5vdGVib29rXG4gICAgICAgICAqXG4gICAgICAgICAqIFBhcmFtZXRlcnM6XG4gICAgICAgICAqICBzZWxlY3Rvcjogc3RyaW5nXG4gICAgICAgICAqICBvcHRpb25zOiBkaWN0aW9uYXJ5XG4gICAgICAgICAqICAgICAgRGljdGlvbmFyeSBvZiBrZXl3b3JkIGFyZ3VtZW50cy5cbiAgICAgICAgICogICAgICAgICAgbm90ZWJvb2s6IE5vdGVib29rIGluc3RhbmNlXG4gICAgICAgICAqICAgICAgICAgIGNvbnRlbnRzOiBDb250ZW50TWFuYWdlciBpbnN0YW5jZVxuICAgICAgICAgKiAgICAgICAgICBldmVudHM6ICQoRXZlbnRzKSBpbnN0YW5jZVxuICAgICAgICAgKiAgICAgICAgICBzYXZlX3dpZGdldDogU2F2ZVdpZGdldCBpbnN0YW5jZVxuICAgICAgICAgKiAgICAgICAgICBxdWlja19oZWxwOiBRdWlja0hlbHAgaW5zdGFuY2VcbiAgICAgICAgICogICAgICAgICAgYmFzZV91cmwgOiBzdHJpbmdcbiAgICAgICAgICogICAgICAgICAgbm90ZWJvb2tfcGF0aCA6IHN0cmluZ1xuICAgICAgICAgKiAgICAgICAgICBub3RlYm9va19uYW1lIDogc3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgdGhpcy5iYXNlX3VybCA9IG9wdGlvbnMuYmFzZV91cmwgfHwgdXRpbHMuZ2V0X2JvZHlfZGF0YShcImJhc2VVcmxcIik7XG4gICAgICAgIHRoaXMuc2VsZWN0b3IgPSBzZWxlY3RvcjtcbiAgICAgICAgdGhpcy5ub3RlYm9vayA9IG9wdGlvbnMubm90ZWJvb2s7XG4gICAgICAgIHRoaXMuY29udGVudHMgPSBvcHRpb25zLmNvbnRlbnRzO1xuICAgICAgICB0aGlzLmV2ZW50cyA9IG9wdGlvbnMuZXZlbnRzO1xuICAgICAgICB0aGlzLnNhdmVfd2lkZ2V0ID0gb3B0aW9ucy5zYXZlX3dpZGdldDtcbiAgICAgICAgdGhpcy5xdWlja19oZWxwID0gb3B0aW9ucy5xdWlja19oZWxwO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnRvdXIgPSBuZXcgdG91ci5Ob3RlYm9va1RvdXIodGhpcy5ub3RlYm9vaywgdGhpcy5ldmVudHMpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLnRvdXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkZhaWxlZCB0byBpbnN0YW50aWF0ZSBOb3RlYm9vayBUb3VyXCIsIGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0b3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50ID0gJChzZWxlY3Rvcik7XG4gICAgICAgICAgICB0aGlzLnN0eWxlKCk7XG4gICAgICAgICAgICB0aGlzLmJpbmRfZXZlbnRzKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gVE9ETzogVGhpcyBoYXMgZGVmaW5pdGl2ZWx5IG5vdGhpbmcgdG8gZG8gd2l0aCBzdHlsZSAuLi5cbiAgICBNZW51QmFyLnByb3RvdHlwZS5zdHlsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICB0aGlzLmVsZW1lbnQuZmluZChcImxpXCIpLmNsaWNrKGZ1bmN0aW9uIChldmVudCwgdWkpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgc2VsZWN0ZWQgY2VsbCBsb3NlcyBmb2N1cyB3aGVuIHRoZSBtZW51IGlzIGVudGVyZWQsIHNvIHdlXG4gICAgICAgICAgICAgICAgLy8gcmUtc2VsZWN0IGl0IHVwb24gc2VsZWN0aW9uLlxuICAgICAgICAgICAgICAgIHZhciBpID0gdGhhdC5ub3RlYm9vay5nZXRfc2VsZWN0ZWRfaW5kZXgoKTtcbiAgICAgICAgICAgICAgICB0aGF0Lm5vdGVib29rLnNlbGVjdChpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgTWVudUJhci5wcm90b3R5cGUuX25iY29udmVydCA9IGZ1bmN0aW9uIChmb3JtYXQsIGRvd25sb2FkKSB7XG4gICAgICAgIGRvd25sb2FkID0gZG93bmxvYWQgfHwgZmFsc2U7XG4gICAgICAgIHZhciBub3RlYm9va19wYXRoID0gdGhpcy5ub3RlYm9vay5ub3RlYm9va19wYXRoO1xuICAgICAgICB2YXIgdXJsID0gdXRpbHMudXJsX2pvaW5fZW5jb2RlKFxuICAgICAgICAgICAgdGhpcy5iYXNlX3VybCxcbiAgICAgICAgICAgICduYmNvbnZlcnQnLFxuICAgICAgICAgICAgZm9ybWF0LFxuICAgICAgICAgICAgbm90ZWJvb2tfcGF0aFxuICAgICAgICApICsgXCI/ZG93bmxvYWQ9XCIgKyBkb3dubG9hZC50b1N0cmluZygpO1xuICAgICAgICBcbiAgICAgICAgdmFyIHcgPSB3aW5kb3cub3BlbignJywgSVB5dGhvbi5fdGFyZ2V0KTtcbiAgICAgICAgaWYgKHRoaXMubm90ZWJvb2suZGlydHkpIHtcbiAgICAgICAgICAgIHRoaXMubm90ZWJvb2suc2F2ZV9ub3RlYm9vaygpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdy5sb2NhdGlvbiA9IHVybDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdy5sb2NhdGlvbiA9IHVybDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBNZW51QmFyLnByb3RvdHlwZS5fc2l6ZV9oZWFkZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgLyoqIFxuICAgICAgICAgKiBVcGRhdGUgaGVhZGVyIHNwYWNlciBzaXplLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ldmVudHMudHJpZ2dlcigncmVzaXplLWhlYWRlci5QYWdlJyk7XG4gICAgfTtcblxuICAgIE1lbnVCYXIucHJvdG90eXBlLmJpbmRfZXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogIEZpbGVcbiAgICAgICAgICovXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgXG4gICAgICAgIHRoaXMuZWxlbWVudC5maW5kKCcjb3Blbl9ub3RlYm9vaycpLmNsaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSB1dGlscy51cmxfcGF0aF9zcGxpdCh0aGF0Lm5vdGVib29rLm5vdGVib29rX3BhdGgpWzBdO1xuICAgICAgICAgICAgd2luZG93Lm9wZW4odXRpbHMudXJsX2pvaW5fZW5jb2RlKHRoYXQuYmFzZV91cmwsICd0cmVlJywgcGFyZW50KSwgSVB5dGhvbi5fdGFyZ2V0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZWxlbWVudC5maW5kKCcjY29weV9ub3RlYm9vaycpLmNsaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGF0Lm5vdGVib29rLmRpcnR5KSB7XG4gICAgICAgICAgICAgICAgdGhhdC5ub3RlYm9vay5zYXZlX25vdGVib29rKHthc3luYyA6IGZhbHNlfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGF0Lm5vdGVib29rLmNvcHlfbm90ZWJvb2soKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZWxlbWVudC5maW5kKCcjZG93bmxvYWRfaXB5bmInKS5jbGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYmFzZV91cmwgPSB0aGF0Lm5vdGVib29rLmJhc2VfdXJsO1xuICAgICAgICAgICAgdmFyIG5vdGVib29rX3BhdGggPSB0aGF0Lm5vdGVib29rLm5vdGVib29rX3BhdGg7XG4gICAgICAgICAgICB2YXIgdyA9IHdpbmRvdy5vcGVuKCcnKTtcbiAgICAgICAgICAgIHZhciB1cmwgPSB1dGlscy51cmxfam9pbl9lbmNvZGUoYmFzZV91cmwsICdmaWxlcycsIG5vdGVib29rX3BhdGgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgJz9kb3dubG9hZD0xJztcbiAgICAgICAgICAgIGlmICh0aGF0Lm5vdGVib29rLmRpcnR5KSB7XG4gICAgICAgICAgICAgICAgdGhhdC5ub3RlYm9vay5zYXZlX25vdGVib29rKCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdy5sb2NhdGlvbiA9IHVybDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdy5sb2NhdGlvbiA9IHVybDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICB0aGlzLmVsZW1lbnQuZmluZCgnI3ByaW50X3ByZXZpZXcnKS5jbGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGF0Ll9uYmNvbnZlcnQoJ2h0bWwnLCBmYWxzZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuZWxlbWVudC5maW5kKCcjZG93bmxvYWRfaHRtbCcpLmNsaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoYXQuX25iY29udmVydCgnaHRtbCcsIHRydWUpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmVsZW1lbnQuZmluZCgnI2Rvd25sb2FkX21hcmtkb3duJykuY2xpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhhdC5fbmJjb252ZXJ0KCdtYXJrZG93bicsIHRydWUpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmVsZW1lbnQuZmluZCgnI2Rvd25sb2FkX3JzdCcpLmNsaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoYXQuX25iY29udmVydCgncnN0JywgdHJ1ZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuZWxlbWVudC5maW5kKCcjZG93bmxvYWRfcGRmJykuY2xpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhhdC5fbmJjb252ZXJ0KCdwZGYnLCB0cnVlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5lbGVtZW50LmZpbmQoJyNkb3dubG9hZF9zY3JpcHQnKS5jbGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGF0Ll9uYmNvbnZlcnQoJ3NjcmlwdCcsIHRydWUpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmVsZW1lbnQuZmluZCgnI3JlbmFtZV9ub3RlYm9vaycpLmNsaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoYXQuc2F2ZV93aWRnZXQucmVuYW1lX25vdGVib29rKHtub3RlYm9vazogdGhhdC5ub3RlYm9va30pO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmVsZW1lbnQuZmluZCgnI3NhdmVfY2hlY2twb2ludCcpLmNsaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoYXQubm90ZWJvb2suc2F2ZV9jaGVja3BvaW50KCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuZWxlbWVudC5maW5kKCcjcmVzdG9yZV9jaGVja3BvaW50JykuY2xpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmVsZW1lbnQuZmluZCgnI3RydXN0X25vdGVib29rJykuY2xpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhhdC5ub3RlYm9vay50cnVzdF9ub3RlYm9vaygpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5ldmVudHMub24oJ3RydXN0X2NoYW5nZWQuTm90ZWJvb2snLCBmdW5jdGlvbiAoZXZlbnQsIHRydXN0ZWQpIHtcbiAgICAgICAgICAgIGlmICh0cnVzdGVkKSB7XG4gICAgICAgICAgICAgICAgdGhhdC5lbGVtZW50LmZpbmQoJyN0cnVzdF9ub3RlYm9vaycpXG4gICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcyhcImRpc2FibGVkXCIpLm9mZignY2xpY2snKVxuICAgICAgICAgICAgICAgICAgICAuZmluZChcImFcIikudGV4dChcIlRydXN0ZWQgTm90ZWJvb2tcIik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoYXQuZWxlbWVudC5maW5kKCcjdHJ1c3Rfbm90ZWJvb2snKVxuICAgICAgICAgICAgICAgICAgICAucmVtb3ZlQ2xhc3MoXCJkaXNhYmxlZFwiKS5vbignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0Lm5vdGVib29rLnRydXN0X25vdGVib29rKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5maW5kKFwiYVwiKS50ZXh0KFwiVHJ1c3QgTm90ZWJvb2tcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuZWxlbWVudC5maW5kKCcja2lsbF9hbmRfZXhpdCcpLmNsaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjbG9zZV93aW5kb3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogYWxsb3cgY2xvc2luZyBvZiBuZXcgdGFicyBpbiBDaHJvbWl1bSwgaW1wb3NzaWJsZSBpbiBGRlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHdpbmRvdy5vcGVuKCcnLCAnX3NlbGYnLCAnJyk7XG4gICAgICAgICAgICAgICAgd2luZG93LmNsb3NlKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gZmluaXNoIHdpdGggY2xvc2Ugb24gc3VjY2VzcyBvciBmYWlsdXJlXG4gICAgICAgICAgICB0aGF0Lm5vdGVib29rLnNlc3Npb24uZGVsZXRlKGNsb3NlX3dpbmRvdywgY2xvc2Vfd2luZG93KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gRWRpdFxuICAgICAgICB0aGlzLmVsZW1lbnQuZmluZCgnI2N1dF9jZWxsJykuY2xpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhhdC5ub3RlYm9vay5jdXRfY2VsbCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5lbGVtZW50LmZpbmQoJyNjb3B5X2NlbGwnKS5jbGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGF0Lm5vdGVib29rLmNvcHlfY2VsbCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5lbGVtZW50LmZpbmQoJyNkZWxldGVfY2VsbCcpLmNsaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoYXQubm90ZWJvb2suZGVsZXRlX2NlbGwoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZWxlbWVudC5maW5kKCcjdW5kZWxldGVfY2VsbCcpLmNsaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoYXQubm90ZWJvb2sudW5kZWxldGVfY2VsbCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5lbGVtZW50LmZpbmQoJyNzcGxpdF9jZWxsJykuY2xpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhhdC5ub3RlYm9vay5zcGxpdF9jZWxsKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmVsZW1lbnQuZmluZCgnI21lcmdlX2NlbGxfYWJvdmUnKS5jbGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGF0Lm5vdGVib29rLm1lcmdlX2NlbGxfYWJvdmUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZWxlbWVudC5maW5kKCcjbWVyZ2VfY2VsbF9iZWxvdycpLmNsaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoYXQubm90ZWJvb2subWVyZ2VfY2VsbF9iZWxvdygpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5lbGVtZW50LmZpbmQoJyNtb3ZlX2NlbGxfdXAnKS5jbGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGF0Lm5vdGVib29rLm1vdmVfY2VsbF91cCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5lbGVtZW50LmZpbmQoJyNtb3ZlX2NlbGxfZG93bicpLmNsaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoYXQubm90ZWJvb2subW92ZV9jZWxsX2Rvd24oKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZWxlbWVudC5maW5kKCcjZWRpdF9uYl9tZXRhZGF0YScpLmNsaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoYXQubm90ZWJvb2suZWRpdF9tZXRhZGF0YSh7XG4gICAgICAgICAgICAgICAgbm90ZWJvb2s6IHRoYXQubm90ZWJvb2ssXG4gICAgICAgICAgICAgICAga2V5Ym9hcmRfbWFuYWdlcjogdGhhdC5ub3RlYm9vay5rZXlib2FyZF9tYW5hZ2VyfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgLy8gVmlld1xuICAgICAgICB0aGlzLmVsZW1lbnQuZmluZCgnI3RvZ2dsZV9oZWFkZXInKS5jbGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAkKCcjaGVhZGVyLWNvbnRhaW5lcicpLnRvZ2dsZSgpO1xuICAgICAgICAgICAgJCgnLmhlYWRlci1iYXInKS50b2dnbGUoKTtcbiAgICAgICAgICAgIHRoYXQuX3NpemVfaGVhZGVyKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmVsZW1lbnQuZmluZCgnI3RvZ2dsZV90b29sYmFyJykuY2xpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgJCgnZGl2I21haW50b29sYmFyJykudG9nZ2xlKCk7XG4gICAgICAgICAgICB0aGF0Ll9zaXplX2hlYWRlcigpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gSW5zZXJ0XG4gICAgICAgIHRoaXMuZWxlbWVudC5maW5kKCcjaW5zZXJ0X2NlbGxfYWJvdmUnKS5jbGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGF0Lm5vdGVib29rLmluc2VydF9jZWxsX2Fib3ZlKCdjb2RlJyk7XG4gICAgICAgICAgICB0aGF0Lm5vdGVib29rLnNlbGVjdF9wcmV2KCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmVsZW1lbnQuZmluZCgnI2luc2VydF9jZWxsX2JlbG93JykuY2xpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhhdC5ub3RlYm9vay5pbnNlcnRfY2VsbF9iZWxvdygnY29kZScpO1xuICAgICAgICAgICAgdGhhdC5ub3RlYm9vay5zZWxlY3RfbmV4dCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gQ2VsbFxuICAgICAgICB0aGlzLmVsZW1lbnQuZmluZCgnI3J1bl9jZWxsJykuY2xpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhhdC5ub3RlYm9vay5leGVjdXRlX2NlbGwoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZWxlbWVudC5maW5kKCcjcnVuX2NlbGxfc2VsZWN0X2JlbG93JykuY2xpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhhdC5ub3RlYm9vay5leGVjdXRlX2NlbGxfYW5kX3NlbGVjdF9iZWxvdygpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5lbGVtZW50LmZpbmQoJyNydW5fY2VsbF9pbnNlcnRfYmVsb3cnKS5jbGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGF0Lm5vdGVib29rLmV4ZWN1dGVfY2VsbF9hbmRfaW5zZXJ0X2JlbG93KCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmVsZW1lbnQuZmluZCgnI3J1bl9hbGxfY2VsbHMnKS5jbGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGF0Lm5vdGVib29rLmV4ZWN1dGVfYWxsX2NlbGxzKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmVsZW1lbnQuZmluZCgnI3J1bl9hbGxfY2VsbHNfYWJvdmUnKS5jbGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGF0Lm5vdGVib29rLmV4ZWN1dGVfY2VsbHNfYWJvdmUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZWxlbWVudC5maW5kKCcjcnVuX2FsbF9jZWxsc19iZWxvdycpLmNsaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoYXQubm90ZWJvb2suZXhlY3V0ZV9jZWxsc19iZWxvdygpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5lbGVtZW50LmZpbmQoJyN0b19jb2RlJykuY2xpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhhdC5ub3RlYm9vay50b19jb2RlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmVsZW1lbnQuZmluZCgnI3RvX21hcmtkb3duJykuY2xpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhhdC5ub3RlYm9vay50b19tYXJrZG93bigpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5lbGVtZW50LmZpbmQoJyN0b19yYXcnKS5jbGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGF0Lm5vdGVib29rLnRvX3JhdygpO1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuZWxlbWVudC5maW5kKCcjdG9nZ2xlX2N1cnJlbnRfb3V0cHV0JykuY2xpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhhdC5ub3RlYm9vay50b2dnbGVfb3V0cHV0KCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmVsZW1lbnQuZmluZCgnI3RvZ2dsZV9jdXJyZW50X291dHB1dF9zY3JvbGwnKS5jbGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGF0Lm5vdGVib29rLnRvZ2dsZV9vdXRwdXRfc2Nyb2xsKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmVsZW1lbnQuZmluZCgnI2NsZWFyX2N1cnJlbnRfb3V0cHV0JykuY2xpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhhdC5ub3RlYm9vay5jbGVhcl9vdXRwdXQoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICB0aGlzLmVsZW1lbnQuZmluZCgnI3RvZ2dsZV9hbGxfb3V0cHV0JykuY2xpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhhdC5ub3RlYm9vay50b2dnbGVfYWxsX291dHB1dCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5lbGVtZW50LmZpbmQoJyN0b2dnbGVfYWxsX291dHB1dF9zY3JvbGwnKS5jbGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGF0Lm5vdGVib29rLnRvZ2dsZV9hbGxfb3V0cHV0X3Njcm9sbCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5lbGVtZW50LmZpbmQoJyNjbGVhcl9hbGxfb3V0cHV0JykuY2xpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhhdC5ub3RlYm9vay5jbGVhcl9hbGxfb3V0cHV0KCk7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgLy8gS2VybmVsXG4gICAgICAgIHRoaXMuZWxlbWVudC5maW5kKCcjaW50X2tlcm5lbCcpLmNsaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoYXQubm90ZWJvb2sua2VybmVsLmludGVycnVwdCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5lbGVtZW50LmZpbmQoJyNyZXN0YXJ0X2tlcm5lbCcpLmNsaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoYXQubm90ZWJvb2sucmVzdGFydF9rZXJuZWwoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZWxlbWVudC5maW5kKCcjcmVjb25uZWN0X2tlcm5lbCcpLmNsaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoYXQubm90ZWJvb2sua2VybmVsLnJlY29ubmVjdCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gSGVscFxuICAgICAgICBpZiAodGhpcy50b3VyKSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuZmluZCgnI25vdGVib29rX3RvdXInKS5jbGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhhdC50b3VyLnN0YXJ0KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5maW5kKCcjbm90ZWJvb2tfdG91cicpLmFkZENsYXNzKFwiZGlzYWJsZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbGVtZW50LmZpbmQoJyNrZXlib2FyZF9zaG9ydGN1dHMnKS5jbGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGF0LnF1aWNrX2hlbHAuc2hvd19rZXlib2FyZF9zaG9ydGN1dHMoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICB0aGlzLnVwZGF0ZV9yZXN0b3JlX2NoZWNrcG9pbnQobnVsbCk7XG4gICAgICAgIFxuICAgICAgICB0aGlzLmV2ZW50cy5vbignY2hlY2twb2ludHNfbGlzdGVkLk5vdGVib29rJywgZnVuY3Rpb24gKGV2ZW50LCBkYXRhKSB7XG4gICAgICAgICAgICB0aGF0LnVwZGF0ZV9yZXN0b3JlX2NoZWNrcG9pbnQodGhhdC5ub3RlYm9vay5jaGVja3BvaW50cyk7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5ldmVudHMub24oJ2NoZWNrcG9pbnRfY3JlYXRlZC5Ob3RlYm9vaycsIGZ1bmN0aW9uIChldmVudCwgZGF0YSkge1xuICAgICAgICAgICAgdGhhdC51cGRhdGVfcmVzdG9yZV9jaGVja3BvaW50KHRoYXQubm90ZWJvb2suY2hlY2twb2ludHMpO1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuZXZlbnRzLm9uKCdub3RlYm9va19sb2FkZWQuTm90ZWJvb2snLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBsYW5naW5mbyA9IHRoYXQubm90ZWJvb2subWV0YWRhdGEubGFuZ3VhZ2VfaW5mbyB8fCB7fTtcbiAgICAgICAgICAgIHRoYXQudXBkYXRlX25iY29udmVydF9zY3JpcHQobGFuZ2luZm8pO1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuZXZlbnRzLm9uKCdrZXJuZWxfcmVhZHkuS2VybmVsJywgZnVuY3Rpb24oZXZlbnQsIGRhdGEpIHtcbiAgICAgICAgICAgIHZhciBsYW5naW5mbyA9IGRhdGEua2VybmVsLmluZm9fcmVwbHkubGFuZ3VhZ2VfaW5mbyB8fCB7fTtcbiAgICAgICAgICAgIHRoYXQudXBkYXRlX25iY29udmVydF9zY3JpcHQobGFuZ2luZm8pO1xuICAgICAgICAgICAgdGhhdC5hZGRfa2VybmVsX2hlbHBfbGlua3MoZGF0YS5rZXJuZWwuaW5mb19yZXBseS5oZWxwX2xpbmtzIHx8IFtdKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIE1lbnVCYXIucHJvdG90eXBlLnVwZGF0ZV9yZXN0b3JlX2NoZWNrcG9pbnQgPSBmdW5jdGlvbihjaGVja3BvaW50cykge1xuICAgICAgICB2YXIgdWwgPSB0aGlzLmVsZW1lbnQuZmluZChcIiNyZXN0b3JlX2NoZWNrcG9pbnRcIikuZmluZChcInVsXCIpO1xuICAgICAgICB1bC5lbXB0eSgpO1xuICAgICAgICBpZiAoIWNoZWNrcG9pbnRzIHx8IGNoZWNrcG9pbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdWwuYXBwZW5kKFxuICAgICAgICAgICAgICAgICQoXCI8bGkvPlwiKVxuICAgICAgICAgICAgICAgIC5hZGRDbGFzcyhcImRpc2FibGVkXCIpXG4gICAgICAgICAgICAgICAgLmFwcGVuZChcbiAgICAgICAgICAgICAgICAgICAgJChcIjxhLz5cIilcbiAgICAgICAgICAgICAgICAgICAgLnRleHQoXCJObyBjaGVja3BvaW50c1wiKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgY2hlY2twb2ludHMubWFwKGZ1bmN0aW9uIChjaGVja3BvaW50KSB7XG4gICAgICAgICAgICB2YXIgZCA9IG5ldyBEYXRlKGNoZWNrcG9pbnQubGFzdF9tb2RpZmllZCk7XG4gICAgICAgICAgICB1bC5hcHBlbmQoXG4gICAgICAgICAgICAgICAgJChcIjxsaS8+XCIpLmFwcGVuZChcbiAgICAgICAgICAgICAgICAgICAgJChcIjxhLz5cIilcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJocmVmXCIsIFwiI1wiKVxuICAgICAgICAgICAgICAgICAgICAudGV4dChtb21lbnQoZCkuZm9ybWF0KFwiTExMTFwiKSlcbiAgICAgICAgICAgICAgICAgICAgLmNsaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQubm90ZWJvb2sucmVzdG9yZV9jaGVja3BvaW50X2RpYWxvZyhjaGVja3BvaW50KTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgTWVudUJhci5wcm90b3R5cGUudXBkYXRlX25iY29udmVydF9zY3JpcHQgPSBmdW5jdGlvbihsYW5naW5mbykge1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoZSAnRG93bmxvYWQgYXMgZm9vJyBtZW51IG9wdGlvbiBmb3IgdGhlIHJlbGV2YW50IGxhbmd1YWdlLlxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIGVsID0gdGhpcy5lbGVtZW50LmZpbmQoJyNkb3dubG9hZF9zY3JpcHQnKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFNldCBtZW51IGVudHJ5IHRleHQgdG8gZS5nLiBcIlB5dGhvbiAoLnB5KVwiXG4gICAgICAgIHZhciBsYW5nbmFtZSA9IChsYW5naW5mby5uYW1lIHx8ICdTY3JpcHQnKTtcbiAgICAgICAgbGFuZ25hbWUgPSBsYW5nbmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKStsYW5nbmFtZS5zdWJzdHIoMSk7IC8vIENhcGl0YWxpc2VcbiAgICAgICAgZWwuZmluZCgnYScpLnRleHQobGFuZ25hbWUgKyAnICgnKyhsYW5naW5mby5maWxlX2V4dGVuc2lvbiB8fCAndHh0JykrJyknKTtcbiAgICB9O1xuXG4gICAgTWVudUJhci5wcm90b3R5cGUuYWRkX2tlcm5lbF9oZWxwX2xpbmtzID0gZnVuY3Rpb24oaGVscF9saW5rcykge1xuICAgICAgICAvKiogYWRkIGxpbmtzIGZyb20ga2VybmVsX2luZm8gdG8gdGhlIGhlbHAgbWVudSAqL1xuICAgICAgICB2YXIgZGl2aWRlciA9ICQoXCIja2VybmVsLWhlbHAtbGlua3NcIik7XG4gICAgICAgIGlmIChkaXZpZGVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gaW5zZXJ0IGtlcm5lbCBoZWxwIHNlY3Rpb24gYWJvdmUgYWJvdXQgbGlua1xuICAgICAgICAgICAgdmFyIGFib3V0ID0gJChcIiNub3RlYm9va19hYm91dFwiKS5wYXJlbnQoKTtcbiAgICAgICAgICAgIGRpdmlkZXIgPSAkKFwiPGxpPlwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdpZCcsIFwia2VybmVsLWhlbHAtbGlua3NcIilcbiAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoJ2RpdmlkZXInKTtcbiAgICAgICAgICAgIGFib3V0LnByZXYoKS5iZWZvcmUoZGl2aWRlcik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVtb3ZlIHByZXZpb3VzIGVudHJpZXNcbiAgICAgICAgd2hpbGUgKCFkaXZpZGVyLm5leHQoKS5oYXNDbGFzcygnZGl2aWRlcicpKSB7XG4gICAgICAgICAgICBkaXZpZGVyLm5leHQoKS5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVscF9saW5rcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIC8vIG5vIGhlbHAgbGlua3MsIHJlbW92ZSB0aGUgZGl2aWRlclxuICAgICAgICAgICAgZGl2aWRlci5yZW1vdmUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY3Vyc29yID0gZGl2aWRlcjtcbiAgICAgICAgaGVscF9saW5rcy5tYXAoZnVuY3Rpb24gKGxpbmspIHtcbiAgICAgICAgICAgIGN1cnNvci5hZnRlcigkKFwiPGxpPlwiKVxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJChcIjxhPlwiKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigndGFyZ2V0JywgJ19ibGFuaycpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0aXRsZScsICdPcGVucyBpbiBhIG5ldyB3aW5kb3cnKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignaHJlZicsIGxpbmsudXJsKVxuICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCQoXCI8aT5cIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcyhcImZhIGZhLWV4dGVybmFsLWxpbmsgbWVudS1pY29uIHB1bGwtcmlnaHRcIilcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCQoXCI8c3Bhbj5cIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC50ZXh0KGxpbmsudGV4dClcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjdXJzb3IgPSBjdXJzb3IubmV4dCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgfTtcblxuICAgIGV4cG9ydHMuTWVudUJhciA9IE1lbnVCYXI7XG4iLCIvLyBDb3B5cmlnaHQgKGMpIEp1cHl0ZXIgRGV2ZWxvcG1lbnQgVGVhbS5cbi8vIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgTW9kaWZpZWQgQlNEIExpY2Vuc2UuXG5cbi8qKlxuICogQG1vZHVsZSBub3RlYm9va1xuICovXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICB2YXIgSVB5dGhvbiA9IHJlcXVpcmUoJ2Jhc2UvanMvbmFtZXNwYWNlJyk7XG4gICAgdmFyIHV0aWxzID0gcmVxdWlyZSgnYmFzZS9qcy91dGlscycpO1xuICAgIHZhciBkaWFsb2cgPSByZXF1aXJlKCdiYXNlL2pzL2RpYWxvZycpO1xuICAgIHZhciBjZWxsbW9kID0gcmVxdWlyZSgnbm90ZWJvb2svanMvY2VsbCcpO1xuICAgIHZhciB0ZXh0Y2VsbCA9IHJlcXVpcmUoJ25vdGVib29rL2pzL3RleHRjZWxsJyk7XG4gICAgdmFyIGNvZGVjZWxsID0gcmVxdWlyZSgnbm90ZWJvb2svanMvY29kZWNlbGwnKTtcbiAgICB2YXIgbW9tZW50ID0gcmVxdWlyZSgnbW9tZW50Jyk7XG4gICAgdmFyIGNvbmZpZ21vZCA9IHJlcXVpcmUoJ3NlcnZpY2VzL2NvbmZpZycpO1xuICAgIHZhciBzZXNzaW9uID0gcmVxdWlyZSgnc2VydmljZXMvc2Vzc2lvbnMvc2Vzc2lvbicpO1xuICAgIHZhciBjZWxsdG9vbGJhciA9IHJlcXVpcmUoJ25vdGVib29rL2pzL2NlbGx0b29sYmFyJyk7XG4gICAgdmFyIG1hcmtlZCA9IHJlcXVpcmUoJ21hcmtlZCcpO1xuICAgIHZhciBtYXRoamF4dXRpbHMgPSByZXF1aXJlKCdub3RlYm9vay9qcy9tYXRoamF4dXRpbHMnKTtcbiAgICB2YXIga2V5Ym9hcmQgPSByZXF1aXJlKCdiYXNlL2pzL2tleWJvYXJkJyk7XG4gICAgdmFyIHRvb2x0aXAgPSByZXF1aXJlKCdub3RlYm9vay9qcy90b29sdGlwJyk7XG4gICAgdmFyIGRlZmF1bHRfY2VsbHRvb2xiYXIgPSByZXF1aXJlKCdub3RlYm9vay9qcy9jZWxsdG9vbGJhcnByZXNldHMvZGVmYXVsdCcpO1xuICAgIHZhciByYXdjZWxsX2NlbGx0b29sYmFyID0gcmVxdWlyZSgnbm90ZWJvb2svanMvY2VsbHRvb2xiYXJwcmVzZXRzL3Jhd2NlbGwnKTtcbiAgICB2YXIgc2xpZGVzaG93X2NlbGx0b29sYmFyID0gcmVxdWlyZSgnbm90ZWJvb2svanMvY2VsbHRvb2xiYXJwcmVzZXRzL3NsaWRlc2hvdycpO1xuICAgIHZhciBzY3JvbGxtYW5hZ2VyID0gcmVxdWlyZSgnbm90ZWJvb2svanMvc2Nyb2xsbWFuYWdlcicpO1xuICAgIHZhciBjb21tYW5kcGFsZXR0ZSA9IHJlcXVpcmUoJ25vdGVib29rL2pzL2NvbW1hbmRwYWxldHRlJyk7XG5cbiAgICAvKipcbiAgICAgKiBDb250YWlucyBhbmQgbWFuYWdlcyBjZWxscy5cbiAgICAgKiBAY2xhc3MgTm90ZWJvb2tcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgc2VsZWN0b3JcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gICAgICAgICAgb3B0aW9ucyAtIERpY3Rpb25hcnkgb2Yga2V5d29yZCBhcmd1bWVudHMuICBcbiAgICAgKiBAcGFyYW0ge2pRdWVyeX0gICAgICAgICAgb3B0aW9ucy5ldmVudHMgLSBzZWxlY3RvciBvZiBFdmVudHNcbiAgICAgKiBAcGFyYW0ge0tleWJvYXJkTWFuYWdlcn0gb3B0aW9ucy5rZXlib2FyZF9tYW5hZ2VyXG4gICAgICogQHBhcmFtIHtDb250ZW50c30gICAgICAgIG9wdGlvbnMuY29udGVudHNcbiAgICAgKiBAcGFyYW0ge1NhdmVXaWRnZXR9ICAgICAgb3B0aW9ucy5zYXZlX3dpZGdldFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSAgICAgICAgICBvcHRpb25zLmNvbmZpZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICBvcHRpb25zLmJhc2VfdXJsXG4gICAgICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgIG9wdGlvbnMubm90ZWJvb2tfcGF0aFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICBvcHRpb25zLm5vdGVib29rX25hbWVcbiAgICAgKi9cbiAgICB2YXIgTm90ZWJvb2sgPSBmdW5jdGlvbiAoc2VsZWN0b3IsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5jb25maWcgPSBvcHRpb25zLmNvbmZpZztcbiAgICAgICAgdGhpcy5jbGFzc19jb25maWcgPSBuZXcgY29uZmlnbW9kLkNvbmZpZ1dpdGhEZWZhdWx0cyh0aGlzLmNvbmZpZywgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTm90ZWJvb2sub3B0aW9uc19kZWZhdWx0LCAnTm90ZWJvb2snKTtcbiAgICAgICAgdGhpcy5iYXNlX3VybCA9IG9wdGlvbnMuYmFzZV91cmw7XG4gICAgICAgIHRoaXMubm90ZWJvb2tfcGF0aCA9IG9wdGlvbnMubm90ZWJvb2tfcGF0aDtcbiAgICAgICAgdGhpcy5ub3RlYm9va19uYW1lID0gb3B0aW9ucy5ub3RlYm9va19uYW1lO1xuICAgICAgICB0aGlzLmV2ZW50cyA9IG9wdGlvbnMuZXZlbnRzO1xuICAgICAgICB0aGlzLmtleWJvYXJkX21hbmFnZXIgPSBvcHRpb25zLmtleWJvYXJkX21hbmFnZXI7XG4gICAgICAgIHRoaXMuY29udGVudHMgPSBvcHRpb25zLmNvbnRlbnRzO1xuICAgICAgICB0aGlzLnNhdmVfd2lkZ2V0ID0gb3B0aW9ucy5zYXZlX3dpZGdldDtcbiAgICAgICAgdGhpcy50b29sdGlwID0gbmV3IHRvb2x0aXAuVG9vbHRpcCh0aGlzLmV2ZW50cyk7XG4gICAgICAgIHRoaXMud3NfdXJsID0gb3B0aW9ucy53c191cmw7XG4gICAgICAgIHRoaXMuX3Nlc3Npb25fc3RhcnRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sYXN0X21vZGlmaWVkID0gbnVsbDtcblxuICAgICAgICAvLyAgQ3JlYXRlIGRlZmF1bHQgc2Nyb2xsIG1hbmFnZXIuXG4gICAgICAgIHRoaXMuc2Nyb2xsX21hbmFnZXIgPSBuZXcgc2Nyb2xsbWFuYWdlci5TY3JvbGxNYW5hZ2VyKHRoaXMpO1xuXG4gICAgICAgIC8vIFRPRE86IFRoaXMgY29kZSBzbWVsbHMgKGFuZCB0aGUgb3RoZXIgYD0gdGhpc2AgbGluZSBhIGNvdXBsZSBsaW5lcyBkb3duKVxuICAgICAgICAvLyBXZSBuZWVkIGEgYmV0dGVyIHdheSB0byBkZWFsIHdpdGggY2lyY3VsYXIgaW5zdGFuY2UgcmVmZXJlbmNlcy5cbiAgICAgICAgdGhpcy5rZXlib2FyZF9tYW5hZ2VyLm5vdGVib29rID0gdGhpcztcbiAgICAgICAgdGhpcy5zYXZlX3dpZGdldC5ub3RlYm9vayA9IHRoaXM7XG4gICAgICAgIFxuICAgICAgICBtYXRoamF4dXRpbHMuaW5pdCgpO1xuXG4gICAgICAgIGlmIChtYXJrZWQpIHtcbiAgICAgICAgICAgIG1hcmtlZC5zZXRPcHRpb25zKHtcbiAgICAgICAgICAgICAgICBnZm0gOiB0cnVlLFxuICAgICAgICAgICAgICAgIHRhYmxlczogdHJ1ZSxcbiAgICAgICAgICAgICAgICAvLyBGSVhNRTogcHJvYmFibHkgd2FudCBjZW50cmFsIGNvbmZpZyBmb3IgQ29kZU1pcnJvciB0aGVtZSB3aGVuIHdlIGhhdmUganMgY29uZmlnXG4gICAgICAgICAgICAgICAgbGFuZ1ByZWZpeDogXCJjbS1zLWlweXRob24gbGFuZ3VhZ2UtXCIsXG4gICAgICAgICAgICAgICAgaGlnaGxpZ2h0OiBmdW5jdGlvbihjb2RlLCBsYW5nLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWxhbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vIGxhbmd1YWdlLCBubyBoaWdobGlnaHRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIGNvZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdXRpbHMucmVxdWlyZUNvZGVNaXJyb3JNb2RlKGxhbmcsIGZ1bmN0aW9uIChzcGVjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1vZGUgPSBDb2RlTWlycm9yLmdldE1vZGUoe30sIHNwZWMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJObyBDb2RlTWlycm9yIG1vZGU6IFwiICsgbGFuZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgY29kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBDb2RlTWlycm9yLnJ1bk1vZGUoY29kZSwgc3BlYywgZWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIGVsLmlubmVySFRNTCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkZhaWxlZCB0byBoaWdobGlnaHQgXCIgKyBsYW5nICsgXCIgY29kZVwiLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgY29kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTm8gQ29kZU1pcnJvciBtb2RlOiBcIiArIGxhbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyLCBjb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmVsZW1lbnQgPSAkKHNlbGVjdG9yKTtcbiAgICAgICAgdGhpcy5lbGVtZW50LnNjcm9sbCgpO1xuICAgICAgICB0aGlzLmVsZW1lbnQuZGF0YShcIm5vdGVib29rXCIsIHRoaXMpO1xuICAgICAgICB0aGlzLm5leHRfcHJvbXB0X251bWJlciA9IDE7XG4gICAgICAgIHRoaXMuc2Vzc2lvbiA9IG51bGw7XG4gICAgICAgIHRoaXMua2VybmVsID0gbnVsbDtcbiAgICAgICAgdGhpcy5rZXJuZWxfYnVzeSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNsaXBib2FyZCA9IG51bGw7XG4gICAgICAgIHRoaXMudW5kZWxldGVfYmFja3VwID0gbnVsbDtcbiAgICAgICAgdGhpcy51bmRlbGV0ZV9pbmRleCA9IG51bGw7XG4gICAgICAgIHRoaXMudW5kZWxldGVfYmVsb3cgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wYXN0ZV9lbmFibGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcbiAgICAgICAgLy8gSXQgaXMgaW1wb3J0YW50IHRvIHN0YXJ0IG91dCBpbiBjb21tYW5kIG1vZGUgdG8gbWF0Y2ggdGhlIGludGlhbCBtb2RlXG4gICAgICAgIC8vIG9mIHRoZSBLZXlib2FyZE1hbmFnZXIuXG4gICAgICAgIHRoaXMubW9kZSA9ICdjb21tYW5kJztcbiAgICAgICAgdGhpcy5zZXRfZGlydHkoZmFsc2UpO1xuICAgICAgICB0aGlzLm1ldGFkYXRhID0ge307XG4gICAgICAgIHRoaXMuX2NoZWNrcG9pbnRfYWZ0ZXJfc2F2ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxhc3RfY2hlY2twb2ludCA9IG51bGw7XG4gICAgICAgIHRoaXMuY2hlY2twb2ludHMgPSBbXTtcbiAgICAgICAgdGhpcy5hdXRvc2F2ZV9pbnRlcnZhbCA9IDA7XG4gICAgICAgIHRoaXMuYXV0b3NhdmVfdGltZXIgPSBudWxsO1xuICAgICAgICAvLyBhdXRvc2F2ZSAqYXQgbW9zdCogZXZlcnkgdHdvIG1pbnV0ZXNcbiAgICAgICAgdGhpcy5taW5pbXVtX2F1dG9zYXZlX2ludGVydmFsID0gMTIwMDAwO1xuICAgICAgICB0aGlzLm5vdGVib29rX25hbWVfYmxhY2tsaXN0X3JlID0gL1tcXC9cXFxcOl0vO1xuICAgICAgICB0aGlzLm5iZm9ybWF0ID0gNDsgLy8gSW5jcmVtZW50IHRoaXMgd2hlbiBjaGFuZ2luZyB0aGUgbmJmb3JtYXRcbiAgICAgICAgdGhpcy5uYmZvcm1hdF9taW5vciA9IHRoaXMuY3VycmVudF9uYmZvcm1hdF9taW5vciA9IDA7IC8vIEluY3JlbWVudCB0aGlzIHdoZW4gY2hhbmdpbmcgdGhlIG5iZm9ybWF0XG4gICAgICAgIHRoaXMuY29kZW1pcnJvcl9tb2RlID0gJ3RleHQnO1xuICAgICAgICB0aGlzLmNyZWF0ZV9lbGVtZW50cygpO1xuICAgICAgICB0aGlzLmJpbmRfZXZlbnRzKCk7XG4gICAgICAgIHRoaXMua2VybmVsX3NlbGVjdG9yID0gbnVsbDtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IG51bGw7XG4gICAgICAgIHRoaXMudHJ1c3RlZCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2Z1bGx5X2xvYWRlZCA9IGZhbHNlO1xuXG4gICAgICAgIC8vIFRyaWdnZXIgY2VsbCB0b29sYmFyIHJlZ2lzdHJhdGlvbi5cbiAgICAgICAgZGVmYXVsdF9jZWxsdG9vbGJhci5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgcmF3Y2VsbF9jZWxsdG9vbGJhci5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgc2xpZGVzaG93X2NlbGx0b29sYmFyLnJlZ2lzdGVyKHRoaXMpO1xuXG4gICAgICAgIC8vIHByZXZlbnQgYXNzaWduIHRvIG1pc3MtdHlwZWQgcHJvcGVydGllcy5cbiAgICAgICAgT2JqZWN0LnNlYWwodGhpcyk7XG4gICAgfTtcblxuICAgIE5vdGVib29rLm9wdGlvbnNfZGVmYXVsdCA9IHtcbiAgICAgICAgLy8gY2FuIGJlIGFueSBjZWxsIHR5cGUsIG9yIHRoZSBzcGVjaWFsIHZhbHVlcyBvZlxuICAgICAgICAvLyAnYWJvdmUnLCAnYmVsb3cnLCBvciAnc2VsZWN0ZWQnIHRvIGdldCB0aGUgdmFsdWUgZnJvbSBhbm90aGVyIGNlbGwuXG4gICAgICAgIGRlZmF1bHRfY2VsbF90eXBlOiAnY29kZSdcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuIEhUTUwgYW5kIENTUyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbm90ZWJvb2suXG4gICAgICovXG4gICAgTm90ZWJvb2sucHJvdG90eXBlLmNyZWF0ZV9lbGVtZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICB0aGlzLmVsZW1lbnQuYXR0cigndGFiaW5kZXgnLCctMScpO1xuICAgICAgICB0aGlzLmNvbnRhaW5lciA9ICQoXCI8ZGl2Lz5cIikuYWRkQ2xhc3MoXCJjb250YWluZXJcIikuYXR0cihcImlkXCIsIFwibm90ZWJvb2stY29udGFpbmVyXCIpO1xuICAgICAgICAvLyBXZSBhZGQgdGhpcyBlbmRfc3BhY2UgZGl2IHRvIHRoZSBlbmQgb2YgdGhlIG5vdGVib29rIGRpdiB0bzpcbiAgICAgICAgLy8gaSkgcHJvdmlkZSBhIG1hcmdpbiBiZXR3ZWVuIHRoZSBsYXN0IGNlbGwgYW5kIHRoZSBlbmQgb2YgdGhlIG5vdGVib29rXG4gICAgICAgIC8vIGlpKSB0byBwcmV2ZW50IHRoZSBkaXYgZnJvbSBzY3JvbGxpbmcgdXAgd2hlbiB0aGUgbGFzdCBjZWxsIGlzIGJlaW5nXG4gICAgICAgIC8vIGVkaXRlZCwgYnV0IGlzIHRvbyBsb3cgb24gdGhlIHBhZ2UsIHdoaWNoIGJyb3dzZXJzIHdpbGwgZG8gYXV0b21hdGljYWxseS5cbiAgICAgICAgdmFyIGVuZF9zcGFjZSA9ICQoJzxkaXYvPicpXG4gICAgICAgICAgICAuYWRkQ2xhc3MoJ2VuZF9zcGFjZScpO1xuICAgICAgICBlbmRfc3BhY2UuZGJsY2xpY2soZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciBuY2VsbHMgPSB0aGF0Lm5jZWxscygpO1xuICAgICAgICAgICAgdGhhdC5pbnNlcnRfY2VsbF9iZWxvdygnY29kZScsbmNlbGxzLTEpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5lbGVtZW50LmFwcGVuZCh0aGlzLmNvbnRhaW5lcik7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLmFmdGVyKGVuZF9zcGFjZSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEJpbmQgSmF2YVNjcmlwdCBldmVudHM6IGtleSBwcmVzc2VzIGFuZCBjdXN0b20gSnVweXRlciBldmVudHMuXG4gICAgICovXG4gICAgTm90ZWJvb2sucHJvdG90eXBlLmJpbmRfZXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy5ldmVudHMub24oJ3NldF9uZXh0X2lucHV0Lk5vdGVib29rJywgZnVuY3Rpb24gKGV2ZW50LCBkYXRhKSB7XG4gICAgICAgICAgICBpZiAoZGF0YS5yZXBsYWNlKSB7XG4gICAgICAgICAgICAgICAgZGF0YS5jZWxsLnNldF90ZXh0KGRhdGEudGV4dCk7XG4gICAgICAgICAgICAgICAgZGF0YS5jZWxsLmNsZWFyX291dHB1dCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSB0aGF0LmZpbmRfY2VsbF9pbmRleChkYXRhLmNlbGwpO1xuICAgICAgICAgICAgICAgIHZhciBuZXdfY2VsbCA9IHRoYXQuaW5zZXJ0X2NlbGxfYmVsb3coJ2NvZGUnLGluZGV4KTtcbiAgICAgICAgICAgICAgICBuZXdfY2VsbC5zZXRfdGV4dChkYXRhLnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhhdC5kaXJ0eSA9IHRydWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuZXZlbnRzLm9uKCd1bnJlY29nbml6ZWRfY2VsbC5DZWxsJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhhdC53YXJuX25iZm9ybWF0X21pbm9yKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuZXZlbnRzLm9uKCd1bnJlY29nbml6ZWRfb3V0cHV0Lk91dHB1dEFyZWEnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGF0Lndhcm5fbmJmb3JtYXRfbWlub3IoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5ldmVudHMub24oJ3NldF9kaXJ0eS5Ob3RlYm9vaycsIGZ1bmN0aW9uIChldmVudCwgZGF0YSkge1xuICAgICAgICAgICAgdGhhdC5kaXJ0eSA9IGRhdGEudmFsdWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuZXZlbnRzLm9uKCd0cnVzdF9jaGFuZ2VkLk5vdGVib29rJywgZnVuY3Rpb24gKGV2ZW50LCB0cnVzdGVkKSB7XG4gICAgICAgICAgICB0aGF0LnRydXN0ZWQgPSB0cnVzdGVkO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmV2ZW50cy5vbignc2VsZWN0LkNlbGwnLCBmdW5jdGlvbiAoZXZlbnQsIGRhdGEpIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHRoYXQuZmluZF9jZWxsX2luZGV4KGRhdGEuY2VsbCk7XG4gICAgICAgICAgICB0aGF0LnNlbGVjdChpbmRleCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuZXZlbnRzLm9uKCdlZGl0X21vZGUuQ2VsbCcsIGZ1bmN0aW9uIChldmVudCwgZGF0YSkge1xuICAgICAgICAgICAgdGhhdC5oYW5kbGVfZWRpdF9tb2RlKGRhdGEuY2VsbCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuZXZlbnRzLm9uKCdjb21tYW5kX21vZGUuQ2VsbCcsIGZ1bmN0aW9uIChldmVudCwgZGF0YSkge1xuICAgICAgICAgICAgdGhhdC5oYW5kbGVfY29tbWFuZF9tb2RlKGRhdGEuY2VsbCk7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5ldmVudHMub24oJ3NwZWNfY2hhbmdlZC5LZXJuZWwnLCBmdW5jdGlvbihldmVudCwgZGF0YSkge1xuICAgICAgICAgICAgdGhhdC5tZXRhZGF0YS5rZXJuZWxzcGVjID0ge1xuICAgICAgICAgICAgICAgIG5hbWU6IGRhdGEubmFtZSxcbiAgICAgICAgICAgICAgICBkaXNwbGF5X25hbWU6IGRhdGEuc3BlYy5kaXNwbGF5X25hbWUsXG4gICAgICAgICAgICAgICAgbGFuZ3VhZ2U6IGRhdGEuc3BlYy5sYW5ndWFnZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBzdGFydCBzZXNzaW9uIGlmIHRoZSBjdXJyZW50IHNlc3Npb24gaXNuJ3QgYWxyZWFkeSBjb3JyZWN0XG4gICAgICAgICAgICBpZiAoISh0aGF0LnNlc3Npb24gJiYgdGhhdC5zZXNzaW9uLmtlcm5lbCAmJiB0aGF0LnNlc3Npb24ua2VybmVsLm5hbWUgPT09IGRhdGEubmFtZSkpIHtcbiAgICAgICAgICAgICAgICB0aGF0LnN0YXJ0X3Nlc3Npb24oZGF0YS5uYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5ldmVudHMub24oJ2tlcm5lbF9yZWFkeS5LZXJuZWwnLCBmdW5jdGlvbihldmVudCwgZGF0YSkge1xuICAgICAgICAgICAgdmFyIGtpbmZvID0gZGF0YS5rZXJuZWwuaW5mb19yZXBseTtcbiAgICAgICAgICAgIGlmICgha2luZm8ubGFuZ3VhZ2VfaW5mbykge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGF0Lm1ldGFkYXRhLmxhbmd1YWdlX2luZm87XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGxhbmdpbmZvID0ga2luZm8ubGFuZ3VhZ2VfaW5mbztcbiAgICAgICAgICAgIHRoYXQubWV0YWRhdGEubGFuZ3VhZ2VfaW5mbyA9IGxhbmdpbmZvO1xuICAgICAgICAgICAgLy8gTW9kZSAnbnVsbCcgc2hvdWxkIGJlIHBsYWluLCB1bmhpZ2hsaWdodGVkIHRleHQuXG4gICAgICAgICAgICB2YXIgY21fbW9kZSA9IGxhbmdpbmZvLmNvZGVtaXJyb3JfbW9kZSB8fCBsYW5naW5mby5uYW1lIHx8ICdudWxsJztcbiAgICAgICAgICAgIHRoYXQuc2V0X2NvZGVtaXJyb3JfbW9kZShjbV9tb2RlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICB0aGlzLmV2ZW50cy5vbigna2VybmVsX2lkbGUuS2VybmVsJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhhdC5rZXJuZWxfYnVzeSA9IGZhbHNlO1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuZXZlbnRzLm9uKCdrZXJuZWxfYnVzeS5LZXJuZWwnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGF0Lmtlcm5lbF9idXN5ID0gdHJ1ZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIGNvbGxhcHNlX3RpbWUgPSBmdW5jdGlvbiAodGltZSkge1xuICAgICAgICAgICAgdmFyIGFwcF9oZWlnaHQgPSAkKCcjaXB5dGhvbi1tYWluLWFwcCcpLmhlaWdodCgpOyAvLyBjb250ZW50IGhlaWdodFxuICAgICAgICAgICAgdmFyIHNwbGl0dGVyX2hlaWdodCA9ICQoJ2RpdiNwYWdlcl9zcGxpdHRlcicpLm91dGVySGVpZ2h0KHRydWUpO1xuICAgICAgICAgICAgdmFyIG5ld19oZWlnaHQgPSBhcHBfaGVpZ2h0IC0gc3BsaXR0ZXJfaGVpZ2h0O1xuICAgICAgICAgICAgdGhhdC5lbGVtZW50LmFuaW1hdGUoe2hlaWdodCA6IG5ld19oZWlnaHQgKyAncHgnfSwgdGltZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5lbGVtZW50LmJpbmQoJ2NvbGxhcHNlX3BhZ2VyJywgZnVuY3Rpb24gKGV2ZW50LCBleHRyYXApIHtcbiAgICAgICAgICAgIHZhciB0aW1lID0gKGV4dHJhcCAhPT0gdW5kZWZpbmVkKSA/ICgoZXh0cmFwLmR1cmF0aW9uICE9PSB1bmRlZmluZWQgKSA/IGV4dHJhcC5kdXJhdGlvbiA6ICdmYXN0JykgOiAnZmFzdCc7XG4gICAgICAgICAgICBjb2xsYXBzZV90aW1lKHRpbWUpO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgZXhwYW5kX3RpbWUgPSBmdW5jdGlvbiAodGltZSkge1xuICAgICAgICAgICAgdmFyIGFwcF9oZWlnaHQgPSAkKCcjaXB5dGhvbi1tYWluLWFwcCcpLmhlaWdodCgpOyAvLyBjb250ZW50IGhlaWdodFxuICAgICAgICAgICAgdmFyIHNwbGl0dGVyX2hlaWdodCA9ICQoJ2RpdiNwYWdlcl9zcGxpdHRlcicpLm91dGVySGVpZ2h0KHRydWUpO1xuICAgICAgICAgICAgdmFyIHBhZ2VyX2hlaWdodCA9ICQoJ2RpdiNwYWdlcicpLm91dGVySGVpZ2h0KHRydWUpO1xuICAgICAgICAgICAgdmFyIG5ld19oZWlnaHQgPSBhcHBfaGVpZ2h0IC0gcGFnZXJfaGVpZ2h0IC0gc3BsaXR0ZXJfaGVpZ2h0O1xuICAgICAgICAgICAgdGhhdC5lbGVtZW50LmFuaW1hdGUoe2hlaWdodCA6IG5ld19oZWlnaHQgKyAncHgnfSwgdGltZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5lbGVtZW50LmJpbmQoJ2V4cGFuZF9wYWdlcicsIGZ1bmN0aW9uIChldmVudCwgZXh0cmFwKSB7XG4gICAgICAgICAgICB2YXIgdGltZSA9IChleHRyYXAgIT09IHVuZGVmaW5lZCkgPyAoKGV4dHJhcC5kdXJhdGlvbiAhPT0gdW5kZWZpbmVkICkgPyBleHRyYXAuZHVyYXRpb24gOiAnZmFzdCcpIDogJ2Zhc3QnO1xuICAgICAgICAgICAgZXhwYW5kX3RpbWUodGltZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEZpcmVmb3ggMjIgYnJva2UgJCh3aW5kb3cpLm9uKFwiYmVmb3JldW5sb2FkXCIpXG4gICAgICAgIC8vIEknbSBub3Qgc3VyZSB3aHkgb3IgaG93LlxuICAgICAgICB3aW5kb3cub25iZWZvcmV1bmxvYWQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgLy8gVE9ETzogTWFrZSBraWxsaW5nIHRoZSBrZXJuZWwgY29uZmlndXJhYmxlLlxuICAgICAgICAgICAgdmFyIGtpbGxfa2VybmVsID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoa2lsbF9rZXJuZWwpIHtcbiAgICAgICAgICAgICAgICB0aGF0LnNlc3Npb24uZGVsZXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiB3ZSBhcmUgYXV0b3NhdmluZywgdHJpZ2dlciBhbiBhdXRvc2F2ZSBvbiBuYXYtYXdheS5cbiAgICAgICAgICAgIC8vIHN0aWxsIHdhcm4sIGJlY2F1c2UgaWYgd2UgZG9uJ3QgdGhlIGF1dG9zYXZlIG1heSBmYWlsLlxuICAgICAgICAgICAgaWYgKHRoYXQuZGlydHkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIHRoYXQuYXV0b3NhdmVfaW50ZXJ2YWwgKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNjaGVkdWxlIGF1dG9zYXZlIGluIGEgdGltZW91dFxuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGdpdmVzIHlvdSBhIGNoYW5jZSB0byBmb3JjZWZ1bGx5IGRpc2NhcmQgY2hhbmdlc1xuICAgICAgICAgICAgICAgICAgICAvLyBieSByZWxvYWRpbmcgdGhlIHBhZ2UgaWYgeW91ICpyZWFsbHkqIHdhbnQgdG8uXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSB0aW1lciBkb2Vzbid0IHN0YXJ0IHVudGlsIHlvdSAqZGlzbWlzcyogdGhlIGRpYWxvZy5cbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhhdC5kaXJ0eSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuc2F2ZV9ub3RlYm9vaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCAxMDAwKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiQXV0b3NhdmUgaW4gcHJvZ3Jlc3MsIGxhdGVzdCBjaGFuZ2VzIG1heSBiZSBsb3N0LlwiO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlVuc2F2ZWQgY2hhbmdlcyB3aWxsIGJlIGxvc3QuXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgdGhlIGtlcm5lbCBpcyBidXN5LCBwcm9tcHQgdGhlIHVzZXIgaWYgaGXigJlzIHN1cmVcbiAgICAgICAgICAgIGlmICh0aGF0Lmtlcm5lbF9idXN5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiVGhlIEtlcm5lbCBpcyBidXN5LCBvdXRwdXRzIG1heSBiZSBsb3N0LlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSUUgdHJlYXRzIG51bGwgYXMgYSBzdHJpbmcuICBJbnN0ZWFkIGp1c3QgcmV0dXJuIHdoaWNoIHdpbGwgYXZvaWQgdGhlIGRpYWxvZy5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgTm90ZWJvb2sucHJvdG90eXBlLnNob3dfY29tbWFuZF9wYWxldHRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB4ID0gbmV3IGNvbW1hbmRwYWxldHRlLkNvbW1hbmRQYWxldHRlKHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXIgYSB3YXJuaW5nIGRpYWxvZyBhYm91dCBtaXNzaW5nIGZ1bmN0aW9uYWxpdHkgZnJvbSBuZXdlciBtaW5vciB2ZXJzaW9uc1xuICAgICAqL1xuICAgIE5vdGVib29rLnByb3RvdHlwZS53YXJuX25iZm9ybWF0X21pbm9yID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciB2ID0gJ3YnICsgdGhpcy5uYmZvcm1hdCArICcuJztcbiAgICAgICAgdmFyIG9yaWdfdnMgPSB2ICsgdGhpcy5uYmZvcm1hdF9taW5vcjtcbiAgICAgICAgdmFyIHRoaXNfdnMgPSB2ICsgdGhpcy5jdXJyZW50X25iZm9ybWF0X21pbm9yO1xuICAgICAgICB2YXIgbXNnID0gXCJUaGlzIG5vdGVib29rIGlzIHZlcnNpb24gXCIgKyBvcmlnX3ZzICsgXCIsIGJ1dCB3ZSBvbmx5IGZ1bGx5IHN1cHBvcnQgdXAgdG8gXCIgK1xuICAgICAgICB0aGlzX3ZzICsgXCIuICBZb3UgY2FuIHN0aWxsIHdvcmsgd2l0aCB0aGlzIG5vdGVib29rLCBidXQgY2VsbCBhbmQgb3V0cHV0IHR5cGVzIFwiICtcbiAgICAgICAgXCJpbnRyb2R1Y2VkIGluIGxhdGVyIG5vdGVib29rIHZlcnNpb25zIHdpbGwgbm90IGJlIGF2YWlsYWJsZS5cIjtcblxuICAgICAgICBkaWFsb2cubW9kYWwoe1xuICAgICAgICAgICAgbm90ZWJvb2s6IHRoaXMsXG4gICAgICAgICAgICBrZXlib2FyZF9tYW5hZ2VyOiB0aGlzLmtleWJvYXJkX21hbmFnZXIsXG4gICAgICAgICAgICB0aXRsZSA6IFwiTmV3ZXIgTm90ZWJvb2tcIixcbiAgICAgICAgICAgIGJvZHkgOiBtc2csXG4gICAgICAgICAgICBidXR0b25zIDoge1xuICAgICAgICAgICAgICAgIE9LIDoge1xuICAgICAgICAgICAgICAgICAgICBcImNsYXNzXCIgOiBcImJ0bi1kYW5nZXJcIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgZGlydHkgZmxhZywgYW5kIHRyaWdnZXIgdGhlIHNldF9kaXJ0eS5Ob3RlYm9vayBldmVudFxuICAgICAqL1xuICAgIE5vdGVib29rLnByb3RvdHlwZS5zZXRfZGlydHkgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kaXJ0eSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmV2ZW50cy50cmlnZ2VyKCdzZXRfZGlydHkuTm90ZWJvb2snLCB7dmFsdWU6IHZhbHVlfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNjcm9sbCB0aGUgdG9wIG9mIHRoZSBwYWdlIHRvIGEgZ2l2ZW4gY2VsbC5cbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge2ludGVnZXJ9ICBpbmRleCAtIEFuIGluZGV4IG9mIHRoZSBjZWxsIHRvIHZpZXdcbiAgICAgKiBAcGFyYW0ge2ludGVnZXJ9ICB0aW1lIC0gQW5pbWF0aW9uIHRpbWUgaW4gbWlsbGlzZWNvbmRzXG4gICAgICogQHJldHVybiB7aW50ZWdlcn0gUGl4ZWwgb2Zmc2V0IGZyb20gdGhlIHRvcCBvZiB0aGUgY29udGFpbmVyXG4gICAgICovXG4gICAgTm90ZWJvb2sucHJvdG90eXBlLnNjcm9sbF90b19jZWxsID0gZnVuY3Rpb24gKGluZGV4LCB0aW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjcm9sbF9jZWxsX3BlcmNlbnQoaW5kZXgsIDAsIHRpbWUpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTY3JvbGwgdGhlIG1pZGRsZSBvZiB0aGUgcGFnZSB0byBhIGdpdmVuIGNlbGwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2ludGVnZXJ9ICBpbmRleCAtIEFuIGluZGV4IG9mIHRoZSBjZWxsIHRvIHZpZXdcbiAgICAgKiBAcGFyYW0ge2ludGVnZXJ9ICBwZXJjZW50IC0gMC0xMDAsIHRoZSBsb2NhdGlvbiBvbiB0aGUgc2NyZWVuIHRvIHNjcm9sbC5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAwIGlzIHRoZSB0b3AsIDEwMCBpcyB0aGUgYm90dG9tLlxuICAgICAqIEBwYXJhbSB7aW50ZWdlcn0gIHRpbWUgLSBBbmltYXRpb24gdGltZSBpbiBtaWxsaXNlY29uZHNcbiAgICAgKiBAcmV0dXJuIHtpbnRlZ2VyfSBQaXhlbCBvZmZzZXQgZnJvbSB0aGUgdG9wIG9mIHRoZSBjb250YWluZXJcbiAgICAgKi9cbiAgICBOb3RlYm9vay5wcm90b3R5cGUuc2Nyb2xsX2NlbGxfcGVyY2VudCA9IGZ1bmN0aW9uIChpbmRleCwgcGVyY2VudCwgdGltZSkge1xuICAgICAgICB2YXIgY2VsbHMgPSB0aGlzLmdldF9jZWxscygpO1xuICAgICAgICB0aW1lID0gdGltZSB8fCAwO1xuICAgICAgICBwZXJjZW50ID0gcGVyY2VudCB8fCAwO1xuICAgICAgICBpbmRleCA9IE1hdGgubWluKGNlbGxzLmxlbmd0aC0xLGluZGV4KTtcbiAgICAgICAgaW5kZXggPSBNYXRoLm1heCgwICAgICAgICAgICAgICxpbmRleCk7XG4gICAgICAgIHZhciBzbWUgPSB0aGlzLnNjcm9sbF9tYW5hZ2VyLmVsZW1lbnQ7XG4gICAgICAgIHZhciBoID0gc21lLmhlaWdodCgpO1xuICAgICAgICB2YXIgc3QgPSBzbWUuc2Nyb2xsVG9wKCk7XG4gICAgICAgIHZhciB0ID0gc21lLm9mZnNldCgpLnRvcDtcbiAgICAgICAgdmFyIGN0ID0gY2VsbHNbaW5kZXhdLmVsZW1lbnQub2Zmc2V0KCkudG9wO1xuICAgICAgICB2YXIgc2Nyb2xsX3ZhbHVlID0gIHN0ICsgY3QgLSAodCArIC4wMSAqIHBlcmNlbnQgKiBoKTtcbiAgICAgICAgdGhpcy5zY3JvbGxfbWFuYWdlci5lbGVtZW50LmFuaW1hdGUoe3Njcm9sbFRvcDpzY3JvbGxfdmFsdWV9LCB0aW1lKTtcbiAgICAgICAgcmV0dXJuIHNjcm9sbF92YWx1ZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2Nyb2xsIHRvIHRoZSBib3R0b20gb2YgdGhlIHBhZ2UuXG4gICAgICovXG4gICAgTm90ZWJvb2sucHJvdG90eXBlLnNjcm9sbF90b19ib3R0b20gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsX21hbmFnZXIuZWxlbWVudC5hbmltYXRlKHtzY3JvbGxUb3A6dGhpcy5lbGVtZW50LmdldCgwKS5zY3JvbGxIZWlnaHR9LCAwKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2Nyb2xsIHRvIHRoZSB0b3Agb2YgdGhlIHBhZ2UuXG4gICAgICovXG4gICAgTm90ZWJvb2sucHJvdG90eXBlLnNjcm9sbF90b190b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsX21hbmFnZXIuZWxlbWVudC5hbmltYXRlKHtzY3JvbGxUb3A6MH0sIDApO1xuICAgIH07XG5cbiAgICAvLyBFZGl0IE5vdGVib29rIG1ldGFkYXRhXG5cbiAgICAvKipcbiAgICAgKiBEaXNwbGF5IGEgZGlhbG9nIHRoYXQgYWxsb3dzIHRoZSB1c2VyIHRvIGVkaXQgdGhlIE5vdGVib29rJ3MgbWV0YWRhdGEuXG4gICAgICovXG4gICAgTm90ZWJvb2sucHJvdG90eXBlLmVkaXRfbWV0YWRhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgZGlhbG9nLmVkaXRfbWV0YWRhdGEoe1xuICAgICAgICAgICAgbWQ6IHRoaXMubWV0YWRhdGEsIFxuICAgICAgICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uIChtZCkge1xuICAgICAgICAgICAgICAgIHRoYXQubWV0YWRhdGEgPSBtZDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBuYW1lOiAnTm90ZWJvb2snLFxuICAgICAgICAgICAgbm90ZWJvb2s6IHRoaXMsXG4gICAgICAgICAgICBrZXlib2FyZF9tYW5hZ2VyOiB0aGlzLmtleWJvYXJkX21hbmFnZXJ9KTtcbiAgICB9O1xuXG4gICAgLy8gQ2VsbCBpbmRleGluZywgcmV0cmlldmFsLCBldGMuXG5cbiAgICAvKipcbiAgICAgKiBHZXQgYWxsIGNlbGwgZWxlbWVudHMgaW4gdGhlIG5vdGVib29rLlxuICAgICAqIFxuICAgICAqIEByZXR1cm4ge2pRdWVyeX0gQSBzZWxlY3RvciBvZiBhbGwgY2VsbCBlbGVtZW50c1xuICAgICAqL1xuICAgIE5vdGVib29rLnByb3RvdHlwZS5nZXRfY2VsbF9lbGVtZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGFpbmVyLmZpbmQoXCIuY2VsbFwiKS5ub3QoJy5jZWxsIC5jZWxsJyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBhIHBhcnRpY3VsYXIgY2VsbCBlbGVtZW50LlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7aW50ZWdlcn0gaW5kZXggQW4gaW5kZXggb2YgYSBjZWxsIHRvIHNlbGVjdFxuICAgICAqIEByZXR1cm4ge2pRdWVyeX0gQSBzZWxlY3RvciBvZiB0aGUgZ2l2ZW4gY2VsbC5cbiAgICAgKi9cbiAgICBOb3RlYm9vay5wcm90b3R5cGUuZ2V0X2NlbGxfZWxlbWVudCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgdmFyIGUgPSB0aGlzLmdldF9jZWxsX2VsZW1lbnRzKCkuZXEoaW5kZXgpO1xuICAgICAgICBpZiAoZS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVHJ5IHRvIGdldCBhIHBhcnRpY3VsYXIgY2VsbCBieSBtc2dfaWQuXG4gICAgICogXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1zZ19pZCBBIG1lc3NhZ2UgVVVJRFxuICAgICAqIEByZXR1cm4ge0NlbGx9IENlbGwgb3IgbnVsbCBpZiBubyBjZWxsIHdhcyBmb3VuZC5cbiAgICAgKi9cbiAgICBOb3RlYm9vay5wcm90b3R5cGUuZ2V0X21zZ19jZWxsID0gZnVuY3Rpb24gKG1zZ19pZCkge1xuICAgICAgICByZXR1cm4gY29kZWNlbGwuQ29kZUNlbGwubXNnX2NlbGxzW21zZ19pZF0gfHwgbnVsbDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ291bnQgdGhlIGNlbGxzIGluIHRoaXMgbm90ZWJvb2suXG4gICAgICogXG4gICAgICogQHJldHVybiB7aW50ZWdlcn0gVGhlIG51bWJlciBvZiBjZWxscyBpbiB0aGlzIG5vdGVib29rXG4gICAgICovXG4gICAgTm90ZWJvb2sucHJvdG90eXBlLm5jZWxscyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0X2NlbGxfZWxlbWVudHMoKS5sZW5ndGg7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBhbGwgQ2VsbCBvYmplY3RzIGluIHRoaXMgbm90ZWJvb2suXG4gICAgICogXG4gICAgICogQHJldHVybiB7QXJyYXl9IFRoaXMgbm90ZWJvb2sncyBDZWxsIG9iamVjdHNcbiAgICAgKi9cbiAgICBOb3RlYm9vay5wcm90b3R5cGUuZ2V0X2NlbGxzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBUT0RPOiB3ZSBhcmUgb2Z0ZW4gY2FsbGluZyBjZWxscyBhcyBjZWxscygpW2ldLCB3aGljaCB3ZSBzaG91bGQgb3B0aW1pemVcbiAgICAgICAgLy8gdG8gY2VsbHMoaSkgb3IgYSBuZXcgbWV0aG9kLlxuICAgICAgICByZXR1cm4gdGhpcy5nZXRfY2VsbF9lbGVtZW50cygpLnRvQXJyYXkoKS5tYXAoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJldHVybiAkKGUpLmRhdGEoXCJjZWxsXCIpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IGEgQ2VsbCBvYmplY3RzIGZyb20gdGhpcyBub3RlYm9vay5cbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge2ludGVnZXJ9IGluZGV4IC0gQW4gaW5kZXggb2YgYSBjZWxsIHRvIHJldHJpZXZlXG4gICAgICogQHJldHVybiB7Q2VsbH0gQ2VsbCBvciBudWxsIGlmIG5vIGNlbGwgd2FzIGZvdW5kLlxuICAgICAqL1xuICAgIE5vdGVib29rLnByb3RvdHlwZS5nZXRfY2VsbCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgdmFyIGNlID0gdGhpcy5nZXRfY2VsbF9lbGVtZW50KGluZGV4KTtcbiAgICAgICAgaWYgKGNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBjZS5kYXRhKCdjZWxsJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjZWxsIGJlbG93IGEgZ2l2ZW4gY2VsbC5cbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge0NlbGx9IGNlbGxcbiAgICAgKiBAcmV0dXJuIHtDZWxsfSB0aGUgbmV4dCBjZWxsIG9yIG51bGwgaWYgbm8gY2VsbCB3YXMgZm91bmQuXG4gICAgICovXG4gICAgTm90ZWJvb2sucHJvdG90eXBlLmdldF9uZXh0X2NlbGwgPSBmdW5jdGlvbiAoY2VsbCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5maW5kX2NlbGxfaW5kZXgoY2VsbCk7XG4gICAgICAgIGlmICh0aGlzLmlzX3ZhbGlkX2NlbGxfaW5kZXgoaW5kZXgrMSkpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuZ2V0X2NlbGwoaW5kZXgrMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjZWxsIGFib3ZlIGEgZ2l2ZW4gY2VsbC5cbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge0NlbGx9IGNlbGxcbiAgICAgKiBAcmV0dXJuIHtDZWxsfSBUaGUgcHJldmlvdXMgY2VsbCBvciBudWxsIGlmIG5vIGNlbGwgd2FzIGZvdW5kLlxuICAgICAqL1xuICAgIE5vdGVib29rLnByb3RvdHlwZS5nZXRfcHJldl9jZWxsID0gZnVuY3Rpb24gKGNlbGwpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG51bGw7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuZmluZF9jZWxsX2luZGV4KGNlbGwpO1xuICAgICAgICBpZiAoaW5kZXggIT09IG51bGwgJiYgaW5kZXggPiAwKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLmdldF9jZWxsKGluZGV4LTEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbnVtZXJpYyBpbmRleCBvZiBhIGdpdmVuIGNlbGwuXG4gICAgICogXG4gICAgICogQHBhcmFtIHtDZWxsfSBjZWxsXG4gICAgICogQHJldHVybiB7aW50ZWdlcn0gVGhlIGNlbGwncyBudW1lcmljIGluZGV4IG9yIG51bGwgaWYgbm8gY2VsbCB3YXMgZm91bmQuXG4gICAgICovXG4gICAgTm90ZWJvb2sucHJvdG90eXBlLmZpbmRfY2VsbF9pbmRleCA9IGZ1bmN0aW9uIChjZWxsKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBudWxsO1xuICAgICAgICB0aGlzLmdldF9jZWxsX2VsZW1lbnRzKCkuZmlsdGVyKGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgaWYgKCQodGhpcykuZGF0YShcImNlbGxcIikgPT09IGNlbGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBpbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybiBnaXZlbiBpbmRleCBpZiBkZWZpbmVkLCBvciB0aGUgc2VsZWN0ZWQgaW5kZXggaWYgbm90LlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7aW50ZWdlcn0gW2luZGV4XSAtIEEgY2VsbCdzIGluZGV4XG4gICAgICogQHJldHVybiB7aW50ZWdlcn0gY2VsbCBpbmRleFxuICAgICAqL1xuICAgIE5vdGVib29rLnByb3RvdHlwZS5pbmRleF9vcl9zZWxlY3RlZCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQgfHwgaW5kZXggPT09IG51bGwpIHtcbiAgICAgICAgICAgIGkgPSB0aGlzLmdldF9zZWxlY3RlZF9pbmRleCgpO1xuICAgICAgICAgICAgaWYgKGkgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGkgPSBpbmRleDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgY2VsbC5cbiAgICAgKiBcbiAgICAgKiBAcmV0dXJuIHtDZWxsfSBUaGUgc2VsZWN0ZWQgY2VsbFxuICAgICAqL1xuICAgIE5vdGVib29rLnByb3RvdHlwZS5nZXRfc2VsZWN0ZWRfY2VsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5nZXRfc2VsZWN0ZWRfaW5kZXgoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0X2NlbGwoaW5kZXgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayB3aGV0aGVyIGEgY2VsbCBpbmRleCBpcyB2YWxpZC5cbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge2ludGVnZXJ9IGluZGV4IC0gQSBjZWxsIGluZGV4XG4gICAgICogQHJldHVybiBUcnVlIGlmIHRoZSBpbmRleCBpcyB2YWxpZCwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICovXG4gICAgTm90ZWJvb2sucHJvdG90eXBlLmlzX3ZhbGlkX2NlbGxfaW5kZXggPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgaWYgKGluZGV4ICE9PSBudWxsICYmIGluZGV4ID49IDAgJiYgaW5kZXggPCB0aGlzLm5jZWxscygpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGluZGV4IG9mIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgY2VsbC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge2ludGVnZXJ9IFRoZSBzZWxlY3RlZCBjZWxsJ3MgbnVtZXJpYyBpbmRleFxuICAgICAqL1xuICAgIE5vdGVib29rLnByb3RvdHlwZS5nZXRfc2VsZWN0ZWRfaW5kZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBudWxsO1xuICAgICAgICB0aGlzLmdldF9jZWxsX2VsZW1lbnRzKCkuZmlsdGVyKGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgaWYgKCQodGhpcykuZGF0YShcImNlbGxcIikuc2VsZWN0ZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBpbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgaW5kZXggb2YgdGhlIGFuY2hvciBjZWxsIGZvciByYW5nZSBzZWxlY3Rpb25cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge2ludGVnZXJ9IFRoZSBhbmNob3IgY2VsbCdzIG51bWVyaWMgaW5kZXhcbiAgICAgKi9cbiAgICBOb3RlYm9vay5wcm90b3R5cGUuZ2V0X3NlbGVjdGlvbl9hbmNob3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG51bGw7XG4gICAgICAgIHRoaXMuZ2V0X2NlbGxfZWxlbWVudHMoKS5maWx0ZXIoZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICBpZiAoJCh0aGlzKS5kYXRhKFwiY2VsbFwiKS5zZWxlY3Rpb25fYW5jaG9yID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gaW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYW4gYXJyYXkgb2YgdGhlIGNlbGxzIGluIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgcmFuZ2VcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0FycmF5fSBUaGUgc2VsZWN0ZWQgY2VsbHNcbiAgICAgKi9cbiAgICBOb3RlYm9vay5wcm90b3R5cGUuZ2V0X3NlbGVjdGVkX2NlbGxzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRfY2VsbHMoKS5maWx0ZXIoZnVuY3Rpb24oY2VsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGNlbGwuaW5fc2VsZWN0aW9uO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBpbmRpY2VzIG9mIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgcmFuZ2Ugb2YgY2VsbHMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gVGhlIHNlbGVjdGVkIGNlbGxzJyBudW1lcmljIGluZGljZXNcbiAgICAgKi9cbiAgICBOb3RlYm9vay5wcm90b3R5cGUuZ2V0X3NlbGVjdGVkX2luZGljZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgdGhpcy5nZXRfY2VsbF9lbGVtZW50cygpLmZpbHRlcihmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgIGlmICgkKHRoaXMpLmRhdGEoXCJjZWxsXCIpLmluX3NlbGVjdGlvbiA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIC8vIENlbGwgc2VsZWN0aW9uLlxuXG4gICAgLyoqXG4gICAgICogUHJvZ3JhbW1hdGljYWxseSBzZWxlY3QgYSBjZWxsLlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7aW50ZWdlcn0gaW5kZXggLSBBIGNlbGwncyBpbmRleFxuICAgICAqIEByZXR1cm4ge05vdGVib29rfSBUaGlzIG5vdGVib29rXG4gICAgICovXG4gICAgTm90ZWJvb2sucHJvdG90eXBlLnNlbGVjdCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICBpZiAodGhpcy5pc192YWxpZF9jZWxsX2luZGV4KGluZGV4KSkge1xuICAgICAgICAgICAgdmFyIHNpbmRleCA9IHRoaXMuZ2V0X3NlbGVjdGVkX2luZGV4KCk7XG4gICAgICAgICAgICBpZiAoc2luZGV4ICE9PSBudWxsICYmIGluZGV4ICE9PSBzaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBhcmUgYWJvdXQgdG8gc2VsZWN0IGEgZGlmZmVyZW50IGNlbGwsIG1ha2Ugc3VyZSB3ZSBhcmVcbiAgICAgICAgICAgICAgICAvLyBmaXJzdCBpbiBjb21tYW5kIG1vZGUuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubW9kZSAhPT0gJ2NvbW1hbmQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tbWFuZF9tb2RlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGN1cnJlbnRfc2VsZWN0aW9uID0gdGhpcy5nZXRfc2VsZWN0ZWRfY2VsbHMoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGk9MDsgaTxjdXJyZW50X3NlbGVjdGlvbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRfc2VsZWN0aW9uW2ldLnVuc2VsZWN0KClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGNlbGwgPSB0aGlzLl9zZWxlY3QoaW5kZXgpO1xuICAgICAgICAgICAgY2VsbC5zZWxlY3Rpb25fYW5jaG9yID0gdHJ1ZVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBOb3RlYm9vay5wcm90b3R5cGUuX3NlbGVjdCA9IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgIHZhciBjZWxsID0gdGhpcy5nZXRfY2VsbChpbmRleCk7XG4gICAgICAgIGNlbGwuc2VsZWN0KCk7XG4gICAgICAgIHRoaXMuZXZlbnRzLnRyaWdnZXIoJ3NlbGVjdGVkX2NlbGxfdHlwZV9jaGFuZ2VkLk5vdGVib29rJyxcbiAgICAgICAgICAgIHsnY2VsbF90eXBlJzpjZWxsLmNlbGxfdHlwZX1cbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIGNlbGw7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFByb2dyYW1tYXRpY2FsbHkgc2VsZWN0IHRoZSBuZXh0IGNlbGwuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtOb3RlYm9va30gVGhpcyBub3RlYm9va1xuICAgICAqL1xuICAgIE5vdGVib29rLnByb3RvdHlwZS5zZWxlY3RfbmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5nZXRfc2VsZWN0ZWRfaW5kZXgoKTtcbiAgICAgICAgdGhpcy5zZWxlY3QoaW5kZXgrMSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBQcm9ncmFtbWF0aWNhbGx5IHNlbGVjdCB0aGUgcHJldmlvdXMgY2VsbC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge05vdGVib29rfSBUaGlzIG5vdGVib29rXG4gICAgICovXG4gICAgTm90ZWJvb2sucHJvdG90eXBlLnNlbGVjdF9wcmV2ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmdldF9zZWxlY3RlZF9pbmRleCgpO1xuICAgICAgICB0aGlzLnNlbGVjdChpbmRleC0xKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEV4dGVuZCB0aGUgc2VsZWN0ZWQgcmFuZ2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkaXJlY3Rpb24gLSAndXAnIG9yICdkb3duXG4gICAgICovXG4gICAgTm90ZWJvb2sucHJvdG90eXBlLmV4dGVuZF9zZWxlY3Rpb24gPSBmdW5jdGlvbihkaXJlY3Rpb24pIHtcbiAgICAgICAgdmFyIGFuY2hvcl9peCA9IHRoaXMuZ2V0X3NlbGVjdGlvbl9hbmNob3IoKTtcbiAgICAgICAgdmFyIGN1cnNvcl9peCA9IHRoaXMuZ2V0X3NlbGVjdGVkX2luZGV4KCk7XG4gICAgICAgIHZhciByYW5nZV9kaXJlY3Rpb24gPSAoY3Vyc29yX2l4ID4gYW5jaG9yX2l4KSA/ICdkb3duJyA6ICd1cCc7XG4gICAgICAgIHZhciBjb250cmFjdGluZyA9IChjdXJzb3JfaXggIT09IGFuY2hvcl9peCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZGlyZWN0aW9uICE9PSByYW5nZV9kaXJlY3Rpb24pO1xuICAgICAgICB2YXIgaXhfZGVsdGEgPSAoZGlyZWN0aW9uID09PSAndXAnKSA/IC0xIDogMTtcbiAgICAgICAgdmFyIG5ld19peCA9IGN1cnNvcl9peCArIGl4X2RlbHRhO1xuICAgICAgICBpZiAobmV3X2l4IDwgMCB8fCBuZXdfaXggPj0gdGhpcy5uY2VsbHMoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1vZGUgIT09ICdjb21tYW5kJykge1xuICAgICAgICAgICAgdGhpcy5jb21tYW5kX21vZGUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmdldF9jZWxsKGN1cnNvcl9peCkudW5zZWxlY3QoIWNvbnRyYWN0aW5nKTtcbiAgICAgICAgdGhpcy5fc2VsZWN0KG5ld19peCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDbGVhciBzZWxlY3Rpb24gb2YgbXVsdGlwbGUgY2VsbHMgKGV4Y2VwdCB0aGUgY2VsbCBhdCB0aGUgY3Vyc29yKVxuICAgICAqL1xuICAgIE5vdGVib29rLnByb3RvdHlwZS5yZXNldF9zZWxlY3Rpb24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRfc2VsZWN0aW9uID0gdGhpcy5nZXRfc2VsZWN0ZWRfY2VsbHMoKTtcbiAgICAgICAgZm9yICh2YXIgaT0wOyBpPGN1cnJlbnRfc2VsZWN0aW9uLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIWN1cnJlbnRfc2VsZWN0aW9uW2ldLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudF9zZWxlY3Rpb25baV0udW5zZWxlY3QoKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuXG4gICAgLy8gRWRpdC9Db21tYW5kIG1vZGVcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGluZGV4IG9mIHRoZSBjZWxsIHRoYXQgaXMgaW4gZWRpdCBtb2RlLlxuICAgICAqXG4gICAgICogQHJldHVybiB7aW50ZWdlcn0gaW5kZXhcbiAgICAgKi9cbiAgICBOb3RlYm9vay5wcm90b3R5cGUuZ2V0X2VkaXRfaW5kZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBudWxsO1xuICAgICAgICB0aGlzLmdldF9jZWxsX2VsZW1lbnRzKCkuZmlsdGVyKGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgaWYgKCQodGhpcykuZGF0YShcImNlbGxcIikubW9kZSA9PT0gJ2VkaXQnKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gaW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgd2hlbiBhIGEgY2VsbCBibHVycyBhbmQgdGhlIG5vdGVib29rIHNob3VsZCBlbnRlciBjb21tYW5kIG1vZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NlbGx9IFtjZWxsXSAtIENlbGwgdG8gZW50ZXIgY29tbWFuZCBtb2RlIG9uLlxuICAgICAqL1xuICAgIE5vdGVib29rLnByb3RvdHlwZS5oYW5kbGVfY29tbWFuZF9tb2RlID0gZnVuY3Rpb24gKGNlbGwpIHtcbiAgICAgICAgaWYgKHRoaXMubW9kZSAhPT0gJ2NvbW1hbmQnKSB7XG4gICAgICAgICAgICBjZWxsLmNvbW1hbmRfbW9kZSgpO1xuICAgICAgICAgICAgdGhpcy5tb2RlID0gJ2NvbW1hbmQnO1xuICAgICAgICAgICAgdGhpcy5ldmVudHMudHJpZ2dlcignY29tbWFuZF9tb2RlLk5vdGVib29rJyk7XG4gICAgICAgICAgICB0aGlzLmtleWJvYXJkX21hbmFnZXIuY29tbWFuZF9tb2RlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTWFrZSB0aGUgbm90ZWJvb2sgZW50ZXIgY29tbWFuZCBtb2RlLlxuICAgICAqL1xuICAgIE5vdGVib29rLnByb3RvdHlwZS5jb21tYW5kX21vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjZWxsID0gdGhpcy5nZXRfY2VsbCh0aGlzLmdldF9lZGl0X2luZGV4KCkpO1xuICAgICAgICBpZiAoY2VsbCAmJiB0aGlzLm1vZGUgIT09ICdjb21tYW5kJykge1xuICAgICAgICAgICAgLy8gV2UgZG9uJ3QgY2FsbCBjZWxsLmNvbW1hbmRfbW9kZSwgYnV0IHJhdGhlciBibHVyIHRoZSBDTSBlZGl0b3JcbiAgICAgICAgICAgIC8vIHdoaWNoIHdpbGwgdHJpZ2dlciB0aGUgY2FsbCB0byBoYW5kbGVfY29tbWFuZF9tb2RlLlxuICAgICAgICAgICAgY2VsbC5jb2RlX21pcnJvci5nZXRJbnB1dEZpZWxkKCkuYmx1cigpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEhhbmRsZSB3aGVuIGEgY2VsbCBmaXJlcyBpdCdzIGVkaXRfbW9kZSBldmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2VsbH0gW2NlbGxdIENlbGwgdG8gZW50ZXIgZWRpdCBtb2RlIG9uLlxuICAgICAqL1xuICAgIE5vdGVib29rLnByb3RvdHlwZS5oYW5kbGVfZWRpdF9tb2RlID0gZnVuY3Rpb24gKGNlbGwpIHtcbiAgICAgICAgaWYgKGNlbGwgJiYgdGhpcy5tb2RlICE9PSAnZWRpdCcpIHtcbiAgICAgICAgICAgIGNlbGwuZWRpdF9tb2RlKCk7XG4gICAgICAgICAgICB0aGlzLm1vZGUgPSAnZWRpdCc7XG4gICAgICAgICAgICB0aGlzLnJlc2V0X3NlbGVjdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5ldmVudHMudHJpZ2dlcignZWRpdF9tb2RlLk5vdGVib29rJyk7XG4gICAgICAgICAgICB0aGlzLmtleWJvYXJkX21hbmFnZXIuZWRpdF9tb2RlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTWFrZSBhIGNlbGwgZW50ZXIgZWRpdCBtb2RlLlxuICAgICAqL1xuICAgIE5vdGVib29rLnByb3RvdHlwZS5lZGl0X21vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjZWxsID0gdGhpcy5nZXRfc2VsZWN0ZWRfY2VsbCgpO1xuICAgICAgICBpZiAoY2VsbCAmJiB0aGlzLm1vZGUgIT09ICdlZGl0Jykge1xuICAgICAgICAgICAgY2VsbC51bnJlbmRlcigpO1xuICAgICAgICAgICAgY2VsbC5mb2N1c19lZGl0b3IoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBFbnN1cmUgZWl0aGVyIGNlbGwsIG9yIGNvZGVtaXJyb3IgaXMgZm9jdXNlZC4gSXMgbm9uZSBcbiAgICAgKiBpcyBmb2N1c2VkLCBmb2N1cyB0aGUgY2VsbC5cbiAgICAgKi9cbiAgICBOb3RlYm9vay5wcm90b3R5cGUuZW5zdXJlX2ZvY3VzZWQgPSBmdW5jdGlvbigpe1xuICAgICAgICB2YXIgY2VsbCA9IHRoaXMuZ2V0X3NlbGVjdGVkX2NlbGwoKTtcbiAgICAgICAgaWYgKGNlbGwgPT09IG51bGwpIHtyZXR1cm47fSAgLy8gTm8gY2VsbCBpcyBzZWxlY3RlZFxuICAgICAgICBjZWxsLmVuc3VyZV9mb2N1c2VkKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRm9jdXMgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBjZWxsLlxuICAgICAqL1xuICAgIE5vdGVib29rLnByb3RvdHlwZS5mb2N1c19jZWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2VsbCA9IHRoaXMuZ2V0X3NlbGVjdGVkX2NlbGwoKTtcbiAgICAgICAgaWYgKGNlbGwgPT09IG51bGwpIHtyZXR1cm47fSAgLy8gTm8gY2VsbCBpcyBzZWxlY3RlZFxuICAgICAgICBjZWxsLmZvY3VzX2NlbGwoKTtcbiAgICB9O1xuXG4gICAgLy8gQ2VsbCBtb3ZlbWVudFxuXG4gICAgLyoqXG4gICAgICogTW92ZSBnaXZlbiAob3Igc2VsZWN0ZWQpIGNlbGwgdXAgYW5kIHNlbGVjdCBpdC5cbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge2ludGVnZXJ9IFtpbmRleF0gLSBjZWxsIGluZGV4XG4gICAgICogQHJldHVybiB7Tm90ZWJvb2t9IFRoaXMgbm90ZWJvb2tcbiAgICAgKi9cbiAgICBOb3RlYm9vay5wcm90b3R5cGUubW92ZV9jZWxsX3VwID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHZhciBpID0gdGhpcy5pbmRleF9vcl9zZWxlY3RlZChpbmRleCk7XG4gICAgICAgIGlmICh0aGlzLmlzX3ZhbGlkX2NlbGxfaW5kZXgoaSkgJiYgaSA+IDApIHtcbiAgICAgICAgICAgIHZhciBwaXZvdCA9IHRoaXMuZ2V0X2NlbGxfZWxlbWVudChpLTEpO1xuICAgICAgICAgICAgdmFyIHRvbW92ZSA9IHRoaXMuZ2V0X2NlbGxfZWxlbWVudChpKTtcbiAgICAgICAgICAgIGlmIChwaXZvdCAhPT0gbnVsbCAmJiB0b21vdmUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0b21vdmUuZGV0YWNoKCk7XG4gICAgICAgICAgICAgICAgcGl2b3QuYmVmb3JlKHRvbW92ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3QoaS0xKTtcbiAgICAgICAgICAgICAgICB2YXIgY2VsbCA9IHRoaXMuZ2V0X3NlbGVjdGVkX2NlbGwoKTtcbiAgICAgICAgICAgICAgICBjZWxsLmZvY3VzX2NlbGwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2V0X2RpcnR5KHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cblxuICAgIC8qKlxuICAgICAqIE1vdmUgZ2l2ZW4gKG9yIHNlbGVjdGVkKSBjZWxsIGRvd24gYW5kIHNlbGVjdCBpdC5cbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge2ludGVnZXJ9IFtpbmRleF0gLSBjZWxsIGluZGV4XG4gICAgICogQHJldHVybiB7Tm90ZWJvb2t9IFRoaXMgbm90ZWJvb2tcbiAgICAgKi9cbiAgICBOb3RlYm9vay5wcm90b3R5cGUubW92ZV9jZWxsX2Rvd24gPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgdmFyIGkgPSB0aGlzLmluZGV4X29yX3NlbGVjdGVkKGluZGV4KTtcbiAgICAgICAgaWYgKHRoaXMuaXNfdmFsaWRfY2VsbF9pbmRleChpKSAmJiB0aGlzLmlzX3ZhbGlkX2NlbGxfaW5kZXgoaSsxKSkge1xuICAgICAgICAgICAgdmFyIHBpdm90ID0gdGhpcy5nZXRfY2VsbF9lbGVtZW50KGkrMSk7XG4gICAgICAgICAgICB2YXIgdG9tb3ZlID0gdGhpcy5nZXRfY2VsbF9lbGVtZW50KGkpO1xuICAgICAgICAgICAgaWYgKHBpdm90ICE9PSBudWxsICYmIHRvbW92ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRvbW92ZS5kZXRhY2goKTtcbiAgICAgICAgICAgICAgICBwaXZvdC5hZnRlcih0b21vdmUpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0KGkrMSk7XG4gICAgICAgICAgICAgICAgdmFyIGNlbGwgPSB0aGlzLmdldF9zZWxlY3RlZF9jZWxsKCk7XG4gICAgICAgICAgICAgICAgY2VsbC5mb2N1c19jZWxsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRfZGlydHkoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuXG4gICAgLy8gSW5zZXJ0aW9uLCBkZWxldGlvbi5cblxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBhIGNlbGwgZnJvbSB0aGUgbm90ZWJvb2sgd2l0aG91dCBhbnkgcHJlY2F1dGlvbnNcbiAgICAgKiBOZWVkZWQgdG8gcmVsb2FkIGNoZWNrcG9pbnRzIGFuZCBvdGhlciB0aGluZ3MgbGlrZSB0aGF0LlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7aW50ZWdlcn0gW2luZGV4XSAtIGNlbGwncyBudW1lcmljIGluZGV4XG4gICAgICogQHJldHVybiB7Tm90ZWJvb2t9IFRoaXMgbm90ZWJvb2tcbiAgICAgKi9cbiAgICBOb3RlYm9vay5wcm90b3R5cGUuX3Vuc2FmZV9kZWxldGVfY2VsbCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICB2YXIgaSA9IHRoaXMuaW5kZXhfb3Jfc2VsZWN0ZWQoaW5kZXgpO1xuICAgICAgICB2YXIgY2VsbCA9IHRoaXMuZ2V0X2NlbGwoaSk7XG5cbiAgICAgICAgJCgnI3VuZGVsZXRlX2NlbGwnKS5hZGRDbGFzcygnZGlzYWJsZWQnKTtcbiAgICAgICAgaWYgKHRoaXMuaXNfdmFsaWRfY2VsbF9pbmRleChpKSkge1xuICAgICAgICAgICAgdmFyIG9sZF9uY2VsbHMgPSB0aGlzLm5jZWxscygpO1xuICAgICAgICAgICAgdmFyIGNlID0gdGhpcy5nZXRfY2VsbF9lbGVtZW50KGkpO1xuICAgICAgICAgICAgY2UucmVtb3ZlKCk7XG4gICAgICAgICAgICB0aGlzLnNldF9kaXJ0eSh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5cbiAgICAvKipcbiAgICAgKiBEZWxldGUgY2VsbHMgZnJvbSB0aGUgbm90ZWJvb2tcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtpbmRpY2VzXSAtIHRoZSBudW1lcmljIGluZGljZXMgb2YgY2VsbHMgdG8gZGVsZXRlLlxuICAgICAqIEByZXR1cm4ge05vdGVib29rfSBUaGlzIG5vdGVib29rXG4gICAgICovXG4gICAgTm90ZWJvb2sucHJvdG90eXBlLmRlbGV0ZV9jZWxscyA9IGZ1bmN0aW9uKGluZGljZXMpIHtcbiAgICAgICAgaWYgKGluZGljZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaW5kaWNlcyA9IHRoaXMuZ2V0X3NlbGVjdGVkX2luZGljZXMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudW5kZWxldGVfYmFja3VwID0gW107XG5cbiAgICAgICAgdmFyIGN1cnNvcl9peF9iZWZvcmUgPSB0aGlzLmdldF9zZWxlY3RlZF9pbmRleCgpO1xuICAgICAgICB2YXIgZGVsZXRpbmdfYmVmb3JlX2N1cnNvciA9IDA7XG4gICAgICAgIGZvciAodmFyIGk9MDsgaSA8IGluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5nZXRfY2VsbChpbmRpY2VzW2ldKS5pc19kZWxldGFibGUoKSkge1xuICAgICAgICAgICAgICAgIC8vIElmIGFueSBjZWxsIGlzIG1hcmtlZCB1bmRlbGV0YWJsZSwgY2FuY2VsXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpbmRpY2VzW2ldIDwgY3Vyc29yX2l4X2JlZm9yZSkge1xuICAgICAgICAgICAgICAgIGRlbGV0aW5nX2JlZm9yZV9jdXJzb3IrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHdlIHN0YXJ0ZWQgZGVsZXRpbmcgY2VsbHMgZnJvbSB0aGUgdG9wLCB0aGUgbGF0ZXIgaW5kaWNlcyB3b3VsZFxuICAgICAgICAvLyBnZXQgb2Zmc2V0LiBXZSBzb3J0IHRoZW0gaW50byBkZXNjZW5kaW5nIG9yZGVyIHRvIGF2b2lkIHRoYXQuXG4gICAgICAgIGluZGljZXMuc29ydChmdW5jdGlvbihhLCBiKSB7cmV0dXJuIGItYTt9KTtcbiAgICAgICAgZm9yIChpPTA7IGkgPCBpbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2VsbCA9IHRoaXMuZ2V0X2NlbGwoaW5kaWNlc1tpXSk7XG4gICAgICAgICAgICB0aGlzLnVuZGVsZXRlX2JhY2t1cC5wdXNoKGNlbGwudG9KU09OKCkpO1xuICAgICAgICAgICAgdGhpcy5nZXRfY2VsbF9lbGVtZW50KGluZGljZXNbaV0pLnJlbW92ZSgpO1xuICAgICAgICAgICAgdGhpcy5ldmVudHMudHJpZ2dlcignZGVsZXRlLkNlbGwnLCB7J2NlbGwnOiBjZWxsLCAnaW5kZXgnOiBpbmRpY2VzW2ldfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGbGlwIHRoZSBiYWNrdXAgY29weSBvZiBjZWxscyBiYWNrIHRvIGZpcnN0LXRvLWxhc3Qgb3JkZXJcbiAgICAgICAgdGhpcy51bmRlbGV0ZV9iYWNrdXAucmV2ZXJzZSgpO1xuXG4gICAgICAgIHZhciBuZXdfbmNlbGxzID0gdGhpcy5uY2VsbHMoKTtcbiAgICAgICAgLy8gQWx3YXlzIG1ha2Ugc3VyZSB3ZSBoYXZlIGF0IGxlYXN0IG9uZSBjZWxsLlxuICAgICAgICBpZiAobmV3X25jZWxscyA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5pbnNlcnRfY2VsbF9iZWxvdygnY29kZScpO1xuICAgICAgICAgICAgbmV3X25jZWxscyA9IDE7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnVuZGVsZXRlX2JlbG93ID0gZmFsc2U7XG4gICAgICAgIHZhciBjdXJzb3JfaXhfYWZ0ZXIgPSB0aGlzLmdldF9zZWxlY3RlZF9pbmRleCgpO1xuICAgICAgICBpZiAoY3Vyc29yX2l4X2FmdGVyID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBTZWxlY3RlZCBjZWxsIHdhcyBkZWxldGVkXG4gICAgICAgICAgICBjdXJzb3JfaXhfYWZ0ZXIgPSBjdXJzb3JfaXhfYmVmb3JlIC0gZGVsZXRpbmdfYmVmb3JlX2N1cnNvcjtcbiAgICAgICAgICAgIGlmIChjdXJzb3JfaXhfYWZ0ZXIgPj0gbmV3X25jZWxscykge1xuICAgICAgICAgICAgICAgIGN1cnNvcl9peF9hZnRlciA9IG5ld19uY2VsbHMgLSAxO1xuICAgICAgICAgICAgICAgIHRoaXMudW5kZWxldGVfYmVsb3cgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZWxlY3QoY3Vyc29yX2l4X2FmdGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoaXMgd2lsbCBwdXQgYWxsIHRoZSBkZWxldGVkIGNlbGxzIGJhY2sgaW4gb25lIGxvY2F0aW9uLCByYXRoZXIgdGhhblxuICAgICAgICAvLyB3aGVyZSB0aGV5IGNhbWUgZnJvbS4gSXQgd2lsbCBkbyB1bnRpbCB3ZSBoYXZlIHByb3BlciB1bmRvIHN1cHBvcnQuXG4gICAgICAgIHRoaXMudW5kZWxldGVfaW5kZXggPSBjdXJzb3JfaXhfYWZ0ZXI7XG4gICAgICAgICQoJyN1bmRlbGV0ZV9jZWxsJykucmVtb3ZlQ2xhc3MoJ2Rpc2FibGVkJyk7XG5cbiAgICAgICAgdGhpcy5zZXRfZGlydHkodHJ1ZSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBhIGNlbGwgZnJvbSB0aGUgbm90ZWJvb2suXG4gICAgICogXG4gICAgICogQHBhcmFtIHtpbnRlZ2VyfSBbaW5kZXhdIC0gY2VsbCdzIG51bWVyaWMgaW5kZXhcbiAgICAgKiBAcmV0dXJuIHtOb3RlYm9va30gVGhpcyBub3RlYm9va1xuICAgICAqL1xuICAgIE5vdGVib29rLnByb3RvdHlwZS5kZWxldGVfY2VsbCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVsZXRlX2NlbGxzKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWxldGVfY2VsbHMoW2luZGV4XSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVzdG9yZSB0aGUgbW9zdCByZWNlbnRseSBkZWxldGVkIGNlbGxzLlxuICAgICAqL1xuICAgIE5vdGVib29rLnByb3RvdHlwZS51bmRlbGV0ZV9jZWxsID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLnVuZGVsZXRlX2JhY2t1cCAhPT0gbnVsbCAmJiB0aGlzLnVuZGVsZXRlX2luZGV4ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgaSwgY2VsbF9kYXRhLCBuZXdfY2VsbDtcbiAgICAgICAgICAgIGlmICh0aGlzLnVuZGVsZXRlX2JlbG93KSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gdGhpcy51bmRlbGV0ZV9iYWNrdXAubGVuZ3RoLTE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGNlbGxfZGF0YSA9IHRoaXMudW5kZWxldGVfYmFja3VwW2ldO1xuICAgICAgICAgICAgICAgICAgICBuZXdfY2VsbCA9IHRoaXMuaW5zZXJ0X2NlbGxfYmVsb3coY2VsbF9kYXRhLmNlbGxfdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudW5kZWxldGVfaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBuZXdfY2VsbC5mcm9tSlNPTihjZWxsX2RhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChpPTA7IGkgPCB0aGlzLnVuZGVsZXRlX2JhY2t1cC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjZWxsX2RhdGEgPSB0aGlzLnVuZGVsZXRlX2JhY2t1cFtpXTtcbiAgICAgICAgICAgICAgICAgICAgbmV3X2NlbGwgPSB0aGlzLmluc2VydF9jZWxsX2Fib3ZlKGNlbGxfZGF0YS5jZWxsX3R5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVuZGVsZXRlX2luZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgbmV3X2NlbGwuZnJvbUpTT04oY2VsbF9kYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuc2V0X2RpcnR5KHRydWUpO1xuICAgICAgICAgICAgdGhpcy51bmRlbGV0ZV9iYWNrdXAgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy51bmRlbGV0ZV9pbmRleCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgJCgnI3VuZGVsZXRlX2NlbGwnKS5hZGRDbGFzcygnZGlzYWJsZWQnKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSW5zZXJ0IGEgY2VsbCBzbyB0aGF0IGFmdGVyIGluc2VydGlvbiB0aGUgY2VsbCBpcyBhdCBnaXZlbiBpbmRleC5cbiAgICAgKlxuICAgICAqIElmIGNlbGwgdHlwZSBpcyBub3QgcHJvdmlkZWQsIGl0IHdpbGwgZGVmYXVsdCB0byB0aGUgdHlwZSBvZiB0aGVcbiAgICAgKiBjdXJyZW50bHkgYWN0aXZlIGNlbGwuXG4gICAgICpcbiAgICAgKiBTaW1pbGFyIHRvIGluc2VydF9hYm92ZSwgYnV0IGluZGV4IHBhcmFtZXRlciBpcyBtYW5kYXRvcnkuXG4gICAgICpcbiAgICAgKiBJbmRleCB3aWxsIGJlIGJyb3VnaHQgYmFjayBpbnRvIHRoZSBhY2Nlc3NpYmxlIHJhbmdlIFswLG5dLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlXSAtIGluIFsnY29kZScsJ21hcmtkb3duJywgJ3JhdyddLCBkZWZhdWx0cyB0byAnY29kZSdcbiAgICAgKiBAcGFyYW0ge2ludGVnZXJ9IFtpbmRleF0gLSBhIHZhbGlkIGluZGV4IHdoZXJlIHRvIGluc2VydCBjZWxsXG4gICAgICogQHJldHVybiB7Q2VsbHxudWxsfSBjcmVhdGVkIGNlbGwgb3IgbnVsbFxuICAgICAqL1xuICAgIE5vdGVib29rLnByb3RvdHlwZS5pbnNlcnRfY2VsbF9hdF9pbmRleCA9IGZ1bmN0aW9uKHR5cGUsIGluZGV4KXtcblxuICAgICAgICB2YXIgbmNlbGxzID0gdGhpcy5uY2VsbHMoKTtcbiAgICAgICAgaW5kZXggPSBNYXRoLm1pbihpbmRleCwgbmNlbGxzKTtcbiAgICAgICAgaW5kZXggPSBNYXRoLm1heChpbmRleCwgMCk7XG4gICAgICAgIHZhciBjZWxsID0gbnVsbDtcbiAgICAgICAgdHlwZSA9IHR5cGUgfHwgdGhpcy5jbGFzc19jb25maWcuZ2V0X3N5bmMoJ2RlZmF1bHRfY2VsbF90eXBlJyk7XG4gICAgICAgIGlmICh0eXBlID09PSAnYWJvdmUnKSB7XG4gICAgICAgICAgICBpZiAoaW5kZXggPiAwKSB7XG4gICAgICAgICAgICAgICAgdHlwZSA9IHRoaXMuZ2V0X2NlbGwoaW5kZXgtMSkuY2VsbF90eXBlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0eXBlID0gJ2NvZGUnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdiZWxvdycpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA8IG5jZWxscykge1xuICAgICAgICAgICAgICAgIHR5cGUgPSB0aGlzLmdldF9jZWxsKGluZGV4KS5jZWxsX3R5cGU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHR5cGUgPSAnY29kZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3NlbGVjdGVkJykge1xuICAgICAgICAgICAgdHlwZSA9IHRoaXMuZ2V0X3NlbGVjdGVkX2NlbGwoKS5jZWxsX3R5cGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmNlbGxzID09PSAwIHx8IHRoaXMuaXNfdmFsaWRfY2VsbF9pbmRleChpbmRleCkgfHwgaW5kZXggPT09IG5jZWxscykge1xuICAgICAgICAgICAgdmFyIGNlbGxfb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICBldmVudHM6IHRoaXMuZXZlbnRzLCBcbiAgICAgICAgICAgICAgICBjb25maWc6IHRoaXMuY29uZmlnLCBcbiAgICAgICAgICAgICAgICBrZXlib2FyZF9tYW5hZ2VyOiB0aGlzLmtleWJvYXJkX21hbmFnZXIsIFxuICAgICAgICAgICAgICAgIG5vdGVib29rOiB0aGlzLFxuICAgICAgICAgICAgICAgIHRvb2x0aXA6IHRoaXMudG9vbHRpcFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHN3aXRjaCh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdjb2RlJzpcbiAgICAgICAgICAgICAgICBjZWxsID0gbmV3IGNvZGVjZWxsLkNvZGVDZWxsKHRoaXMua2VybmVsLCBjZWxsX29wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGNlbGwuc2V0X2lucHV0X3Byb21wdCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbWFya2Rvd24nOlxuICAgICAgICAgICAgICAgIGNlbGwgPSBuZXcgdGV4dGNlbGwuTWFya2Rvd25DZWxsKGNlbGxfb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdyYXcnOlxuICAgICAgICAgICAgICAgIGNlbGwgPSBuZXcgdGV4dGNlbGwuUmF3Q2VsbChjZWxsX29wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlVucmVjb2duaXplZCBjZWxsIHR5cGU6IFwiLCB0eXBlLCBjZWxsbW9kKTtcbiAgICAgICAgICAgICAgICBjZWxsID0gbmV3IGNlbGxtb2QuVW5yZWNvZ25pemVkQ2VsbChjZWxsX29wdGlvbnMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZih0aGlzLl9pbnNlcnRfZWxlbWVudF9hdF9pbmRleChjZWxsLmVsZW1lbnQsaW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgY2VsbC5yZW5kZXIoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cy50cmlnZ2VyKCdjcmVhdGUuQ2VsbCcsIHsnY2VsbCc6IGNlbGwsICdpbmRleCc6IGluZGV4fSk7XG4gICAgICAgICAgICAgICAgY2VsbC5yZWZyZXNoKCk7XG4gICAgICAgICAgICAgICAgLy8gV2UgdXNlZCB0byBzZWxlY3QgdGhlIGNlbGwgYWZ0ZXIgd2UgcmVmcmVzaCBpdCwgYnV0IHRoZXJlXG4gICAgICAgICAgICAgICAgLy8gYXJlIG5vdyBjYXNlcyB3ZXJlIHRoaXMgbWV0aG9kIGlzIGNhbGxlZCB3aGVyZSBzZWxlY3QgaXNcbiAgICAgICAgICAgICAgICAvLyBub3QgYXBwcm9wcmlhdGUuIFRoZSBzZWxlY3Rpb24gbG9naWMgc2hvdWxkIGJlIGhhbmRsZWQgYnkgdGhlXG4gICAgICAgICAgICAgICAgLy8gY2FsbGVyIG9mIHRoZSB0aGUgdG9wIGxldmVsIGluc2VydF9jZWxsIG1ldGhvZHMuXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRfZGlydHkodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNlbGw7XG5cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSW5zZXJ0IGFuIGVsZW1lbnQgYXQgZ2l2ZW4gY2VsbCBpbmRleC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgLSBhIGNlbGwgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7aW50ZWdlcn0gICAgIFtpbmRleF0gLSBhIHZhbGlkIGluZGV4IHdoZXJlIHRvIGluc2VyIGNlbGxcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gICBzdWNjZXNzXG4gICAgICovXG4gICAgTm90ZWJvb2sucHJvdG90eXBlLl9pbnNlcnRfZWxlbWVudF9hdF9pbmRleCA9IGZ1bmN0aW9uKGVsZW1lbnQsIGluZGV4KXtcbiAgICAgICAgaWYgKGVsZW1lbnQgPT09IHVuZGVmaW5lZCl7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbmNlbGxzID0gdGhpcy5uY2VsbHMoKTtcblxuICAgICAgICBpZiAobmNlbGxzID09PSAwKSB7XG4gICAgICAgICAgICAvLyBzcGVjaWFsIGNhc2UgYXBwZW5kIGlmIGVtcHR5XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmQoZWxlbWVudCk7XG4gICAgICAgIH0gZWxzZSBpZiAoIG5jZWxscyA9PT0gaW5kZXggKSB7XG4gICAgICAgICAgICAvLyBzcGVjaWFsIGNhc2UgYXBwZW5kIGl0IHRoZSBlbmQsIGJ1dCBub3QgZW1wdHlcbiAgICAgICAgICAgIHRoaXMuZ2V0X2NlbGxfZWxlbWVudChpbmRleC0xKS5hZnRlcihlbGVtZW50KTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmlzX3ZhbGlkX2NlbGxfaW5kZXgoaW5kZXgpKSB7XG4gICAgICAgICAgICAvLyBvdGhlcndpc2UgYWx3YXlzIHNvbWV3aGVyZSB0byBhcHBlbmQgdG9cbiAgICAgICAgICAgIHRoaXMuZ2V0X2NlbGxfZWxlbWVudChpbmRleCkuYmVmb3JlKGVsZW1lbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMudW5kZWxldGVfaW5kZXggIT09IG51bGwgJiYgaW5kZXggPD0gdGhpcy51bmRlbGV0ZV9pbmRleCkge1xuICAgICAgICAgICAgdGhpcy51bmRlbGV0ZV9pbmRleCA9IHRoaXMudW5kZWxldGVfaW5kZXggKyAxO1xuICAgICAgICAgICAgdGhpcy5zZXRfZGlydHkodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEluc2VydCBhIGNlbGwgb2YgZ2l2ZW4gdHlwZSBhYm92ZSBnaXZlbiBpbmRleCwgb3IgYXQgdG9wXG4gICAgICogb2Ygbm90ZWJvb2sgaWYgaW5kZXggc21hbGxlciB0aGFuIDAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gICAgIFt0eXBlXSAtIGNlbGwgdHlwZVxuICAgICAqIEBwYXJhbSB7aW50ZWdlcn0gICAgW2luZGV4XSAtIGRlZmF1bHRzIHRvIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgY2VsbFxuICAgICAqIEByZXR1cm4ge0NlbGx8bnVsbH0gaGFuZGxlIHRvIGNyZWF0ZWQgY2VsbCBvciBudWxsXG4gICAgICovXG4gICAgTm90ZWJvb2sucHJvdG90eXBlLmluc2VydF9jZWxsX2Fib3ZlID0gZnVuY3Rpb24gKHR5cGUsIGluZGV4KSB7XG4gICAgICAgIGluZGV4ID0gdGhpcy5pbmRleF9vcl9zZWxlY3RlZChpbmRleCk7XG4gICAgICAgIHJldHVybiB0aGlzLmluc2VydF9jZWxsX2F0X2luZGV4KHR5cGUsIGluZGV4KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSW5zZXJ0IGEgY2VsbCBvZiBnaXZlbiB0eXBlIGJlbG93IGdpdmVuIGluZGV4LCBvciBhdCBib3R0b21cbiAgICAgKiBvZiBub3RlYm9vayBpZiBpbmRleCBncmVhdGVyIHRoYW4gbnVtYmVyIG9mIGNlbGxzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gICAgIFt0eXBlXSAtIGNlbGwgdHlwZVxuICAgICAqIEBwYXJhbSB7aW50ZWdlcn0gICAgW2luZGV4XSAtIGRlZmF1bHRzIHRvIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgY2VsbFxuICAgICAqIEByZXR1cm4ge0NlbGx8bnVsbH0gaGFuZGxlIHRvIGNyZWF0ZWQgY2VsbCBvciBudWxsXG4gICAgICovXG4gICAgTm90ZWJvb2sucHJvdG90eXBlLmluc2VydF9jZWxsX2JlbG93ID0gZnVuY3Rpb24gKHR5cGUsIGluZGV4KSB7XG4gICAgICAgIGluZGV4ID0gdGhpcy5pbmRleF9vcl9zZWxlY3RlZChpbmRleCk7XG4gICAgICAgIHJldHVybiB0aGlzLmluc2VydF9jZWxsX2F0X2luZGV4KHR5cGUsIGluZGV4KzEpO1xuICAgIH07XG5cblxuICAgIC8qKlxuICAgICAqIEluc2VydCBjZWxsIGF0IGVuZCBvZiBub3RlYm9va1xuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBjZWxsIHR5cGVcbiAgICAgKiBAcmV0dXJuIHtDZWxsfG51bGx9IGhhbmRsZSB0byBjcmVhdGVkIGNlbGwgb3IgbnVsbFxuICAgICAqL1xuICAgIE5vdGVib29rLnByb3RvdHlwZS5pbnNlcnRfY2VsbF9hdF9ib3R0b20gPSBmdW5jdGlvbiAodHlwZSl7XG4gICAgICAgIHZhciBsZW4gPSB0aGlzLm5jZWxscygpO1xuICAgICAgICByZXR1cm4gdGhpcy5pbnNlcnRfY2VsbF9iZWxvdyh0eXBlLGxlbi0xKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVHVybiBhIGNlbGwgaW50byBhIGNvZGUgY2VsbC5cbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge2ludGVnZXJ9IFtpbmRleF0gLSBjZWxsIGluZGV4XG4gICAgICovXG4gICAgTm90ZWJvb2sucHJvdG90eXBlLnRvX2NvZGUgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgdmFyIGkgPSB0aGlzLmluZGV4X29yX3NlbGVjdGVkKGluZGV4KTtcbiAgICAgICAgaWYgKHRoaXMuaXNfdmFsaWRfY2VsbF9pbmRleChpKSkge1xuICAgICAgICAgICAgdmFyIHNvdXJjZV9jZWxsID0gdGhpcy5nZXRfY2VsbChpKTtcbiAgICAgICAgICAgIGlmICghKHNvdXJjZV9jZWxsIGluc3RhbmNlb2YgY29kZWNlbGwuQ29kZUNlbGwpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldF9jZWxsID0gdGhpcy5pbnNlcnRfY2VsbF9iZWxvdygnY29kZScsaSk7XG4gICAgICAgICAgICAgICAgdmFyIHRleHQgPSBzb3VyY2VfY2VsbC5nZXRfdGV4dCgpO1xuICAgICAgICAgICAgICAgIGlmICh0ZXh0ID09PSBzb3VyY2VfY2VsbC5wbGFjZWhvbGRlcikge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vbWV0YWRhdGFcbiAgICAgICAgICAgICAgICB0YXJnZXRfY2VsbC5tZXRhZGF0YSA9IHNvdXJjZV9jZWxsLm1ldGFkYXRhO1xuXG4gICAgICAgICAgICAgICAgdGFyZ2V0X2NlbGwuc2V0X3RleHQodGV4dCk7XG4gICAgICAgICAgICAgICAgLy8gbWFrZSB0aGlzIHZhbHVlIHRoZSBzdGFydGluZyBwb2ludCwgc28gdGhhdCB3ZSBjYW4gb25seSB1bmRvXG4gICAgICAgICAgICAgICAgLy8gdG8gdGhpcyBzdGF0ZSwgaW5zdGVhZCBvZiBhIGJsYW5rIGNlbGxcbiAgICAgICAgICAgICAgICB0YXJnZXRfY2VsbC5jb2RlX21pcnJvci5jbGVhckhpc3RvcnkoKTtcbiAgICAgICAgICAgICAgICBzb3VyY2VfY2VsbC5lbGVtZW50LnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0KGkpO1xuICAgICAgICAgICAgICAgIHZhciBjdXJzb3IgPSBzb3VyY2VfY2VsbC5jb2RlX21pcnJvci5nZXRDdXJzb3IoKTtcbiAgICAgICAgICAgICAgICB0YXJnZXRfY2VsbC5jb2RlX21pcnJvci5zZXRDdXJzb3IoY3Vyc29yKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldF9kaXJ0eSh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUdXJuIGEgY2VsbCBpbnRvIGEgTWFya2Rvd24gY2VsbC5cbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge2ludGVnZXJ9IFtpbmRleF0gLSBjZWxsIGluZGV4XG4gICAgICovXG4gICAgTm90ZWJvb2sucHJvdG90eXBlLnRvX21hcmtkb3duID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHZhciBpID0gdGhpcy5pbmRleF9vcl9zZWxlY3RlZChpbmRleCk7XG4gICAgICAgIGlmICh0aGlzLmlzX3ZhbGlkX2NlbGxfaW5kZXgoaSkpIHtcbiAgICAgICAgICAgIHZhciBzb3VyY2VfY2VsbCA9IHRoaXMuZ2V0X2NlbGwoaSk7XG5cbiAgICAgICAgICAgIGlmICghKHNvdXJjZV9jZWxsIGluc3RhbmNlb2YgdGV4dGNlbGwuTWFya2Rvd25DZWxsKSkge1xuICAgICAgICAgICAgICAgIHZhciB0YXJnZXRfY2VsbCA9IHRoaXMuaW5zZXJ0X2NlbGxfYmVsb3coJ21hcmtkb3duJyxpKTtcbiAgICAgICAgICAgICAgICB2YXIgdGV4dCA9IHNvdXJjZV9jZWxsLmdldF90ZXh0KCk7XG5cbiAgICAgICAgICAgICAgICBpZiAodGV4dCA9PT0gc291cmNlX2NlbGwucGxhY2Vob2xkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dCA9ICcnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBtZXRhZGF0YVxuICAgICAgICAgICAgICAgIHRhcmdldF9jZWxsLm1ldGFkYXRhID0gc291cmNlX2NlbGwubWV0YWRhdGE7XG4gICAgICAgICAgICAgICAgLy8gV2UgbXVzdCBzaG93IHRoZSBlZGl0b3IgYmVmb3JlIHNldHRpbmcgaXRzIGNvbnRlbnRzXG4gICAgICAgICAgICAgICAgdGFyZ2V0X2NlbGwudW5yZW5kZXIoKTtcbiAgICAgICAgICAgICAgICB0YXJnZXRfY2VsbC5zZXRfdGV4dCh0ZXh0KTtcbiAgICAgICAgICAgICAgICAvLyBtYWtlIHRoaXMgdmFsdWUgdGhlIHN0YXJ0aW5nIHBvaW50LCBzbyB0aGF0IHdlIGNhbiBvbmx5IHVuZG9cbiAgICAgICAgICAgICAgICAvLyB0byB0aGlzIHN0YXRlLCBpbnN0ZWFkIG9mIGEgYmxhbmsgY2VsbFxuICAgICAgICAgICAgICAgIHRhcmdldF9jZWxsLmNvZGVfbWlycm9yLmNsZWFySGlzdG9yeSgpO1xuICAgICAgICAgICAgICAgIHNvdXJjZV9jZWxsLmVsZW1lbnQucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3QoaSk7XG4gICAgICAgICAgICAgICAgaWYgKChzb3VyY2VfY2VsbCBpbnN0YW5jZW9mIHRleHRjZWxsLlRleHRDZWxsKSAmJiBzb3VyY2VfY2VsbC5yZW5kZXJlZCkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRfY2VsbC5yZW5kZXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGN1cnNvciA9IHNvdXJjZV9jZWxsLmNvZGVfbWlycm9yLmdldEN1cnNvcigpO1xuICAgICAgICAgICAgICAgIHRhcmdldF9jZWxsLmNvZGVfbWlycm9yLnNldEN1cnNvcihjdXJzb3IpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0X2RpcnR5KHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFR1cm4gYSBjZWxsIGludG8gYSByYXcgdGV4dCBjZWxsLlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7aW50ZWdlcn0gW2luZGV4XSAtIGNlbGwgaW5kZXhcbiAgICAgKi9cbiAgICBOb3RlYm9vay5wcm90b3R5cGUudG9fcmF3ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHZhciBpID0gdGhpcy5pbmRleF9vcl9zZWxlY3RlZChpbmRleCk7XG4gICAgICAgIGlmICh0aGlzLmlzX3ZhbGlkX2NlbGxfaW5kZXgoaSkpIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXRfY2VsbCA9IG51bGw7XG4gICAgICAgICAgICB2YXIgc291cmNlX2NlbGwgPSB0aGlzLmdldF9jZWxsKGkpO1xuXG4gICAgICAgICAgICBpZiAoIShzb3VyY2VfY2VsbCBpbnN0YW5jZW9mIHRleHRjZWxsLlJhd0NlbGwpKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0X2NlbGwgPSB0aGlzLmluc2VydF9jZWxsX2JlbG93KCdyYXcnLGkpO1xuICAgICAgICAgICAgICAgIHZhciB0ZXh0ID0gc291cmNlX2NlbGwuZ2V0X3RleHQoKTtcbiAgICAgICAgICAgICAgICBpZiAodGV4dCA9PT0gc291cmNlX2NlbGwucGxhY2Vob2xkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dCA9ICcnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvL21ldGFkYXRhXG4gICAgICAgICAgICAgICAgdGFyZ2V0X2NlbGwubWV0YWRhdGEgPSBzb3VyY2VfY2VsbC5tZXRhZGF0YTtcbiAgICAgICAgICAgICAgICAvLyBXZSBtdXN0IHNob3cgdGhlIGVkaXRvciBiZWZvcmUgc2V0dGluZyBpdHMgY29udGVudHNcbiAgICAgICAgICAgICAgICB0YXJnZXRfY2VsbC51bnJlbmRlcigpO1xuICAgICAgICAgICAgICAgIHRhcmdldF9jZWxsLnNldF90ZXh0KHRleHQpO1xuICAgICAgICAgICAgICAgIC8vIG1ha2UgdGhpcyB2YWx1ZSB0aGUgc3RhcnRpbmcgcG9pbnQsIHNvIHRoYXQgd2UgY2FuIG9ubHkgdW5kb1xuICAgICAgICAgICAgICAgIC8vIHRvIHRoaXMgc3RhdGUsIGluc3RlYWQgb2YgYSBibGFuayBjZWxsXG4gICAgICAgICAgICAgICAgdGFyZ2V0X2NlbGwuY29kZV9taXJyb3IuY2xlYXJIaXN0b3J5KCk7XG4gICAgICAgICAgICAgICAgc291cmNlX2NlbGwuZWxlbWVudC5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdChpKTtcbiAgICAgICAgICAgICAgICB2YXIgY3Vyc29yID0gc291cmNlX2NlbGwuY29kZV9taXJyb3IuZ2V0Q3Vyc29yKCk7XG4gICAgICAgICAgICAgICAgdGFyZ2V0X2NlbGwuY29kZV9taXJyb3Iuc2V0Q3Vyc29yKGN1cnNvcik7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRfZGlydHkodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogV2FybiBhYm91dCBoZWFkaW5nIGNlbGwgc3VwcG9ydCByZW1vdmFsLlxuICAgICAqL1xuICAgIE5vdGVib29rLnByb3RvdHlwZS5fd2Fybl9oZWFkaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBkaWFsb2cubW9kYWwoe1xuICAgICAgICAgICAgbm90ZWJvb2s6IHRoaXMsXG4gICAgICAgICAgICBrZXlib2FyZF9tYW5hZ2VyOiB0aGlzLmtleWJvYXJkX21hbmFnZXIsXG4gICAgICAgICAgICB0aXRsZSA6IFwiVXNlIG1hcmtkb3duIGhlYWRpbmdzXCIsXG4gICAgICAgICAgICBib2R5IDogJChcIjxwLz5cIikudGV4dChcbiAgICAgICAgICAgICAgICAnSnVweXRlciBubyBsb25nZXIgdXNlcyBzcGVjaWFsIGhlYWRpbmcgY2VsbHMuICcgKyBcbiAgICAgICAgICAgICAgICAnSW5zdGVhZCwgd3JpdGUgeW91ciBoZWFkaW5ncyBpbiBNYXJrZG93biBjZWxscyB1c2luZyAjIGNoYXJhY3RlcnM6J1xuICAgICAgICAgICAgKS5hcHBlbmQoJCgnPHByZS8+JykudGV4dChcbiAgICAgICAgICAgICAgICAnIyMgVGhpcyBpcyBhIGxldmVsIDIgaGVhZGluZydcbiAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgYnV0dG9ucyA6IHtcbiAgICAgICAgICAgICAgICBcIk9LXCIgOiB7fVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVHVybiBhIGNlbGwgaW50byBhIGhlYWRpbmcgY29udGFpbmluZyBtYXJrZG93biBjZWxsLlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7aW50ZWdlcn0gW2luZGV4XSAtIGNlbGwgaW5kZXhcbiAgICAgKiBAcGFyYW0ge2ludGVnZXJ9IFtsZXZlbF0gLSBoZWFkaW5nIGxldmVsIChlLmcuLCAxIGZvciBoMSlcbiAgICAgKi9cbiAgICBOb3RlYm9vay5wcm90b3R5cGUudG9faGVhZGluZyA9IGZ1bmN0aW9uIChpbmRleCwgbGV2ZWwpIHtcbiAgICAgICAgdGhpcy50b19tYXJrZG93bihpbmRleCk7XG4gICAgICAgIGxldmVsID0gbGV2ZWwgfHwgMTtcbiAgICAgICAgdmFyIGkgPSB0aGlzLmluZGV4X29yX3NlbGVjdGVkKGluZGV4KTtcbiAgICAgICAgaWYgKHRoaXMuaXNfdmFsaWRfY2VsbF9pbmRleChpKSkge1xuICAgICAgICAgICAgdmFyIGNlbGwgPSB0aGlzLmdldF9jZWxsKGkpO1xuICAgICAgICAgICAgY2VsbC5zZXRfaGVhZGluZ19sZXZlbChsZXZlbCk7XG4gICAgICAgICAgICB0aGlzLnNldF9kaXJ0eSh0cnVlKTtcbiAgICAgICAgfVxuICAgIH07XG5cblxuICAgIC8vIEN1dC9Db3B5L1Bhc3RlXG5cbiAgICAvKipcbiAgICAgKiBFbmFibGUgdGhlIFVJIGVsZW1lbnRzIGZvciBwYXN0aW5nIGNlbGxzLlxuICAgICAqL1xuICAgIE5vdGVib29rLnByb3RvdHlwZS5lbmFibGVfcGFzdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLnBhc3RlX2VuYWJsZWQpIHtcbiAgICAgICAgICAgICQoJyNwYXN0ZV9jZWxsX3JlcGxhY2UnKS5yZW1vdmVDbGFzcygnZGlzYWJsZWQnKVxuICAgICAgICAgICAgICAgIC5vbignY2xpY2snLCBmdW5jdGlvbiAoKSB7dGhhdC5wYXN0ZV9jZWxsX3JlcGxhY2UoKTt9KTtcbiAgICAgICAgICAgICQoJyNwYXN0ZV9jZWxsX2Fib3ZlJykucmVtb3ZlQ2xhc3MoJ2Rpc2FibGVkJylcbiAgICAgICAgICAgICAgICAub24oJ2NsaWNrJywgZnVuY3Rpb24gKCkge3RoYXQucGFzdGVfY2VsbF9hYm92ZSgpO30pO1xuICAgICAgICAgICAgJCgnI3Bhc3RlX2NlbGxfYmVsb3cnKS5yZW1vdmVDbGFzcygnZGlzYWJsZWQnKVxuICAgICAgICAgICAgICAgIC5vbignY2xpY2snLCBmdW5jdGlvbiAoKSB7dGhhdC5wYXN0ZV9jZWxsX2JlbG93KCk7fSk7XG4gICAgICAgICAgICB0aGlzLnBhc3RlX2VuYWJsZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIERpc2FibGUgdGhlIFVJIGVsZW1lbnRzIGZvciBwYXN0aW5nIGNlbGxzLlxuICAgICAqL1xuICAgIE5vdGVib29rLnByb3RvdHlwZS5kaXNhYmxlX3Bhc3RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5wYXN0ZV9lbmFibGVkKSB7XG4gICAgICAgICAgICAkKCcjcGFzdGVfY2VsbF9yZXBsYWNlJykuYWRkQ2xhc3MoJ2Rpc2FibGVkJykub2ZmKCdjbGljaycpO1xuICAgICAgICAgICAgJCgnI3Bhc3RlX2NlbGxfYWJvdmUnKS5hZGRDbGFzcygnZGlzYWJsZWQnKS5vZmYoJ2NsaWNrJyk7XG4gICAgICAgICAgICAkKCcjcGFzdGVfY2VsbF9iZWxvdycpLmFkZENsYXNzKCdkaXNhYmxlZCcpLm9mZignY2xpY2snKTtcbiAgICAgICAgICAgIHRoaXMucGFzdGVfZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEN1dCBhIGNlbGwuXG4gICAgICovXG4gICAgTm90ZWJvb2sucHJvdG90eXBlLmN1dF9jZWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNvcHlfY2VsbCgpO1xuICAgICAgICB0aGlzLmRlbGV0ZV9jZWxsKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvcHkgY2VsbHMuXG4gICAgICovXG4gICAgTm90ZWJvb2sucHJvdG90eXBlLmNvcHlfY2VsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNlbGxzID0gdGhpcy5nZXRfc2VsZWN0ZWRfY2VsbHMoKTtcbiAgICAgICAgdGhpcy5jbGlwYm9hcmQgPSBbXTtcbiAgICAgICAgdmFyIGNlbGxfanNvbjtcbiAgICAgICAgZm9yICh2YXIgaT0wOyBpIDwgY2VsbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNlbGxfanNvbiA9IGNlbGxzW2ldLnRvSlNPTigpO1xuICAgICAgICAgICAgaWYgKGNlbGxfanNvbi5tZXRhZGF0YS5kZWxldGFibGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBjZWxsX2pzb24ubWV0YWRhdGEuZGVsZXRhYmxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jbGlwYm9hcmQucHVzaChjZWxsX2pzb24pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW5hYmxlX3Bhc3RlKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlcGxhY2UgdGhlIHNlbGVjdGVkIGNlbGwgd2l0aCB0aGUgY2VsbHMgaW4gdGhlIGNsaXBib2FyZC5cbiAgICAgKi9cbiAgICBOb3RlYm9vay5wcm90b3R5cGUucGFzdGVfY2VsbF9yZXBsYWNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5jbGlwYm9hcmQgIT09IG51bGwgJiYgdGhpcy5wYXN0ZV9lbmFibGVkKSB7XG4gICAgICAgICAgICB2YXIgZmlyc3RfaW5zZXJ0ZWQgPSBudWxsO1xuICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpIDwgdGhpcy5jbGlwYm9hcmQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY2VsbF9kYXRhID0gdGhpcy5jbGlwYm9hcmQ7XG4gICAgICAgICAgICAgICAgdmFyIG5ld19jZWxsID0gdGhpcy5pbnNlcnRfY2VsbF9hYm92ZShjZWxsX2RhdGEuY2VsbF90eXBlKTtcbiAgICAgICAgICAgICAgICBuZXdfY2VsbC5mcm9tSlNPTihjZWxsX2RhdGEpO1xuICAgICAgICAgICAgICAgIGlmIChmaXJzdF9pbnNlcnRlZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdF9pbnNlcnRlZCA9IG5ld19jZWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBvbGRfc2VsZWN0ZWQgPSB0aGlzLmdldF9zZWxlY3RlZF9pbmRleCgpO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3QodGhpcy5maW5kX2NlbGxfaW5kZXgoZmlyc3RfaW5zZXJ0ZWQpKTtcbiAgICAgICAgICAgIHRoaXMuZGVsZXRlX2NlbGwob2xkX3NlbGVjdGVkKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBQYXN0ZSBjZWxscyBmcm9tIHRoZSBjbGlwYm9hcmQgYWJvdmUgdGhlIHNlbGVjdGVkIGNlbGwuXG4gICAgICovXG4gICAgTm90ZWJvb2sucHJvdG90eXBlLnBhc3RlX2NlbGxfYWJvdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmNsaXBib2FyZCAhPT0gbnVsbCAmJiB0aGlzLnBhc3RlX2VuYWJsZWQpIHtcbiAgICAgICAgICAgIHZhciBmaXJzdF9pbnNlcnRlZCA9IG51bGw7XG4gICAgICAgICAgICBmb3IgKHZhciBpPTA7IGkgPCB0aGlzLmNsaXBib2FyZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBjZWxsX2RhdGEgPSB0aGlzLmNsaXBib2FyZFtpXTtcbiAgICAgICAgICAgICAgICB2YXIgbmV3X2NlbGwgPSB0aGlzLmluc2VydF9jZWxsX2Fib3ZlKGNlbGxfZGF0YS5jZWxsX3R5cGUpO1xuICAgICAgICAgICAgICAgIG5ld19jZWxsLmZyb21KU09OKGNlbGxfZGF0YSk7XG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0X2luc2VydGVkID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0X2luc2VydGVkID0gbmV3X2NlbGw7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaXJzdF9pbnNlcnRlZC5mb2N1c19jZWxsKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUGFzdGUgY2VsbHMgZnJvbSB0aGUgY2xpcGJvYXJkIGJlbG93IHRoZSBzZWxlY3RlZCBjZWxsLlxuICAgICAqL1xuICAgIE5vdGVib29rLnByb3RvdHlwZS5wYXN0ZV9jZWxsX2JlbG93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5jbGlwYm9hcmQgIT09IG51bGwgJiYgdGhpcy5wYXN0ZV9lbmFibGVkKSB7XG4gICAgICAgICAgICB2YXIgZmlyc3RfaW5zZXJ0ZWQgPSBudWxsO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMuY2xpcGJvYXJkLmxlbmd0aC0xOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIHZhciBjZWxsX2RhdGEgPSB0aGlzLmNsaXBib2FyZFtpXTtcbiAgICAgICAgICAgICAgICB2YXIgbmV3X2NlbGwgPSB0aGlzLmluc2VydF9jZWxsX2JlbG93KGNlbGxfZGF0YS5jZWxsX3R5cGUpO1xuICAgICAgICAgICAgICAgIG5ld19jZWxsLmZyb21KU09OKGNlbGxfZGF0YSk7XG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0X2luc2VydGVkID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0X2luc2VydGVkID0gbmV3X2NlbGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmlyc3RfaW5zZXJ0ZWQuZm9jdXNfY2VsbCgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIFNwbGl0L21lcmdlXG5cbiAgICAvKipcbiAgICAgKiBTcGxpdCB0aGUgc2VsZWN0ZWQgY2VsbCBpbnRvIHR3byBjZWxscy5cbiAgICAgKi9cbiAgICBOb3RlYm9vay5wcm90b3R5cGUuc3BsaXRfY2VsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNlbGwgPSB0aGlzLmdldF9zZWxlY3RlZF9jZWxsKCk7XG4gICAgICAgIGlmIChjZWxsLmlzX3NwbGl0dGFibGUoKSkge1xuICAgICAgICAgICAgdmFyIHRleHRhID0gY2VsbC5nZXRfcHJlX2N1cnNvcigpO1xuICAgICAgICAgICAgdmFyIHRleHRiID0gY2VsbC5nZXRfcG9zdF9jdXJzb3IoKTtcbiAgICAgICAgICAgIGNlbGwuc2V0X3RleHQodGV4dGIpO1xuICAgICAgICAgICAgdmFyIG5ld19jZWxsID0gdGhpcy5pbnNlcnRfY2VsbF9hYm92ZShjZWxsLmNlbGxfdHlwZSk7XG4gICAgICAgICAgICAvLyBVbnJlbmRlciB0aGUgbmV3IGNlbGwgc28gd2UgY2FuIGNhbGwgc2V0X3RleHQuXG4gICAgICAgICAgICBuZXdfY2VsbC51bnJlbmRlcigpO1xuICAgICAgICAgICAgbmV3X2NlbGwuc2V0X3RleHQodGV4dGEpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIE1lcmdlIGEgc2VyaWVzIG9mIGNlbGxzIGludG8gb25lXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBpbmRpY2VzIC0gdGhlIG51bWVyaWMgaW5kaWNlcyBvZiB0aGUgY2VsbHMgdG8gYmUgbWVyZ2VkXG4gICAgICogQHBhcmFtIHtib29sfSBpbnRvX2xhc3QgLSBtZXJnZSBpbnRvIHRoZSBsYXN0IGNlbGwgaW5zdGVhZCBvZiB0aGUgZmlyc3RcbiAgICAgKi9cbiAgICBOb3RlYm9vay5wcm90b3R5cGUubWVyZ2VfY2VsbHMgPSBmdW5jdGlvbihpbmRpY2VzLCBpbnRvX2xhc3QpIHtcbiAgICAgICAgaWYgKGluZGljZXMubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpPTA7IGkgPCBpbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZ2V0X2NlbGwoaW5kaWNlc1tpXSkuaXNfbWVyZ2VhYmxlKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRhcmdldCA9IHRoaXMuZ2V0X2NlbGwoaW50b19sYXN0ID8gaW5kaWNlcy5wb3AoKSA6IGluZGljZXMuc2hpZnQoKSk7XG5cbiAgICAgICAgLy8gR2V0IGFsbCB0aGUgY2VsbHMnIGNvbnRlbnRzXG4gICAgICAgIHZhciBjb250ZW50cyA9IFtdO1xuICAgICAgICBmb3IgKGk9MDsgaSA8IGluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnRlbnRzLnB1c2godGhpcy5nZXRfY2VsbChpbmRpY2VzW2ldKS5nZXRfdGV4dCgpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW50b19sYXN0KSB7XG4gICAgICAgICAgICBjb250ZW50cy5wdXNoKHRhcmdldC5nZXRfdGV4dCgpKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29udGVudHMudW5zaGlmdCh0YXJnZXQuZ2V0X3RleHQoKSlcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgY29udGVudHMgb2YgdGhlIHRhcmdldCBjZWxsXG4gICAgICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBjb2RlY2VsbC5Db2RlQ2VsbCkge1xuICAgICAgICAgICAgdGFyZ2V0LnNldF90ZXh0KGNvbnRlbnRzLmpvaW4oJ1xcblxcbicpKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHdhc19yZW5kZXJlZCA9IHRhcmdldC5yZW5kZXJlZDtcbiAgICAgICAgICAgIHRhcmdldC51bnJlbmRlcigpOyAvLyBNdXN0IHVucmVuZGVyIGJlZm9yZSB3ZSBzZXRfdGV4dC5cbiAgICAgICAgICAgIHRhcmdldC5zZXRfdGV4dChjb250ZW50cy5qb2luKCdcXG5cXG4nKSk7XG4gICAgICAgICAgICBpZiAod2FzX3JlbmRlcmVkKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIHJlbmRlcmVkIHN0YXRlIG9mIHRoZSBmaW5hbCBjZWxsIHNob3VsZCBtYXRjaFxuICAgICAgICAgICAgICAgIC8vIHRoYXQgb2YgdGhlIG9yaWdpbmFsIHNlbGVjdGVkIGNlbGw7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnJlbmRlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVsZXRlIHRoZSBvdGhlciBjZWxsc1xuICAgICAgICB0aGlzLmRlbGV0ZV9jZWxscyhpbmRpY2VzKTtcblxuICAgICAgICB0aGlzLnNlbGVjdCh0aGlzLmZpbmRfY2VsbF9pbmRleCh0YXJnZXQpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTWVyZ2UgdGhlIHNlbGVjdGVkIHJhbmdlIG9mIGNlbGxzXG4gICAgICovXG4gICAgTm90ZWJvb2sucHJvdG90eXBlLm1lcmdlX3NlbGVjdGVkX2NlbGxzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMubWVyZ2VfY2VsbHModGhpcy5nZXRfc2VsZWN0ZWRfaW5kaWNlcygpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTWVyZ2UgdGhlIHNlbGVjdGVkIGNlbGwgaW50byB0aGUgY2VsbCBhYm92ZSBpdC5cbiAgICAgKi9cbiAgICBOb3RlYm9vay5wcm90b3R5cGUubWVyZ2VfY2VsbF9hYm92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5nZXRfc2VsZWN0ZWRfaW5kZXgoKTtcbiAgICAgICAgdGhpcy5tZXJnZV9jZWxscyhbaW5kZXgtMSwgaW5kZXhdLCB0cnVlKVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBNZXJnZSB0aGUgc2VsZWN0ZWQgY2VsbCBpbnRvIHRoZSBjZWxsIGJlbG93IGl0LlxuICAgICAqL1xuICAgIE5vdGVib29rLnByb3RvdHlwZS5tZXJnZV9jZWxsX2JlbG93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmdldF9zZWxlY3RlZF9pbmRleCgpO1xuICAgICAgICB0aGlzLm1lcmdlX2NlbGxzKFtpbmRleCwgaW5kZXgrMV0sIGZhbHNlKVxuICAgIH07XG5cblxuICAgIC8vIENlbGwgY29sbGFwc2luZyBhbmQgb3V0cHV0IGNsZWFyaW5nXG5cbiAgICAvKipcbiAgICAgKiBIaWRlIGEgY2VsbCdzIG91dHB1dC5cbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge2ludGVnZXJ9IGluZGV4IC0gY2VsbCBpbmRleFxuICAgICAqL1xuICAgIE5vdGVib29rLnByb3RvdHlwZS5jb2xsYXBzZV9vdXRwdXQgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgdmFyIGkgPSB0aGlzLmluZGV4X29yX3NlbGVjdGVkKGluZGV4KTtcbiAgICAgICAgdmFyIGNlbGwgPSB0aGlzLmdldF9jZWxsKGkpO1xuICAgICAgICBpZiAoY2VsbCAhPT0gbnVsbCAmJiAoY2VsbCBpbnN0YW5jZW9mIGNvZGVjZWxsLkNvZGVDZWxsKSkge1xuICAgICAgICAgICAgY2VsbC5jb2xsYXBzZV9vdXRwdXQoKTtcbiAgICAgICAgICAgIHRoaXMuc2V0X2RpcnR5KHRydWUpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEhpZGUgZWFjaCBjb2RlIGNlbGwncyBvdXRwdXQgYXJlYS5cbiAgICAgKi9cbiAgICBOb3RlYm9vay5wcm90b3R5cGUuY29sbGFwc2VfYWxsX291dHB1dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5nZXRfY2VsbHMoKS5tYXAoZnVuY3Rpb24gKGNlbGwsIGkpIHtcbiAgICAgICAgICAgIGlmIChjZWxsIGluc3RhbmNlb2YgY29kZWNlbGwuQ29kZUNlbGwpIHtcbiAgICAgICAgICAgICAgICBjZWxsLmNvbGxhcHNlX291dHB1dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gdGhpcyBzaG91bGQgbm90IGJlIHNldCBpZiB0aGUgYGNvbGxhcHNlYCBrZXkgaXMgcmVtb3ZlZCBmcm9tIG5iZm9ybWF0XG4gICAgICAgIHRoaXMuc2V0X2RpcnR5KHRydWUpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTaG93IGEgY2VsbCdzIG91dHB1dC5cbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge2ludGVnZXJ9IGluZGV4IC0gY2VsbCBpbmRleFxuICAgICAqL1xuICAgIE5vdGVib29rLnByb3RvdHlwZS5leHBhbmRfb3V0cHV0ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHZhciBpID0gdGhpcy5pbmRleF9vcl9zZWxlY3RlZChpbmRleCk7XG4gICAgICAgIHZhciBjZWxsID0gdGhpcy5nZXRfY2VsbChpKTtcbiAgICAgICAgaWYgKGNlbGwgIT09IG51bGwgJiYgKGNlbGwgaW5zdGFuY2VvZiBjb2RlY2VsbC5Db2RlQ2VsbCkpIHtcbiAgICAgICAgICAgIGNlbGwuZXhwYW5kX291dHB1dCgpO1xuICAgICAgICAgICAgdGhpcy5zZXRfZGlydHkodHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRXhwYW5kIGVhY2ggY29kZSBjZWxsJ3Mgb3V0cHV0IGFyZWEsIGFuZCByZW1vdmUgc2Nyb2xsYmFycy5cbiAgICAgKi9cbiAgICBOb3RlYm9vay5wcm90b3R5cGUuZXhwYW5kX2FsbF9vdXRwdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZ2V0X2NlbGxzKCkubWFwKGZ1bmN0aW9uIChjZWxsLCBpKSB7XG4gICAgICAgICAgICBpZiAoY2VsbCBpbnN0YW5jZW9mIGNvZGVjZWxsLkNvZGVDZWxsKSB7XG4gICAgICAgICAgICAgICAgY2VsbC5leHBhbmRfb3V0cHV0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyB0aGlzIHNob3VsZCBub3QgYmUgc2V0IGlmIHRoZSBgY29sbGFwc2VgIGtleSBpcyByZW1vdmVkIGZyb20gbmJmb3JtYXRcbiAgICAgICAgdGhpcy5zZXRfZGlydHkodHJ1ZSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENsZWFyIHRoZSBzZWxlY3RlZCBDb2RlQ2VsbCdzIG91dHB1dCBhcmVhLlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7aW50ZWdlcn0gaW5kZXggLSBjZWxsIGluZGV4XG4gICAgICovXG4gICAgTm90ZWJvb2sucHJvdG90eXBlLmNsZWFyX291dHB1dCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICB2YXIgaSA9IHRoaXMuaW5kZXhfb3Jfc2VsZWN0ZWQoaW5kZXgpO1xuICAgICAgICB2YXIgY2VsbCA9IHRoaXMuZ2V0X2NlbGwoaSk7XG4gICAgICAgIGlmIChjZWxsICE9PSBudWxsICYmIChjZWxsIGluc3RhbmNlb2YgY29kZWNlbGwuQ29kZUNlbGwpKSB7XG4gICAgICAgICAgICBjZWxsLmNsZWFyX291dHB1dCgpO1xuICAgICAgICAgICAgdGhpcy5zZXRfZGlydHkodHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2xlYXIgZWFjaCBjb2RlIGNlbGwncyBvdXRwdXQgYXJlYS5cbiAgICAgKi9cbiAgICBOb3RlYm9vay5wcm90b3R5cGUuY2xlYXJfYWxsX291dHB1dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5nZXRfY2VsbHMoKS5tYXAoZnVuY3Rpb24gKGNlbGwsIGkpIHtcbiAgICAgICAgICAgIGlmIChjZWxsIGluc3RhbmNlb2YgY29kZWNlbGwuQ29kZUNlbGwpIHtcbiAgICAgICAgICAgICAgICBjZWxsLmNsZWFyX291dHB1dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZXRfZGlydHkodHJ1ZSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNjcm9sbCB0aGUgc2VsZWN0ZWQgQ29kZUNlbGwncyBvdXRwdXQgYXJlYS5cbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge2ludGVnZXJ9IGluZGV4IC0gY2VsbCBpbmRleFxuICAgICAqL1xuICAgIE5vdGVib29rLnByb3RvdHlwZS5zY3JvbGxfb3V0cHV0ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHZhciBpID0gdGhpcy5pbmRleF9vcl9zZWxlY3RlZChpbmRleCk7XG4gICAgICAgIHZhciBjZWxsID0gdGhpcy5nZXRfY2VsbChpKTtcbiAgICAgICAgaWYgKGNlbGwgIT09IG51bGwgJiYgKGNlbGwgaW5zdGFuY2VvZiBjb2RlY2VsbC5Db2RlQ2VsbCkpIHtcbiAgICAgICAgICAgIGNlbGwuc2Nyb2xsX291dHB1dCgpO1xuICAgICAgICAgICAgdGhpcy5zZXRfZGlydHkodHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRXhwYW5kIGVhY2ggY29kZSBjZWxsJ3Mgb3V0cHV0IGFyZWEgYW5kIGFkZCBhIHNjcm9sbGJhciBmb3IgbG9uZyBvdXRwdXQuXG4gICAgICovXG4gICAgTm90ZWJvb2sucHJvdG90eXBlLnNjcm9sbF9hbGxfb3V0cHV0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmdldF9jZWxscygpLm1hcChmdW5jdGlvbiAoY2VsbCwgaSkge1xuICAgICAgICAgICAgaWYgKGNlbGwgaW5zdGFuY2VvZiBjb2RlY2VsbC5Db2RlQ2VsbCkge1xuICAgICAgICAgICAgICAgIGNlbGwuc2Nyb2xsX291dHB1dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gdGhpcyBzaG91bGQgbm90IGJlIHNldCBpZiB0aGUgYGNvbGxhcHNlYCBrZXkgaXMgcmVtb3ZlZCBmcm9tIG5iZm9ybWF0XG4gICAgICAgIHRoaXMuc2V0X2RpcnR5KHRydWUpO1xuICAgIH07XG5cbiAgICAvKiogXG4gICAgICogVG9nZ2xlIHdoZXRoZXIgYSBjZWxsJ3Mgb3V0cHV0IGlzIGNvbGxhcHNlZCBvciBleHBhbmRlZC5cbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge2ludGVnZXJ9IGluZGV4IC0gY2VsbCBpbmRleFxuICAgICAqL1xuICAgIE5vdGVib29rLnByb3RvdHlwZS50b2dnbGVfb3V0cHV0ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHZhciBpID0gdGhpcy5pbmRleF9vcl9zZWxlY3RlZChpbmRleCk7XG4gICAgICAgIHZhciBjZWxsID0gdGhpcy5nZXRfY2VsbChpKTtcbiAgICAgICAgaWYgKGNlbGwgIT09IG51bGwgJiYgKGNlbGwgaW5zdGFuY2VvZiBjb2RlY2VsbC5Db2RlQ2VsbCkpIHtcbiAgICAgICAgICAgIGNlbGwudG9nZ2xlX291dHB1dCgpO1xuICAgICAgICAgICAgdGhpcy5zZXRfZGlydHkodHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVG9nZ2xlIHRoZSBvdXRwdXQgb2YgYWxsIGNlbGxzLlxuICAgICAqL1xuICAgIE5vdGVib29rLnByb3RvdHlwZS50b2dnbGVfYWxsX291dHB1dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5nZXRfY2VsbHMoKS5tYXAoZnVuY3Rpb24gKGNlbGwsIGkpIHtcbiAgICAgICAgICAgIGlmIChjZWxsIGluc3RhbmNlb2YgY29kZWNlbGwuQ29kZUNlbGwpIHtcbiAgICAgICAgICAgICAgICBjZWxsLnRvZ2dsZV9vdXRwdXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIHRoaXMgc2hvdWxkIG5vdCBiZSBzZXQgaWYgdGhlIGBjb2xsYXBzZWAga2V5IGlzIHJlbW92ZWQgZnJvbSBuYmZvcm1hdFxuICAgICAgICB0aGlzLnNldF9kaXJ0eSh0cnVlKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVG9nZ2xlIGEgc2Nyb2xsYmFyIGZvciBsb25nIGNlbGwgb3V0cHV0cy5cbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge2ludGVnZXJ9IGluZGV4IC0gY2VsbCBpbmRleFxuICAgICAqL1xuICAgIE5vdGVib29rLnByb3RvdHlwZS50b2dnbGVfb3V0cHV0X3Njcm9sbCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICB2YXIgaSA9IHRoaXMuaW5kZXhfb3Jfc2VsZWN0ZWQoaW5kZXgpO1xuICAgICAgICB2YXIgY2VsbCA9IHRoaXMuZ2V0X2NlbGwoaSk7XG4gICAgICAgIGlmIChjZWxsICE9PSBudWxsICYmIChjZWxsIGluc3RhbmNlb2YgY29kZWNlbGwuQ29kZUNlbGwpKSB7XG4gICAgICAgICAgICBjZWxsLnRvZ2dsZV9vdXRwdXRfc2Nyb2xsKCk7XG4gICAgICAgICAgICB0aGlzLnNldF9kaXJ0eSh0cnVlKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUb2dnbGUgdGhlIHNjcm9sbGluZyBvZiBsb25nIG91dHB1dCBvbiBhbGwgY2VsbHMuXG4gICAgICovXG4gICAgTm90ZWJvb2sucHJvdG90eXBlLnRvZ2dsZV9hbGxfb3V0cHV0X3Njcm9sbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5nZXRfY2VsbHMoKS5tYXAoZnVuY3Rpb24gKGNlbGwsIGkpIHtcbiAgICAgICAgICAgIGlmIChjZWxsIGluc3RhbmNlb2YgY29kZWNlbGwuQ29kZUNlbGwpIHtcbiAgICAgICAgICAgICAgICBjZWxsLnRvZ2dsZV9vdXRwdXRfc2Nyb2xsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyB0aGlzIHNob3VsZCBub3QgYmUgc2V0IGlmIHRoZSBgY29sbGFwc2VgIGtleSBpcyByZW1vdmVkIGZyb20gbmJmb3JtYXRcbiAgICAgICAgdGhpcy5zZXRfZGlydHkodHJ1ZSk7XG4gICAgfTtcblxuICAgIC8vIE90aGVyIGNlbGwgZnVuY3Rpb25zOiBsaW5lIG51bWJlcnMsIC4uLlxuXG4gICAgLyoqXG4gICAgICogVG9nZ2xlIGxpbmUgbnVtYmVycyBpbiB0aGUgc2VsZWN0ZWQgY2VsbCdzIGlucHV0IGFyZWEuXG4gICAgICovXG4gICAgTm90ZWJvb2sucHJvdG90eXBlLmNlbGxfdG9nZ2xlX2xpbmVfbnVtYmVycyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmdldF9zZWxlY3RlZF9jZWxsKCkudG9nZ2xlX2xpbmVfbnVtYmVycygpO1xuICAgIH07XG5cblxuICAgIC8vZGlzcGF0Y2ggY29kZW1pcnJvciBtb2RlIHRvIGFsbCBjZWxscy5cbiAgICBOb3RlYm9vay5wcm90b3R5cGUuX2Rpc3BhdGNoX21vZGUgPSBmdW5jdGlvbihzcGVjLCBuZXdtb2RlKXtcbiAgICAgICAgdGhpcy5jb2RlbWlycm9yX21vZGUgPSBuZXdtb2RlO1xuICAgICAgICBjb2RlY2VsbC5Db2RlQ2VsbC5vcHRpb25zX2RlZmF1bHQuY21fY29uZmlnLm1vZGUgPSBuZXdtb2RlO1xuICAgICAgICB0aGlzLmdldF9jZWxscygpLm1hcChmdW5jdGlvbihjZWxsLCBpKSB7XG4gICAgICAgICAgICBpZiAoY2VsbC5jZWxsX3R5cGUgPT09ICdjb2RlJyl7XG4gICAgICAgICAgICAgICAgY2VsbC5jb2RlX21pcnJvci5zZXRPcHRpb24oJ21vZGUnLCBzcGVjKTtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGN1cnJlbnRseSByZWR1bmRhbnQsIGJlY2F1c2UgY21fY29uZmlnIGVuZHMgdXAgYXNcbiAgICAgICAgICAgICAgICAvLyBjb2RlbWlycm9yJ3Mgb3duIC5vcHRpb25zIG9iamVjdCwgYnV0IEkgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAgICAgICAgIC8vIHJlbHkgb24gdGhhdC5cbiAgICAgICAgICAgICAgICBjZWxsLl9vcHRpb25zLmNtX2NvbmZpZy5tb2RlID0gc3BlYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICB9O1xuXG4gICAgLy8gcm91Z2hseSB0cnkgdG8gY2hlY2sgbW9kZSBlcXVhbGl0eVxuICAgIHZhciBfbW9kZV9lcXVhbCA9IGZ1bmN0aW9uKG1vZGUxLCBtb2RlMil7XG4gICAgICAgIHJldHVybiAoKG1vZGUxfHx7fSkubmFtZXx8bW9kZTEpPT09KChtb2RlMnx8e30pLm5hbWV8fG1vZGUyKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBjb2RlbWlycm9yIG1vZGUgZm9yIGFsbCBjb2RlIGNlbGxzLCBpbmNsdWRpbmcgdGhlIGRlZmF1bHQgZm9yXG4gICAgICogbmV3IGNvZGUgY2VsbHMuXG4gICAgICogU2V0IHRoZSBtb2RlIHRvICdudWxsJyAobm8gaGlnaGxpZ2h0aW5nKSBpZiBpdCBjYW4ndCBiZSBmb3VuZC5cbiAgICAgKi9cbiAgICBOb3RlYm9vay5wcm90b3R5cGUuc2V0X2NvZGVtaXJyb3JfbW9kZSA9IGZ1bmN0aW9uKG5ld21vZGUpe1xuICAgICAgICAvLyBpZiBtb2RlIGlzIHRoZSBzYW1lIGRvbid0IHJlc2V0LFxuICAgICAgICAvLyB0byBhdm9pZCBuLXRpbWUgcmUtaGlnaGxpZ2h0aW5nLlxuICAgICAgICBpZiAoX21vZGVfZXF1YWwobmV3bW9kZSwgdGhpcy5jb2RlbWlycm9yX21vZGUpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgdXRpbHMucmVxdWlyZUNvZGVNaXJyb3JNb2RlKG5ld21vZGUsIGZ1bmN0aW9uIChzcGVjKSB7XG4gICAgICAgICAgICB0aGF0Ll9kaXNwYXRjaF9tb2RlKHNwZWMsIG5ld21vZGUpO1xuICAgICAgICB9LCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgLy8gb24gZXJyb3IgZG9uJ3QgZGlzcGF0Y2ggdGhlIG5ldyBtb2RlIGFzIHJlLXNldHRpbmcgaXQgbGF0ZXIgd2lsbCBub3Qgd29yay5cbiAgICAgICAgICAgIC8vIGRvbid0IGVpdGhlciBzZXQgdG8gbnVsbCBtb2RlIGlmIGl0IGhhcyBiZWVuIGNoYW5nZWQgaW4gdGhlIG1lYW50aW1lXG4gICAgICAgICAgICBpZiggX21vZGVfZXF1YWwobmV3bW9kZSwgdGhpcy5jb2RlbWlycm9yX21vZGUpICl7XG4gICAgICAgICAgICAgICAgdGhhdC5fZGlzcGF0Y2hfbW9kZSgnbnVsbCcsJ251bGwnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIFNlc3Npb24gcmVsYXRlZCB0aGluZ3NcblxuICAgIC8qKlxuICAgICAqIFN0YXJ0IGEgbmV3IHNlc3Npb24gYW5kIHNldCBpdCBvbiBlYWNoIGNvZGUgY2VsbC5cbiAgICAgKi9cbiAgICBOb3RlYm9vay5wcm90b3R5cGUuc3RhcnRfc2Vzc2lvbiA9IGZ1bmN0aW9uIChrZXJuZWxfbmFtZSkge1xuICAgICAgICBpZiAodGhpcy5fc2Vzc2lvbl9zdGFydGluZykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IHNlc3Npb24uU2Vzc2lvbkFscmVhZHlTdGFydGluZygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Nlc3Npb25fc3RhcnRpbmcgPSB0cnVlO1xuXG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgICAgYmFzZV91cmw6IHRoaXMuYmFzZV91cmwsXG4gICAgICAgICAgICB3c191cmw6IHRoaXMud3NfdXJsLFxuICAgICAgICAgICAgbm90ZWJvb2tfcGF0aDogdGhpcy5ub3RlYm9va19wYXRoLFxuICAgICAgICAgICAgbm90ZWJvb2tfbmFtZTogdGhpcy5ub3RlYm9va19uYW1lLFxuICAgICAgICAgICAga2VybmVsX25hbWU6IGtlcm5lbF9uYW1lLFxuICAgICAgICAgICAgbm90ZWJvb2s6IHRoaXNcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgc3VjY2VzcyA9ICQucHJveHkodGhpcy5fc2Vzc2lvbl9zdGFydGVkLCB0aGlzKTtcbiAgICAgICAgdmFyIGZhaWx1cmUgPSAkLnByb3h5KHRoaXMuX3Nlc3Npb25fc3RhcnRfZmFpbGVkLCB0aGlzKTtcblxuICAgICAgICBpZiAodGhpcy5zZXNzaW9uICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnNlc3Npb24ucmVzdGFydChvcHRpb25zLCBzdWNjZXNzLCBmYWlsdXJlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbiA9IG5ldyBzZXNzaW9uLlNlc3Npb24ob3B0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLnNlc3Npb24uc3RhcnQoc3VjY2VzcywgZmFpbHVyZSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG5cbiAgICAvKipcbiAgICAgKiBPbmNlIGEgc2Vzc2lvbiBpcyBzdGFydGVkLCBsaW5rIHRoZSBjb2RlIGNlbGxzIHRvIHRoZSBrZXJuZWwgYW5kIHBhc3MgdGhlIFxuICAgICAqIGNvbW0gbWFuYWdlciB0byB0aGUgd2lkZ2V0IG1hbmFnZXIuXG4gICAgICovXG4gICAgTm90ZWJvb2sucHJvdG90eXBlLl9zZXNzaW9uX3N0YXJ0ZWQgPSBmdW5jdGlvbiAoKXtcbiAgICAgICAgdGhpcy5fc2Vzc2lvbl9zdGFydGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmtlcm5lbCA9IHRoaXMuc2Vzc2lvbi5rZXJuZWw7XG4gICAgICAgIHZhciBuY2VsbHMgPSB0aGlzLm5jZWxscygpO1xuICAgICAgICBmb3IgKHZhciBpPTA7IGk8bmNlbGxzOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjZWxsID0gdGhpcy5nZXRfY2VsbChpKTtcbiAgICAgICAgICAgIGlmIChjZWxsIGluc3RhbmNlb2YgY29kZWNlbGwuQ29kZUNlbGwpIHtcbiAgICAgICAgICAgICAgICBjZWxsLnNldF9rZXJuZWwodGhpcy5zZXNzaW9uLmtlcm5lbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIHNlc3Npb24gZmFpbHMgdG8gc3RhcnQuXG4gICAgICovXG4gICAgTm90ZWJvb2sucHJvdG90eXBlLl9zZXNzaW9uX3N0YXJ0X2ZhaWxlZCA9IGZ1bmN0aW9uKGpxeGhyLCBzdGF0dXMsIGVycm9yKXtcbiAgICAgICAgdGhpcy5fc2Vzc2lvbl9zdGFydGluZyA9IGZhbHNlO1xuICAgICAgICB1dGlscy5sb2dfYWpheF9lcnJvcihqcXhociwgc3RhdHVzLCBlcnJvcik7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFByb21wdCB0aGUgdXNlciB0byByZXN0YXJ0IHRoZSBKdXB5dGVyIGtlcm5lbC5cbiAgICAgKi9cbiAgICBOb3RlYm9vay5wcm90b3R5cGUucmVzdGFydF9rZXJuZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgZGlhbG9nLm1vZGFsKHtcbiAgICAgICAgICAgIG5vdGVib29rOiB0aGlzLFxuICAgICAgICAgICAga2V5Ym9hcmRfbWFuYWdlcjogdGhpcy5rZXlib2FyZF9tYW5hZ2VyLFxuICAgICAgICAgICAgdGl0bGUgOiBcIlJlc3RhcnQga2VybmVsIG9yIGNvbnRpbnVlIHJ1bm5pbmc/XCIsXG4gICAgICAgICAgICBib2R5IDogJChcIjxwLz5cIikudGV4dChcbiAgICAgICAgICAgICAgICAnRG8geW91IHdhbnQgdG8gcmVzdGFydCB0aGUgY3VycmVudCBrZXJuZWw/ICBZb3Ugd2lsbCBsb3NlIGFsbCB2YXJpYWJsZXMgZGVmaW5lZCBpbiBpdC4nXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgYnV0dG9ucyA6IHtcbiAgICAgICAgICAgICAgICBcIkNvbnRpbnVlIHJ1bm5pbmdcIiA6IHt9LFxuICAgICAgICAgICAgICAgIFwiQ2xlYXIgYWxsIG91dHB1dHMgJiByZXN0YXJ0XCIgOiB7XG4gICAgICAgICAgICAgICAgICAgIFwiY2xhc3NcIiA6IFwiYnRuLWRhbmdlclwiLFxuICAgICAgICAgICAgICAgICAgICBcImNsaWNrXCIgOiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5jbGVhcl9hbGxfb3V0cHV0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0Lmtlcm5lbC5yZXN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcIlJlc3RhcnRcIiA6IHtcbiAgICAgICAgICAgICAgICAgICAgXCJjbGFzc1wiIDogXCJidG4td2FybmluZ1wiLFxuICAgICAgICAgICAgICAgICAgICBcImNsaWNrXCIgOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQua2VybmVsLnJlc3RhcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlIG9yIHJlbmRlciBjZWxsIG91dHB1dHMgYW5kIGdvIGludG8gY29tbWFuZCBtb2RlLlxuICAgICAqL1xuICAgIE5vdGVib29rLnByb3RvdHlwZS5leGVjdXRlX2NlbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIG1vZGUgPSBzaGlmdCwgY3RybCwgYWx0XG4gICAgICAgIHZhciBjZWxsID0gdGhpcy5nZXRfc2VsZWN0ZWRfY2VsbCgpO1xuICAgICAgICBcbiAgICAgICAgY2VsbC5leGVjdXRlKCk7XG4gICAgICAgIHRoaXMuY29tbWFuZF9tb2RlKCk7XG4gICAgICAgIHRoaXMuc2V0X2RpcnR5KHRydWUpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlIG9yIHJlbmRlciBjZWxsIG91dHB1dHMgYW5kIGluc2VydCBhIG5ldyBjZWxsIGJlbG93LlxuICAgICAqL1xuICAgIE5vdGVib29rLnByb3RvdHlwZS5leGVjdXRlX2NlbGxfYW5kX2luc2VydF9iZWxvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNlbGwgPSB0aGlzLmdldF9zZWxlY3RlZF9jZWxsKCk7XG4gICAgICAgIHZhciBjZWxsX2luZGV4ID0gdGhpcy5maW5kX2NlbGxfaW5kZXgoY2VsbCk7XG4gICAgICAgIFxuICAgICAgICBjZWxsLmV4ZWN1dGUoKTtcblxuICAgICAgICAvLyBJZiB3ZSBhcmUgYXQgdGhlIGVuZCBhbHdheXMgaW5zZXJ0IGEgbmV3IGNlbGwgYW5kIHJldHVyblxuICAgICAgICBpZiAoY2VsbF9pbmRleCA9PT0gKHRoaXMubmNlbGxzKCktMSkpIHtcbiAgICAgICAgICAgIHRoaXMuY29tbWFuZF9tb2RlKCk7XG4gICAgICAgICAgICB0aGlzLmluc2VydF9jZWxsX2JlbG93KCk7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdChjZWxsX2luZGV4KzEpO1xuICAgICAgICAgICAgdGhpcy5lZGl0X21vZGUoKTtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsX3RvX2JvdHRvbSgpO1xuICAgICAgICAgICAgdGhpcy5zZXRfZGlydHkodHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNvbW1hbmRfbW9kZSgpO1xuICAgICAgICB0aGlzLmluc2VydF9jZWxsX2JlbG93KCk7XG4gICAgICAgIHRoaXMuc2VsZWN0KGNlbGxfaW5kZXgrMSk7XG4gICAgICAgIHRoaXMuZWRpdF9tb2RlKCk7XG4gICAgICAgIHRoaXMuc2V0X2RpcnR5KHRydWUpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlIG9yIHJlbmRlciBjZWxsIG91dHB1dHMgYW5kIHNlbGVjdCB0aGUgbmV4dCBjZWxsLlxuICAgICAqL1xuICAgIE5vdGVib29rLnByb3RvdHlwZS5leGVjdXRlX2NlbGxfYW5kX3NlbGVjdF9iZWxvdyA9IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICB2YXIgY2VsbCA9IHRoaXMuZ2V0X3NlbGVjdGVkX2NlbGwoKTtcbiAgICAgICAgdmFyIGNlbGxfaW5kZXggPSB0aGlzLmZpbmRfY2VsbF9pbmRleChjZWxsKTtcbiAgICAgICAgXG4gICAgICAgIGNlbGwuZXhlY3V0ZSgpO1xuXG4gICAgICAgIC8vIElmIHdlIGFyZSBhdCB0aGUgZW5kIGFsd2F5cyBpbnNlcnQgYSBuZXcgY2VsbCBhbmQgcmV0dXJuXG4gICAgICAgIGlmIChjZWxsX2luZGV4ID09PSAodGhpcy5uY2VsbHMoKS0xKSkge1xuICAgICAgICAgICAgdGhpcy5jb21tYW5kX21vZGUoKTtcbiAgICAgICAgICAgIHRoaXMuaW5zZXJ0X2NlbGxfYmVsb3coKTtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0KGNlbGxfaW5kZXgrMSk7XG4gICAgICAgICAgICB0aGlzLmVkaXRfbW9kZSgpO1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxfdG9fYm90dG9tKCk7XG4gICAgICAgICAgICB0aGlzLnNldF9kaXJ0eSh0cnVlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY29tbWFuZF9tb2RlKCk7XG4gICAgICAgIHRoaXMuc2VsZWN0KGNlbGxfaW5kZXgrMSk7XG4gICAgICAgIHRoaXMuZm9jdXNfY2VsbCgpO1xuICAgICAgICB0aGlzLnNldF9kaXJ0eSh0cnVlKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRXhlY3V0ZSBhbGwgY2VsbHMgYmVsb3cgdGhlIHNlbGVjdGVkIGNlbGwuXG4gICAgICovXG4gICAgTm90ZWJvb2sucHJvdG90eXBlLmV4ZWN1dGVfY2VsbHNfYmVsb3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZXhlY3V0ZV9jZWxsX3JhbmdlKHRoaXMuZ2V0X3NlbGVjdGVkX2luZGV4KCksIHRoaXMubmNlbGxzKCkpO1xuICAgICAgICB0aGlzLnNjcm9sbF90b19ib3R0b20oKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRXhlY3V0ZSBhbGwgY2VsbHMgYWJvdmUgdGhlIHNlbGVjdGVkIGNlbGwuXG4gICAgICovXG4gICAgTm90ZWJvb2sucHJvdG90eXBlLmV4ZWN1dGVfY2VsbHNfYWJvdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZXhlY3V0ZV9jZWxsX3JhbmdlKDAsIHRoaXMuZ2V0X3NlbGVjdGVkX2luZGV4KCkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlIGFsbCBjZWxscy5cbiAgICAgKi9cbiAgICBOb3RlYm9vay5wcm90b3R5cGUuZXhlY3V0ZV9hbGxfY2VsbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZXhlY3V0ZV9jZWxsX3JhbmdlKDAsIHRoaXMubmNlbGxzKCkpO1xuICAgICAgICB0aGlzLnNjcm9sbF90b19ib3R0b20oKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRXhlY3V0ZSBhIGNvbnRpZ3VvdXMgcmFuZ2Ugb2YgY2VsbHMuXG4gICAgICogXG4gICAgICogQHBhcmFtIHtpbnRlZ2VyfSBzdGFydCAtIGluZGV4IG9mIHRoZSBmaXJzdCBjZWxsIHRvIGV4ZWN1dGUgKGluY2x1c2l2ZSlcbiAgICAgKiBAcGFyYW0ge2ludGVnZXJ9IGVuZCAtIGluZGV4IG9mIHRoZSBsYXN0IGNlbGwgdG8gZXhlY3V0ZSAoZXhjbHVzaXZlKVxuICAgICAqL1xuICAgIE5vdGVib29rLnByb3RvdHlwZS5leGVjdXRlX2NlbGxfcmFuZ2UgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICAgICAgICB0aGlzLmNvbW1hbmRfbW9kZSgpO1xuICAgICAgICBmb3IgKHZhciBpPXN0YXJ0OyBpPGVuZDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdChpKTtcbiAgICAgICAgICAgIHRoaXMuZXhlY3V0ZV9jZWxsKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gUGVyc2lzdGFuY2UgYW5kIGxvYWRpbmdcblxuICAgIC8qKlxuICAgICAqIEdldHRlciBtZXRob2QgZm9yIHRoaXMgbm90ZWJvb2sncyBuYW1lLlxuICAgICAqIFxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhpcyBub3RlYm9vaydzIG5hbWUgKGV4Y2x1ZGluZyBmaWxlIGV4dGVuc2lvbilcbiAgICAgKi9cbiAgICBOb3RlYm9vay5wcm90b3R5cGUuZ2V0X25vdGVib29rX25hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBuYm5hbWUgPSB1dGlscy5zcGxpdGV4dCh0aGlzLm5vdGVib29rX25hbWUpWzBdO1xuICAgICAgICByZXR1cm4gbmJuYW1lO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXR0ZXIgbWV0aG9kIGZvciB0aGlzIG5vdGVib29rJ3MgbmFtZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICovXG4gICAgTm90ZWJvb2sucHJvdG90eXBlLnNldF9ub3RlYm9va19uYW1lID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdmFyIHBhcmVudCA9IHV0aWxzLnVybF9wYXRoX3NwbGl0KHRoaXMubm90ZWJvb2tfcGF0aClbMF07XG4gICAgICAgIHRoaXMubm90ZWJvb2tfbmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMubm90ZWJvb2tfcGF0aCA9IHV0aWxzLnVybF9wYXRoX2pvaW4ocGFyZW50LCBuYW1lKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgdGhhdCBhIG5vdGVib29rJ3MgbmFtZSBpcyB2YWxpZC5cbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmJuYW1lIC0gQSBuYW1lIGZvciB0aGlzIG5vdGVib29rXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgbmFtZSBpcyB2YWxpZCwgZmFsc2UgaWYgaW52YWxpZFxuICAgICAqL1xuICAgIE5vdGVib29rLnByb3RvdHlwZS50ZXN0X25vdGVib29rX25hbWUgPSBmdW5jdGlvbiAobmJuYW1lKSB7XG4gICAgICAgIG5ibmFtZSA9IG5ibmFtZSB8fCAnJztcbiAgICAgICAgaWYgKG5ibmFtZS5sZW5ndGg+MCAmJiAhdGhpcy5ub3RlYm9va19uYW1lX2JsYWNrbGlzdF9yZS50ZXN0KG5ibmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIExvYWQgYSBub3RlYm9vayBmcm9tIEpTT04gKC5pcHluYikuXG4gICAgICogXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGRhdGEgLSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIGEgbm90ZWJvb2tcbiAgICAgKi9cbiAgICBOb3RlYm9vay5wcm90b3R5cGUuZnJvbUpTT04gPSBmdW5jdGlvbiAoZGF0YSkge1xuXG4gICAgICAgIHZhciBjb250ZW50ID0gZGF0YS5jb250ZW50O1xuICAgICAgICB2YXIgbmNlbGxzID0gdGhpcy5uY2VsbHMoKTtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIGZvciAoaT0wOyBpPG5jZWxsczsgaSsrKSB7XG4gICAgICAgICAgICAvLyBBbHdheXMgZGVsZXRlIGNlbGwgMCBhcyB0aGV5IGdldCByZW51bWJlcmVkIGFzIHRoZXkgYXJlIGRlbGV0ZWQuXG4gICAgICAgICAgICB0aGlzLl91bnNhZmVfZGVsZXRlX2NlbGwoMCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2F2ZSB0aGUgbWV0YWRhdGEgYW5kIG5hbWUuXG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBjb250ZW50Lm1ldGFkYXRhO1xuICAgICAgICB0aGlzLm5vdGVib29rX25hbWUgPSBkYXRhLm5hbWU7XG4gICAgICAgIHRoaXMubm90ZWJvb2tfcGF0aCA9IGRhdGEucGF0aDtcbiAgICAgICAgdmFyIHRydXN0ZWQgPSB0cnVlO1xuICAgICAgICBcbiAgICAgICAgLy8gU2V0IHRoZSBjb2RlbWlycm9yIG1vZGUgZnJvbSBsYW5ndWFnZV9pbmZvIG1ldGFkYXRhXG4gICAgICAgIGlmICh0aGlzLm1ldGFkYXRhLmxhbmd1YWdlX2luZm8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIGxhbmdpbmZvID0gdGhpcy5tZXRhZGF0YS5sYW5ndWFnZV9pbmZvO1xuICAgICAgICAgICAgLy8gTW9kZSAnbnVsbCcgc2hvdWxkIGJlIHBsYWluLCB1bmhpZ2hsaWdodGVkIHRleHQuXG4gICAgICAgICAgICB2YXIgY21fbW9kZSA9IGxhbmdpbmZvLmNvZGVtaXJyb3JfbW9kZSB8fCBsYW5naW5mby5uYW1lIHx8ICdudWxsJztcbiAgICAgICAgICAgIHRoaXMuc2V0X2NvZGVtaXJyb3JfbW9kZShjbV9tb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdmFyIG5ld19jZWxscyA9IGNvbnRlbnQuY2VsbHM7XG4gICAgICAgIG5jZWxscyA9IG5ld19jZWxscy5sZW5ndGg7XG4gICAgICAgIHZhciBjZWxsX2RhdGEgPSBudWxsO1xuICAgICAgICB2YXIgbmV3X2NlbGwgPSBudWxsO1xuICAgICAgICBmb3IgKGk9MDsgaTxuY2VsbHM7IGkrKykge1xuICAgICAgICAgICAgY2VsbF9kYXRhID0gbmV3X2NlbGxzW2ldO1xuICAgICAgICAgICAgbmV3X2NlbGwgPSB0aGlzLmluc2VydF9jZWxsX2F0X2luZGV4KGNlbGxfZGF0YS5jZWxsX3R5cGUsIGkpO1xuICAgICAgICAgICAgbmV3X2NlbGwuZnJvbUpTT04oY2VsbF9kYXRhKTtcbiAgICAgICAgICAgIGlmIChuZXdfY2VsbC5jZWxsX3R5cGUgPT09ICdjb2RlJyAmJiAhbmV3X2NlbGwub3V0cHV0X2FyZWEudHJ1c3RlZCkge1xuICAgICAgICAgICAgICAgIHRydXN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHJ1c3RlZCAhPT0gdGhpcy50cnVzdGVkKSB7XG4gICAgICAgICAgICB0aGlzLnRydXN0ZWQgPSB0cnVzdGVkO1xuICAgICAgICAgICAgdGhpcy5ldmVudHMudHJpZ2dlcihcInRydXN0X2NoYW5nZWQuTm90ZWJvb2tcIiwgdHJ1c3RlZCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRHVtcCB0aGlzIG5vdGVib29rIGludG8gYSBKU09OLWZyaWVuZGx5IG9iamVjdC5cbiAgICAgKiBcbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9IEEgSlNPTi1mcmllbmRseSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG5vdGVib29rLlxuICAgICAqL1xuICAgIE5vdGVib29rLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIHJlbW92ZSB0aGUgY29udmVyc2lvbiBpbmRpY2F0b3IsIHdoaWNoIG9ubHkgYmVsb25ncyBpbi1tZW1vcnlcbiAgICAgICAgZGVsZXRlIHRoaXMubWV0YWRhdGEub3JpZ19uYmZvcm1hdDtcbiAgICAgICAgZGVsZXRlIHRoaXMubWV0YWRhdGEub3JpZ19uYmZvcm1hdF9taW5vcjtcblxuICAgICAgICB2YXIgY2VsbHMgPSB0aGlzLmdldF9jZWxscygpO1xuICAgICAgICB2YXIgbmNlbGxzID0gY2VsbHMubGVuZ3RoO1xuICAgICAgICB2YXIgY2VsbF9hcnJheSA9IG5ldyBBcnJheShuY2VsbHMpO1xuICAgICAgICB2YXIgdHJ1c3RlZCA9IHRydWU7XG4gICAgICAgIGZvciAodmFyIGk9MDsgaTxuY2VsbHM7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNlbGwgPSBjZWxsc1tpXTtcbiAgICAgICAgICAgIGlmIChjZWxsLmNlbGxfdHlwZSA9PT0gJ2NvZGUnICYmICFjZWxsLm91dHB1dF9hcmVhLnRydXN0ZWQpIHtcbiAgICAgICAgICAgICAgICB0cnVzdGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjZWxsX2FycmF5W2ldID0gY2VsbC50b0pTT04oKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgICAgIGNlbGxzOiBjZWxsX2FycmF5LFxuICAgICAgICAgICAgbWV0YWRhdGE6IHRoaXMubWV0YWRhdGEsXG4gICAgICAgICAgICBuYmZvcm1hdDogdGhpcy5uYmZvcm1hdCxcbiAgICAgICAgICAgIG5iZm9ybWF0X21pbm9yOiB0aGlzLm5iZm9ybWF0X21pbm9yXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0cnVzdGVkICE9PSB0aGlzLnRydXN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMudHJ1c3RlZCA9IHRydXN0ZWQ7XG4gICAgICAgICAgICB0aGlzLmV2ZW50cy50cmlnZ2VyKFwidHJ1c3RfY2hhbmdlZC5Ob3RlYm9va1wiLCB0cnVzdGVkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU3RhcnQgYW4gYXV0b3NhdmUgdGltZXIgd2hpY2ggcGVyaW9kaWNhbGx5IHNhdmVzIHRoZSBub3RlYm9vay5cbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge2ludGVnZXJ9IGludGVydmFsIC0gdGhlIGF1dG9zYXZlIGludGVydmFsIGluIG1pbGxpc2Vjb25kc1xuICAgICAqL1xuICAgIE5vdGVib29rLnByb3RvdHlwZS5zZXRfYXV0b3NhdmVfaW50ZXJ2YWwgPSBmdW5jdGlvbiAoaW50ZXJ2YWwpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICAvLyBjbGVhciBwcmV2aW91cyBpbnRlcnZhbCwgc28gd2UgZG9uJ3QgZ2V0IHNpbXVsdGFuZW91cyB0aW1lcnNcbiAgICAgICAgaWYgKHRoaXMuYXV0b3NhdmVfdGltZXIpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5hdXRvc2F2ZV90aW1lcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLndyaXRhYmxlKSB7XG4gICAgICAgICAgICAvLyBkaXNhYmxlIGF1dG9zYXZlIGlmIG5vdCB3cml0YWJsZVxuICAgICAgICAgICAgaW50ZXJ2YWwgPSAwO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB0aGlzLmF1dG9zYXZlX2ludGVydmFsID0gdGhpcy5taW5pbXVtX2F1dG9zYXZlX2ludGVydmFsID0gaW50ZXJ2YWw7XG4gICAgICAgIGlmIChpbnRlcnZhbCkge1xuICAgICAgICAgICAgdGhpcy5hdXRvc2F2ZV90aW1lciA9IHNldEludGVydmFsKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGF0LmRpcnR5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQuc2F2ZV9ub3RlYm9vaygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGludGVydmFsKTtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzLnRyaWdnZXIoXCJhdXRvc2F2ZV9lbmFibGVkLk5vdGVib29rXCIsIGludGVydmFsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYXV0b3NhdmVfdGltZXIgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5ldmVudHMudHJpZ2dlcihcImF1dG9zYXZlX2Rpc2FibGVkLk5vdGVib29rXCIpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNhdmUgdGhpcyBub3RlYm9vayBvbiB0aGUgc2VydmVyLiBUaGlzIGJlY29tZXMgYSBub3RlYm9vayBpbnN0YW5jZSdzXG4gICAgICogLnNhdmVfbm90ZWJvb2sgbWV0aG9kICphZnRlciogdGhlIGVudGlyZSBub3RlYm9vayBoYXMgYmVlbiBsb2FkZWQuXG4gICAgICovXG4gICAgTm90ZWJvb2sucHJvdG90eXBlLnNhdmVfbm90ZWJvb2sgPSBmdW5jdGlvbiAoY2hlY2tfbGFzdF9tb2RpZmllZCkge1xuICAgICAgICBpZiAoY2hlY2tfbGFzdF9tb2RpZmllZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjaGVja19sYXN0X21vZGlmaWVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX2Z1bGx5X2xvYWRlZCkge1xuICAgICAgICAgICAgdGhpcy5ldmVudHMudHJpZ2dlcignbm90ZWJvb2tfc2F2ZV9mYWlsZWQuTm90ZWJvb2snLFxuICAgICAgICAgICAgICAgIG5ldyBFcnJvcihcIkxvYWQgZmFpbGVkLCBzYXZlIGlzIGRpc2FibGVkXCIpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLndyaXRhYmxlKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50cy50cmlnZ2VyKCdub3RlYm9va19zYXZlX2ZhaWxlZC5Ob3RlYm9vaycsXG4gICAgICAgICAgICAgICAgbmV3IEVycm9yKFwiTm90ZWJvb2sgaXMgcmVhZC1vbmx5XCIpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVHJpZ2dlciBhbiBldmVudCBiZWZvcmUgc2F2ZSwgd2hpY2ggYWxsb3dzIGxpc3RlbmVycyB0byBtb2RpZnlcbiAgICAgICAgLy8gdGhlIG5vdGVib29rIGFzIG5lZWRlZC5cbiAgICAgICAgdGhpcy5ldmVudHMudHJpZ2dlcignYmVmb3JlX3NhdmUuTm90ZWJvb2snKTtcblxuICAgICAgICAvLyBDcmVhdGUgYSBKU09OIG1vZGVsIHRvIGJlIHNlbnQgdG8gdGhlIHNlcnZlci5cbiAgICAgICAgdmFyIG1vZGVsID0ge1xuICAgICAgICAgICAgdHlwZSA6IFwibm90ZWJvb2tcIixcbiAgICAgICAgICAgIGNvbnRlbnQgOiB0aGlzLnRvSlNPTigpXG4gICAgICAgIH07XG4gICAgICAgIC8vIHRpbWUgdGhlIGFqYXggY2FsbCBmb3IgYXV0b3NhdmUgdHVuaW5nIHB1cnBvc2VzLlxuICAgICAgICB2YXIgc3RhcnQgPSAgbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICB2YXIgX3NhdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhhdC5jb250ZW50cy5zYXZlKHRoYXQubm90ZWJvb2tfcGF0aCwgbW9kZWwpLnRoZW4oXG4gICAgICAgICAgICAgICAgJC5wcm94eSh0aGF0LnNhdmVfbm90ZWJvb2tfc3VjY2VzcywgdGhhdCwgc3RhcnQpLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aGF0LmV2ZW50cy50cmlnZ2VyKCdub3RlYm9va19zYXZlX2ZhaWxlZC5Ob3RlYm9vaycsIGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChjaGVja19sYXN0X21vZGlmaWVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50cy5nZXQodGhpcy5ub3RlYm9va19wYXRoLCB7Y29udGVudDogZmFsc2V9KS50aGVuKFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsYXN0X21vZGlmaWVkID0gbmV3IERhdGUoZGF0YS5sYXN0X21vZGlmaWVkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3RfbW9kaWZpZWQgPiB0aGF0Lmxhc3RfbW9kaWZpZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpYWxvZy5tb2RhbCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm90ZWJvb2s6IHRoYXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5Ym9hcmRfbWFuYWdlcjogdGhhdC5rZXlib2FyZF9tYW5hZ2VyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcIk5vdGVib29rIGNoYW5nZWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBcIlRoZSBub3RlYm9vayBmaWxlIGhhcyBjaGFuZ2VkIG9uIGRpc2sgc2luY2UgdGhlIGxhc3QgdGltZSB3ZSBvcGVuZWQgb3Igc2F2ZWQgaXQuIFwiK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiRG8geW91IHdhbnQgdG8gb3ZlcndyaXRlIHRoZSBmaWxlIG9uIGRpc2sgd2l0aCB0aGUgdmVyc2lvbiBvcGVuIGhlcmUsIG9yIGxvYWQgXCIrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ0aGUgdmVyc2lvbiBvbiBkaXNrIChyZWxvYWQgdGhlIHBhZ2UpID9cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXR0b25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlbG9hZDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M6ICdidG4td2FybmluZycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGljazogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDYW5jZWw6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPdmVyd3JpdGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzOiAnYnRuLWRhbmdlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGljazogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9zYXZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3NhdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBtYXliZSBpdCBoYXMgYmVlbiBkZWxldGVkIG9yIHJlbmFtZWQ/IEdvIGFoZWFkIGFuZCBzYXZlLlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3NhdmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIF9zYXZlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU3VjY2VzcyBjYWxsYmFjayBmb3Igc2F2aW5nIGEgbm90ZWJvb2suXG4gICAgICogXG4gICAgICogQHBhcmFtIHtpbnRlZ2VyfSBzdGFydCAtIFRpbWUgd2hlbiB0aGUgc2F2ZSByZXF1ZXN0IHN0YXJ0XG4gICAgICogQHBhcmFtIHtvYmplY3R9ICBkYXRhIC0gSlNPTiByZXByZXNlbnRhdGlvbiBvZiBhIG5vdGVib29rXG4gICAgICovXG4gICAgTm90ZWJvb2sucHJvdG90eXBlLnNhdmVfbm90ZWJvb2tfc3VjY2VzcyA9IGZ1bmN0aW9uIChzdGFydCwgZGF0YSkge1xuICAgICAgICB0aGlzLnNldF9kaXJ0eShmYWxzZSk7XG4gICAgICAgIHRoaXMubGFzdF9tb2RpZmllZCA9IG5ldyBEYXRlKGRhdGEubGFzdF9tb2RpZmllZCk7XG4gICAgICAgIGlmIChkYXRhLm1lc3NhZ2UpIHtcbiAgICAgICAgICAgIC8vIHNhdmUgc3VjY2VlZGVkLCBidXQgdmFsaWRhdGlvbiBmYWlsZWQuXG4gICAgICAgICAgICB2YXIgYm9keSA9ICQoXCI8ZGl2PlwiKTtcbiAgICAgICAgICAgIHZhciB0aXRsZSA9IFwiTm90ZWJvb2sgdmFsaWRhdGlvbiBmYWlsZWRcIjtcblxuICAgICAgICAgICAgYm9keS5hcHBlbmQoJChcIjxwPlwiKS50ZXh0KFxuICAgICAgICAgICAgICAgIFwiVGhlIHNhdmUgb3BlcmF0aW9uIHN1Y2NlZWRlZCxcIiArXG4gICAgICAgICAgICAgICAgXCIgYnV0IHRoZSBub3RlYm9vayBkb2VzIG5vdCBhcHBlYXIgdG8gYmUgdmFsaWQuXCIgK1xuICAgICAgICAgICAgICAgIFwiIFRoZSB2YWxpZGF0aW9uIGVycm9yIHdhczpcIlxuICAgICAgICAgICAgKSkuYXBwZW5kKCQoXCI8ZGl2PlwiKS5hZGRDbGFzcyhcInZhbGlkYXRpb24tZXJyb3JcIikuYXBwZW5kKFxuICAgICAgICAgICAgICAgICQoXCI8cHJlPlwiKS50ZXh0KGRhdGEubWVzc2FnZSlcbiAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgZGlhbG9nLm1vZGFsKHtcbiAgICAgICAgICAgICAgICBub3RlYm9vazogdGhpcyxcbiAgICAgICAgICAgICAgICBrZXlib2FyZF9tYW5hZ2VyOiB0aGlzLmtleWJvYXJkX21hbmFnZXIsXG4gICAgICAgICAgICAgICAgdGl0bGU6IHRpdGxlLFxuICAgICAgICAgICAgICAgIGJvZHk6IGJvZHksXG4gICAgICAgICAgICAgICAgYnV0dG9ucyA6IHtcbiAgICAgICAgICAgICAgICAgICAgT0sgOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcImNsYXNzXCIgOiBcImJ0bi1wcmltYXJ5XCJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXZlbnRzLnRyaWdnZXIoJ25vdGVib29rX3NhdmVkLk5vdGVib29rJyk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZV9hdXRvc2F2ZV9pbnRlcnZhbChzdGFydCk7XG4gICAgICAgIGlmICh0aGlzLl9jaGVja3BvaW50X2FmdGVyX3NhdmUpIHtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlX2NoZWNrcG9pbnQoKTtcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrcG9pbnRfYWZ0ZXJfc2F2ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgYXV0b3NhdmUgaW50ZXJ2YWwgYmFzZWQgb24gdGhlIGR1cmF0aW9uIG9mIHRoZSBsYXN0IHNhdmUuXG4gICAgICogXG4gICAgICogQHBhcmFtIHtpbnRlZ2VyfSB0aW1lc3RhbXAgLSB3aGVuIHRoZSBzYXZlIHJlcXVlc3Qgc3RhcnRlZFxuICAgICAqL1xuICAgIE5vdGVib29rLnByb3RvdHlwZS5fdXBkYXRlX2F1dG9zYXZlX2ludGVydmFsID0gZnVuY3Rpb24gKHN0YXJ0KSB7XG4gICAgICAgIHZhciBkdXJhdGlvbiA9IChuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHN0YXJ0KTtcbiAgICAgICAgaWYgKHRoaXMuYXV0b3NhdmVfaW50ZXJ2YWwpIHtcbiAgICAgICAgICAgIC8vIG5ldyBzYXZlIGludGVydmFsOiBoaWdoZXIgb2YgMTB4IHNhdmUgZHVyYXRpb24gb3IgcGFyYW1ldGVyIChkZWZhdWx0IDMwIHNlY29uZHMpXG4gICAgICAgICAgICB2YXIgaW50ZXJ2YWwgPSBNYXRoLm1heCgxMCAqIGR1cmF0aW9uLCB0aGlzLm1pbmltdW1fYXV0b3NhdmVfaW50ZXJ2YWwpO1xuICAgICAgICAgICAgLy8gcm91bmQgdG8gMTAgc2Vjb25kcywgb3RoZXJ3aXNlIHdlIHdpbGwgYmUgc2V0dGluZyBhIG5ldyBpbnRlcnZhbCB0b28gb2Z0ZW5cbiAgICAgICAgICAgIGludGVydmFsID0gMTAwMDAgKiBNYXRoLnJvdW5kKGludGVydmFsIC8gMTAwMDApO1xuICAgICAgICAgICAgLy8gc2V0IG5ldyBpbnRlcnZhbCwgaWYgaXQncyBjaGFuZ2VkXG4gICAgICAgICAgICBpZiAoaW50ZXJ2YWwgIT09IHRoaXMuYXV0b3NhdmVfaW50ZXJ2YWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldF9hdXRvc2F2ZV9pbnRlcnZhbChpbnRlcnZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRXhwbGljaXRseSB0cnVzdCB0aGUgb3V0cHV0IG9mIHRoaXMgbm90ZWJvb2suXG4gICAgICovXG4gICAgTm90ZWJvb2sucHJvdG90eXBlLnRydXN0X25vdGVib29rID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYm9keSA9ICQoXCI8ZGl2PlwiKS5hcHBlbmQoJChcIjxwPlwiKVxuICAgICAgICAgICAgLnRleHQoXCJBIHRydXN0ZWQgSnVweXRlciBub3RlYm9vayBtYXkgZXhlY3V0ZSBoaWRkZW4gbWFsaWNpb3VzIGNvZGUgXCIpXG4gICAgICAgICAgICAuYXBwZW5kKCQoXCI8c3Ryb25nPlwiKVxuICAgICAgICAgICAgICAgIC5hcHBlbmQoXG4gICAgICAgICAgICAgICAgICAgICQoXCI8ZW0+XCIpLnRleHQoXCJ3aGVuIHlvdSBvcGVuIGl0XCIpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKS5hcHBlbmQoXCIuXCIpLmFwcGVuZChcbiAgICAgICAgICAgICAgICBcIiBTZWxlY3RpbmcgdHJ1c3Qgd2lsbCBpbW1lZGlhdGVseSByZWxvYWQgdGhpcyBub3RlYm9vayBpbiBhIHRydXN0ZWQgc3RhdGUuXCJcbiAgICAgICAgICAgICkuYXBwZW5kKFxuICAgICAgICAgICAgICAgIFwiIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWUgdGhlIFwiXG4gICAgICAgICAgICApLmFwcGVuZCgkKFwiPGE+XCIpLmF0dHIoXCJocmVmXCIsIFwiaHR0cDovL2lweXRob24ub3JnL2lweXRob24tZG9jLzIvbm90ZWJvb2svc2VjdXJpdHkuaHRtbFwiKVxuICAgICAgICAgICAgICAgIC50ZXh0KFwiSnVweXRlciBzZWN1cml0eSBkb2N1bWVudGF0aW9uXCIpXG4gICAgICAgICAgICApLmFwcGVuZChcIi5cIilcbiAgICAgICAgKTtcblxuICAgICAgICB2YXIgbmIgPSB0aGlzO1xuICAgICAgICBkaWFsb2cubW9kYWwoe1xuICAgICAgICAgICAgbm90ZWJvb2s6IHRoaXMsXG4gICAgICAgICAgICBrZXlib2FyZF9tYW5hZ2VyOiB0aGlzLmtleWJvYXJkX21hbmFnZXIsXG4gICAgICAgICAgICB0aXRsZTogXCJUcnVzdCB0aGlzIG5vdGVib29rP1wiLFxuICAgICAgICAgICAgYm9keTogYm9keSxcblxuICAgICAgICAgICAgYnV0dG9uczoge1xuICAgICAgICAgICAgICAgIENhbmNlbCA6IHt9LFxuICAgICAgICAgICAgICAgIFRydXN0IDoge1xuICAgICAgICAgICAgICAgICAgICBjbGFzcyA6IFwiYnRuLWRhbmdlclwiLFxuICAgICAgICAgICAgICAgICAgICBjbGljayA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjZWxscyA9IG5iLmdldF9jZWxscygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjZWxscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjZWxsID0gY2VsbHNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNlbGwuY2VsbF90eXBlID09PSAnY29kZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbC5vdXRwdXRfYXJlYS50cnVzdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBuYi5ldmVudHMub24oJ25vdGVib29rX3NhdmVkLk5vdGVib29rJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmIuc2F2ZV9ub3RlYm9vaygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTWFrZSBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgbm90ZWJvb2suXG4gICAgICovXG4gICAgTm90ZWJvb2sucHJvdG90eXBlLmNvcHlfbm90ZWJvb2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgdmFyIGJhc2VfdXJsID0gdGhpcy5iYXNlX3VybDtcbiAgICAgICAgdmFyIHcgPSB3aW5kb3cub3BlbignJywgSVB5dGhvbi5fdGFyZ2V0KTtcbiAgICAgICAgdmFyIHBhcmVudCA9IHV0aWxzLnVybF9wYXRoX3NwbGl0KHRoaXMubm90ZWJvb2tfcGF0aClbMF07XG4gICAgICAgIHRoaXMuY29udGVudHMuY29weSh0aGlzLm5vdGVib29rX3BhdGgsIHBhcmVudCkudGhlbihcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgdy5sb2NhdGlvbiA9IHV0aWxzLnVybF9qb2luX2VuY29kZShcbiAgICAgICAgICAgICAgICAgICAgYmFzZV91cmwsICdub3RlYm9va3MnLCBkYXRhLnBhdGhcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdy5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIHRoYXQuZXZlbnRzLnRyaWdnZXIoJ25vdGVib29rX2NvcHlfZmFpbGVkJywgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBFbnN1cmUgYSBmaWxlbmFtZSBoYXMgdGhlIHJpZ2h0IGV4dGVuc2lvblxuICAgICAqIFJldHVybnMgdGhlIGZpbGVuYW1lIHdpdGggdGhlIGFwcHJvcHJpYXRlIGV4dGVuc2lvbiwgYXBwZW5kaW5nIGlmIG5lY2Vzc2FyeS5cbiAgICAgKi9cbiAgICBOb3RlYm9vay5wcm90b3R5cGUuZW5zdXJlX2V4dGVuc2lvbiA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHZhciBleHQgPSB1dGlscy5zcGxpdGV4dCh0aGlzLm5vdGVib29rX3BhdGgpWzFdO1xuICAgICAgICBpZiAoZXh0Lmxlbmd0aCAmJiBuYW1lLnNsaWNlKC1leHQubGVuZ3RoKSAhPT0gZXh0KSB7XG4gICAgICAgICAgICBuYW1lID0gbmFtZSArIGV4dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVuYW1lIHRoZSBub3RlYm9vay5cbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IG5ld19uYW1lXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhlIG5vdGVib29rIGlzIHJlbmFtZWQuXG4gICAgICovXG4gICAgTm90ZWJvb2sucHJvdG90eXBlLnJlbmFtZSA9IGZ1bmN0aW9uIChuZXdfbmFtZSkge1xuICAgICAgICBuZXdfbmFtZSA9IHRoaXMuZW5zdXJlX2V4dGVuc2lvbihuZXdfbmFtZSk7XG5cbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICB2YXIgcGFyZW50ID0gdXRpbHMudXJsX3BhdGhfc3BsaXQodGhpcy5ub3RlYm9va19wYXRoKVswXTtcbiAgICAgICAgdmFyIG5ld19wYXRoID0gdXRpbHMudXJsX3BhdGhfam9pbihwYXJlbnQsIG5ld19uYW1lKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudHMucmVuYW1lKHRoaXMubm90ZWJvb2tfcGF0aCwgbmV3X3BhdGgpLnRoZW4oXG4gICAgICAgICAgICBmdW5jdGlvbiAoanNvbikge1xuICAgICAgICAgICAgICAgIHRoYXQubm90ZWJvb2tfbmFtZSA9IGpzb24ubmFtZTtcbiAgICAgICAgICAgICAgICB0aGF0Lm5vdGVib29rX3BhdGggPSBqc29uLnBhdGg7XG4gICAgICAgICAgICAgICAgdGhhdC5sYXN0X21vZGlmaWVkID0gbmV3IERhdGUoanNvbi5sYXN0X21vZGlmaWVkKTtcbiAgICAgICAgICAgICAgICB0aGF0LnNlc3Npb24ucmVuYW1lX25vdGVib29rKGpzb24ucGF0aCk7XG4gICAgICAgICAgICAgICAgdGhhdC5ldmVudHMudHJpZ2dlcignbm90ZWJvb2tfcmVuYW1lZC5Ob3RlYm9vaycsIGpzb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZWxldGUgdGhpcyBub3RlYm9va1xuICAgICAqL1xuICAgIE5vdGVib29rLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY29udGVudHMuZGVsZXRlKHRoaXMubm90ZWJvb2tfcGF0aCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlcXVlc3QgYSBub3RlYm9vaydzIGRhdGEgZnJvbSB0aGUgc2VydmVyLlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBub3RlYm9va19wYXRoIC0gQSBub3RlYm9vayB0byBsb2FkXG4gICAgICovXG4gICAgTm90ZWJvb2sucHJvdG90eXBlLmxvYWRfbm90ZWJvb2sgPSBmdW5jdGlvbiAobm90ZWJvb2tfcGF0aCkge1xuICAgICAgICB0aGlzLm5vdGVib29rX3BhdGggPSBub3RlYm9va19wYXRoO1xuICAgICAgICB0aGlzLm5vdGVib29rX25hbWUgPSB1dGlscy51cmxfcGF0aF9zcGxpdCh0aGlzLm5vdGVib29rX3BhdGgpWzFdO1xuICAgICAgICB0aGlzLmV2ZW50cy50cmlnZ2VyKCdub3RlYm9va19sb2FkaW5nLk5vdGVib29rJyk7XG4gICAgICAgIHRoaXMuY29udGVudHMuZ2V0KG5vdGVib29rX3BhdGgsIHt0eXBlOiAnbm90ZWJvb2snfSkudGhlbihcbiAgICAgICAgICAgICQucHJveHkodGhpcy5sb2FkX25vdGVib29rX3N1Y2Nlc3MsIHRoaXMpLFxuICAgICAgICAgICAgJC5wcm94eSh0aGlzLmxvYWRfbm90ZWJvb2tfZXJyb3IsIHRoaXMpXG4gICAgICAgICk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFN1Y2Nlc3MgY2FsbGJhY2sgZm9yIGxvYWRpbmcgYSBub3RlYm9vayBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAgICogXG4gICAgICogTG9hZCBub3RlYm9vayBkYXRhIGZyb20gdGhlIEpTT04gcmVzcG9uc2UuXG4gICAgICogXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGRhdGEgSlNPTiByZXByZXNlbnRhdGlvbiBvZiBhIG5vdGVib29rXG4gICAgICovXG4gICAgTm90ZWJvb2sucHJvdG90eXBlLmxvYWRfbm90ZWJvb2tfc3VjY2VzcyA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciBmYWlsZWQsIG1zZztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuZnJvbUpTT04oZGF0YSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGZhaWxlZCA9IGU7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIk5vdGVib29rIGZhaWxlZCB0byBsb2FkIGZyb20gSlNPTjpcIiwgZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZhaWxlZCB8fCBkYXRhLm1lc3NhZ2UpIHtcbiAgICAgICAgICAgIC8vICplaXRoZXIqIGZyb21KU09OIGZhaWxlZCBvciB2YWxpZGF0aW9uIGZhaWxlZFxuICAgICAgICAgICAgdmFyIGJvZHkgPSAkKFwiPGRpdj5cIik7XG4gICAgICAgICAgICB2YXIgdGl0bGU7XG4gICAgICAgICAgICBpZiAoZmFpbGVkKSB7XG4gICAgICAgICAgICAgICAgdGl0bGUgPSBcIk5vdGVib29rIGZhaWxlZCB0byBsb2FkXCI7XG4gICAgICAgICAgICAgICAgYm9keS5hcHBlbmQoJChcIjxwPlwiKS50ZXh0KFxuICAgICAgICAgICAgICAgICAgICBcIlRoZSBlcnJvciB3YXM6IFwiXG4gICAgICAgICAgICAgICAgKSkuYXBwZW5kKCQoXCI8ZGl2PlwiKS5hZGRDbGFzcyhcImpzLWVycm9yXCIpLnRleHQoXG4gICAgICAgICAgICAgICAgICAgIGZhaWxlZC50b1N0cmluZygpXG4gICAgICAgICAgICAgICAgKSkuYXBwZW5kKCQoXCI8cD5cIikudGV4dChcbiAgICAgICAgICAgICAgICAgICAgXCJTZWUgdGhlIGVycm9yIGNvbnNvbGUgZm9yIGRldGFpbHMuXCJcbiAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGl0bGUgPSBcIk5vdGVib29rIHZhbGlkYXRpb24gZmFpbGVkXCI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkYXRhLm1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmFpbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG1zZyA9IFwiVGhlIG5vdGVib29rIGFsc28gZmFpbGVkIHZhbGlkYXRpb246XCI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbXNnID0gXCJBbiBpbnZhbGlkIG5vdGVib29rIG1heSBub3QgZnVuY3Rpb24gcHJvcGVybHkuXCIgK1xuICAgICAgICAgICAgICAgICAgICBcIiBUaGUgdmFsaWRhdGlvbiBlcnJvciB3YXM6XCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJvZHkuYXBwZW5kKCQoXCI8cD5cIikudGV4dChcbiAgICAgICAgICAgICAgICAgICAgbXNnXG4gICAgICAgICAgICAgICAgKSkuYXBwZW5kKCQoXCI8ZGl2PlwiKS5hZGRDbGFzcyhcInZhbGlkYXRpb24tZXJyb3JcIikuYXBwZW5kKFxuICAgICAgICAgICAgICAgICAgICAkKFwiPHByZT5cIikudGV4dChkYXRhLm1lc3NhZ2UpXG4gICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRpYWxvZy5tb2RhbCh7XG4gICAgICAgICAgICAgICAgbm90ZWJvb2s6IHRoaXMsXG4gICAgICAgICAgICAgICAga2V5Ym9hcmRfbWFuYWdlcjogdGhpcy5rZXlib2FyZF9tYW5hZ2VyLFxuICAgICAgICAgICAgICAgIHRpdGxlOiB0aXRsZSxcbiAgICAgICAgICAgICAgICBib2R5OiBib2R5LFxuICAgICAgICAgICAgICAgIGJ1dHRvbnMgOiB7XG4gICAgICAgICAgICAgICAgICAgIE9LIDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJjbGFzc1wiIDogXCJidG4tcHJpbWFyeVwiXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5uY2VsbHMoKSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5pbnNlcnRfY2VsbF9iZWxvdygnY29kZScpO1xuICAgICAgICAgICAgdGhpcy5lZGl0X21vZGUoMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdCgwKTtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlX2NvbW1hbmRfbW9kZSh0aGlzLmdldF9jZWxsKDApKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldF9kaXJ0eShmYWxzZSk7XG4gICAgICAgIHRoaXMuc2Nyb2xsX3RvX3RvcCgpO1xuICAgICAgICB0aGlzLndyaXRhYmxlID0gZGF0YS53cml0YWJsZSB8fCBmYWxzZTtcbiAgICAgICAgdGhpcy5sYXN0X21vZGlmaWVkID0gbmV3IERhdGUoZGF0YS5sYXN0X21vZGlmaWVkKTtcbiAgICAgICAgdmFyIG5ibW9kZWwgPSBkYXRhLmNvbnRlbnQ7XG4gICAgICAgIHZhciBvcmlnX25iZm9ybWF0ID0gbmJtb2RlbC5tZXRhZGF0YS5vcmlnX25iZm9ybWF0O1xuICAgICAgICB2YXIgb3JpZ19uYmZvcm1hdF9taW5vciA9IG5ibW9kZWwubWV0YWRhdGEub3JpZ19uYmZvcm1hdF9taW5vcjtcbiAgICAgICAgaWYgKG9yaWdfbmJmb3JtYXQgIT09IHVuZGVmaW5lZCAmJiBuYm1vZGVsLm5iZm9ybWF0ICE9PSBvcmlnX25iZm9ybWF0KSB7XG4gICAgICAgICAgICB2YXIgc3JjO1xuICAgICAgICAgICAgaWYgKG5ibW9kZWwubmJmb3JtYXQgPiBvcmlnX25iZm9ybWF0KSB7XG4gICAgICAgICAgICAgICAgc3JjID0gXCIgYW4gb2xkZXIgbm90ZWJvb2sgZm9ybWF0IFwiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBcIiBhIG5ld2VyIG5vdGVib29rIGZvcm1hdCBcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgbXNnID0gXCJUaGlzIG5vdGVib29rIGhhcyBiZWVuIGNvbnZlcnRlZCBmcm9tXCIgKyBzcmMgK1xuICAgICAgICAgICAgXCIodlwiK29yaWdfbmJmb3JtYXQrXCIpIHRvIHRoZSBjdXJyZW50IG5vdGVib29rIFwiICtcbiAgICAgICAgICAgIFwiZm9ybWF0ICh2XCIrbmJtb2RlbC5uYmZvcm1hdCtcIikuIFRoZSBuZXh0IHRpbWUgeW91IHNhdmUgdGhpcyBub3RlYm9vaywgdGhlIFwiICtcbiAgICAgICAgICAgIFwiY3VycmVudCBub3RlYm9vayBmb3JtYXQgd2lsbCBiZSB1c2VkLlwiO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAobmJtb2RlbC5uYmZvcm1hdCA+IG9yaWdfbmJmb3JtYXQpIHtcbiAgICAgICAgICAgICAgICBtc2cgKz0gXCIgT2xkZXIgdmVyc2lvbnMgb2YgSnVweXRlciBtYXkgbm90IGJlIGFibGUgdG8gcmVhZCB0aGUgbmV3IGZvcm1hdC5cIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbXNnICs9IFwiIFNvbWUgZmVhdHVyZXMgb2YgdGhlIG9yaWdpbmFsIG5vdGVib29rIG1heSBub3QgYmUgYXZhaWxhYmxlLlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbXNnICs9IFwiIFRvIHByZXNlcnZlIHRoZSBvcmlnaW5hbCB2ZXJzaW9uLCBjbG9zZSB0aGUgXCIgK1xuICAgICAgICAgICAgICAgIFwibm90ZWJvb2sgd2l0aG91dCBzYXZpbmcgaXQuXCI7XG4gICAgICAgICAgICBkaWFsb2cubW9kYWwoe1xuICAgICAgICAgICAgICAgIG5vdGVib29rOiB0aGlzLFxuICAgICAgICAgICAgICAgIGtleWJvYXJkX21hbmFnZXI6IHRoaXMua2V5Ym9hcmRfbWFuYWdlcixcbiAgICAgICAgICAgICAgICB0aXRsZSA6IFwiTm90ZWJvb2sgY29udmVydGVkXCIsXG4gICAgICAgICAgICAgICAgYm9keSA6IG1zZyxcbiAgICAgICAgICAgICAgICBidXR0b25zIDoge1xuICAgICAgICAgICAgICAgICAgICBPSyA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzIDogXCJidG4tcHJpbWFyeVwiXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm5iZm9ybWF0X21pbm9yIDwgbmJtb2RlbC5uYmZvcm1hdF9taW5vcikge1xuICAgICAgICAgICAgdGhpcy5uYmZvcm1hdF9taW5vciA9IG5ibW9kZWwubmJmb3JtYXRfbWlub3I7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5zZXNzaW9uID09PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIga2VybmVsX25hbWUgPSB1dGlscy5nZXRfdXJsX3BhcmFtKCdrZXJuZWxfbmFtZScpO1xuICAgICAgICAgICAgaWYgKGtlcm5lbF9uYW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5rZXJuZWxfc2VsZWN0b3Iuc2V0X2tlcm5lbChrZXJuZWxfbmFtZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMubWV0YWRhdGEua2VybmVsc3BlYykge1xuICAgICAgICAgICAgICAgIHRoaXMua2VybmVsX3NlbGVjdG9yLnNldF9rZXJuZWwodGhpcy5tZXRhZGF0YS5rZXJuZWxzcGVjKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5tZXRhZGF0YS5sYW5ndWFnZSkge1xuICAgICAgICAgICAgICAgIC8vIGNvbXBhdCB3aXRoIElKdWxpYSwgSUhhc2tlbGwsIGFuZCBvdGhlciBlYXJseSBrZXJuZWxzXG4gICAgICAgICAgICAgICAgLy8gYWRvcHRlcnMgdGhhdCB3aGVyZSBzZXR0aW5nIGEgbGFuZ3VhZ2UgbWV0YWRhdGEuXG4gICAgICAgICAgICAgICAgdGhpcy5rZXJuZWxfc2VsZWN0b3Iuc2V0X2tlcm5lbCh7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiKE5vIG5hbWUpXCIsXG4gICAgICAgICAgICAgICAgICAgIGxhbmd1YWdlOiB0aGlzLm1ldGFkYXRhLmxhbmd1YWdlXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIHNob3VsZCBiZSBzdG9yZWQgaW4ga3NwZWMgbm93LCBkZWxldGUgaXQuXG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIG9uY2Ugd2UgZG8gbm90IHN1cHBvcnQgbm90ZWJvb2sgdjMgYW55bW9yZS5cbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5tZXRhZGF0YS5sYW5ndWFnZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gc2V0dGluZyBrZXJuZWwgdmlhIHNldF9rZXJuZWwgYWJvdmUgdHJpZ2dlcnMgc3RhcnRfc2Vzc2lvbixcbiAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2Ugc3RhcnQgYSBuZXcgc2Vzc2lvbiB3aXRoIHRoZSBzZXJ2ZXIncyBkZWZhdWx0IGtlcm5lbFxuICAgICAgICAgICAgICAgIC8vIHNwZWNfY2hhbmdlZCBldmVudHMgd2lsbCBmaXJlIGFmdGVyIGtlcm5lbCBpcyBsb2FkZWRcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0X3Nlc3Npb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBsb2FkIG91ciBjaGVja3BvaW50IGxpc3RcbiAgICAgICAgdGhpcy5saXN0X2NoZWNrcG9pbnRzKCk7XG4gICAgICAgIFxuICAgICAgICAvLyBsb2FkIHRvb2xiYXIgc3RhdGVcbiAgICAgICAgaWYgKHRoaXMubWV0YWRhdGEuY2VsbHRvb2xiYXIpIHtcbiAgICAgICAgICAgIGNlbGx0b29sYmFyLkNlbGxUb29sYmFyLmdsb2JhbF9zaG93KCk7XG4gICAgICAgICAgICBjZWxsdG9vbGJhci5DZWxsVG9vbGJhci5hY3RpdmF0ZV9wcmVzZXQodGhpcy5tZXRhZGF0YS5jZWxsdG9vbGJhcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjZWxsdG9vbGJhci5DZWxsVG9vbGJhci5nbG9iYWxfaGlkZSgpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAoIXRoaXMud3JpdGFibGUpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0X2F1dG9zYXZlX2ludGVydmFsKDApO1xuICAgICAgICAgICAgdGhpcy5ldmVudHMudHJpZ2dlcignbm90ZWJvb2tfcmVhZF9vbmx5Lk5vdGVib29rJyk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIG5vdyB0aGF0IHdlJ3JlIGZ1bGx5IGxvYWRlZCwgaXQgaXMgc2FmZSB0byByZXN0b3JlIHNhdmUgZnVuY3Rpb25hbGl0eVxuICAgICAgICB0aGlzLl9mdWxseV9sb2FkZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmV2ZW50cy50cmlnZ2VyKCdub3RlYm9va19sb2FkZWQuTm90ZWJvb2snKTtcbiAgICB9O1xuXG4gICAgTm90ZWJvb2sucHJvdG90eXBlLnNldF9rZXJuZWxzZWxlY3RvciA9IGZ1bmN0aW9uKGtfc2VsZWN0b3Ipe1xuICAgICAgICB0aGlzLmtlcm5lbF9zZWxlY3RvciA9IGtfc2VsZWN0b3I7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEZhaWx1cmUgY2FsbGJhY2sgZm9yIGxvYWRpbmcgYSBub3RlYm9vayBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAgICogXG4gICAgICogQHBhcmFtIHtFcnJvcn0gZXJyb3JcbiAgICAgKi9cbiAgICBOb3RlYm9vay5wcm90b3R5cGUubG9hZF9ub3RlYm9va19lcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICB0aGlzLmV2ZW50cy50cmlnZ2VyKCdub3RlYm9va19sb2FkX2ZhaWxlZC5Ob3RlYm9vaycsIGVycm9yKTtcbiAgICAgICAgdmFyIG1zZztcbiAgICAgICAgaWYgKGVycm9yLm5hbWUgPT09IHV0aWxzLlhIUl9FUlJPUiAmJiBlcnJvci54aHIuc3RhdHVzID09PSA1MDApIHtcbiAgICAgICAgICAgIHV0aWxzLmxvZ19hamF4X2Vycm9yKGVycm9yLnhociwgZXJyb3IueGhyX3N0YXR1cywgZXJyb3IueGhyX2Vycm9yKTtcbiAgICAgICAgICAgIG1zZyA9IFwiQW4gdW5rbm93biBlcnJvciBvY2N1cnJlZCB3aGlsZSBsb2FkaW5nIHRoaXMgbm90ZWJvb2suIFwiICtcbiAgICAgICAgICAgIFwiVGhpcyB2ZXJzaW9uIGNhbiBsb2FkIG5vdGVib29rIGZvcm1hdHMgXCIgK1xuICAgICAgICAgICAgXCJ2XCIgKyB0aGlzLm5iZm9ybWF0ICsgXCIgb3IgZWFybGllci4gU2VlIHRoZSBzZXJ2ZXIgbG9nIGZvciBkZXRhaWxzLlwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbXNnID0gZXJyb3IubWVzc2FnZTtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignRXJyb3Igc3RhY2sgdHJhY2Ugd2hpbGUgbG9hZGluZyBub3RlYm9vayB3YXM6Jyk7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oZXJyb3Iuc3RhY2spO1xuICAgICAgICB9XG4gICAgICAgIGRpYWxvZy5tb2RhbCh7XG4gICAgICAgICAgICBub3RlYm9vazogdGhpcyxcbiAgICAgICAgICAgIGtleWJvYXJkX21hbmFnZXI6IHRoaXMua2V5Ym9hcmRfbWFuYWdlcixcbiAgICAgICAgICAgIHRpdGxlOiBcIkVycm9yIGxvYWRpbmcgbm90ZWJvb2tcIixcbiAgICAgICAgICAgIGJvZHkgOiBtc2csXG4gICAgICAgICAgICBidXR0b25zIDoge1xuICAgICAgICAgICAgICAgIFwiT0tcIjoge31cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKioqKioqKioqKioqKioqKioqKiogIGNoZWNrcG9pbnQtcmVsYXRlZCAgKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAvKipcbiAgICAgKiBTYXZlIHRoZSBub3RlYm9vayB0aGVuIGltbWVkaWF0ZWx5IGNyZWF0ZSBhIGNoZWNrcG9pbnQuXG4gICAgICovXG4gICAgTm90ZWJvb2sucHJvdG90eXBlLnNhdmVfY2hlY2twb2ludCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fY2hlY2twb2ludF9hZnRlcl9zYXZlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zYXZlX25vdGVib29rKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFkZCBhIGNoZWNrcG9pbnQgZm9yIHRoaXMgbm90ZWJvb2suXG4gICAgICovXG4gICAgTm90ZWJvb2sucHJvdG90eXBlLmFkZF9jaGVja3BvaW50ID0gZnVuY3Rpb24gKGNoZWNrcG9pbnQpIHtcbiAgICAgICAgdmFyIGZvdW5kID0gZmFsc2U7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGVja3BvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGV4aXN0aW5nID0gdGhpcy5jaGVja3BvaW50c1tpXTtcbiAgICAgICAgICAgIGlmIChleGlzdGluZy5pZCA9PT0gY2hlY2twb2ludC5pZCkge1xuICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmNoZWNrcG9pbnRzW2ldID0gY2hlY2twb2ludDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWZvdW5kKSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrcG9pbnRzLnB1c2goY2hlY2twb2ludCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sYXN0X2NoZWNrcG9pbnQgPSB0aGlzLmNoZWNrcG9pbnRzW3RoaXMuY2hlY2twb2ludHMubGVuZ3RoIC0gMV07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIExpc3QgY2hlY2twb2ludHMgZm9yIHRoaXMgbm90ZWJvb2suXG4gICAgICovXG4gICAgTm90ZWJvb2sucHJvdG90eXBlLmxpc3RfY2hlY2twb2ludHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgdGhpcy5jb250ZW50cy5saXN0X2NoZWNrcG9pbnRzKHRoaXMubm90ZWJvb2tfcGF0aCkudGhlbihcbiAgICAgICAgICAgICQucHJveHkodGhpcy5saXN0X2NoZWNrcG9pbnRzX3N1Y2Nlc3MsIHRoaXMpLFxuICAgICAgICAgICAgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aGF0LmV2ZW50cy50cmlnZ2VyKCdsaXN0X2NoZWNrcG9pbnRzX2ZhaWxlZC5Ob3RlYm9vaycsIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU3VjY2VzcyBjYWxsYmFjayBmb3IgbGlzdGluZyBjaGVja3BvaW50cy5cbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YSAtIEpTT04gcmVwcmVzZW50YXRpb24gb2YgYSBjaGVja3BvaW50XG4gICAgICovXG4gICAgTm90ZWJvb2sucHJvdG90eXBlLmxpc3RfY2hlY2twb2ludHNfc3VjY2VzcyA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHRoaXMuY2hlY2twb2ludHMgPSBkYXRhO1xuICAgICAgICBpZiAoZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMubGFzdF9jaGVja3BvaW50ID0gZGF0YVtkYXRhLmxlbmd0aCAtIDFdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5sYXN0X2NoZWNrcG9pbnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXZlbnRzLnRyaWdnZXIoJ2NoZWNrcG9pbnRzX2xpc3RlZC5Ob3RlYm9vaycsIFtkYXRhXSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGNoZWNrcG9pbnQgb2YgdGhpcyBub3RlYm9vayBvbiB0aGUgc2VydmVyIGZyb20gdGhlIG1vc3QgcmVjZW50IHNhdmUuXG4gICAgICovXG4gICAgTm90ZWJvb2sucHJvdG90eXBlLmNyZWF0ZV9jaGVja3BvaW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIHRoaXMuY29udGVudHMuY3JlYXRlX2NoZWNrcG9pbnQodGhpcy5ub3RlYm9va19wYXRoKS50aGVuKFxuICAgICAgICAgICAgJC5wcm94eSh0aGlzLmNyZWF0ZV9jaGVja3BvaW50X3N1Y2Nlc3MsIHRoaXMpLFxuICAgICAgICAgICAgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhhdC5ldmVudHMudHJpZ2dlcignY2hlY2twb2ludF9mYWlsZWQuTm90ZWJvb2snLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFN1Y2Nlc3MgY2FsbGJhY2sgZm9yIGNyZWF0aW5nIGEgY2hlY2twb2ludC5cbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YSAtIEpTT04gcmVwcmVzZW50YXRpb24gb2YgYSBjaGVja3BvaW50XG4gICAgICovXG4gICAgTm90ZWJvb2sucHJvdG90eXBlLmNyZWF0ZV9jaGVja3BvaW50X3N1Y2Nlc3MgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB0aGlzLmFkZF9jaGVja3BvaW50KGRhdGEpO1xuICAgICAgICB0aGlzLmV2ZW50cy50cmlnZ2VyKCdjaGVja3BvaW50X2NyZWF0ZWQuTm90ZWJvb2snLCBkYXRhKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGlzcGxheSB0aGUgcmVzdG9yZSBjaGVja3BvaW50IGRpYWxvZ1xuICAgICAqIEBwYXJhbSAge3N0cmluZ30gY2hlY2twb2ludCBJRFxuICAgICAqL1xuICAgIE5vdGVib29rLnByb3RvdHlwZS5yZXN0b3JlX2NoZWNrcG9pbnRfZGlhbG9nID0gZnVuY3Rpb24gKGNoZWNrcG9pbnQpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICBjaGVja3BvaW50ID0gY2hlY2twb2ludCB8fCB0aGlzLmxhc3RfY2hlY2twb2ludDtcbiAgICAgICAgaWYgKCAhIGNoZWNrcG9pbnQgKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcInJlc3RvcmUgZGlhbG9nLCBidXQgbm8gY2hlY2twb2ludCB0byByZXN0b3JlIHRvIVwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYm9keSA9ICQoJzxkaXYvPicpLmFwcGVuZChcbiAgICAgICAgICAgICQoJzxwLz4nKS5hZGRDbGFzcyhcInAtc3BhY2VcIikudGV4dChcbiAgICAgICAgICAgICAgICBcIkFyZSB5b3Ugc3VyZSB5b3Ugd2FudCB0byByZXZlcnQgdGhlIG5vdGVib29rIHRvIFwiICtcbiAgICAgICAgICAgICAgICBcInRoZSBsYXRlc3QgY2hlY2twb2ludD9cIlxuICAgICAgICAgICAgKS5hcHBlbmQoXG4gICAgICAgICAgICAgICAgJChcIjxzdHJvbmcvPlwiKS50ZXh0KFxuICAgICAgICAgICAgICAgICAgICBcIiBUaGlzIGNhbm5vdCBiZSB1bmRvbmUuXCJcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApXG4gICAgICAgICkuYXBwZW5kKFxuICAgICAgICAgICAgJCgnPHAvPicpLmFkZENsYXNzKFwicC1zcGFjZVwiKS50ZXh0KFwiVGhlIGNoZWNrcG9pbnQgd2FzIGxhc3QgdXBkYXRlZCBhdDpcIilcbiAgICAgICAgKS5hcHBlbmQoXG4gICAgICAgICAgICAkKCc8cC8+JykuYWRkQ2xhc3MoXCJwLXNwYWNlXCIpLnRleHQoXG4gICAgICAgICAgICAgICAgbW9tZW50KGNoZWNrcG9pbnQubGFzdF9tb2RpZmllZCkuZm9ybWF0KCdMTExMJykgK1xuICAgICAgICAgICAgICAgICcgKCcrbW9tZW50KGNoZWNrcG9pbnQubGFzdF9tb2RpZmllZCkuZnJvbU5vdygpKycpJy8vIExvbmcgZm9ybTogIFR1ZXNkYXksIEphbnVhcnkgMjcsIDIwMTUgMTI6MTUgUE1cbiAgICAgICAgICAgICkuY3NzKFwidGV4dC1hbGlnblwiLCBcImNlbnRlclwiKVxuICAgICAgICApO1xuICAgICAgICBcbiAgICAgICAgZGlhbG9nLm1vZGFsKHtcbiAgICAgICAgICAgIG5vdGVib29rOiB0aGlzLFxuICAgICAgICAgICAga2V5Ym9hcmRfbWFuYWdlcjogdGhpcy5rZXlib2FyZF9tYW5hZ2VyLFxuICAgICAgICAgICAgdGl0bGUgOiBcIlJldmVydCBub3RlYm9vayB0byBjaGVja3BvaW50XCIsXG4gICAgICAgICAgICBib2R5IDogYm9keSxcbiAgICAgICAgICAgIGJ1dHRvbnMgOiB7XG4gICAgICAgICAgICAgICAgUmV2ZXJ0IDoge1xuICAgICAgICAgICAgICAgICAgICBjbGFzcyA6IFwiYnRuLWRhbmdlclwiLFxuICAgICAgICAgICAgICAgICAgICBjbGljayA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQucmVzdG9yZV9jaGVja3BvaW50KGNoZWNrcG9pbnQuaWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBDYW5jZWwgOiB7fVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlc3RvcmUgdGhlIG5vdGVib29rIHRvIGEgY2hlY2twb2ludCBzdGF0ZS5cbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hlY2twb2ludCBJRFxuICAgICAqL1xuICAgIE5vdGVib29rLnByb3RvdHlwZS5yZXN0b3JlX2NoZWNrcG9pbnQgPSBmdW5jdGlvbiAoY2hlY2twb2ludCkge1xuICAgICAgICB0aGlzLmV2ZW50cy50cmlnZ2VyKCdub3RlYm9va19yZXN0b3JpbmcuTm90ZWJvb2snLCBjaGVja3BvaW50KTtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICB0aGlzLmNvbnRlbnRzLnJlc3RvcmVfY2hlY2twb2ludCh0aGlzLm5vdGVib29rX3BhdGgsIGNoZWNrcG9pbnQpLnRoZW4oXG4gICAgICAgICAgICAkLnByb3h5KHRoaXMucmVzdG9yZV9jaGVja3BvaW50X3N1Y2Nlc3MsIHRoaXMpLFxuICAgICAgICAgICAgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhhdC5ldmVudHMudHJpZ2dlcignY2hlY2twb2ludF9yZXN0b3JlX2ZhaWxlZC5Ob3RlYm9vaycsIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU3VjY2VzcyBjYWxsYmFjayBmb3IgcmVzdG9yaW5nIGEgbm90ZWJvb2sgdG8gYSBjaGVja3BvaW50LlxuICAgICAqL1xuICAgIE5vdGVib29rLnByb3RvdHlwZS5yZXN0b3JlX2NoZWNrcG9pbnRfc3VjY2VzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5ldmVudHMudHJpZ2dlcignY2hlY2twb2ludF9yZXN0b3JlZC5Ob3RlYm9vaycpO1xuICAgICAgICB0aGlzLmxvYWRfbm90ZWJvb2sodGhpcy5ub3RlYm9va19wYXRoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGVsZXRlIGEgbm90ZWJvb2sgY2hlY2twb2ludC5cbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hlY2twb2ludCBJRFxuICAgICAqL1xuICAgIE5vdGVib29rLnByb3RvdHlwZS5kZWxldGVfY2hlY2twb2ludCA9IGZ1bmN0aW9uIChjaGVja3BvaW50KSB7XG4gICAgICAgIHRoaXMuZXZlbnRzLnRyaWdnZXIoJ25vdGVib29rX3Jlc3RvcmluZy5Ob3RlYm9vaycsIGNoZWNrcG9pbnQpO1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIHRoaXMuY29udGVudHMuZGVsZXRlX2NoZWNrcG9pbnQodGhpcy5ub3RlYm9va19wYXRoLCBjaGVja3BvaW50KS50aGVuKFxuICAgICAgICAgICAgJC5wcm94eSh0aGlzLmRlbGV0ZV9jaGVja3BvaW50X3N1Y2Nlc3MsIHRoaXMpLFxuICAgICAgICAgICAgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhhdC5ldmVudHMudHJpZ2dlcignY2hlY2twb2ludF9kZWxldGVfZmFpbGVkLk5vdGVib29rJywgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTdWNjZXNzIGNhbGxiYWNrIGZvciBkZWxldGluZyBhIG5vdGVib29rIGNoZWNrcG9pbnQuXG4gICAgICovXG4gICAgTm90ZWJvb2sucHJvdG90eXBlLmRlbGV0ZV9jaGVja3BvaW50X3N1Y2Nlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZXZlbnRzLnRyaWdnZXIoJ2NoZWNrcG9pbnRfZGVsZXRlZC5Ob3RlYm9vaycpO1xuICAgICAgICB0aGlzLmxvYWRfbm90ZWJvb2sodGhpcy5ub3RlYm9va19wYXRoKTtcbiAgICB9O1xuXG4gICAgZXhwb3J0cy5Ob3RlYm9vayA9IE5vdGVib29rO1xuIiwiLy8gQ29weXJpZ2h0IChjKSBKdXB5dGVyIERldmVsb3BtZW50IFRlYW0uXG4vLyBEaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIE1vZGlmaWVkIEJTRCBMaWNlbnNlLlxuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgdmFyIHV0aWxzID0gcmVxdWlyZSgnYmFzZS9qcy91dGlscycpO1xuICAgIHZhciBkaWFsb2cgPSByZXF1aXJlKCdiYXNlL2pzL2RpYWxvZycpO1xuICAgIHZhciBub3RpZmljYXRpb25hcmVhID0gcmVxdWlyZSgnYmFzZS9qcy9ub3RpZmljYXRpb25hcmVhJyk7XG4gICAgdmFyIG1vbWVudCA9IHJlcXVpcmUoJ21vbWVudCcpO1xuXG4gICAgdmFyIE5vdGlmaWNhdGlvbkFyZWEgPSBub3RpZmljYXRpb25hcmVhLk5vdGlmaWNhdGlvbkFyZWE7XG5cbiAgICB2YXIgTm90ZWJvb2tOb3RpZmljYXRpb25BcmVhID0gZnVuY3Rpb24oc2VsZWN0b3IsIG9wdGlvbnMpIHtcbiAgICAgICAgTm90aWZpY2F0aW9uQXJlYS5hcHBseSh0aGlzLCBbc2VsZWN0b3IsIG9wdGlvbnNdKTtcbiAgICAgICAgdGhpcy5zYXZlX3dpZGdldCA9IG9wdGlvbnMuc2F2ZV93aWRnZXQ7XG4gICAgICAgIHRoaXMubm90ZWJvb2sgPSBvcHRpb25zLm5vdGVib29rO1xuICAgICAgICB0aGlzLmtleWJvYXJkX21hbmFnZXIgPSBvcHRpb25zLmtleWJvYXJkX21hbmFnZXI7XG4gICAgfTtcblxuICAgIE5vdGVib29rTm90aWZpY2F0aW9uQXJlYS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE5vdGlmaWNhdGlvbkFyZWEucHJvdG90eXBlKTtcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgdGhlIGRlZmF1bHQgc2V0IG9mIG5vdGlmaWNhdGlvbiB3aWRnZXRzLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBpbml0X25vdGlmaWNhdGlvbl93aWRnZXRzXG4gICAgICovXG4gICAgTm90ZWJvb2tOb3RpZmljYXRpb25BcmVhLnByb3RvdHlwZS5pbml0X25vdGlmaWNhdGlvbl93aWRnZXRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmluaXRfa2VybmVsX25vdGlmaWNhdGlvbl93aWRnZXQoKTtcbiAgICAgICAgdGhpcy5pbml0X25vdGVib29rX25vdGlmaWNhdGlvbl93aWRnZXQoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSB0aGUgbm90aWZpY2F0aW9uIHdpZGdldCBmb3Iga2VybmVsIHN0YXR1cyBtZXNzYWdlcy5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgaW5pdF9rZXJuZWxfbm90aWZpY2F0aW9uX3dpZGdldFxuICAgICAqL1xuICAgIE5vdGVib29rTm90aWZpY2F0aW9uQXJlYS5wcm90b3R5cGUuaW5pdF9rZXJuZWxfbm90aWZpY2F0aW9uX3dpZGdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICB2YXIga253ID0gdGhpcy5uZXdfbm90aWZpY2F0aW9uX3dpZGdldCgna2VybmVsJyk7XG4gICAgICAgIHZhciAka2VybmVsX2luZF9pY29uID0gJChcIiNrZXJuZWxfaW5kaWNhdG9yX2ljb25cIik7XG4gICAgICAgIHZhciAkbW9kYWxfaW5kX2ljb24gPSAkKFwiI21vZGFsX2luZGljYXRvclwiKTtcbiAgICAgICAgdmFyICRyZWFkb25seV9pbmRfaWNvbiA9ICQoJyNyZWFkb25seS1pbmRpY2F0b3InKTtcbiAgICAgICAgdmFyICRib2R5ID0gJCgnYm9keScpO1xuXG4gICAgICAgIC8vIExpc3RlbiBmb3IgdGhlIG5vdGVib29rIGxvYWRlZCBldmVudC4gIFNldCByZWFkb25seSBpbmRpY2F0b3IuXG4gICAgICAgIHRoaXMuZXZlbnRzLm9uKCdub3RlYm9va19sb2FkZWQuTm90ZWJvb2snLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICh0aGF0Lm5vdGVib29rLndyaXRhYmxlKSB7XG4gICAgICAgICAgICAgICAgJHJlYWRvbmx5X2luZF9pY29uLmhpZGUoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJHJlYWRvbmx5X2luZF9pY29uLnNob3coKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQ29tbWFuZC9FZGl0IG1vZGVcbiAgICAgICAgdGhpcy5ldmVudHMub24oJ2VkaXRfbW9kZS5Ob3RlYm9vaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoYXQuc2F2ZV93aWRnZXQudXBkYXRlX2RvY3VtZW50X3RpdGxlKCk7XG4gICAgICAgICAgICAkYm9keS5hZGRDbGFzcygnZWRpdF9tb2RlJyk7XG4gICAgICAgICAgICAkYm9keS5yZW1vdmVDbGFzcygnY29tbWFuZF9tb2RlJyk7XG4gICAgICAgICAgICAkbW9kYWxfaW5kX2ljb24uYXR0cigndGl0bGUnLCdFZGl0IE1vZGUnKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5ldmVudHMub24oJ2NvbW1hbmRfbW9kZS5Ob3RlYm9vaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoYXQuc2F2ZV93aWRnZXQudXBkYXRlX2RvY3VtZW50X3RpdGxlKCk7XG4gICAgICAgICAgICAkYm9keS5yZW1vdmVDbGFzcygnZWRpdF9tb2RlJyk7XG4gICAgICAgICAgICAkYm9keS5hZGRDbGFzcygnY29tbWFuZF9tb2RlJyk7XG4gICAgICAgICAgICAkbW9kYWxfaW5kX2ljb24uYXR0cigndGl0bGUnLCdDb21tYW5kIE1vZGUnKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gSW1wbGljaXRseSBzdGFydCBvZmYgaW4gQ29tbWFuZCBtb2RlLCBzd2l0Y2hpbmcgdG8gRWRpdCBtb2RlIHdpbGwgdHJpZ2dlciBldmVudFxuICAgICAgICAkbW9kYWxfaW5kX2ljb24uYWRkQ2xhc3MoJ21vZGFsX2luZGljYXRvcicpLmF0dHIoJ3RpdGxlJywnQ29tbWFuZCBNb2RlJyk7XG4gICAgICAgICRib2R5LmFkZENsYXNzKCdjb21tYW5kX21vZGUnKTtcblxuICAgICAgICAvLyBLZXJuZWwgZXZlbnRzXG5cbiAgICAgICAgLy8gdGhpcyBjYW4gYmUgZWl0aGVyIGtlcm5lbF9jcmVhdGVkLktlcm5lbCBvciBrZXJuZWxfY3JlYXRlZC5TZXNzaW9uXG4gICAgICAgIHRoaXMuZXZlbnRzLm9uKCdrZXJuZWxfY3JlYXRlZC5LZXJuZWwga2VybmVsX2NyZWF0ZWQuU2Vzc2lvbicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGtudy5pbmZvKFwiS2VybmVsIENyZWF0ZWRcIiwgNTAwKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5ldmVudHMub24oJ2tlcm5lbF9yZWNvbm5lY3RpbmcuS2VybmVsJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAga253Lndhcm5pbmcoXCJDb25uZWN0aW5nIHRvIGtlcm5lbFwiKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5ldmVudHMub24oJ2tlcm5lbF9jb25uZWN0aW9uX2RlYWQuS2VybmVsJywgZnVuY3Rpb24gKGV2dCwgaW5mbykge1xuICAgICAgICAgICAga253LmRhbmdlcihcIk5vdCBDb25uZWN0ZWRcIiwgdW5kZWZpbmVkLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gc2NoZWR1bGUgcmVjb25uZWN0IGEgc2hvcnQgdGltZSBpbiB0aGUgZnV0dXJlLCBkb24ndCByZWNvbm5lY3QgaW1tZWRpYXRlbHlcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCQucHJveHkoaW5mby5rZXJuZWwucmVjb25uZWN0LCBpbmZvLmtlcm5lbCksIDUwMCk7XG4gICAgICAgICAgICB9LCB7dGl0bGU6ICdjbGljayB0byByZWNvbm5lY3QnfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuZXZlbnRzLm9uKCdrZXJuZWxfY29ubmVjdGVkLktlcm5lbCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGtudy5pbmZvKFwiQ29ubmVjdGVkXCIsIDUwMCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuZXZlbnRzLm9uKCdrZXJuZWxfcmVzdGFydGluZy5LZXJuZWwnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGF0LnNhdmVfd2lkZ2V0LnVwZGF0ZV9kb2N1bWVudF90aXRsZSgpO1xuICAgICAgICAgICAga253LnNldF9tZXNzYWdlKFwiUmVzdGFydGluZyBrZXJuZWxcIiwgMjAwMCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuZXZlbnRzLm9uKCdrZXJuZWxfYXV0b3Jlc3RhcnRpbmcuS2VybmVsJywgZnVuY3Rpb24gKGV2dCwgaW5mbykge1xuICAgICAgICAgICAgLy8gT25seSBzaG93IHRoZSBkaWFsb2cgb24gdGhlIGZpcnN0IHJlc3RhcnQgYXR0ZW1wdC4gVGhpc1xuICAgICAgICAgICAgLy8gbnVtYmVyIGdldHMgdHJhY2tlZCBieSB0aGUgYEtlcm5lbGAgb2JqZWN0IGFuZCBwYXNzZWRcbiAgICAgICAgICAgIC8vIGFsb25nIGhlcmUsIGJlY2F1c2Ugd2UgZG9uJ3Qgd2FudCB0byBzaG93IHRoZSB1c2VyIDVcbiAgICAgICAgICAgIC8vIGRpYWxvZ3Mgc2F5aW5nIHRoZSBzYW1lIHRoaW5nICh3aGljaCBpcyB0aGUgbnVtYmVyIG9mXG4gICAgICAgICAgICAvLyB0aW1lcyBpdCB0cmllcyByZXN0YXJ0aW5nKS5cbiAgICAgICAgICAgIGlmIChpbmZvLmF0dGVtcHQgPT09IDEpIHtcblxuICAgICAgICAgICAgICAgIGRpYWxvZy5rZXJuZWxfbW9kYWwoe1xuICAgICAgICAgICAgICAgICAgICBub3RlYm9vazogdGhhdC5ub3RlYm9vayxcbiAgICAgICAgICAgICAgICAgICAga2V5Ym9hcmRfbWFuYWdlcjogdGhhdC5rZXlib2FyZF9tYW5hZ2VyLFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogXCJLZXJuZWwgUmVzdGFydGluZ1wiLFxuICAgICAgICAgICAgICAgICAgICBib2R5OiBcIlRoZSBrZXJuZWwgYXBwZWFycyB0byBoYXZlIGRpZWQuIEl0IHdpbGwgcmVzdGFydCBhdXRvbWF0aWNhbGx5LlwiLFxuICAgICAgICAgICAgICAgICAgICBidXR0b25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBPSyA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzcyA6IFwiYnRuLXByaW1hcnlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoYXQuc2F2ZV93aWRnZXQudXBkYXRlX2RvY3VtZW50X3RpdGxlKCk7XG4gICAgICAgICAgICBrbncuZGFuZ2VyKFwiRGVhZCBrZXJuZWxcIik7XG4gICAgICAgICAgICAka2VybmVsX2luZF9pY29uLmF0dHIoJ2NsYXNzJywna2VybmVsX2RlYWRfaWNvbicpLmF0dHIoJ3RpdGxlJywnS2VybmVsIERlYWQnKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5ldmVudHMub24oJ2tlcm5lbF9pbnRlcnJ1cHRpbmcuS2VybmVsJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAga253LnNldF9tZXNzYWdlKFwiSW50ZXJydXB0aW5nIGtlcm5lbFwiLCAyMDAwKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5ldmVudHMub24oJ2tlcm5lbF9kaXNjb25uZWN0ZWQuS2VybmVsJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgJGtlcm5lbF9pbmRfaWNvblxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdrZXJuZWxfZGlzY29ubmVjdGVkX2ljb24nKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd0aXRsZScsICdObyBDb25uZWN0aW9uIHRvIEtlcm5lbCcpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmV2ZW50cy5vbigna2VybmVsX2Nvbm5lY3Rpb25fZmFpbGVkLktlcm5lbCcsIGZ1bmN0aW9uIChldnQsIGluZm8pIHtcbiAgICAgICAgICAgIC8vIG9ubHkgc2hvdyB0aGUgZGlhbG9nIGlmIHRoaXMgaXMgdGhlIGZpcnN0IGZhaWxlZFxuICAgICAgICAgICAgLy8gY29ubmVjdCBhdHRlbXB0LCBiZWNhdXNlIHRoZSBrZXJuZWwgd2lsbCBjb250aW51ZVxuICAgICAgICAgICAgLy8gdHJ5aW5nIHRvIHJlY29ubmVjdCBhbmQgd2UgZG9uJ3Qgd2FudCB0byBzcGFtIHRoZSB1c2VyXG4gICAgICAgICAgICAvLyB3aXRoIG1lc3NhZ2VzXG4gICAgICAgICAgICBpZiAoaW5mby5hdHRlbXB0ID09PSAxKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgbXNnID0gXCJBIGNvbm5lY3Rpb24gdG8gdGhlIG5vdGVib29rIHNlcnZlciBjb3VsZCBub3QgYmUgZXN0YWJsaXNoZWQuXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCIgVGhlIG5vdGVib29rIHdpbGwgY29udGludWUgdHJ5aW5nIHRvIHJlY29ubmVjdCwgYnV0XCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCIgdW50aWwgaXQgZG9lcywgeW91IHdpbGwgTk9UIGJlIGFibGUgdG8gcnVuIGNvZGUuIENoZWNrIHlvdXJcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiBuZXR3b3JrIGNvbm5lY3Rpb24gb3Igbm90ZWJvb2sgc2VydmVyIGNvbmZpZ3VyYXRpb24uXCI7XG5cbiAgICAgICAgICAgICAgICBkaWFsb2cua2VybmVsX21vZGFsKHtcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFwiQ29ubmVjdGlvbiBmYWlsZWRcIixcbiAgICAgICAgICAgICAgICAgICAgYm9keTogbXNnLFxuICAgICAgICAgICAgICAgICAgICBrZXlib2FyZF9tYW5hZ2VyOiB0aGF0LmtleWJvYXJkX21hbmFnZXIsXG4gICAgICAgICAgICAgICAgICAgIG5vdGVib29rOiB0aGF0Lm5vdGVib29rLFxuICAgICAgICAgICAgICAgICAgICBidXR0b25zIDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJPS1wiOiB7fVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuZXZlbnRzLm9uKCdrZXJuZWxfa2lsbGVkLktlcm5lbCBrZXJuZWxfa2lsbGVkLlNlc3Npb24nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGF0LnNhdmVfd2lkZ2V0LnVwZGF0ZV9kb2N1bWVudF90aXRsZSgpO1xuICAgICAgICAgICAga253Lndhcm5pbmcoXCJObyBrZXJuZWxcIik7XG4gICAgICAgICAgICAka2VybmVsX2luZF9pY29uLmF0dHIoJ2NsYXNzJywna2VybmVsX2J1c3lfaWNvbicpLmF0dHIoJ3RpdGxlJywnS2VybmVsIGlzIG5vdCBydW5uaW5nJyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuZXZlbnRzLm9uKCdrZXJuZWxfZGVhZC5LZXJuZWwnLCBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIHZhciBzaG93TXNnID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICAgICAgdmFyIG1zZyA9ICdUaGUga2VybmVsIGhhcyBkaWVkLCBhbmQgdGhlIGF1dG9tYXRpYyByZXN0YXJ0IGhhcyBmYWlsZWQuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnIEl0IGlzIHBvc3NpYmxlIHRoZSBrZXJuZWwgY2Fubm90IGJlIHJlc3RhcnRlZC4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcgSWYgeW91IGFyZSBub3QgYWJsZSB0byByZXN0YXJ0IHRoZSBrZXJuZWwsIHlvdSB3aWxsIHN0aWxsIGJlIGFibGUgdG8gc2F2ZScgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJyB0aGUgbm90ZWJvb2ssIGJ1dCBydW5uaW5nIGNvZGUgd2lsbCBubyBsb25nZXIgd29yayB1bnRpbCB0aGUgbm90ZWJvb2snICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcgaXMgcmVvcGVuZWQuJztcblxuICAgICAgICAgICAgICAgIGRpYWxvZy5rZXJuZWxfbW9kYWwoe1xuICAgICAgICAgICAgICAgICAgICB0aXRsZTogXCJEZWFkIGtlcm5lbFwiLFxuICAgICAgICAgICAgICAgICAgICBib2R5IDogbXNnLFxuICAgICAgICAgICAgICAgICAgICBrZXlib2FyZF9tYW5hZ2VyOiB0aGF0LmtleWJvYXJkX21hbmFnZXIsXG4gICAgICAgICAgICAgICAgICAgIG5vdGVib29rOiB0aGF0Lm5vdGVib29rLFxuICAgICAgICAgICAgICAgICAgICBidXR0b25zIDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJUcnkgcmVzdGFydGluZyBub3dcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzOiBcImJ0bi1kYW5nZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGljazogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0Lm5vdGVib29rLnN0YXJ0X3Nlc3Npb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBcIkRvbid0IHJlc3RhcnRcIjoge31cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhhdC5zYXZlX3dpZGdldC51cGRhdGVfZG9jdW1lbnRfdGl0bGUoKTtcbiAgICAgICAgICAgIGtudy5kYW5nZXIoXCJEZWFkIGtlcm5lbFwiLCB1bmRlZmluZWQsIHNob3dNc2cpO1xuICAgICAgICAgICAgJGtlcm5lbF9pbmRfaWNvbi5hdHRyKCdjbGFzcycsJ2tlcm5lbF9kZWFkX2ljb24nKS5hdHRyKCd0aXRsZScsJ0tlcm5lbCBEZWFkJyk7XG5cbiAgICAgICAgICAgIHNob3dNc2coKTtcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICB0aGlzLmV2ZW50cy5vbihcIm5vX2tlcm5lbC5LZXJuZWxcIiwgZnVuY3Rpb24gKGV2dCwgZGF0YSkge1xuICAgICAgICAgICAgJChcIiNrZXJuZWxfaW5kaWNhdG9yXCIpLmZpbmQoJy5rZXJuZWxfaW5kaWNhdG9yX25hbWUnKS50ZXh0KFwiTm8gS2VybmVsXCIpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmV2ZW50cy5vbigna2VybmVsX2RlYWQuU2Vzc2lvbicsIGZ1bmN0aW9uIChldnQsIGluZm8pIHtcbiAgICAgICAgICAgIHZhciBmdWxsID0gaW5mby54aHIucmVzcG9uc2VKU09OLm1lc3NhZ2U7XG4gICAgICAgICAgICB2YXIgc2hvcnQgPSBpbmZvLnhoci5yZXNwb25zZUpTT04uc2hvcnRfbWVzc2FnZSB8fCAnS2VybmVsIGVycm9yJztcbiAgICAgICAgICAgIHZhciB0cmFjZWJhY2sgPSBpbmZvLnhoci5yZXNwb25zZUpTT04udHJhY2ViYWNrO1xuXG4gICAgICAgICAgICB2YXIgc2hvd01zZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbXNnID0gJCgnPGRpdi8+JykuYXBwZW5kKCQoJzxwLz4nKS50ZXh0KGZ1bGwpKTtcbiAgICAgICAgICAgICAgICB2YXIgY20sIGNtX2VsZW0sIGNtX29wZW47XG5cbiAgICAgICAgICAgICAgICBpZiAodHJhY2ViYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNtX2VsZW0gPSAkKCc8ZGl2Lz4nKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNzcygnbWFyZ2luLXRvcCcsICcxZW0nKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNzcygncGFkZGluZycsICcxZW0nKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKCdvdXRwdXRfc2Nyb2xsJyk7XG4gICAgICAgICAgICAgICAgICAgIG1zZy5hcHBlbmQoY21fZWxlbSk7XG4gICAgICAgICAgICAgICAgICAgIGNtID0gQ29kZU1pcnJvcihjbV9lbGVtLmdldCgwKSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZTogIFwicHl0aG9uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICByZWFkT25seSA6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNtLnNldFZhbHVlKHRyYWNlYmFjayk7XG4gICAgICAgICAgICAgICAgICAgIGNtX29wZW4gPSAkLnByb3h5KGNtLnJlZnJlc2gsIGNtKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBkaWFsb2cua2VybmVsX21vZGFsKHtcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFwiRmFpbGVkIHRvIHN0YXJ0IHRoZSBrZXJuZWxcIixcbiAgICAgICAgICAgICAgICAgICAgYm9keSA6IG1zZyxcbiAgICAgICAgICAgICAgICAgICAga2V5Ym9hcmRfbWFuYWdlcjogdGhhdC5rZXlib2FyZF9tYW5hZ2VyLFxuICAgICAgICAgICAgICAgICAgICBub3RlYm9vazogdGhhdC5ub3RlYm9vayxcbiAgICAgICAgICAgICAgICAgICAgb3BlbjogY21fb3BlbixcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9ucyA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiT2tcIjogeyBjbGFzczogJ2J0bi1wcmltYXJ5JyB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoYXQuc2F2ZV93aWRnZXQudXBkYXRlX2RvY3VtZW50X3RpdGxlKCk7XG4gICAgICAgICAgICAka2VybmVsX2luZF9pY29uLmF0dHIoJ2NsYXNzJywna2VybmVsX2RlYWRfaWNvbicpLmF0dHIoJ3RpdGxlJywnS2VybmVsIERlYWQnKTtcbiAgICAgICAgICAgIGtudy5kYW5nZXIoc2hvcnQsIHVuZGVmaW5lZCwgc2hvd01zZyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuZXZlbnRzLm9uKCdrZXJuZWxfc3RhcnRpbmcuS2VybmVsIGtlcm5lbF9jcmVhdGVkLlNlc3Npb24nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB3aW5kb3cuZG9jdW1lbnQudGl0bGU9JyhTdGFydGluZykgJyt3aW5kb3cuZG9jdW1lbnQudGl0bGU7XG4gICAgICAgICAgICAka2VybmVsX2luZF9pY29uLmF0dHIoJ2NsYXNzJywna2VybmVsX2J1c3lfaWNvbicpLmF0dHIoJ3RpdGxlJywnS2VybmVsIEJ1c3knKTtcbiAgICAgICAgICAgIGtudy5zZXRfbWVzc2FnZShcIktlcm5lbCBzdGFydGluZywgcGxlYXNlIHdhaXQuLi5cIik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuZXZlbnRzLm9uKCdrZXJuZWxfcmVhZHkuS2VybmVsJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhhdC5zYXZlX3dpZGdldC51cGRhdGVfZG9jdW1lbnRfdGl0bGUoKTtcbiAgICAgICAgICAgICRrZXJuZWxfaW5kX2ljb24uYXR0cignY2xhc3MnLCdrZXJuZWxfaWRsZV9pY29uJykuYXR0cigndGl0bGUnLCdLZXJuZWwgSWRsZScpO1xuICAgICAgICAgICAga253LmluZm8oXCJLZXJuZWwgcmVhZHlcIiwgNTAwKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5ldmVudHMub24oJ2tlcm5lbF9pZGxlLktlcm5lbCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoYXQuc2F2ZV93aWRnZXQudXBkYXRlX2RvY3VtZW50X3RpdGxlKCk7XG4gICAgICAgICAgICAka2VybmVsX2luZF9pY29uLmF0dHIoJ2NsYXNzJywna2VybmVsX2lkbGVfaWNvbicpLmF0dHIoJ3RpdGxlJywnS2VybmVsIElkbGUnKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5ldmVudHMub24oJ2tlcm5lbF9idXN5Lktlcm5lbCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHdpbmRvdy5kb2N1bWVudC50aXRsZT0nKEJ1c3kpICcrd2luZG93LmRvY3VtZW50LnRpdGxlO1xuICAgICAgICAgICAgJGtlcm5lbF9pbmRfaWNvbi5hdHRyKCdjbGFzcycsJ2tlcm5lbF9idXN5X2ljb24nKS5hdHRyKCd0aXRsZScsJ0tlcm5lbCBCdXN5Jyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuZXZlbnRzLm9uKCdzcGVjX21hdGNoX2ZvdW5kLktlcm5lbCcsIGZ1bmN0aW9uIChldnQsIGRhdGEpIHtcbiAgICAgICAgICAgIHRoYXQud2lkZ2V0KCdrZXJuZWxzcGVjJykuaW5mbyhcIlVzaW5nIGtlcm5lbDogXCIgKyBkYXRhLmZvdW5kLnNwZWMuZGlzcGxheV9uYW1lLCAzMDAwLCB1bmRlZmluZWQsIHtcbiAgICAgICAgICAgICAgICB0aXRsZTogXCJPbmx5IGNhbmRpZGF0ZSBmb3IgbGFuZ3VhZ2U6IFwiICsgZGF0YS5zZWxlY3RlZC5sYW5ndWFnZSArIFwiIHdhcyBcIiArIGRhdGEuZm91bmQuc3BlYy5kaXNwbGF5X25hbWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBcbiAgICAgICAgLy8gU3RhcnQgdGhlIGtlcm5lbCBpbmRpY2F0b3IgaW4gdGhlIGJ1c3kgc3RhdGUsIGFuZCBzZW5kIGEga2VybmVsX2luZm8gcmVxdWVzdC5cbiAgICAgICAgLy8gV2hlbiB0aGUga2VybmVsX2luZm8gcmVwbHkgYXJyaXZlcywgdGhlIGtlcm5lbCBpcyBpZGxlLlxuICAgICAgICAka2VybmVsX2luZF9pY29uLmF0dHIoJ2NsYXNzJywna2VybmVsX2J1c3lfaWNvbicpLmF0dHIoJ3RpdGxlJywnS2VybmVsIEJ1c3knKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSB0aGUgbm90aWZpY2F0aW9uIHdpZGdldCBmb3Igbm90ZWJvb2sgc3RhdHVzIG1lc3NhZ2VzLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBpbml0X25vdGVib29rX25vdGlmaWNhdGlvbl93aWRnZXRcbiAgICAgKi9cbiAgICBOb3RlYm9va05vdGlmaWNhdGlvbkFyZWEucHJvdG90eXBlLmluaXRfbm90ZWJvb2tfbm90aWZpY2F0aW9uX3dpZGdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5udyA9IHRoaXMubmV3X25vdGlmaWNhdGlvbl93aWRnZXQoJ25vdGVib29rJyk7XG5cbiAgICAgICAgLy8gTm90ZWJvb2sgZXZlbnRzXG4gICAgICAgIHRoaXMuZXZlbnRzLm9uKCdub3RlYm9va19sb2FkaW5nLk5vdGVib29rJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgbm53LnNldF9tZXNzYWdlKFwiTG9hZGluZyBub3RlYm9va1wiLDUwMCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmV2ZW50cy5vbignbm90ZWJvb2tfbG9hZGVkLk5vdGVib29rJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgbm53LnNldF9tZXNzYWdlKFwiTm90ZWJvb2sgbG9hZGVkXCIsNTAwKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZXZlbnRzLm9uKCdub3RlYm9va19zYXZpbmcuTm90ZWJvb2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBubncuc2V0X21lc3NhZ2UoXCJTYXZpbmcgbm90ZWJvb2tcIiw1MDApO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5ldmVudHMub24oJ25vdGVib29rX3NhdmVkLk5vdGVib29rJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgbm53LnNldF9tZXNzYWdlKFwiTm90ZWJvb2sgc2F2ZWRcIiwyMDAwKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZXZlbnRzLm9uKCdub3RlYm9va19zYXZlX2ZhaWxlZC5Ob3RlYm9vaycsIGZ1bmN0aW9uIChldnQsIGVycm9yKSB7XG4gICAgICAgICAgICBubncud2FybmluZyhlcnJvci5tZXNzYWdlIHx8IFwiTm90ZWJvb2sgc2F2ZSBmYWlsZWRcIik7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmV2ZW50cy5vbignbm90ZWJvb2tfY29weV9mYWlsZWQuTm90ZWJvb2snLCBmdW5jdGlvbiAoZXZ0LCBlcnJvcikge1xuICAgICAgICAgICAgbm53Lndhcm5pbmcoZXJyb3IubWVzc2FnZSB8fCBcIk5vdGVib29rIGNvcHkgZmFpbGVkXCIpO1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIC8vIENoZWNrcG9pbnQgZXZlbnRzXG4gICAgICAgIHRoaXMuZXZlbnRzLm9uKCdjaGVja3BvaW50X2NyZWF0ZWQuTm90ZWJvb2snLCBmdW5jdGlvbiAoZXZ0LCBkYXRhKSB7XG4gICAgICAgICAgICB2YXIgbXNnID0gXCJDaGVja3BvaW50IGNyZWF0ZWRcIjtcbiAgICAgICAgICAgIGlmIChkYXRhLmxhc3RfbW9kaWZpZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZCA9IG5ldyBEYXRlKGRhdGEubGFzdF9tb2RpZmllZCk7XG4gICAgICAgICAgICAgICAgbXNnID0gbXNnICsgXCI6IFwiICsgbW9tZW50KGQpLmZvcm1hdChcIkhIOm1tOnNzXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm53LnNldF9tZXNzYWdlKG1zZywgMjAwMCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmV2ZW50cy5vbignY2hlY2twb2ludF9mYWlsZWQuTm90ZWJvb2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBubncud2FybmluZyhcIkNoZWNrcG9pbnQgZmFpbGVkXCIpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5ldmVudHMub24oJ2NoZWNrcG9pbnRfZGVsZXRlZC5Ob3RlYm9vaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIG5udy5zZXRfbWVzc2FnZShcIkNoZWNrcG9pbnQgZGVsZXRlZFwiLCA1MDApO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5ldmVudHMub24oJ2NoZWNrcG9pbnRfZGVsZXRlX2ZhaWxlZC5Ob3RlYm9vaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIG5udy53YXJuaW5nKFwiQ2hlY2twb2ludCBkZWxldGUgZmFpbGVkXCIpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5ldmVudHMub24oJ2NoZWNrcG9pbnRfcmVzdG9yaW5nLk5vdGVib29rJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgbm53LnNldF9tZXNzYWdlKFwiUmVzdG9yaW5nIHRvIGNoZWNrcG9pbnQuLi5cIiwgNTAwKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZXZlbnRzLm9uKCdjaGVja3BvaW50X3Jlc3RvcmVfZmFpbGVkLk5vdGVib29rJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgbm53Lndhcm5pbmcoXCJDaGVja3BvaW50IHJlc3RvcmUgZmFpbGVkXCIpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBBdXRvc2F2ZSBldmVudHNcbiAgICAgICAgdGhpcy5ldmVudHMub24oJ2F1dG9zYXZlX2Rpc2FibGVkLk5vdGVib29rJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgbm53LnNldF9tZXNzYWdlKFwiQXV0b3NhdmUgZGlzYWJsZWRcIiwgMjAwMCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmV2ZW50cy5vbignYXV0b3NhdmVfZW5hYmxlZC5Ob3RlYm9vaycsIGZ1bmN0aW9uIChldnQsIGludGVydmFsKSB7XG4gICAgICAgICAgICBubncuc2V0X21lc3NhZ2UoXCJTYXZpbmcgZXZlcnkgXCIgKyBpbnRlcnZhbCAvIDEwMDAgKyBcInNcIiwgMTAwMCk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBleHBvcnRzLk5vdGVib29rTm90aWZpY2F0aW9uQXJlYSA9IE5vdGVib29rTm90aWZpY2F0aW9uQXJlYTtcbiIsIi8vIENvcHlyaWdodCAoYykgSnVweXRlciBEZXZlbG9wbWVudCBUZWFtLlxuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBNb2RpZmllZCBCU0QgTGljZW5zZS5cbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIHZhciB1dGlscyA9IHJlcXVpcmUoJ2Jhc2UvanMvdXRpbHMnKTtcbiAgICB2YXIgc2VjdXJpdHkgPSByZXF1aXJlKCdiYXNlL2pzL3NlY3VyaXR5Jyk7XG4gICAgdmFyIGtleWJvYXJkID0gcmVxdWlyZSgnYmFzZS9qcy9rZXlib2FyZCcpO1xuICAgIHZhciBtYXRoamF4dXRpbHMgPSByZXF1aXJlKCdub3RlYm9vay9qcy9tYXRoamF4dXRpbHMnKTtcbiAgICB2YXIgbWFya2VkID0gcmVxdWlyZSgnbWFya2VkJyk7XG5cbiAgICAvKipcbiAgICAgKiBAY2xhc3MgT3V0cHV0QXJlYVxuICAgICAqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG5cbiAgICB2YXIgT3V0cHV0QXJlYSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0b3IgPSBvcHRpb25zLnNlbGVjdG9yO1xuICAgICAgICB0aGlzLmV2ZW50cyA9IG9wdGlvbnMuZXZlbnRzO1xuICAgICAgICB0aGlzLmtleWJvYXJkX21hbmFnZXIgPSBvcHRpb25zLmtleWJvYXJkX21hbmFnZXI7XG4gICAgICAgIHRoaXMud3JhcHBlciA9ICQob3B0aW9ucy5zZWxlY3Rvcik7XG4gICAgICAgIHRoaXMub3V0cHV0cyA9IFtdO1xuICAgICAgICB0aGlzLmNvbGxhcHNlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNjcm9sbGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2Nyb2xsX3N0YXRlID0gJ2F1dG8nO1xuICAgICAgICB0aGlzLnRydXN0ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmNsZWFyX3F1ZXVlZCA9IG51bGw7XG4gICAgICAgIGlmIChvcHRpb25zLnByb21wdF9hcmVhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMucHJvbXB0X2FyZWEgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wcm9tcHRfYXJlYSA9IG9wdGlvbnMucHJvbXB0X2FyZWE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jcmVhdGVfZWxlbWVudHMoKTtcbiAgICAgICAgdGhpcy5zdHlsZSgpO1xuICAgICAgICB0aGlzLmJpbmRfZXZlbnRzKCk7XG4gICAgfTtcblxuXG4gICAgLyoqXG4gICAgICogQ2xhc3MgcHJvdG90eXBlc1xuICAgICAqKi9cblxuICAgIE91dHB1dEFyZWEucHJvdG90eXBlLmNyZWF0ZV9lbGVtZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gJChcIjxkaXYvPlwiKTtcbiAgICAgICAgdGhpcy5jb2xsYXBzZV9idXR0b24gPSAkKFwiPGRpdi8+XCIpO1xuICAgICAgICB0aGlzLnByb21wdF9vdmVybGF5ID0gJChcIjxkaXYvPlwiKTtcbiAgICAgICAgdGhpcy53cmFwcGVyLmFwcGVuZCh0aGlzLnByb21wdF9vdmVybGF5KTtcbiAgICAgICAgdGhpcy53cmFwcGVyLmFwcGVuZCh0aGlzLmVsZW1lbnQpO1xuICAgICAgICB0aGlzLndyYXBwZXIuYXBwZW5kKHRoaXMuY29sbGFwc2VfYnV0dG9uKTtcbiAgICB9O1xuXG5cbiAgICBPdXRwdXRBcmVhLnByb3RvdHlwZS5zdHlsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jb2xsYXBzZV9idXR0b24uaGlkZSgpO1xuICAgICAgICB0aGlzLnByb21wdF9vdmVybGF5LmhpZGUoKTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMud3JhcHBlci5hZGRDbGFzcygnb3V0cHV0X3dyYXBwZXInKTtcbiAgICAgICAgdGhpcy5lbGVtZW50LmFkZENsYXNzKCdvdXRwdXQnKTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuY29sbGFwc2VfYnV0dG9uLmFkZENsYXNzKFwiYnRuIGJ0bi1kZWZhdWx0IG91dHB1dF9jb2xsYXBzZWRcIik7XG4gICAgICAgIHRoaXMuY29sbGFwc2VfYnV0dG9uLmF0dHIoJ3RpdGxlJywgJ2NsaWNrIHRvIGV4cGFuZCBvdXRwdXQnKTtcbiAgICAgICAgdGhpcy5jb2xsYXBzZV9idXR0b24udGV4dCgnLiAuIC4nKTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMucHJvbXB0X292ZXJsYXkuYWRkQ2xhc3MoJ291dF9wcm9tcHRfb3ZlcmxheSBwcm9tcHQnKTtcbiAgICAgICAgdGhpcy5wcm9tcHRfb3ZlcmxheS5hdHRyKCd0aXRsZScsICdjbGljayB0byBleHBhbmQgb3V0cHV0OyBkb3VibGUgY2xpY2sgdG8gaGlkZSBvdXRwdXQnKTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuY29sbGFwc2UoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2hvdWxkIHRoZSBPdXRwdXRBcmVhIHNjcm9sbD9cbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGhlaWdodCAoaW4gbGluZXMpIGV4Y2VlZHMgdGhlIGN1cnJlbnQgdGhyZXNob2xkLlxuICAgICAqIFRocmVzaG9sZCB3aWxsIGJlIE91dHB1dEFyZWEubWluaW11bV9zY3JvbGxfdGhyZXNob2xkIGlmIHNjcm9sbF9zdGF0ZT10cnVlIChtYW51YWxseSByZXF1ZXN0ZWQpXG4gICAgICogb3IgT3V0cHV0QXJlYS5hdXRvX3Njcm9sbF90aHJlc2hvbGQgaWYgc2Nyb2xsX3N0YXRlPSdhdXRvJy5cbiAgICAgKiBUaGlzIHdpbGwgYWx3YXlzIHJldHVybiBmYWxzZSBpZiBzY3JvbGxfc3RhdGU9ZmFsc2UgKHNjcm9sbCBkaXNhYmxlZCkuXG4gICAgICpcbiAgICAgKi9cbiAgICBPdXRwdXRBcmVhLnByb3RvdHlwZS5fc2hvdWxkX3Njcm9sbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRocmVzaG9sZDtcbiAgICAgICAgaWYgKHRoaXMuc2Nyb2xsX3N0YXRlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc2Nyb2xsX3N0YXRlID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aHJlc2hvbGQgPSBPdXRwdXRBcmVhLm1pbmltdW1fc2Nyb2xsX3RocmVzaG9sZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocmVzaG9sZCA9IE91dHB1dEFyZWEuYXV0b19zY3JvbGxfdGhyZXNob2xkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aHJlc2hvbGQgPD0wKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbGluZS1oZWlnaHQgZnJvbSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzExODUxNTFcbiAgICAgICAgdmFyIGZvbnRTaXplID0gdGhpcy5lbGVtZW50LmNzcygnZm9udC1zaXplJyk7XG4gICAgICAgIHZhciBsaW5lSGVpZ2h0ID0gTWF0aC5mbG9vcihwYXJzZUludChmb250U2l6ZS5yZXBsYWNlKCdweCcsJycpKSAqIDEuNSk7XG4gICAgICAgIHJldHVybiAodGhpcy5lbGVtZW50LmhlaWdodCgpID4gdGhyZXNob2xkICogbGluZUhlaWdodCk7XG4gICAgfTtcblxuXG4gICAgT3V0cHV0QXJlYS5wcm90b3R5cGUuYmluZF9ldmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgdGhpcy5wcm9tcHRfb3ZlcmxheS5kYmxjbGljayhmdW5jdGlvbiAoKSB7IHRoYXQudG9nZ2xlX291dHB1dCgpOyB9KTtcbiAgICAgICAgdGhpcy5wcm9tcHRfb3ZlcmxheS5jbGljayhmdW5jdGlvbiAoKSB7IHRoYXQudG9nZ2xlX3Njcm9sbCgpOyB9KTtcblxuICAgICAgICB0aGlzLmVsZW1lbnQucmVzaXplKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIEZJWE1FOiBGaXJlZm94IG9uIExpbnV4IG1pc2JlaGF2ZXMsIHNvIGF1dG9tYXRpYyBzY3JvbGxpbmcgaXMgZGlzYWJsZWRcbiAgICAgICAgICAgIGlmICggdXRpbHMuYnJvd3NlclswXSA9PT0gXCJGaXJlZm94XCIgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbWF5YmUgc2Nyb2xsIG91dHB1dCxcbiAgICAgICAgICAgIC8vIGlmIGl0J3MgZ3Jvd24gbGFyZ2UgZW5vdWdoIGFuZCBoYXNuJ3QgYWxyZWFkeSBiZWVuIHNjcm9sbGVkLlxuICAgICAgICAgICAgaWYgKCF0aGF0LnNjcm9sbGVkICYmIHRoYXQuX3Nob3VsZF9zY3JvbGwoKSkge1xuICAgICAgICAgICAgICAgIHRoYXQuc2Nyb2xsX2FyZWEoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29sbGFwc2VfYnV0dG9uLmNsaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoYXQuZXhwYW5kKCk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cblxuICAgIE91dHB1dEFyZWEucHJvdG90eXBlLmNvbGxhcHNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuY29sbGFwc2VkKSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuaGlkZSgpO1xuICAgICAgICAgICAgdGhpcy5wcm9tcHRfb3ZlcmxheS5oaWRlKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5lbGVtZW50Lmh0bWwoKSl7XG4gICAgICAgICAgICAgICAgdGhpcy5jb2xsYXBzZV9idXR0b24uc2hvdygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jb2xsYXBzZWQgPSB0cnVlO1xuICAgICAgICAgICAgLy8gY29sbGFwc2luZyBvdXRwdXQgY2xlYXJzIHNjcm9sbCBzdGF0ZVxuICAgICAgICAgICAgdGhpcy5zY3JvbGxfc3RhdGUgPSAnYXV0byc7XG4gICAgICAgIH1cbiAgICB9O1xuXG5cbiAgICBPdXRwdXRBcmVhLnByb3RvdHlwZS5leHBhbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbGxhcHNlZCkge1xuICAgICAgICAgICAgdGhpcy5jb2xsYXBzZV9idXR0b24uaGlkZSgpO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LnNob3coKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb21wdF9hcmVhKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9tcHRfb3ZlcmxheS5zaG93KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNvbGxhcHNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxfaWZfbG9uZygpO1xuICAgICAgICB9XG4gICAgfTtcblxuXG4gICAgT3V0cHV0QXJlYS5wcm90b3R5cGUudG9nZ2xlX291dHB1dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuY29sbGFwc2VkKSB7XG4gICAgICAgICAgICB0aGlzLmV4cGFuZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jb2xsYXBzZSgpO1xuICAgICAgICB9XG4gICAgfTtcblxuXG4gICAgT3V0cHV0QXJlYS5wcm90b3R5cGUuc2Nyb2xsX2FyZWEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudC5hZGRDbGFzcygnb3V0cHV0X3Njcm9sbCcpO1xuICAgICAgICB0aGlzLnByb21wdF9vdmVybGF5LmF0dHIoJ3RpdGxlJywgJ2NsaWNrIHRvIHVuc2Nyb2xsIG91dHB1dDsgZG91YmxlIGNsaWNrIHRvIGhpZGUnKTtcbiAgICAgICAgdGhpcy5zY3JvbGxlZCA9IHRydWU7XG4gICAgfTtcblxuXG4gICAgT3V0cHV0QXJlYS5wcm90b3R5cGUudW5zY3JvbGxfYXJlYSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50LnJlbW92ZUNsYXNzKCdvdXRwdXRfc2Nyb2xsJyk7XG4gICAgICAgIHRoaXMucHJvbXB0X292ZXJsYXkuYXR0cigndGl0bGUnLCAnY2xpY2sgdG8gc2Nyb2xsIG91dHB1dDsgZG91YmxlIGNsaWNrIHRvIGhpZGUnKTtcbiAgICAgICAgdGhpcy5zY3JvbGxlZCA9IGZhbHNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTY3JvbGwgT3V0cHV0QXJlYSBpZiBoZWlnaHQgZXhjZWVkcyBhIHRocmVzaG9sZC5cbiAgICAgKlxuICAgICAqIFRocmVzaG9sZCBpcyBPdXRwdXRBcmVhLm1pbmltdW1fc2Nyb2xsX3RocmVzaG9sZCBpZiBzY3JvbGxfc3RhdGUgPSB0cnVlLFxuICAgICAqIE91dHB1dEFyZWEuYXV0b19zY3JvbGxfdGhyZXNob2xkIGlmIHNjcm9sbF9zdGF0ZT0nYXV0bycuXG4gICAgICpcbiAgICAgKiovXG4gICAgT3V0cHV0QXJlYS5wcm90b3R5cGUuc2Nyb2xsX2lmX2xvbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzaG91bGRfc2Nyb2xsID0gdGhpcy5fc2hvdWxkX3Njcm9sbCgpO1xuICAgICAgICBpZiAoIXRoaXMuc2Nyb2xsZWQgJiYgc2hvdWxkX3Njcm9sbCkge1xuICAgICAgICAgICAgLy8gb25seSBhbGxvdyBzY3JvbGxpbmcgbG9uZy1lbm91Z2ggb3V0cHV0XG4gICAgICAgICAgICB0aGlzLnNjcm9sbF9hcmVhKCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5zY3JvbGxlZCAmJiAhc2hvdWxkX3Njcm9sbCkge1xuICAgICAgICAgICAgLy8gc2Nyb2xsZWQgYW5kIHNob3VsZG4ndCBiZVxuICAgICAgICAgICAgdGhpcy51bnNjcm9sbF9hcmVhKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG5cbiAgICBPdXRwdXRBcmVhLnByb3RvdHlwZS50b2dnbGVfc2Nyb2xsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zY3JvbGxfc3RhdGUgPT0gJ2F1dG8nKSB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbF9zdGF0ZSA9ICF0aGlzLnNjcm9sbGVkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxfc3RhdGUgPSAhdGhpcy5zY3JvbGxfc3RhdGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc2Nyb2xsZWQpIHtcbiAgICAgICAgICAgIHRoaXMudW5zY3JvbGxfYXJlYSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gb25seSBhbGxvdyBzY3JvbGxpbmcgbG9uZy1lbm91Z2ggb3V0cHV0XG4gICAgICAgICAgICB0aGlzLnNjcm9sbF9pZl9sb25nKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG5cbiAgICAvLyB0eXBlc2V0IHdpdGggTWF0aEpheCBpZiBNYXRoSmF4IGlzIGF2YWlsYWJsZVxuICAgIE91dHB1dEFyZWEucHJvdG90eXBlLnR5cGVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHV0aWxzLnR5cGVzZXQodGhpcy5lbGVtZW50KTtcbiAgICB9O1xuXG5cbiAgICBPdXRwdXRBcmVhLnByb3RvdHlwZS5oYW5kbGVfb3V0cHV0ID0gZnVuY3Rpb24gKG1zZykge1xuICAgICAgICB2YXIganNvbiA9IHt9O1xuICAgICAgICB2YXIgbXNnX3R5cGUgPSBqc29uLm91dHB1dF90eXBlID0gbXNnLmhlYWRlci5tc2dfdHlwZTtcbiAgICAgICAgdmFyIGNvbnRlbnQgPSBtc2cuY29udGVudDtcbiAgICAgICAgaWYgKG1zZ190eXBlID09PSBcInN0cmVhbVwiKSB7XG4gICAgICAgICAgICBqc29uLnRleHQgPSBjb250ZW50LnRleHQ7XG4gICAgICAgICAgICBqc29uLm5hbWUgPSBjb250ZW50Lm5hbWU7XG4gICAgICAgIH0gZWxzZSBpZiAobXNnX3R5cGUgPT09IFwiZGlzcGxheV9kYXRhXCIpIHtcbiAgICAgICAgICAgIGpzb24uZGF0YSA9IGNvbnRlbnQuZGF0YTtcbiAgICAgICAgICAgIGpzb24ubWV0YWRhdGEgPSBjb250ZW50Lm1ldGFkYXRhO1xuICAgICAgICB9IGVsc2UgaWYgKG1zZ190eXBlID09PSBcImV4ZWN1dGVfcmVzdWx0XCIpIHtcbiAgICAgICAgICAgIGpzb24uZGF0YSA9IGNvbnRlbnQuZGF0YTtcbiAgICAgICAgICAgIGpzb24ubWV0YWRhdGEgPSBjb250ZW50Lm1ldGFkYXRhO1xuICAgICAgICAgICAganNvbi5leGVjdXRpb25fY291bnQgPSBjb250ZW50LmV4ZWN1dGlvbl9jb3VudDtcbiAgICAgICAgfSBlbHNlIGlmIChtc2dfdHlwZSA9PT0gXCJlcnJvclwiKSB7XG4gICAgICAgICAgICBqc29uLmVuYW1lID0gY29udGVudC5lbmFtZTtcbiAgICAgICAgICAgIGpzb24uZXZhbHVlID0gY29udGVudC5ldmFsdWU7XG4gICAgICAgICAgICBqc29uLnRyYWNlYmFjayA9IGNvbnRlbnQudHJhY2ViYWNrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJ1bmhhbmRsZWQgb3V0cHV0IG1lc3NhZ2VcIiwgbXNnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFwcGVuZF9vdXRwdXQoanNvbik7XG4gICAgfTtcblxuXG4gICAgT3V0cHV0QXJlYS5vdXRwdXRfdHlwZXMgPSBbXG4gICAgICAgICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0JyxcbiAgICAgICAgJ3RleHQvaHRtbCcsXG4gICAgICAgICd0ZXh0L21hcmtkb3duJyxcbiAgICAgICAgJ3RleHQvbGF0ZXgnLFxuICAgICAgICAnaW1hZ2Uvc3ZnK3htbCcsXG4gICAgICAgICdpbWFnZS9wbmcnLFxuICAgICAgICAnaW1hZ2UvanBlZycsXG4gICAgICAgICdhcHBsaWNhdGlvbi9wZGYnLFxuICAgICAgICAndGV4dC9wbGFpbidcbiAgICBdO1xuXG4gICAgT3V0cHV0QXJlYS5wcm90b3R5cGUudmFsaWRhdGVfbWltZWJ1bmRsZSA9IGZ1bmN0aW9uIChidW5kbGUpIHtcbiAgICAgICAgLyoqIHNjcnViIGludmFsaWQgb3V0cHV0cyAqL1xuICAgICAgICBpZiAodHlwZW9mIGJ1bmRsZS5kYXRhICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwibWltZWJ1bmRsZSBtaXNzaW5nIGRhdGFcIiwgYnVuZGxlKTtcbiAgICAgICAgICAgIGJ1bmRsZS5kYXRhID0ge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBidW5kbGUubWV0YWRhdGEgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJtaW1lYnVuZGxlIG1pc3NpbmcgbWV0YWRhdGFcIiwgYnVuZGxlKTtcbiAgICAgICAgICAgIGJ1bmRsZS5tZXRhZGF0YSA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBkYXRhID0gYnVuZGxlLmRhdGE7XG4gICAgICAgICQubWFwKE91dHB1dEFyZWEub3V0cHV0X3R5cGVzLCBmdW5jdGlvbihrZXkpe1xuICAgICAgICAgICAgaWYgKGtleSAhPT0gJ2FwcGxpY2F0aW9uL2pzb24nICYmXG4gICAgICAgICAgICAgICAgZGF0YVtrZXldICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgZGF0YVtrZXldICE9PSAnc3RyaW5nJ1xuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJJbnZhbGlkIHR5cGUgZm9yIFwiICsga2V5LCBkYXRhW2tleV0pO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBkYXRhW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYnVuZGxlO1xuICAgIH07XG5cbiAgICBPdXRwdXRBcmVhLnByb3RvdHlwZS5hcHBlbmRfb3V0cHV0ID0gZnVuY3Rpb24gKGpzb24pIHtcbiAgICAgICAgdGhpcy5leHBhbmQoKTtcbiAgICAgICAgXG4gICAgICAgIC8vIENsZWFyIHRoZSBvdXRwdXQgaWYgY2xlYXIgaXMgcXVldWVkLlxuICAgICAgICB2YXIgbmVlZHNfaGVpZ2h0X3Jlc2V0ID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLmNsZWFyX3F1ZXVlZCkge1xuICAgICAgICAgICAgdGhpcy5jbGVhcl9vdXRwdXQoZmFsc2UpO1xuICAgICAgICAgICAgbmVlZHNfaGVpZ2h0X3Jlc2V0ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZWNvcmRfb3V0cHV0ID0gdHJ1ZTtcbiAgICAgICAgc3dpdGNoKGpzb24ub3V0cHV0X3R5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2V4ZWN1dGVfcmVzdWx0JzpcbiAgICAgICAgICAgICAgICBqc29uID0gdGhpcy52YWxpZGF0ZV9taW1lYnVuZGxlKGpzb24pO1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwZW5kX2V4ZWN1dGVfcmVzdWx0KGpzb24pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnc3RyZWFtJzpcbiAgICAgICAgICAgICAgICAvLyBhcHBlbmRfc3RyZWFtIG1pZ2h0IGhhdmUgbWVyZ2VkIHRoZSBvdXRwdXQgd2l0aCBlYXJsaWVyIHN0cmVhbSBvdXRwdXRcbiAgICAgICAgICAgICAgICByZWNvcmRfb3V0cHV0ID0gdGhpcy5hcHBlbmRfc3RyZWFtKGpzb24pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZXJyb3InOlxuICAgICAgICAgICAgICAgIHRoaXMuYXBwZW5kX2Vycm9yKGpzb24pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZGlzcGxheV9kYXRhJzpcbiAgICAgICAgICAgICAgICAvLyBhcHBlbmQgaGFuZGxlZCBiZWxvd1xuICAgICAgICAgICAgICAgIGpzb24gPSB0aGlzLnZhbGlkYXRlX21pbWVidW5kbGUoanNvbik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwidW5yZWNvZ25pemVkIG91dHB1dCB0eXBlOiBcIiArIGpzb24ub3V0cHV0X3R5cGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwZW5kX3VucmVjb2duaXplZChqc29uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdlIG11c3QgcmVsZWFzZSB0aGUgYW5pbWF0aW9uIGZpeGVkIGhlaWdodCBpbiBhIGNhbGxiYWNrIHNpbmNlIEdlY2tvXG4gICAgICAgIC8vIChGaXJlRm94KSBkb2Vzbid0IHJlbmRlciB0aGUgaW1hZ2UgaW1tZWRpYXRlbHkgYXMgdGhlIGRhdGEgaXMgXG4gICAgICAgIC8vIGF2YWlsYWJsZS5cbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICB2YXIgaGFuZGxlX2FwcGVuZGVkID0gZnVuY3Rpb24gKCRlbCkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBPbmx5IHJlc2V0IHRoZSBoZWlnaHQgdG8gYXV0b21hdGljIGlmIHRoZSBoZWlnaHQgaXMgY3VycmVudGx5XG4gICAgICAgICAgICAgKiBmaXhlZCAoZG9uZSBieSB3YWl0PVRydWUgZmxhZyBvbiBjbGVhcl9vdXRwdXQpLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAobmVlZHNfaGVpZ2h0X3Jlc2V0KSB7XG4gICAgICAgICAgICAgICAgdGhhdC5lbGVtZW50LmhlaWdodCgnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGF0LmVsZW1lbnQudHJpZ2dlcigncmVzaXplJyk7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChqc29uLm91dHB1dF90eXBlID09PSAnZGlzcGxheV9kYXRhJykge1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRfZGlzcGxheV9kYXRhKGpzb24sIGhhbmRsZV9hcHBlbmRlZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoYW5kbGVfYXBwZW5kZWQoKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKHJlY29yZF9vdXRwdXQpIHtcbiAgICAgICAgICAgIHRoaXMub3V0cHV0cy5wdXNoKGpzb24pO1xuICAgICAgICB9XG4gICAgfTtcblxuXG4gICAgT3V0cHV0QXJlYS5wcm90b3R5cGUuY3JlYXRlX291dHB1dF9hcmVhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb2EgPSAkKFwiPGRpdi8+XCIpLmFkZENsYXNzKFwib3V0cHV0X2FyZWFcIik7XG4gICAgICAgIGlmICh0aGlzLnByb21wdF9hcmVhKSB7XG4gICAgICAgICAgICBvYS5hcHBlbmQoJCgnPGRpdi8+JykuYWRkQ2xhc3MoJ3Byb21wdCcpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2E7XG4gICAgfTtcblxuXG4gICAgZnVuY3Rpb24gX2dldF9tZXRhZGF0YV9rZXkobWV0YWRhdGEsIGtleSwgbWltZSkge1xuICAgICAgICB2YXIgbWltZV9tZCA9IG1ldGFkYXRhW21pbWVdO1xuICAgICAgICAvLyBtaW1lLXNwZWNpZmljIGhpZ2hlciBwcmlvcml0eVxuICAgICAgICBpZiAobWltZV9tZCAmJiBtaW1lX21kW2tleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIG1pbWVfbWRba2V5XTtcbiAgICAgICAgfVxuICAgICAgICAvLyBmYWxsYmFjayBvbiBnbG9iYWxcbiAgICAgICAgcmV0dXJuIG1ldGFkYXRhW2tleV07XG4gICAgfVxuXG4gICAgT3V0cHV0QXJlYS5wcm90b3R5cGUuY3JlYXRlX291dHB1dF9zdWJhcmVhID0gZnVuY3Rpb24obWQsIGNsYXNzZXMsIG1pbWUpIHtcbiAgICAgICAgdmFyIHN1YmFyZWEgPSAkKCc8ZGl2Lz4nKS5hZGRDbGFzcygnb3V0cHV0X3N1YmFyZWEnKS5hZGRDbGFzcyhjbGFzc2VzKTtcbiAgICAgICAgaWYgKF9nZXRfbWV0YWRhdGFfa2V5KG1kLCAnaXNvbGF0ZWQnLCBtaW1lKSkge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGFuIGlmcmFtZSB0byBpc29sYXRlIHRoZSBzdWJhcmVhIGZyb20gdGhlIHJlc3Qgb2YgdGhlXG4gICAgICAgICAgICAvLyBkb2N1bWVudFxuICAgICAgICAgICAgdmFyIGlmcmFtZSA9ICQoJzxpZnJhbWUvPicpLmFkZENsYXNzKCdib3gtZmxleDEnKTtcbiAgICAgICAgICAgIGlmcmFtZS5jc3MoeydoZWlnaHQnOjEsICd3aWR0aCc6JzEwMCUnLCAnZGlzcGxheSc6J2Jsb2NrJ30pO1xuICAgICAgICAgICAgaWZyYW1lLmF0dHIoJ2ZyYW1lYm9yZGVyJywgMCk7XG4gICAgICAgICAgICBpZnJhbWUuYXR0cignc2Nyb2xsaW5nJywgJ2F1dG8nKTtcblxuICAgICAgICAgICAgLy8gT25jZSB0aGUgaWZyYW1lIGlzIGxvYWRlZCwgdGhlIHN1YmFyZWEgaXMgZHluYW1pY2FsbHkgaW5zZXJ0ZWRcbiAgICAgICAgICAgIGlmcmFtZS5vbignbG9hZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIC8vIFdvcmthcm91bmQgbmVlZGVkIGJ5IEZpcmVmb3gsIHRvIHByb3Blcmx5IHJlbmRlciBzdmcgaW5zaWRlXG4gICAgICAgICAgICAgICAgLy8gaWZyYW1lcywgc2VlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTAxNzcxOTAvXG4gICAgICAgICAgICAgICAgLy8gc3ZnLWR5bmFtaWNhbGx5LWFkZGVkLXRvLWlmcmFtZS1kb2VzLW5vdC1yZW5kZXItY29ycmVjdGx5XG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZW50RG9jdW1lbnQub3BlbigpO1xuXG4gICAgICAgICAgICAgICAgLy8gSW5zZXJ0IHRoZSBzdWJhcmVhIGludG8gdGhlIGlmcmFtZVxuICAgICAgICAgICAgICAgIC8vIFdlIG11c3QgZGlyZWN0bHkgd3JpdGUgdGhlIGh0bWwuIFdoZW4gdXNpbmcgSnF1ZXJ5J3MgYXBwZW5kXG4gICAgICAgICAgICAgICAgLy8gbWV0aG9kLCBqYXZhc2NyaXB0IGlzIGV2YWx1YXRlZCBpbiB0aGUgcGFyZW50IGRvY3VtZW50IGFuZFxuICAgICAgICAgICAgICAgIC8vIG5vdCBpbiB0aGUgaWZyYW1lIGRvY3VtZW50LiAgQXQgdGhpcyBwb2ludCwgc3ViYXJlYSBkb2Vzbid0XG4gICAgICAgICAgICAgICAgLy8gY29udGFpbiBhbnkgdXNlciBjb250ZW50LlxuICAgICAgICAgICAgICAgIHRoaXMuY29udGVudERvY3VtZW50LndyaXRlKHN1YmFyZWEuaHRtbCgpKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuY29udGVudERvY3VtZW50LmNsb3NlKCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgYm9keSA9IHRoaXMuY29udGVudERvY3VtZW50LmJvZHk7XG4gICAgICAgICAgICAgICAgLy8gQWRqdXN0IHRoZSBpZnJhbWUgaGVpZ2h0IGF1dG9tYXRpY2FsbHlcbiAgICAgICAgICAgICAgICBpZnJhbWUuaGVpZ2h0KGJvZHkuc2Nyb2xsSGVpZ2h0ICsgJ3B4Jyk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gRWxlbWVudHMgc2hvdWxkIGJlIGFwcGVuZGVkIHRvIHRoZSBpbm5lciBzdWJhcmVhIGFuZCBub3QgdG8gdGhlXG4gICAgICAgICAgICAvLyBpZnJhbWVcbiAgICAgICAgICAgIGlmcmFtZS5hcHBlbmQgPSBmdW5jdGlvbih0aGF0KSB7XG4gICAgICAgICAgICAgICAgc3ViYXJlYS5hcHBlbmQodGhhdCk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXR1cm4gaWZyYW1lO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHN1YmFyZWE7XG4gICAgICAgIH1cbiAgICB9O1xuXG5cbiAgICBPdXRwdXRBcmVhLnByb3RvdHlwZS5fYXBwZW5kX2phdmFzY3JpcHRfZXJyb3IgPSBmdW5jdGlvbiAoZXJyLCBlbGVtZW50KSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBkaXNwbGF5IGEgbWVzc2FnZSB3aGVuIGEgamF2YXNjcmlwdCBlcnJvciBvY2N1cnMgaW4gZGlzcGxheSBvdXRwdXRcbiAgICAgICAgICovXG4gICAgICAgIHZhciBtc2cgPSBcIkphdmFzY3JpcHQgZXJyb3IgYWRkaW5nIG91dHB1dCFcIjtcbiAgICAgICAgaWYgKCBlbGVtZW50ID09PSB1bmRlZmluZWQgKSByZXR1cm47XG4gICAgICAgIGVsZW1lbnRcbiAgICAgICAgICAgIC5hcHBlbmQoJCgnPGRpdi8+JykudGV4dChtc2cpLmFkZENsYXNzKCdqcy1lcnJvcicpKVxuICAgICAgICAgICAgLmFwcGVuZCgkKCc8ZGl2Lz4nKS50ZXh0KGVyci50b1N0cmluZygpKS5hZGRDbGFzcygnanMtZXJyb3InKSlcbiAgICAgICAgICAgIC5hcHBlbmQoJCgnPGRpdi8+JykudGV4dCgnU2VlIHlvdXIgYnJvd3NlciBKYXZhc2NyaXB0IGNvbnNvbGUgZm9yIG1vcmUgZGV0YWlscy4nKS5hZGRDbGFzcygnanMtZXJyb3InKSk7XG4gICAgfTtcblxuICAgIE91dHB1dEFyZWEucHJvdG90eXBlLl9zYWZlX2FwcGVuZCA9IGZ1bmN0aW9uICh0b2luc2VydCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogc2FmZWx5IGFwcGVuZCBhbiBpdGVtIHRvIHRoZSBkb2N1bWVudFxuICAgICAgICAgKiB0aGlzIGlzIGFuIG9iamVjdCBjcmVhdGVkIGJ5IHVzZXIgY29kZSxcbiAgICAgICAgICogYW5kIG1heSBoYXZlIGVycm9ycywgd2hpY2ggc2hvdWxkIG5vdCBiZSByYWlzZWRcbiAgICAgICAgICogdW5kZXIgYW55IGNpcmN1bXN0YW5jZXMuXG4gICAgICAgICAqL1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LmFwcGVuZCh0b2luc2VydCk7XG4gICAgICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGFuIGFjdHVhbCBvdXRwdXRfYXJlYSBhbmQgb3V0cHV0X3N1YmFyZWEsIHdoaWNoIGNyZWF0ZXNcbiAgICAgICAgICAgIC8vIHRoZSBwcm9tcHQgYXJlYSBhbmQgdGhlIHByb3BlciBpbmRlbnRhdGlvbi5cbiAgICAgICAgICAgIHZhciB0b2luc2VydCA9IHRoaXMuY3JlYXRlX291dHB1dF9hcmVhKCk7XG4gICAgICAgICAgICB2YXIgc3ViYXJlYSA9ICQoJzxkaXYvPicpLmFkZENsYXNzKCdvdXRwdXRfc3ViYXJlYScpO1xuICAgICAgICAgICAgdG9pbnNlcnQuYXBwZW5kKHN1YmFyZWEpO1xuICAgICAgICAgICAgdGhpcy5fYXBwZW5kX2phdmFzY3JpcHRfZXJyb3IoZXJyLCBzdWJhcmVhKTtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5hcHBlbmQodG9pbnNlcnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTm90aWZ5IG90aGVycyBvZiBjaGFuZ2VzLlxuICAgICAgICB0aGlzLmVsZW1lbnQudHJpZ2dlcignY2hhbmdlZCcpO1xuICAgIH07XG5cblxuICAgIE91dHB1dEFyZWEucHJvdG90eXBlLmFwcGVuZF9leGVjdXRlX3Jlc3VsdCA9IGZ1bmN0aW9uIChqc29uKSB7XG4gICAgICAgIHZhciBuID0ganNvbi5leGVjdXRpb25fY291bnQgfHwgJyAnO1xuICAgICAgICB2YXIgdG9pbnNlcnQgPSB0aGlzLmNyZWF0ZV9vdXRwdXRfYXJlYSgpO1xuICAgICAgICBpZiAodGhpcy5wcm9tcHRfYXJlYSkge1xuICAgICAgICAgICAgdG9pbnNlcnQuZmluZCgnZGl2LnByb21wdCcpLmFkZENsYXNzKCdvdXRwdXRfcHJvbXB0JykudGV4dCgnT3V0WycgKyBuICsgJ106Jyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluc2VydGVkID0gdGhpcy5hcHBlbmRfbWltZV90eXBlKGpzb24sIHRvaW5zZXJ0KTtcbiAgICAgICAgaWYgKGluc2VydGVkKSB7XG4gICAgICAgICAgICBpbnNlcnRlZC5hZGRDbGFzcygnb3V0cHV0X3Jlc3VsdCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NhZmVfYXBwZW5kKHRvaW5zZXJ0KTtcbiAgICAgICAgLy8gSWYgd2UganVzdCBvdXRwdXQgbGF0ZXgsIHR5cGVzZXQgaXQuXG4gICAgICAgIGlmICgoanNvbi5kYXRhWyd0ZXh0L2xhdGV4J10gIT09IHVuZGVmaW5lZCkgfHxcbiAgICAgICAgICAgIChqc29uLmRhdGFbJ3RleHQvaHRtbCddICE9PSB1bmRlZmluZWQpIHx8XG4gICAgICAgICAgICAoanNvbi5kYXRhWyd0ZXh0L21hcmtkb3duJ10gIT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZXNldCgpO1xuICAgICAgICB9XG4gICAgfTtcblxuXG4gICAgT3V0cHV0QXJlYS5wcm90b3R5cGUuYXBwZW5kX2Vycm9yID0gZnVuY3Rpb24gKGpzb24pIHtcbiAgICAgICAgdmFyIHRiID0ganNvbi50cmFjZWJhY2s7XG4gICAgICAgIGlmICh0YiAhPT0gdW5kZWZpbmVkICYmIHRiLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhciBzID0gJyc7XG4gICAgICAgICAgICB2YXIgbGVuID0gdGIubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcyA9IHMgKyB0YltpXSArICdcXG4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcyA9IHMgKyAnXFxuJztcbiAgICAgICAgICAgIHZhciB0b2luc2VydCA9IHRoaXMuY3JlYXRlX291dHB1dF9hcmVhKCk7XG4gICAgICAgICAgICB2YXIgYXBwZW5kX3RleHQgPSBPdXRwdXRBcmVhLmFwcGVuZF9tYXBbJ3RleHQvcGxhaW4nXTtcbiAgICAgICAgICAgIGlmIChhcHBlbmRfdGV4dCkge1xuICAgICAgICAgICAgICAgIGFwcGVuZF90ZXh0LmFwcGx5KHRoaXMsIFtzLCB7fSwgdG9pbnNlcnRdKS5hZGRDbGFzcygnb3V0cHV0X2Vycm9yJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9zYWZlX2FwcGVuZCh0b2luc2VydCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG5cbiAgICBPdXRwdXRBcmVhLnByb3RvdHlwZS5hcHBlbmRfc3RyZWFtID0gZnVuY3Rpb24gKGpzb24pIHtcbiAgICAgICAgdmFyIHRleHQgPSBqc29uLnRleHQ7XG4gICAgICAgIGlmICh0eXBlb2YgdGV4dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJTdHJlYW0gb3V0cHV0IGlzIGludmFsaWQgKG1pc3NpbmcgdGV4dClcIiwganNvbik7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN1YmNsYXNzID0gXCJvdXRwdXRfXCIranNvbi5uYW1lO1xuICAgICAgICBpZiAodGhpcy5vdXRwdXRzLmxlbmd0aCA+IDApe1xuICAgICAgICAgICAgLy8gaGF2ZSBhdCBsZWFzdCBvbmUgb3V0cHV0IHRvIGNvbnNpZGVyXG4gICAgICAgICAgICB2YXIgbGFzdCA9IHRoaXMub3V0cHV0c1t0aGlzLm91dHB1dHMubGVuZ3RoLTFdO1xuICAgICAgICAgICAgaWYgKGxhc3Qub3V0cHV0X3R5cGUgPT0gJ3N0cmVhbScgJiYganNvbi5uYW1lID09IGxhc3QubmFtZSl7XG4gICAgICAgICAgICAgICAgLy8gbGF0ZXN0IG91dHB1dCB3YXMgaW4gdGhlIHNhbWUgc3RyZWFtLFxuICAgICAgICAgICAgICAgIC8vIHNvIGFwcGVuZCBkaXJlY3RseSBpbnRvIGl0cyBwcmUgdGFnXG4gICAgICAgICAgICAgICAgLy8gZXNjYXBlIEFOU0kgJiBIVE1MIHNwZWNpYWxzOlxuICAgICAgICAgICAgICAgIGxhc3QudGV4dCA9IHV0aWxzLmZpeENhcnJpYWdlUmV0dXJuKGxhc3QudGV4dCArIGpzb24udGV4dCk7XG4gICAgICAgICAgICAgICAgdmFyIHByZSA9IHRoaXMuZWxlbWVudC5maW5kKCdkaXYuJytzdWJjbGFzcykubGFzdCgpLmZpbmQoJ3ByZScpO1xuICAgICAgICAgICAgICAgIHZhciBodG1sID0gdXRpbHMuZml4Q29uc29sZShsYXN0LnRleHQpO1xuICAgICAgICAgICAgICAgIGh0bWwgPSB1dGlscy5hdXRvTGlua1VybHMoaHRtbCk7XG4gICAgICAgICAgICAgICAgLy8gVGhlIG9ubHkgdXNlciBjb250ZW50IGluamVjdGVkIHdpdGggdGhpcyBIVE1MIGNhbGwgaXNcbiAgICAgICAgICAgICAgICAvLyBlc2NhcGVkIGJ5IHRoZSBmaXhDb25zb2xlKCkgbWV0aG9kLlxuICAgICAgICAgICAgICAgIHByZS5odG1sKGh0bWwpO1xuICAgICAgICAgICAgICAgIC8vIHJldHVybiBmYWxzZSBzaWduYWxzIHRoYXQgd2UgbWVyZ2VkIHRoaXMgb3V0cHV0IHdpdGggdGhlIHByZXZpb3VzIG9uZSxcbiAgICAgICAgICAgICAgICAvLyBhbmQgdGhlIG5ldyBvdXRwdXQgc2hvdWxkbid0IGJlIHJlY29yZGVkLlxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGV4dC5yZXBsYWNlKFwiXFxyXCIsIFwiXCIpKSB7XG4gICAgICAgICAgICAvLyB0ZXh0IGlzIG5vdGhpbmcgKGVtcHR5IHN0cmluZywgXFxyLCBldGMuKVxuICAgICAgICAgICAgLy8gc28gZG9uJ3QgYXBwZW5kIGFueSBlbGVtZW50cywgd2hpY2ggbWlnaHQgYWRkIHVuZGVzaXJhYmxlIHNwYWNlXG4gICAgICAgICAgICAvLyByZXR1cm4gdHJ1ZSB0byBpbmRpY2F0ZSB0aGUgb3V0cHV0IHNob3VsZCBiZSByZWNvcmRlZC5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgd2UgZ290IGhlcmUsIGF0dGFjaCBhIG5ldyBkaXZcbiAgICAgICAgdmFyIHRvaW5zZXJ0ID0gdGhpcy5jcmVhdGVfb3V0cHV0X2FyZWEoKTtcbiAgICAgICAgdmFyIGFwcGVuZF90ZXh0ID0gT3V0cHV0QXJlYS5hcHBlbmRfbWFwWyd0ZXh0L3BsYWluJ107XG4gICAgICAgIGlmIChhcHBlbmRfdGV4dCkge1xuICAgICAgICAgICAgYXBwZW5kX3RleHQuYXBwbHkodGhpcywgW3RleHQsIHt9LCB0b2luc2VydF0pLmFkZENsYXNzKFwib3V0cHV0X3N0cmVhbSBcIiArIHN1YmNsYXNzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zYWZlX2FwcGVuZCh0b2luc2VydCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cblxuICAgIE91dHB1dEFyZWEucHJvdG90eXBlLmFwcGVuZF91bnJlY29nbml6ZWQgPSBmdW5jdGlvbiAoanNvbikge1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIHZhciB0b2luc2VydCA9IHRoaXMuY3JlYXRlX291dHB1dF9hcmVhKCk7XG4gICAgICAgIHZhciBzdWJhcmVhID0gJCgnPGRpdi8+JykuYWRkQ2xhc3MoJ291dHB1dF9zdWJhcmVhIG91dHB1dF91bnJlY29nbml6ZWQnKTtcbiAgICAgICAgdG9pbnNlcnQuYXBwZW5kKHN1YmFyZWEpO1xuICAgICAgICBzdWJhcmVhLmFwcGVuZChcbiAgICAgICAgICAgICQoXCI8YT5cIilcbiAgICAgICAgICAgICAgICAuYXR0cihcImhyZWZcIiwgXCIjXCIpXG4gICAgICAgICAgICAgICAgLnRleHQoXCJVbnJlY29nbml6ZWQgb3V0cHV0OiBcIiArIGpzb24ub3V0cHV0X3R5cGUpXG4gICAgICAgICAgICAgICAgLmNsaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5ldmVudHMudHJpZ2dlcigndW5yZWNvZ25pemVkX291dHB1dC5PdXRwdXRBcmVhJywge291dHB1dDoganNvbn0pO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuX3NhZmVfYXBwZW5kKHRvaW5zZXJ0KTtcbiAgICB9O1xuXG5cbiAgICBPdXRwdXRBcmVhLnByb3RvdHlwZS5hcHBlbmRfZGlzcGxheV9kYXRhID0gZnVuY3Rpb24gKGpzb24sIGhhbmRsZV9pbnNlcnRlZCkge1xuICAgICAgICB2YXIgdG9pbnNlcnQgPSB0aGlzLmNyZWF0ZV9vdXRwdXRfYXJlYSgpO1xuICAgICAgICBpZiAodGhpcy5hcHBlbmRfbWltZV90eXBlKGpzb24sIHRvaW5zZXJ0LCBoYW5kbGVfaW5zZXJ0ZWQpKSB7XG4gICAgICAgICAgICB0aGlzLl9zYWZlX2FwcGVuZCh0b2luc2VydCk7XG4gICAgICAgICAgICAvLyBJZiB3ZSBqdXN0IG91dHB1dCBsYXRleCwgdHlwZXNldCBpdC5cbiAgICAgICAgICAgIGlmICgoanNvbi5kYXRhWyd0ZXh0L2xhdGV4J10gIT09IHVuZGVmaW5lZCkgfHxcbiAgICAgICAgICAgICAgICAoanNvbi5kYXRhWyd0ZXh0L2h0bWwnXSAhPT0gdW5kZWZpbmVkKSB8fFxuICAgICAgICAgICAgICAgIChqc29uLmRhdGFbJ3RleHQvbWFya2Rvd24nXSAhPT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgICAgIHRoaXMudHlwZXNldCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuXG4gICAgT3V0cHV0QXJlYS5zYWZlX291dHB1dHMgPSB7XG4gICAgICAgICd0ZXh0L3BsYWluJyA6IHRydWUsXG4gICAgICAgICd0ZXh0L2xhdGV4JyA6IHRydWUsXG4gICAgICAgICdpbWFnZS9wbmcnIDogdHJ1ZSxcbiAgICAgICAgJ2ltYWdlL2pwZWcnIDogdHJ1ZVxuICAgIH07XG5cbiAgICBPdXRwdXRBcmVhLnByb3RvdHlwZS5hcHBlbmRfbWltZV90eXBlID0gZnVuY3Rpb24gKGpzb24sIGVsZW1lbnQsIGhhbmRsZV9pbnNlcnRlZCkge1xuICAgICAgICBmb3IgKHZhciBpPTA7IGkgPCBPdXRwdXRBcmVhLmRpc3BsYXlfb3JkZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB0eXBlID0gT3V0cHV0QXJlYS5kaXNwbGF5X29yZGVyW2ldO1xuICAgICAgICAgICAgdmFyIGFwcGVuZCA9IE91dHB1dEFyZWEuYXBwZW5kX21hcFt0eXBlXTtcbiAgICAgICAgICAgIGlmICgoanNvbi5kYXRhW3R5cGVdICE9PSB1bmRlZmluZWQpICYmIGFwcGVuZCkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGpzb24uZGF0YVt0eXBlXTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMudHJ1c3RlZCAmJiAhT3V0cHV0QXJlYS5zYWZlX291dHB1dHNbdHlwZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbm90IHRydXN0ZWQsIHNhbml0aXplIEhUTUxcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGU9PT0ndGV4dC9odG1sJyB8fCB0eXBlPT09J3RleHQvc3ZnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBzZWN1cml0eS5zYW5pdGl6ZV9odG1sKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRvbid0IGRpc3BsYXkgaWYgd2UgZG9uJ3Qga25vdyBob3cgdG8gc2FuaXRpemUgaXRcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiSWdub3JpbmcgdW50cnVzdGVkIFwiICsgdHlwZSArIFwiIG91dHB1dC5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgbWQgPSBqc29uLm1ldGFkYXRhIHx8IHt9O1xuICAgICAgICAgICAgICAgIHZhciB0b2luc2VydCA9IGFwcGVuZC5hcHBseSh0aGlzLCBbdmFsdWUsIG1kLCBlbGVtZW50LCBoYW5kbGVfaW5zZXJ0ZWRdKTtcbiAgICAgICAgICAgICAgICAvLyBTaW5jZSBvbmx5IHRoZSBwbmcgYW5kIGpwZWcgbWltZSB0eXBlcyBjYWxsIHRoZSBpbnNlcnRlZFxuICAgICAgICAgICAgICAgIC8vIGNhbGxiYWNrLCBpZiB0aGUgbWltZSB0eXBlIGlzIHNvbWV0aGluZyBvdGhlciB3ZSBtdXN0IGNhbGwgdGhlIFxuICAgICAgICAgICAgICAgIC8vIGluc2VydGVkIGNhbGxiYWNrIG9ubHkgd2hlbiB0aGUgZWxlbWVudCBpcyBhY3R1YWxseSBpbnNlcnRlZFxuICAgICAgICAgICAgICAgIC8vIGludG8gdGhlIERPTS4gIFVzZSBhIHRpbWVvdXQgb2YgMCB0byBkbyB0aGlzLlxuICAgICAgICAgICAgICAgIGlmIChbJ2ltYWdlL3BuZycsICdpbWFnZS9qcGVnJ10uaW5kZXhPZih0eXBlKSA8IDAgJiYgaGFuZGxlX2luc2VydGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChoYW5kbGVfaW5zZXJ0ZWQsIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cy50cmlnZ2VyKCdvdXRwdXRfYXBwZW5kZWQuT3V0cHV0QXJlYScsIFt0eXBlLCB2YWx1ZSwgbWQsIHRvaW5zZXJ0XSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvaW5zZXJ0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cblxuICAgIHZhciBhcHBlbmRfaHRtbCA9IGZ1bmN0aW9uIChodG1sLCBtZCwgZWxlbWVudCkge1xuICAgICAgICB2YXIgdHlwZSA9ICd0ZXh0L2h0bWwnO1xuICAgICAgICB2YXIgdG9pbnNlcnQgPSB0aGlzLmNyZWF0ZV9vdXRwdXRfc3ViYXJlYShtZCwgXCJvdXRwdXRfaHRtbCByZW5kZXJlZF9odG1sXCIsIHR5cGUpO1xuICAgICAgICB0aGlzLmtleWJvYXJkX21hbmFnZXIucmVnaXN0ZXJfZXZlbnRzKHRvaW5zZXJ0KTtcbiAgICAgICAgdG9pbnNlcnQuYXBwZW5kKGh0bWwpO1xuICAgICAgICBkYmxjbGlja190b19yZXNldF9zaXplKHRvaW5zZXJ0LmZpbmQoJ2ltZycpKTtcbiAgICAgICAgZWxlbWVudC5hcHBlbmQodG9pbnNlcnQpO1xuICAgICAgICByZXR1cm4gdG9pbnNlcnQ7XG4gICAgfTtcblxuXG4gICAgdmFyIGFwcGVuZF9tYXJrZG93biA9IGZ1bmN0aW9uKG1hcmtkb3duLCBtZCwgZWxlbWVudCkge1xuICAgICAgICB2YXIgdHlwZSA9ICd0ZXh0L21hcmtkb3duJztcbiAgICAgICAgdmFyIHRvaW5zZXJ0ID0gdGhpcy5jcmVhdGVfb3V0cHV0X3N1YmFyZWEobWQsIFwib3V0cHV0X21hcmtkb3duIHJlbmRlcmVkX2h0bWxcIiwgdHlwZSk7XG4gICAgICAgIHZhciB0ZXh0X2FuZF9tYXRoID0gbWF0aGpheHV0aWxzLnJlbW92ZV9tYXRoKG1hcmtkb3duKTtcbiAgICAgICAgdmFyIHRleHQgPSB0ZXh0X2FuZF9tYXRoWzBdO1xuICAgICAgICB2YXIgbWF0aCA9IHRleHRfYW5kX21hdGhbMV07XG4gICAgICAgIG1hcmtlZCh0ZXh0LCBmdW5jdGlvbiAoZXJyLCBodG1sKSB7XG4gICAgICAgICAgICBodG1sID0gbWF0aGpheHV0aWxzLnJlcGxhY2VfbWF0aChodG1sLCBtYXRoKTtcbiAgICAgICAgICAgIHRvaW5zZXJ0LmFwcGVuZChodG1sKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRibGNsaWNrX3RvX3Jlc2V0X3NpemUodG9pbnNlcnQuZmluZCgnaW1nJykpO1xuICAgICAgICBlbGVtZW50LmFwcGVuZCh0b2luc2VydCk7XG4gICAgICAgIHJldHVybiB0b2luc2VydDtcbiAgICB9O1xuXG5cbiAgICB2YXIgYXBwZW5kX2phdmFzY3JpcHQgPSBmdW5jdGlvbiAoanMsIG1kLCBlbGVtZW50KSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXZSBqdXN0IGV2YWwgdGhlIEpTIGNvZGUsIGVsZW1lbnQgYXBwZWFycyBpbiB0aGUgbG9jYWwgc2NvcGUuXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgdHlwZSA9ICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0JztcbiAgICAgICAgdmFyIHRvaW5zZXJ0ID0gdGhpcy5jcmVhdGVfb3V0cHV0X3N1YmFyZWEobWQsIFwib3V0cHV0X2phdmFzY3JpcHQgcmVuZGVyZWRfaHRtbFwiLCB0eXBlKTtcbiAgICAgICAgdGhpcy5rZXlib2FyZF9tYW5hZ2VyLnJlZ2lzdGVyX2V2ZW50cyh0b2luc2VydCk7XG4gICAgICAgIGVsZW1lbnQuYXBwZW5kKHRvaW5zZXJ0KTtcblxuICAgICAgICAvLyBGaXggZm9yIGlweXRob24vaXNzdWVzLzUyOTMsIG1ha2Ugc3VyZSBgZWxlbWVudGAgaXMgdGhlIGFyZWEgd2hpY2hcbiAgICAgICAgLy8gb3V0cHV0IGNhbiBiZSBpbnNlcnRlZCBpbnRvIGF0IHRoZSB0aW1lIG9mIEpTIGV4ZWN1dGlvbi5cbiAgICAgICAgZWxlbWVudCA9IHRvaW5zZXJ0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZXZhbChqcyk7XG4gICAgICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICAgICAgICAgICAgdGhpcy5fYXBwZW5kX2phdmFzY3JpcHRfZXJyb3IoZXJyLCB0b2luc2VydCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvaW5zZXJ0O1xuICAgIH07XG5cblxuICAgIHZhciBhcHBlbmRfdGV4dCA9IGZ1bmN0aW9uIChkYXRhLCBtZCwgZWxlbWVudCkge1xuICAgICAgICB2YXIgdHlwZSA9ICd0ZXh0L3BsYWluJztcbiAgICAgICAgdmFyIHRvaW5zZXJ0ID0gdGhpcy5jcmVhdGVfb3V0cHV0X3N1YmFyZWEobWQsIFwib3V0cHV0X3RleHRcIiwgdHlwZSk7XG4gICAgICAgIC8vIGVzY2FwZSBBTlNJICYgSFRNTCBzcGVjaWFscyBpbiBwbGFpbnRleHQ6XG4gICAgICAgIGRhdGEgPSB1dGlscy5maXhDb25zb2xlKGRhdGEpO1xuICAgICAgICBkYXRhID0gdXRpbHMuZml4Q2FycmlhZ2VSZXR1cm4oZGF0YSk7XG4gICAgICAgIGRhdGEgPSB1dGlscy5hdXRvTGlua1VybHMoZGF0YSk7XG4gICAgICAgIC8vIFRoZSBvbmx5IHVzZXIgY29udGVudCBpbmplY3RlZCB3aXRoIHRoaXMgSFRNTCBjYWxsIGlzXG4gICAgICAgIC8vIGVzY2FwZWQgYnkgdGhlIGZpeENvbnNvbGUoKSBtZXRob2QuXG4gICAgICAgIHRvaW5zZXJ0LmFwcGVuZCgkKFwiPHByZS8+XCIpLmh0bWwoZGF0YSkpO1xuICAgICAgICBlbGVtZW50LmFwcGVuZCh0b2luc2VydCk7XG4gICAgICAgIHJldHVybiB0b2luc2VydDtcbiAgICB9O1xuXG5cbiAgICB2YXIgYXBwZW5kX3N2ZyA9IGZ1bmN0aW9uIChzdmdfaHRtbCwgbWQsIGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIHR5cGUgPSAnaW1hZ2Uvc3ZnK3htbCc7XG4gICAgICAgIHZhciB0b2luc2VydCA9IHRoaXMuY3JlYXRlX291dHB1dF9zdWJhcmVhKG1kLCBcIm91dHB1dF9zdmdcIiwgdHlwZSk7XG5cbiAgICAgICAgLy8gR2V0IHRoZSBzdmcgZWxlbWVudCBmcm9tIHdpdGhpbiB0aGUgSFRNTC5cbiAgICAgICAgdmFyIHN2ZyA9ICQoJzxkaXYgLz4nKS5odG1sKHN2Z19odG1sKS5maW5kKCdzdmcnKTtcbiAgICAgICAgdmFyIHN2Z19hcmVhID0gJCgnPGRpdiAvPicpO1xuICAgICAgICB2YXIgd2lkdGggPSBzdmcuYXR0cignd2lkdGgnKTtcbiAgICAgICAgdmFyIGhlaWdodCA9IHN2Zy5hdHRyKCdoZWlnaHQnKTtcbiAgICAgICAgc3ZnXG4gICAgICAgICAgICAud2lkdGgoJzEwMCUnKVxuICAgICAgICAgICAgLmhlaWdodCgnMTAwJScpO1xuICAgICAgICBzdmdfYXJlYVxuICAgICAgICAgICAgLndpZHRoKHdpZHRoKVxuICAgICAgICAgICAgLmhlaWdodChoZWlnaHQpO1xuXG4gICAgICAgIHN2Z19hcmVhLmFwcGVuZChzdmcpO1xuICAgICAgICB0b2luc2VydC5hcHBlbmQoc3ZnX2FyZWEpO1xuICAgICAgICBlbGVtZW50LmFwcGVuZCh0b2luc2VydCk7XG5cbiAgICAgICAgcmV0dXJuIHRvaW5zZXJ0O1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBkYmxjbGlja190b19yZXNldF9zaXplIChpbWcpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERvdWJsZS1jbGljayBvbiBhbiBpbWFnZSB0b2dnbGVzIGNvbmZpbmVtZW50IHRvIG5vdGVib29rIHdpZHRoXG4gICAgICAgICAqXG4gICAgICAgICAqIGltZzogalF1ZXJ5IGVsZW1lbnRcbiAgICAgICAgICovXG5cbiAgICAgICAgaW1nLmRibGNsaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIGRibGNsaWNrIHRvZ2dsZXMgKnJhdyogc2l6ZSwgZGlzYWJsaW5nIG1heC13aWR0aCBjb25maW5lbWVudC5cbiAgICAgICAgICAgIGlmIChpbWcuaGFzQ2xhc3MoJ3VuY29uZmluZWQnKSkge1xuICAgICAgICAgICAgICAgIGltZy5yZW1vdmVDbGFzcygndW5jb25maW5lZCcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbWcuYWRkQ2xhc3MoJ3VuY29uZmluZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHZhciBzZXRfd2lkdGhfaGVpZ2h0ID0gZnVuY3Rpb24gKGltZywgbWQsIG1pbWUpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHNldCB3aWR0aCBhbmQgaGVpZ2h0IG9mIGFuIGltZyBlbGVtZW50IGZyb20gbWV0YWRhdGFcbiAgICAgICAgICovXG4gICAgICAgIHZhciBoZWlnaHQgPSBfZ2V0X21ldGFkYXRhX2tleShtZCwgJ2hlaWdodCcsIG1pbWUpO1xuICAgICAgICBpZiAoaGVpZ2h0ICE9PSB1bmRlZmluZWQpIGltZy5hdHRyKCdoZWlnaHQnLCBoZWlnaHQpO1xuICAgICAgICB2YXIgd2lkdGggPSBfZ2V0X21ldGFkYXRhX2tleShtZCwgJ3dpZHRoJywgbWltZSk7XG4gICAgICAgIGlmICh3aWR0aCAhPT0gdW5kZWZpbmVkKSBpbWcuYXR0cignd2lkdGgnLCB3aWR0aCk7XG4gICAgICAgIGlmIChfZ2V0X21ldGFkYXRhX2tleShtZCwgJ3VuY29uZmluZWQnLCBtaW1lKSkge1xuICAgICAgICAgICAgaW1nLmFkZENsYXNzKCd1bmNvbmZpbmVkJyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGFwcGVuZF9wbmcgPSBmdW5jdGlvbiAocG5nLCBtZCwgZWxlbWVudCwgaGFuZGxlX2luc2VydGVkKSB7XG4gICAgICAgIHZhciB0eXBlID0gJ2ltYWdlL3BuZyc7XG4gICAgICAgIHZhciB0b2luc2VydCA9IHRoaXMuY3JlYXRlX291dHB1dF9zdWJhcmVhKG1kLCBcIm91dHB1dF9wbmdcIiwgdHlwZSk7XG4gICAgICAgIHZhciBpbWcgPSAkKFwiPGltZy8+XCIpO1xuICAgICAgICBpZiAoaGFuZGxlX2luc2VydGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGltZy5vbignbG9hZCcsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgaGFuZGxlX2luc2VydGVkKGltZyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpbWdbMF0uc3JjID0gJ2RhdGE6aW1hZ2UvcG5nO2Jhc2U2NCwnKyBwbmc7XG4gICAgICAgIHNldF93aWR0aF9oZWlnaHQoaW1nLCBtZCwgJ2ltYWdlL3BuZycpO1xuICAgICAgICBkYmxjbGlja190b19yZXNldF9zaXplKGltZyk7XG4gICAgICAgIHRvaW5zZXJ0LmFwcGVuZChpbWcpO1xuICAgICAgICBlbGVtZW50LmFwcGVuZCh0b2luc2VydCk7XG4gICAgICAgIHJldHVybiB0b2luc2VydDtcbiAgICB9O1xuXG5cbiAgICB2YXIgYXBwZW5kX2pwZWcgPSBmdW5jdGlvbiAoanBlZywgbWQsIGVsZW1lbnQsIGhhbmRsZV9pbnNlcnRlZCkge1xuICAgICAgICB2YXIgdHlwZSA9ICdpbWFnZS9qcGVnJztcbiAgICAgICAgdmFyIHRvaW5zZXJ0ID0gdGhpcy5jcmVhdGVfb3V0cHV0X3N1YmFyZWEobWQsIFwib3V0cHV0X2pwZWdcIiwgdHlwZSk7XG4gICAgICAgIHZhciBpbWcgPSAkKFwiPGltZy8+XCIpO1xuICAgICAgICBpZiAoaGFuZGxlX2luc2VydGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGltZy5vbignbG9hZCcsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgaGFuZGxlX2luc2VydGVkKGltZyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpbWdbMF0uc3JjID0gJ2RhdGE6aW1hZ2UvanBlZztiYXNlNjQsJysganBlZztcbiAgICAgICAgc2V0X3dpZHRoX2hlaWdodChpbWcsIG1kLCAnaW1hZ2UvanBlZycpO1xuICAgICAgICBkYmxjbGlja190b19yZXNldF9zaXplKGltZyk7XG4gICAgICAgIHRvaW5zZXJ0LmFwcGVuZChpbWcpO1xuICAgICAgICBlbGVtZW50LmFwcGVuZCh0b2luc2VydCk7XG4gICAgICAgIHJldHVybiB0b2luc2VydDtcbiAgICB9O1xuXG5cbiAgICB2YXIgYXBwZW5kX3BkZiA9IGZ1bmN0aW9uIChwZGYsIG1kLCBlbGVtZW50KSB7XG4gICAgICAgIHZhciB0eXBlID0gJ2FwcGxpY2F0aW9uL3BkZic7XG4gICAgICAgIHZhciB0b2luc2VydCA9IHRoaXMuY3JlYXRlX291dHB1dF9zdWJhcmVhKG1kLCBcIm91dHB1dF9wZGZcIiwgdHlwZSk7XG4gICAgICAgIHZhciBhID0gJCgnPGEvPicpLmF0dHIoJ2hyZWYnLCAnZGF0YTphcHBsaWNhdGlvbi9wZGY7YmFzZTY0LCcrcGRmKTtcbiAgICAgICAgYS5hdHRyKCd0YXJnZXQnLCAnX2JsYW5rJyk7XG4gICAgICAgIGEudGV4dCgnVmlldyBQREYnKTtcbiAgICAgICAgdG9pbnNlcnQuYXBwZW5kKGEpO1xuICAgICAgICBlbGVtZW50LmFwcGVuZCh0b2luc2VydCk7XG4gICAgICAgIHJldHVybiB0b2luc2VydDtcbiAgICAgfTtcblxuICAgIHZhciBhcHBlbmRfbGF0ZXggPSBmdW5jdGlvbiAobGF0ZXgsIG1kLCBlbGVtZW50KSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCBjYW5ub3QgZG8gdGhlIHR5cGVzZXR0aW5nIGJlY2F1c2UgdGhlIGxhdGV4IGZpcnN0IGhhcyB0b1xuICAgICAgICAgKiBiZSBvbiB0aGUgcGFnZS5cbiAgICAgICAgICovXG4gICAgICAgIHZhciB0eXBlID0gJ3RleHQvbGF0ZXgnO1xuICAgICAgICB2YXIgdG9pbnNlcnQgPSB0aGlzLmNyZWF0ZV9vdXRwdXRfc3ViYXJlYShtZCwgXCJvdXRwdXRfbGF0ZXhcIiwgdHlwZSk7XG4gICAgICAgIHRvaW5zZXJ0LmFwcGVuZChsYXRleCk7XG4gICAgICAgIGVsZW1lbnQuYXBwZW5kKHRvaW5zZXJ0KTtcbiAgICAgICAgcmV0dXJuIHRvaW5zZXJ0O1xuICAgIH07XG5cblxuICAgIE91dHB1dEFyZWEucHJvdG90eXBlLmFwcGVuZF9yYXdfaW5wdXQgPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgdGhpcy5leHBhbmQoKTtcbiAgICAgICAgdmFyIGNvbnRlbnQgPSBtc2cuY29udGVudDtcbiAgICAgICAgdmFyIGFyZWEgPSB0aGlzLmNyZWF0ZV9vdXRwdXRfYXJlYSgpO1xuICAgICAgICBcbiAgICAgICAgLy8gZGlzYWJsZSBhbnkgb3RoZXIgcmF3X2lucHV0cywgaWYgdGhleSBhcmUgbGVmdCBhcm91bmRcbiAgICAgICAgJChcImRpdi5vdXRwdXRfc3ViYXJlYS5yYXdfaW5wdXRfY29udGFpbmVyXCIpLnJlbW92ZSgpO1xuICAgICAgICBcbiAgICAgICAgdmFyIGlucHV0X3R5cGUgPSBjb250ZW50LnBhc3N3b3JkID8gJ3Bhc3N3b3JkJyA6ICd0ZXh0JztcbiAgICAgICAgXG4gICAgICAgIGFyZWEuYXBwZW5kKFxuICAgICAgICAgICAgJChcIjxkaXYvPlwiKVxuICAgICAgICAgICAgLmFkZENsYXNzKFwiYm94LWZsZXgxIG91dHB1dF9zdWJhcmVhIHJhd19pbnB1dF9jb250YWluZXJcIilcbiAgICAgICAgICAgIC5hcHBlbmQoXG4gICAgICAgICAgICAgICAgJChcIjxwcmUvPlwiKVxuICAgICAgICAgICAgICAgIC5hZGRDbGFzcyhcInJhd19pbnB1dF9wcm9tcHRcIilcbiAgICAgICAgICAgICAgICAudGV4dChjb250ZW50LnByb21wdClcbiAgICAgICAgICAgICAgICAuYXBwZW5kKFxuICAgICAgICAgICAgICAgICAgICAkKFwiPGlucHV0Lz5cIilcbiAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKFwicmF3X2lucHV0XCIpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0eXBlJywgaW5wdXRfdHlwZSlcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJzaXplXCIsIDQ3KVxuICAgICAgICAgICAgICAgICAgICAua2V5ZG93bihmdW5jdGlvbiAoZXZlbnQsIHVpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtYWtlIHN1cmUgd2Ugc3VibWl0IG9uIGVudGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIGRvbid0IHJlLWV4ZWN1dGUgdGhlICpjZWxsKiBvbiBzaGlmdC1lbnRlclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50LndoaWNoID09PSBrZXlib2FyZC5rZXljb2Rlcy5lbnRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuX3N1Ym1pdF9yYXdfaW5wdXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5lbGVtZW50LmFwcGVuZChhcmVhKTtcbiAgICAgICAgdmFyIHJhd19pbnB1dCA9IGFyZWEuZmluZCgnaW5wdXQucmF3X2lucHV0Jyk7XG4gICAgICAgIC8vIFJlZ2lzdGVyIGV2ZW50cyB0aGF0IGVuYWJsZS9kaXNhYmxlIHRoZSBrZXlib2FyZCBtYW5hZ2VyIHdoaWxlIHJhd1xuICAgICAgICAvLyBpbnB1dCBpcyBmb2N1c2VkLlxuICAgICAgICB0aGlzLmtleWJvYXJkX21hbmFnZXIucmVnaXN0ZXJfZXZlbnRzKHJhd19pbnB1dCk7XG4gICAgICAgIC8vIE5vdGUsIHRoZSBmb2xsb3dpbmcgbGluZSB1c2VkIHRvIHJlYWQgcmF3X2lucHV0LmZvY3VzKCkuZm9jdXMoKS5cbiAgICAgICAgLy8gVGhpcyBzZWVtZWQgdG8gYmUgbmVlZGVkIG90aGVyd2lzZSBvbmx5IHRoZSBjZWxsIHdvdWxkIGJlIGZvY3VzZWQuXG4gICAgICAgIC8vIEJ1dCB3aXRoIHRoZSBtb2RhbCBVSSwgdGhpcyBzZWVtcyB0byB3b3JrIGZpbmUgd2l0aCBvbmUgY2FsbCB0byBmb2N1cygpLlxuICAgICAgICByYXdfaW5wdXQuZm9jdXMoKTtcbiAgICB9O1xuXG4gICAgT3V0cHV0QXJlYS5wcm90b3R5cGUuX3N1Ym1pdF9yYXdfaW5wdXQgPSBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgIHZhciBjb250YWluZXIgPSB0aGlzLmVsZW1lbnQuZmluZChcImRpdi5yYXdfaW5wdXRfY29udGFpbmVyXCIpO1xuICAgICAgICB2YXIgdGhlcHJvbXB0ID0gY29udGFpbmVyLmZpbmQoXCJwcmUucmF3X2lucHV0X3Byb21wdFwiKTtcbiAgICAgICAgdmFyIHRoZWlucHV0ID0gY29udGFpbmVyLmZpbmQoXCJpbnB1dC5yYXdfaW5wdXRcIik7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoZWlucHV0LnZhbCgpO1xuICAgICAgICB2YXIgZWNobyAgPSB2YWx1ZTtcbiAgICAgICAgLy8gZG9uJ3QgZWNobyBpZiBpdCdzIGEgcGFzc3dvcmRcbiAgICAgICAgaWYgKHRoZWlucHV0LmF0dHIoJ3R5cGUnKSA9PSAncGFzc3dvcmQnKSB7XG4gICAgICAgICAgICBlY2hvID0gJ8K3wrfCt8K3wrfCt8K3wrcnO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb250ZW50ID0ge1xuICAgICAgICAgICAgb3V0cHV0X3R5cGUgOiAnc3RyZWFtJyxcbiAgICAgICAgICAgIG5hbWUgOiAnc3Rkb3V0JyxcbiAgICAgICAgICAgIHRleHQgOiB0aGVwcm9tcHQudGV4dCgpICsgZWNobyArICdcXG4nXG4gICAgICAgIH07XG4gICAgICAgIC8vIHJlbW92ZSBmb3JtIGNvbnRhaW5lclxuICAgICAgICBjb250YWluZXIucGFyZW50KCkucmVtb3ZlKCk7XG4gICAgICAgIC8vIHJlcGxhY2Ugd2l0aCBwbGFpbnRleHQgdmVyc2lvbiBpbiBzdGRvdXRcbiAgICAgICAgdGhpcy5hcHBlbmRfb3V0cHV0KGNvbnRlbnQsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5ldmVudHMudHJpZ2dlcignc2VuZF9pbnB1dF9yZXBseS5LZXJuZWwnLCB2YWx1ZSk7XG4gICAgfTtcblxuXG4gICAgT3V0cHV0QXJlYS5wcm90b3R5cGUuaGFuZGxlX2NsZWFyX291dHB1dCA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIG1zZyBzcGVjIHY0IGhhZCBzdGRvdXQsIHN0ZGVyciwgZGlzcGxheSBrZXlzXG4gICAgICAgICAqIHY0LjEgcmVwbGFjZWQgdGhlc2Ugd2l0aCBqdXN0IHdhaXRcbiAgICAgICAgICogVGhlIGRlZmF1bHQgYmVoYXZpb3IgaXMgdGhlIHNhbWUgKHN0ZG91dD1zdGRlcnI9ZGlzcGxheT1UcnVlLCB3YWl0PUZhbHNlKSxcbiAgICAgICAgICogc28gdjQgbWVzc2FnZXMgd2lsbCBzdGlsbCBiZSBwcm9wZXJseSBoYW5kbGVkLFxuICAgICAgICAgKiBleGNlcHQgZm9yIHRoZSByYXJlbHkgdXNlZCBjbGVhcmluZyBsZXNzIHRoYW4gYWxsIG91dHB1dC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2xlYXJfb3V0cHV0KG1zZy5jb250ZW50LndhaXQgfHwgZmFsc2UpO1xuICAgIH07XG5cblxuICAgIE91dHB1dEFyZWEucHJvdG90eXBlLmNsZWFyX291dHB1dCA9IGZ1bmN0aW9uKHdhaXQsIGlnbm9yZV9xdWUpIHtcbiAgICAgICAgaWYgKHdhaXQpIHtcblxuICAgICAgICAgICAgLy8gSWYgYSBjbGVhciBpcyBxdWV1ZWQsIGNsZWFyIGJlZm9yZSBhZGRpbmcgYW5vdGhlciB0byB0aGUgcXVldWUuXG4gICAgICAgICAgICBpZiAodGhpcy5jbGVhcl9xdWV1ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFyX291dHB1dChmYWxzZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuY2xlYXJfcXVldWVkID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgLy8gRml4IHRoZSBvdXRwdXQgZGl2J3MgaGVpZ2h0IGlmIHRoZSBjbGVhcl9vdXRwdXQgaXMgd2FpdGluZyBmb3JcbiAgICAgICAgICAgIC8vIG5ldyBvdXRwdXQgKGl0IGlzIGJlaW5nIHVzZWQgaW4gYW4gYW5pbWF0aW9uKS5cbiAgICAgICAgICAgIGlmICghaWdub3JlX3F1ZSAmJiB0aGlzLmNsZWFyX3F1ZXVlZCkge1xuICAgICAgICAgICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLmVsZW1lbnQuaGVpZ2h0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50LmhlaWdodChoZWlnaHQpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJfcXVldWVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIENsZWFyIGFsbFxuICAgICAgICAgICAgLy8gUmVtb3ZlIGxvYWQgZXZlbnQgaGFuZGxlcnMgZnJvbSBpbWcgdGFncyBiZWNhdXNlIHdlIGRvbid0IHdhbnRcbiAgICAgICAgICAgIC8vIHRoZW0gdG8gZmlyZSBpZiB0aGUgaW1hZ2UgaXMgbmV2ZXIgYWRkZWQgdG8gdGhlIHBhZ2UuXG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuZmluZCgnaW1nJykub2ZmKCdsb2FkJyk7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuaHRtbChcIlwiKTtcblxuICAgICAgICAgICAgLy8gTm90aWZ5IG90aGVycyBvZiBjaGFuZ2VzLlxuICAgICAgICAgICAgdGhpcy5lbGVtZW50LnRyaWdnZXIoJ2NoYW5nZWQnKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5vdXRwdXRzID0gW107XG4gICAgICAgICAgICB0aGlzLnRydXN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy51bnNjcm9sbF9hcmVhKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9O1xuXG5cbiAgICAvLyBKU09OIHNlcmlhbGl6YXRpb25cblxuICAgIE91dHB1dEFyZWEucHJvdG90eXBlLmZyb21KU09OID0gZnVuY3Rpb24gKG91dHB1dHMsIG1ldGFkYXRhKSB7XG4gICAgICAgIHZhciBsZW4gPSBvdXRwdXRzLmxlbmd0aDtcbiAgICAgICAgbWV0YWRhdGEgPSBtZXRhZGF0YSB8fCB7fTtcblxuICAgICAgICBmb3IgKHZhciBpPTA7IGk8bGVuOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kX291dHB1dChvdXRwdXRzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWV0YWRhdGEuY29sbGFwc2VkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChtZXRhZGF0YS5jb2xsYXBzZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbGxhcHNlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZXhwYW5kKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGFkYXRhLnNjcm9sbGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsX3N0YXRlID0gbWV0YWRhdGEuc2Nyb2xsZWQ7XG4gICAgICAgICAgICBpZiAobWV0YWRhdGEuc2Nyb2xsZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbF9pZl9sb25nKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudW5zY3JvbGxfYXJlYSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuXG4gICAgT3V0cHV0QXJlYS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vdXRwdXRzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDbGFzcyBwcm9wZXJ0aWVzXG4gICAgICoqL1xuXG4gICAgLyoqXG4gICAgICogVGhyZXNob2xkIHRvIHRyaWdnZXIgYXV0b3Njcm9sbCB3aGVuIHRoZSBPdXRwdXRBcmVhIGlzIHJlc2l6ZWQsXG4gICAgICogdHlwaWNhbGx5IHdoZW4gbmV3IG91dHB1dHMgYXJlIGFkZGVkLlxuICAgICAqXG4gICAgICogQmVoYXZpb3IgaXMgdW5kZWZpbmVkIGlmIGF1dG9zY3JvbGwgaXMgbG93ZXIgdGhhbiBtaW5pbXVtX3Njcm9sbF90aHJlc2hvbGQsXG4gICAgICogdW5sZXNzIGl0IGlzIDwgMCwgaW4gd2hpY2ggY2FzZSBhdXRvc2Nyb2xsIHdpbGwgbmV2ZXIgYmUgdHJpZ2dlcmVkXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgYXV0b19zY3JvbGxfdGhyZXNob2xkXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHQgMTAwXG4gICAgICpcbiAgICAgKiovXG4gICAgT3V0cHV0QXJlYS5hdXRvX3Njcm9sbF90aHJlc2hvbGQgPSAxMDA7XG5cbiAgICAvKipcbiAgICAgKiBMb3dlciBsaW1pdCAoaW4gbGluZXMpIGZvciBPdXRwdXRBcmVhIHRvIGJlIG1hZGUgc2Nyb2xsYWJsZS4gT3V0cHV0QXJlYXNcbiAgICAgKiBzaG9ydGVyIHRoYW4gdGhpcyBhcmUgbmV2ZXIgc2Nyb2xsZWQuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkgbWluaW11bV9zY3JvbGxfdGhyZXNob2xkXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICogQGRlZmF1bHQgMjBcbiAgICAgKlxuICAgICAqKi9cbiAgICBPdXRwdXRBcmVhLm1pbmltdW1fc2Nyb2xsX3RocmVzaG9sZCA9IDIwO1xuXG5cbiAgICBPdXRwdXRBcmVhLmRpc3BsYXlfb3JkZXIgPSBbXG4gICAgICAgICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0JyxcbiAgICAgICAgJ3RleHQvaHRtbCcsXG4gICAgICAgICd0ZXh0L21hcmtkb3duJyxcbiAgICAgICAgJ3RleHQvbGF0ZXgnLFxuICAgICAgICAnaW1hZ2Uvc3ZnK3htbCcsXG4gICAgICAgICdpbWFnZS9wbmcnLFxuICAgICAgICAnaW1hZ2UvanBlZycsXG4gICAgICAgICdhcHBsaWNhdGlvbi9wZGYnLFxuICAgICAgICAndGV4dC9wbGFpbidcbiAgICBdO1xuXG4gICAgT3V0cHV0QXJlYS5hcHBlbmRfbWFwID0ge1xuICAgICAgICBcInRleHQvcGxhaW5cIiA6IGFwcGVuZF90ZXh0LFxuICAgICAgICBcInRleHQvaHRtbFwiIDogYXBwZW5kX2h0bWwsXG4gICAgICAgIFwidGV4dC9tYXJrZG93blwiOiBhcHBlbmRfbWFya2Rvd24sXG4gICAgICAgIFwiaW1hZ2Uvc3ZnK3htbFwiIDogYXBwZW5kX3N2ZyxcbiAgICAgICAgXCJpbWFnZS9wbmdcIiA6IGFwcGVuZF9wbmcsXG4gICAgICAgIFwiaW1hZ2UvanBlZ1wiIDogYXBwZW5kX2pwZWcsXG4gICAgICAgIFwidGV4dC9sYXRleFwiIDogYXBwZW5kX2xhdGV4LFxuICAgICAgICBcImFwcGxpY2F0aW9uL2phdmFzY3JpcHRcIiA6IGFwcGVuZF9qYXZhc2NyaXB0LFxuICAgICAgICBcImFwcGxpY2F0aW9uL3BkZlwiIDogYXBwZW5kX3BkZlxuICAgIH07XG5cbiAgICBleHBvcnRzLk91dHB1dEFyZWEgPSBPdXRwdXRBcmVhO1xuIiwiLy8gQ29weXJpZ2h0IChjKSBKdXB5dGVyIERldmVsb3BtZW50IFRlYW0uXG4vLyBEaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIE1vZGlmaWVkIEJTRCBMaWNlbnNlLlxuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgdmFyIHV0aWxzID0gcmVxdWlyZSgnYmFzZS9qcy91dGlscycpO1xuXG4gICAgdmFyIFBhZ2VyID0gZnVuY3Rpb24gKHBhZ2VyX3NlbGVjdG9yLCBvcHRpb25zKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAgICAgKlxuICAgICAgICAgKiBQYXJhbWV0ZXJzOlxuICAgICAgICAgKiAgcGFnZXJfc2VsZWN0b3I6IHN0cmluZ1xuICAgICAgICAgKiAgb3B0aW9uczogZGljdGlvbmFyeVxuICAgICAgICAgKiAgICAgIERpY3Rpb25hcnkgb2Yga2V5d29yZCBhcmd1bWVudHMuXG4gICAgICAgICAqICAgICAgICAgIGV2ZW50czogJChFdmVudHMpIGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmV2ZW50cyA9IG9wdGlvbnMuZXZlbnRzO1xuICAgICAgICB0aGlzLnBhZ2VyX2VsZW1lbnQgPSAkKHBhZ2VyX3NlbGVjdG9yKTtcbiAgICAgICAgdGhpcy5wYWdlcl9idXR0b25fYXJlYSA9ICQoJyNwYWdlci1idXR0b24tYXJlYScpO1xuICAgICAgICB0aGlzLl9kZWZhdWx0X2VuZF9zcGFjZSA9IDEwMDtcbiAgICAgICAgdGhpcy5wYWdlcl9lbGVtZW50LnJlc2l6YWJsZSh7aGFuZGxlczogJ24nLCByZXNpemU6ICQucHJveHkodGhpcy5fcmVzaXplLCB0aGlzKX0pO1xuICAgICAgICB0aGlzLmV4cGFuZGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY3JlYXRlX2J1dHRvbl9hcmVhKCk7XG4gICAgICAgIHRoaXMuYmluZF9ldmVudHMoKTtcbiAgICB9O1xuXG4gICAgUGFnZXIucHJvdG90eXBlLmNyZWF0ZV9idXR0b25fYXJlYSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgdGhpcy5wYWdlcl9idXR0b25fYXJlYS5hcHBlbmQoXG4gICAgICAgICAgICAkKCc8YT4nKS5hdHRyKCdyb2xlJywgXCJidXR0b25cIilcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RpdGxlJyxcIk9wZW4gdGhlIHBhZ2VyIGluIGFuIGV4dGVybmFsIHdpbmRvd1wiKVxuICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoJ3VpLWJ1dHRvbicpXG4gICAgICAgICAgICAgICAgICAgIC5jbGljayhmdW5jdGlvbigpe3RoYXQuZGV0YWNoKCk7fSlcbiAgICAgICAgICAgICAgICAgICAgLmFwcGVuZChcbiAgICAgICAgICAgICAgICAgICAgICAgICQoJzxzcGFuPicpLmFkZENsYXNzKFwidWktaWNvbiB1aS1pY29uLWV4dGxpbmtcIilcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgICB0aGlzLnBhZ2VyX2J1dHRvbl9hcmVhLmFwcGVuZChcbiAgICAgICAgICAgICQoJzxhPicpLmF0dHIoJ3JvbGUnLCBcImJ1dHRvblwiKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigndGl0bGUnLFwiQ2xvc2UgdGhlIHBhZ2VyXCIpXG4gICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcygndWktYnV0dG9uJylcbiAgICAgICAgICAgICAgICAgICAgLmNsaWNrKGZ1bmN0aW9uKCl7dGhhdC5jb2xsYXBzZSgpO30pXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoXG4gICAgICAgICAgICAgICAgICAgICAgICAkKCc8c3Bhbj4nKS5hZGRDbGFzcyhcInVpLWljb24gdWktaWNvbi1jbG9zZVwiKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgfTtcblxuXG4gICAgUGFnZXIucHJvdG90eXBlLmJpbmRfZXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy5wYWdlcl9lbGVtZW50LmJpbmQoJ2NvbGxhcHNlX3BhZ2VyJywgZnVuY3Rpb24gKGV2ZW50LCBleHRyYXApIHtcbiAgICAgICAgICAgIC8vIEFuaW1hdGUgaGlkaW5nIG9mIHRoZSBwYWdlci5cbiAgICAgICAgICAgIHZhciB0aW1lID0gKGV4dHJhcCAmJiBleHRyYXAuZHVyYXRpb24pID8gZXh0cmFwLmR1cmF0aW9uIDogJ2Zhc3QnO1xuICAgICAgICAgICAgdGhhdC5wYWdlcl9lbGVtZW50LmFuaW1hdGUoe1xuICAgICAgICAgICAgICAgIGhlaWdodDogJ3RvZ2dsZSdcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogdGltZSxcbiAgICAgICAgICAgICAgICBkb25lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgJCgnLmVuZF9zcGFjZScpLmNzcygnaGVpZ2h0JywgdGhhdC5fZGVmYXVsdF9lbmRfc3BhY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnBhZ2VyX2VsZW1lbnQuYmluZCgnZXhwYW5kX3BhZ2VyJywgZnVuY3Rpb24gKGV2ZW50LCBleHRyYXApIHtcbiAgICAgICAgICAgIC8vIENsZWFyIHRoZSBwYWdlcidzIGhlaWdodCBhdHRyIGlmIGl0J3Mgc2V0LiAgVGhpcyBhbGxvd3MgdGhlXG4gICAgICAgICAgICAvLyBwYWdlciB0byBzaXplIGl0c2VsZiBhY2NvcmRpbmcgdG8gaXRzIGNvbnRlbnRzLlxuICAgICAgICAgICAgdGhhdC5wYWdlcl9lbGVtZW50LmhlaWdodCgnaW5pdGlhbCcpO1xuXG4gICAgICAgICAgICAvLyBBbmltYXRlIHRoZSBzaG93aW5nIG9mIHRoZSBwYWdlclxuICAgICAgICAgICAgdmFyIHRpbWUgPSAoZXh0cmFwICYmIGV4dHJhcC5kdXJhdGlvbikgPyBleHRyYXAuZHVyYXRpb24gOiAnZmFzdCc7XG4gICAgICAgICAgICB0aGF0LnBhZ2VyX2VsZW1lbnQuc2hvdyh0aW1lLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyBFeHBsaWNpdGx5IHNldCBwYWdlciBoZWlnaHQgb25jZSB0aGUgcGFnZXIgaGFzIHNob3duIGl0c2VsZi5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGFsbG93cyB0aGUgcGFnZXItY29udGVudHMgZGl2IHRvIHVzZSBwZXJjZW50YWdlIHNpemluZy5cbiAgICAgICAgICAgICAgICB0aGF0LnBhZ2VyX2VsZW1lbnQuaGVpZ2h0KHRoYXQucGFnZXJfZWxlbWVudC5oZWlnaHQoKSk7XG4gICAgICAgICAgICAgICAgdGhhdC5fcmVzaXplKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5ldmVudHMub24oJ29wZW5fd2l0aF90ZXh0LlBhZ2VyJywgZnVuY3Rpb24gKGV2ZW50LCBwYXlsb2FkKSB7XG4gICAgICAgICAgICAvLyBGSVhNRTogc3VwcG9ydCBvdGhlciBtaW1lIHR5cGVzIHdpdGggZ2VuZXJpYyBtaW1lYnVuZGxlIGRpc3BsYXlcbiAgICAgICAgICAgIC8vIG1lY2hhbmlzbVxuICAgICAgICAgICAgaWYgKHBheWxvYWQuZGF0YVsndGV4dC9odG1sJ10gJiYgcGF5bG9hZC5kYXRhWyd0ZXh0L2h0bWwnXSAhPT0gXCJcIikge1xuICAgICAgICAgICAgICAgIHRoYXQuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICB0aGF0LmV4cGFuZCgpO1xuICAgICAgICAgICAgICAgIHRoYXQuYXBwZW5kKHBheWxvYWQuZGF0YVsndGV4dC9odG1sJ10pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwYXlsb2FkLmRhdGFbJ3RleHQvcGxhaW4nXSAmJiBwYXlsb2FkLmRhdGFbJ3RleHQvcGxhaW4nXSAhPT0gXCJcIikge1xuICAgICAgICAgICAgICAgIHRoYXQuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICB0aGF0LmV4cGFuZCgpO1xuICAgICAgICAgICAgICAgIHRoYXQuYXBwZW5kX3RleHQocGF5bG9hZC5kYXRhWyd0ZXh0L3BsYWluJ10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG5cbiAgICBQYWdlci5wcm90b3R5cGUuY29sbGFwc2UgPSBmdW5jdGlvbiAoZXh0cmFwKSB7XG4gICAgICAgIGlmICh0aGlzLmV4cGFuZGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLmV4cGFuZGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnBhZ2VyX2VsZW1lbnQudHJpZ2dlcignY29sbGFwc2VfcGFnZXInLCBleHRyYXApO1xuICAgICAgICB9XG4gICAgfTtcblxuXG4gICAgUGFnZXIucHJvdG90eXBlLmV4cGFuZCA9IGZ1bmN0aW9uIChleHRyYXApIHtcbiAgICAgICAgaWYgKHRoaXMuZXhwYW5kZWQgIT09IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMuZXhwYW5kZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5wYWdlcl9lbGVtZW50LnRyaWdnZXIoJ2V4cGFuZF9wYWdlcicsIGV4dHJhcCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG5cbiAgICBQYWdlci5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5leHBhbmRlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5jb2xsYXBzZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5leHBhbmQoKTtcbiAgICAgICAgfVxuICAgIH07XG5cblxuICAgIFBhZ2VyLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICAgIHRoaXMucGFnZXJfZWxlbWVudC5maW5kKFwiLmNvbnRhaW5lclwiKS5lbXB0eSgpO1xuICAgIH07XG5cbiAgICBQYWdlci5wcm90b3R5cGUuZGV0YWNoID0gZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIHcgPSB3aW5kb3cub3BlbihcIlwiLFwiX2JsYW5rXCIpO1xuICAgICAgICAkKHcuZG9jdW1lbnQuaGVhZClcbiAgICAgICAgLmFwcGVuZChcbiAgICAgICAgICAgICAgICAkKCc8bGluaz4nKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdyZWwnLFwic3R5bGVzaGVldFwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdocmVmJyxcIi9zdGF0aWMvY3NzL25vdGVib29rLmNzc1wiKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd0eXBlJyxcInRleHQvY3NzXCIpXG4gICAgICAgIClcbiAgICAgICAgLmFwcGVuZChcbiAgICAgICAgICAgICAgICAkKCc8dGl0bGU+JykudGV4dChcIkp1cHl0ZXIgUGFnZXJcIilcbiAgICAgICAgKTtcbiAgICAgICAgdmFyIHBhZ2VyX2JvZHkgPSAkKHcuZG9jdW1lbnQuYm9keSk7XG4gICAgICAgIHBhZ2VyX2JvZHkuY3NzKCdvdmVyZmxvdycsJ3Njcm9sbCcpO1xuXG4gICAgICAgIHBhZ2VyX2JvZHkuYXBwZW5kKHRoaXMucGFnZXJfZWxlbWVudC5jbG9uZSgpLmNoaWxkcmVuKCkpO1xuICAgICAgICB3LmRvY3VtZW50LmNsb3NlKCk7XG4gICAgICAgIHRoaXMuY29sbGFwc2UoKTtcbiAgICB9O1xuXG4gICAgUGFnZXIucHJvdG90eXBlLmFwcGVuZF90ZXh0ID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBvbmx5IHVzZXIgY29udGVudCBpbmplY3RlZCB3aXRoIHRoaXMgSFRNTCBjYWxsIGlzIGVzY2FwZWQgYnlcbiAgICAgICAgICogdGhlIGZpeENvbnNvbGUoKSBtZXRob2QuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBhZ2VyX2VsZW1lbnQuZmluZChcIi5jb250YWluZXJcIikuYXBwZW5kKCQoJzxwcmUvPicpLmh0bWwodXRpbHMuZml4Q2FycmlhZ2VSZXR1cm4odXRpbHMuZml4Q29uc29sZSh0ZXh0KSkpKTtcbiAgICB9O1xuXG5cbiAgICBQYWdlci5wcm90b3R5cGUuX3Jlc2l6ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlIGRvY3VtZW50IGJhc2VkIG9uIHBhZ2VyIHNpemUuXG4gICAgICAgICAqL1xuICAgICAgICBcbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBwYWRkaW5nIGF0IHRoZSBlbmQgb2YgdGhlIG5vdGVib29rIGlzIGxhcmdlXG4gICAgICAgIC8vIGVub3VnaCB0aGF0IHRoZSB1c2VyIGNhbiBzY3JvbGwgdG8gdGhlIGJvdHRvbSBvZiB0aGUgXG4gICAgICAgIC8vIG5vdGVib29rLlxuICAgICAgICAkKCcuZW5kX3NwYWNlJykuY3NzKCdoZWlnaHQnLCBNYXRoLm1heCh0aGlzLnBhZ2VyX2VsZW1lbnQuaGVpZ2h0KCksIHRoaXMuX2RlZmF1bHRfZW5kX3NwYWNlKSk7XG4gICAgfTtcblxuICAgIGV4cG9ydHMuUGFnZXIgPSBQYWdlcjtcbiIsIi8vIENvcHlyaWdodCAoYykgSnVweXRlciBEZXZlbG9wbWVudCBUZWFtLlxuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBNb2RpZmllZCBCU0QgTGljZW5zZS5cbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIHZhciB1dGlscyA9IHJlcXVpcmUoJ2Jhc2UvanMvdXRpbHMnKTtcbiAgICB2YXIgZGlhbG9nID0gcmVxdWlyZSgnYmFzZS9qcy9kaWFsb2cnKTtcblxuICAgIHZhciBwbGF0Zm9ybSA9IHV0aWxzLnBsYXRmb3JtO1xuXG4gICAgdmFyIFF1aWNrSGVscCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAgICAgKlxuICAgICAgICAgKiBQYXJhbWV0ZXJzOlxuICAgICAgICAgKiAgb3B0aW9uczogZGljdGlvbmFyeVxuICAgICAgICAgKiAgICAgIERpY3Rpb25hcnkgb2Yga2V5d29yZCBhcmd1bWVudHMuXG4gICAgICAgICAqICAgICAgICAgIGV2ZW50czogJChFdmVudHMpIGluc3RhbmNlXG4gICAgICAgICAqICAgICAgICAgIGtleWJvYXJkX21hbmFnZXI6IEtleWJvYXJkTWFuYWdlciBpbnN0YW5jZVxuICAgICAgICAgKiAgICAgICAgICBub3RlYm9vazogTm90ZWJvb2sgaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMua2V5Ym9hcmRfbWFuYWdlciA9IG9wdGlvbnMua2V5Ym9hcmRfbWFuYWdlcjtcbiAgICAgICAgdGhpcy5ub3RlYm9vayA9IG9wdGlvbnMubm90ZWJvb2s7XG4gICAgICAgIHRoaXMua2V5Ym9hcmRfbWFuYWdlci5xdWlja19oZWxwID0gdGhpcztcbiAgICAgICAgdGhpcy5ldmVudHMgPSBvcHRpb25zLmV2ZW50cztcbiAgICB9O1xuXG4gICAgdmFyIGNtZF9jdHJsID0gJ0N0cmwtJztcbiAgICB2YXIgcGxhdGZvcm1fc3BlY2lmaWM7XG5cbiAgICBpZiAocGxhdGZvcm0gPT09ICdNYWNPUycpIHtcbiAgICAgICAgLy8gTWFjIE9TIFggc3BlY2lmaWNcbiAgICAgICAgY21kX2N0cmwgPSAnQ21kLSc7XG4gICAgICAgIHBsYXRmb3JtX3NwZWNpZmljID0gW1xuICAgICAgICAgICAgeyBzaG9ydGN1dDogXCJDbWQtVXBcIiwgICAgIGhlbHA6XCJnbyB0byBjZWxsIHN0YXJ0XCIgIH0sXG4gICAgICAgICAgICB7IHNob3J0Y3V0OiBcIkNtZC1Eb3duXCIsICAgaGVscDpcImdvIHRvIGNlbGwgZW5kXCIgIH0sXG4gICAgICAgICAgICB7IHNob3J0Y3V0OiBcIkFsdC1MZWZ0XCIsICAgaGVscDpcImdvIG9uZSB3b3JkIGxlZnRcIiAgfSxcbiAgICAgICAgICAgIHsgc2hvcnRjdXQ6IFwiQWx0LVJpZ2h0XCIsICBoZWxwOlwiZ28gb25lIHdvcmQgcmlnaHRcIiAgfSxcbiAgICAgICAgICAgIHsgc2hvcnRjdXQ6IFwiQWx0LUJhY2tzcGFjZVwiLCAgICAgIGhlbHA6XCJkZWxldGUgd29yZCBiZWZvcmVcIiAgfSxcbiAgICAgICAgICAgIHsgc2hvcnRjdXQ6IFwiQWx0LURlbGV0ZVwiLCAgICAgICAgIGhlbHA6XCJkZWxldGUgd29yZCBhZnRlclwiICB9LFxuICAgICAgICBdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFBDIHNwZWNpZmljXG4gICAgICAgIHBsYXRmb3JtX3NwZWNpZmljID0gW1xuICAgICAgICAgICAgeyBzaG9ydGN1dDogXCJDdHJsLUhvbWVcIiwgIGhlbHA6XCJnbyB0byBjZWxsIHN0YXJ0XCIgIH0sXG4gICAgICAgICAgICB7IHNob3J0Y3V0OiBcIkN0cmwtVXBcIiwgICAgIGhlbHA6XCJnbyB0byBjZWxsIHN0YXJ0XCIgIH0sXG4gICAgICAgICAgICB7IHNob3J0Y3V0OiBcIkN0cmwtRW5kXCIsICAgaGVscDpcImdvIHRvIGNlbGwgZW5kXCIgIH0sXG4gICAgICAgICAgICB7IHNob3J0Y3V0OiBcIkN0cmwtRG93blwiLCAgaGVscDpcImdvIHRvIGNlbGwgZW5kXCIgIH0sXG4gICAgICAgICAgICB7IHNob3J0Y3V0OiBcIkN0cmwtTGVmdFwiLCAgaGVscDpcImdvIG9uZSB3b3JkIGxlZnRcIiAgfSxcbiAgICAgICAgICAgIHsgc2hvcnRjdXQ6IFwiQ3RybC1SaWdodFwiLCBoZWxwOlwiZ28gb25lIHdvcmQgcmlnaHRcIiAgfSxcbiAgICAgICAgICAgIHsgc2hvcnRjdXQ6IFwiQ3RybC1CYWNrc3BhY2VcIiwgaGVscDpcImRlbGV0ZSB3b3JkIGJlZm9yZVwiICB9LFxuICAgICAgICAgICAgeyBzaG9ydGN1dDogXCJDdHJsLURlbGV0ZVwiLCAgICBoZWxwOlwiZGVsZXRlIHdvcmQgYWZ0ZXJcIiAgfSxcbiAgICAgICAgXTtcbiAgICB9XG5cbiAgICB2YXIgY21fc2hvcnRjdXRzID0gW1xuICAgICAgICB7IHNob3J0Y3V0OlwiVGFiXCIsICAgaGVscDpcImNvZGUgY29tcGxldGlvbiBvciBpbmRlbnRcIiB9LFxuICAgICAgICB7IHNob3J0Y3V0OlwiU2hpZnQtVGFiXCIsICAgaGVscDpcInRvb2x0aXBcIiB9LFxuICAgICAgICB7IHNob3J0Y3V0OiBjbWRfY3RybCArIFwiXVwiLCAgIGhlbHA6XCJpbmRlbnRcIiAgfSxcbiAgICAgICAgeyBzaG9ydGN1dDogY21kX2N0cmwgKyBcIltcIiwgICBoZWxwOlwiZGVkZW50XCIgIH0sXG4gICAgICAgIHsgc2hvcnRjdXQ6IGNtZF9jdHJsICsgXCJhXCIsICAgaGVscDpcInNlbGVjdCBhbGxcIiAgfSxcbiAgICAgICAgeyBzaG9ydGN1dDogY21kX2N0cmwgKyBcInpcIiwgICBoZWxwOlwidW5kb1wiICB9LFxuICAgICAgICB7IHNob3J0Y3V0OiBjbWRfY3RybCArIFwiU2hpZnQtelwiLCAgIGhlbHA6XCJyZWRvXCIgIH0sXG4gICAgICAgIHsgc2hvcnRjdXQ6IGNtZF9jdHJsICsgXCJ5XCIsICAgaGVscDpcInJlZG9cIiAgfSxcbiAgICBdLmNvbmNhdCggcGxhdGZvcm1fc3BlY2lmaWMgKTtcblxuICAgIHZhciBtYWNfaHVtYW5pemVfbWFwID0ge1xuICAgICAgICAvLyBhbGwgdGhlc2UgYXJlIHVuaWNvZGUsIHdpbGwgcHJvYmFibHkgZGlzcGxheSBiYWRseSBvbiBhbnl0aGluZyBleGNlcHQgbWFjcy5cbiAgICAgICAgLy8gdGhlc2UgYXJlIHRoZSBzdGFuZGFyZCBzeW1ib2wgdGhhdCBhcmUgdXNlZCBpbiBNYWNPUyBuYXRpdmUgbWVudXNcbiAgICAgICAgLy8gY2YgaHR0cDovL2FwcGxlLnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy81NTcyNy9cbiAgICAgICAgLy8gZm9yIGh0bWxlbnRpdGllcyBhbmQvb3IgdW5pY29kZSB2YWx1ZVxuICAgICAgICAnY21kJzon4oyYJyxcbiAgICAgICAgJ3NoaWZ0Jzon4oenJyxcbiAgICAgICAgJ2FsdCc6J+KMpScsXG4gICAgICAgICd1cCc6J+KGkScsXG4gICAgICAgICdkb3duJzon4oaTJyxcbiAgICAgICAgJ2xlZnQnOifihpAnLFxuICAgICAgICAncmlnaHQnOifihpInLFxuICAgICAgICAnZWplY3QnOifij48nLFxuICAgICAgICAndGFiJzon4oelJyxcbiAgICAgICAgJ2JhY2t0YWInOifih6QnLFxuICAgICAgICAnY2Fwc2xvY2snOifih6onLFxuICAgICAgICAnZXNjJzonZXNjJyxcbiAgICAgICAgJ2N0cmwnOifijIMnLFxuICAgICAgICAnZW50ZXInOifihqknLFxuICAgICAgICAncGFnZXVwJzon4oeeJyxcbiAgICAgICAgJ3BhZ2Vkb3duJzon4oefJyxcbiAgICAgICAgJ2hvbWUnOifihpYnLFxuICAgICAgICAnZW5kJzon4oaYJyxcbiAgICAgICAgJ2FsdGVudGVyJzon4oykJyxcbiAgICAgICAgJ3NwYWNlJzon4pCjJyxcbiAgICAgICAgJ2RlbGV0ZSc6J+KMpicsXG4gICAgICAgICdiYWNrc3BhY2UnOifijKsnLFxuICAgICAgICAnYXBwbGUnOifvo78nLFxuICAgIH07XG5cbiAgICB2YXIgZGVmYXVsdF9odW1hbml6ZV9tYXAgPSB7XG4gICAgICAgICdzaGlmdCc6J1NoaWZ0JyxcbiAgICAgICAgJ2FsdCc6J0FsdCcsXG4gICAgICAgICd1cCc6J1VwJyxcbiAgICAgICAgJ2Rvd24nOidEb3duJyxcbiAgICAgICAgJ2xlZnQnOidMZWZ0JyxcbiAgICAgICAgJ3JpZ2h0JzonUmlnaHQnLFxuICAgICAgICAndGFiJzonVGFiJyxcbiAgICAgICAgJ2NhcHNsb2NrJzonQ2FwcyBMb2NrJyxcbiAgICAgICAgJ2VzYyc6J0VzYycsXG4gICAgICAgICdjdHJsJzonQ3RybCcsXG4gICAgICAgICdlbnRlcic6J0VudGVyJyxcbiAgICAgICAgJ3BhZ2V1cCc6J1BhZ2UgVXAnLFxuICAgICAgICAncGFnZWRvd24nOidQYWdlIERvd24nLFxuICAgICAgICAnaG9tZSc6J0hvbWUnLFxuICAgICAgICAnZW5kJzonRW5kJyxcbiAgICAgICAgJ3NwYWNlJzonU3BhY2UnLFxuICAgICAgICAnYmFja3NwYWNlJzonQmFja3NwYWNlJyxcbiAgICAgICAgfTtcblxuICAgIHZhciBodW1hbml6ZV9tYXA7XG5cbiAgICBpZiAocGxhdGZvcm0gPT09ICdNYWNPUycpe1xuICAgICAgICBodW1hbml6ZV9tYXAgPSBtYWNfaHVtYW5pemVfbWFwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGh1bWFuaXplX21hcCA9IGRlZmF1bHRfaHVtYW5pemVfbWFwO1xuICAgIH1cblxuICAgIHZhciBzcGVjaWFsX2Nhc2UgPSB7IHBhZ2V1cDogXCJQYWdlVXBcIiwgcGFnZWRvd246IFwiUGFnZSBEb3duXCIsICdtaW51cyc6ICctJyB9O1xuICAgIFxuICAgIGZ1bmN0aW9uIGh1bWFuaXplX2tleShrZXkpe1xuICAgICAgICBpZiAoa2V5Lmxlbmd0aCA9PT0gMSl7XG4gICAgICAgICAgICByZXR1cm4ga2V5LnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBrZXkgPSBodW1hbml6ZV9tYXBba2V5LnRvTG93ZXJDYXNlKCldfHxrZXk7XG4gICAgICAgIFxuICAgICAgICBpZiAoa2V5LmluZGV4T2YoJywnKSA9PT0gLTEpe1xuICAgICAgICAgICAgcmV0dXJuICAoIHNwZWNpYWxfY2FzZVtrZXldID8gc3BlY2lhbF9jYXNlW2tleV0gOiBrZXkuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBrZXkuc2xpY2UoMSkgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIHJldHVybiBhbiAqKmh0bWwqKiBzdHJpbmcgb2YgdGhlIGtleWJvYXJkIHNob3J0Y3V0XG4gICAgLy8gZm9yIGh1bWFuIGV5ZXMgY29uc3VtcHRpb24uXG4gICAgLy8gdGhlIHNlcXVlbmNlIGlzIGEgc3RyaW5nLCBjb21tYSBzZXBwYXJhdGVkIGxpbmt0IG9mIHNob3J0Y3V0LFxuICAgIC8vIHdoZXJlIHRoZSBzaG9ydGN1dCBpcyBhIGxpc3Qgb2YgZGFzaC1qb2luZWQga2V5cy5cbiAgICAvLyBFYWNoIHNob3J0Y3V0IHdpbGwgYmUgd3JhcHBlZCBpbiA8a2JkPiB0YWcsIGFuZCBqb2luZWQgYnkgY29tbWEgaXMgaW4gYVxuICAgIC8vIHNlcXVlbmNlLlxuICAgIC8vXG4gICAgLy8gRGVwZW5kaW5nIG9uIHRoZSBwbGF0Zm9ybSBlYWNoIHNob3J0Y3V0IHdpbGwgYmUgbm9ybWFsaXplZCwgd2l0aCBvciB3aXRob3V0IGRhc2hlcy5cbiAgICAvLyBhbmQgcmVwbGFjZSB3aXRoIHRoZSBjb3JyZXNwb25kaW5nIHVuaWNvZGUgc3ltYm9sIGZvciBtb2RpZmllciBpZiBuZWNlc3NhcnkuXG4gICAgZnVuY3Rpb24gaHVtYW5pemVfc2VxdWVuY2Uoc2VxdWVuY2Upe1xuICAgICAgICB2YXIgam9pbmNoYXIgPSAnLCc7XG4gICAgICAgIHZhciBodW0gPSBfLm1hcChzZXF1ZW5jZS5yZXBsYWNlKC9tZXRhL2csICdjbWQnKS5zcGxpdCgnLCcpLCBodW1hbml6ZV9zaG9ydGN1dCkuam9pbihqb2luY2hhcik7XG4gICAgICAgIHJldHVybiBodW07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaHVtYW5pemVfc2hvcnRjdXQoc2hvcnRjdXQpe1xuICAgICAgICB2YXIgam9pbmNoYXIgPSAnLSc7XG4gICAgICAgIGlmIChwbGF0Zm9ybSA9PT0gJ01hY09TJyl7XG4gICAgICAgICAgICBqb2luY2hhciA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzaCA9IF8ubWFwKHNob3J0Y3V0LnNwbGl0KCctJyksIGh1bWFuaXplX2tleSApLmpvaW4oam9pbmNoYXIpO1xuICAgICAgICByZXR1cm4gJzxrYmQ+JytzaCsnPC9rYmQ+JztcbiAgICB9XG4gICAgXG5cbiAgICBRdWlja0hlbHAucHJvdG90eXBlLnNob3dfa2V5Ym9hcmRfc2hvcnRjdXRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogdG9nZ2xlcyBkaXNwbGF5IG9mIGtleWJvYXJkIHNob3J0Y3V0IGRpYWxvZ1xuICAgICAgICAgKi9cbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICBpZiAoIHRoaXMuZm9yY2VfcmVidWlsZCApIHtcbiAgICAgICAgICAgIHRoaXMuc2hvcnRjdXRfZGlhbG9nLnJlbW92ZSgpO1xuICAgICAgICAgICAgZGVsZXRlKHRoaXMuc2hvcnRjdXRfZGlhbG9nKTtcbiAgICAgICAgICAgIHRoaXMuZm9yY2VfcmVidWlsZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICggdGhpcy5zaG9ydGN1dF9kaWFsb2cgKXtcbiAgICAgICAgICAgIC8vIGlmIGRpYWxvZyBpcyBhbHJlYWR5IHNob3duLCBjbG9zZSBpdFxuICAgICAgICAgICAgJCh0aGlzLnNob3J0Y3V0X2RpYWxvZykubW9kYWwoXCJ0b2dnbGVcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbW1hbmRfc2hvcnRjdXRzID0gdGhpcy5rZXlib2FyZF9tYW5hZ2VyLmNvbW1hbmRfc2hvcnRjdXRzLmhlbHAoKTtcbiAgICAgICAgdmFyIGVkaXRfc2hvcnRjdXRzID0gdGhpcy5rZXlib2FyZF9tYW5hZ2VyLmVkaXRfc2hvcnRjdXRzLmhlbHAoKTtcbiAgICAgICAgdmFyIGhlbHAsIHNob3J0Y3V0O1xuICAgICAgICB2YXIgaSwgaGFsZiwgbjtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSAkKCc8ZGl2Lz4nKTtcblxuICAgICAgICAvLyBUaGUgZG9jdW1lbnRhdGlvblxuICAgICAgICB2YXIgZG9jID0gJCgnPGRpdi8+JykuYWRkQ2xhc3MoJ2FsZXJ0IGFsZXJ0LWluZm8nKTtcbiAgICAgICAgZG9jLmFwcGVuZChcbiAgICAgICAgICAgICdUaGUgSnVweXRlciBOb3RlYm9vayBoYXMgdHdvIGRpZmZlcmVudCBrZXlib2FyZCBpbnB1dCBtb2Rlcy4gPGI+RWRpdCBtb2RlPC9iPiAnK1xuICAgICAgICAgICAgJ2FsbG93cyB5b3UgdG8gdHlwZSBjb2RlL3RleHQgaW50byBhIGNlbGwgYW5kIGlzIGluZGljYXRlZCBieSBhIGdyZWVuIGNlbGwgJytcbiAgICAgICAgICAgICdib3JkZXIuIDxiPkNvbW1hbmQgbW9kZTwvYj4gYmluZHMgdGhlIGtleWJvYXJkIHRvIG5vdGVib29rIGxldmVsIGFjdGlvbnMgJytcbiAgICAgICAgICAgICdhbmQgaXMgaW5kaWNhdGVkIGJ5IGEgZ3JleSBjZWxsIGJvcmRlci4nXG4gICAgICAgICk7XG4gICAgICAgIGlmIChwbGF0Zm9ybSA9PT0gJ01hY09TJykge1xuICAgICAgICAgICAgdmFyIGtleV9kaXYgPSB0aGlzLmJ1aWxkX2tleV9uYW1lcygpO1xuICAgICAgICAgICAgZG9jLmFwcGVuZChrZXlfZGl2KTtcbiAgICAgICAgfVxuICAgICAgICBlbGVtZW50LmFwcGVuZChkb2MpO1xuXG4gICAgICAgIC8vIENvbW1hbmQgbW9kZVxuICAgICAgICB2YXIgY21kX2RpdiA9IHRoaXMuYnVpbGRfY29tbWFuZF9oZWxwKCk7XG4gICAgICAgIGVsZW1lbnQuYXBwZW5kKGNtZF9kaXYpO1xuXG4gICAgICAgIC8vIEVkaXQgbW9kZVxuICAgICAgICB2YXIgZWRpdF9kaXYgPSB0aGlzLmJ1aWxkX2VkaXRfaGVscChjbV9zaG9ydGN1dHMpO1xuICAgICAgICBlbGVtZW50LmFwcGVuZChlZGl0X2Rpdik7XG5cbiAgICAgICAgdGhpcy5zaG9ydGN1dF9kaWFsb2cgPSBkaWFsb2cubW9kYWwoe1xuICAgICAgICAgICAgdGl0bGUgOiBcIktleWJvYXJkIHNob3J0Y3V0c1wiLFxuICAgICAgICAgICAgYm9keSA6IGVsZW1lbnQsXG4gICAgICAgICAgICBkZXN0cm95IDogZmFsc2UsXG4gICAgICAgICAgICBidXR0b25zIDoge1xuICAgICAgICAgICAgICAgIENsb3NlIDoge31cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBub3RlYm9vazogdGhpcy5ub3RlYm9vayxcbiAgICAgICAgICAgIGtleWJvYXJkX21hbmFnZXI6IHRoaXMua2V5Ym9hcmRfbWFuYWdlcixcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2hvcnRjdXRfZGlhbG9nLmFkZENsYXNzKFwibW9kYWxfc3RyZXRjaFwiKTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuZXZlbnRzLm9uKCdyZWJ1aWxkLlF1aWNrSGVscCcsIGZ1bmN0aW9uKCkgeyB0aGF0LmZvcmNlX3JlYnVpbGQgPSB0cnVlO30pO1xuICAgIH07XG5cbiAgICBRdWlja0hlbHAucHJvdG90eXBlLmJ1aWxkX2tleV9uYW1lcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICB2YXIga2V5X25hbWVzX21hYyA9ICBbeyBzaG9ydGN1dDpcIuKMmFwiLCBoZWxwOlwiQ29tbWFuZFwiIH0sXG4gICAgICAgICAgICAgICAgICAgIHsgc2hvcnRjdXQ6XCLijINcIiwgaGVscDpcIkNvbnRyb2xcIiB9LFxuICAgICAgICAgICAgICAgICAgICB7IHNob3J0Y3V0Olwi4oylXCIsIGhlbHA6XCJPcHRpb25cIiB9LFxuICAgICAgICAgICAgICAgICAgICB7IHNob3J0Y3V0Olwi4oenXCIsIGhlbHA6XCJTaGlmdFwiIH0sXG4gICAgICAgICAgICAgICAgICAgIHsgc2hvcnRjdXQ6XCLihqlcIiwgaGVscDpcIlJldHVyblwiIH0sXG4gICAgICAgICAgICAgICAgICAgIHsgc2hvcnRjdXQ6XCLikKNcIiwgaGVscDpcIlNwYWNlXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgeyBzaG9ydGN1dDpcIuKHpVwiLCBoZWxwOlwiVGFiXCIgfV07XG4gICAgICAgIHZhciBpLCBoYWxmLCBuO1xuICAgICAgICB2YXIgZGl2ID0gJCgnPGRpdi8+JykuYXBwZW5kKCdNYWNPUyBtb2RpZmllciBrZXlzOicpO1xuICAgICAgICB2YXIgc3ViX2RpdiA9ICQoJzxkaXYvPicpLmFkZENsYXNzKCdjb250YWluZXItZmx1aWQnKTtcbiAgICAgICAgdmFyIGNvbDEgPSAkKCc8ZGl2Lz4nKS5hZGRDbGFzcygnY29sLW1kLTYnKTtcbiAgICAgICAgdmFyIGNvbDIgPSAkKCc8ZGl2Lz4nKS5hZGRDbGFzcygnY29sLW1kLTYnKTtcbiAgICAgICAgbiA9IGtleV9uYW1lc19tYWMubGVuZ3RoO1xuICAgICAgICBoYWxmID0gfn4obi8yKTtcbiAgICAgICAgZm9yIChpPTA7IGk8aGFsZjsgaSsrKSB7IGNvbDEuYXBwZW5kKFxuICAgICAgICAgICAgICAgIGJ1aWxkX29uZShrZXlfbmFtZXNfbWFjW2ldKVxuICAgICAgICAgICAgICAgICk7IH1cbiAgICAgICAgZm9yIChpPWhhbGY7IGk8bjsgaSsrKSB7IGNvbDIuYXBwZW5kKFxuICAgICAgICAgICAgICAgIGJ1aWxkX29uZShrZXlfbmFtZXNfbWFjW2ldKVxuICAgICAgICAgICAgICAgICk7IH1cbiAgICAgICAgc3ViX2Rpdi5hcHBlbmQoY29sMSkuYXBwZW5kKGNvbDIpO1xuICAgICAgICBkaXYuYXBwZW5kKHN1Yl9kaXYpO1xuICAgICAgICByZXR1cm4gZGl2O1xuICAgIH07XG5cblxuICAgIFF1aWNrSGVscC5wcm90b3R5cGUuYnVpbGRfY29tbWFuZF9oZWxwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29tbWFuZF9zaG9ydGN1dHMgPSB0aGlzLmtleWJvYXJkX21hbmFnZXIuY29tbWFuZF9zaG9ydGN1dHMuaGVscCgpO1xuICAgICAgICByZXR1cm4gYnVpbGRfZGl2KCc8aDQ+Q29tbWFuZCBNb2RlIChwcmVzcyA8a2JkPkVzYzwva2JkPiB0byBlbmFibGUpPC9oND4nLCBjb21tYW5kX3Nob3J0Y3V0cyk7XG4gICAgfTtcblxuICAgIFxuICAgIFF1aWNrSGVscC5wcm90b3R5cGUuYnVpbGRfZWRpdF9oZWxwID0gZnVuY3Rpb24gKGNtX3Nob3J0Y3V0cykge1xuICAgICAgICB2YXIgZWRpdF9zaG9ydGN1dHMgPSB0aGlzLmtleWJvYXJkX21hbmFnZXIuZWRpdF9zaG9ydGN1dHMuaGVscCgpO1xuICAgICAgICBqUXVlcnkubWVyZ2UoY21fc2hvcnRjdXRzLCBlZGl0X3Nob3J0Y3V0cyk7XG4gICAgICAgIHJldHVybiBidWlsZF9kaXYoJzxoND5FZGl0IE1vZGUgKHByZXNzIDxrYmQ+RW50ZXI8L2tiZD4gdG8gZW5hYmxlKTwvaDQ+JywgY21fc2hvcnRjdXRzKTtcbiAgICB9O1xuXG4gICAgdmFyIGJ1aWxkX29uZSA9IGZ1bmN0aW9uIChzKSB7XG4gICAgICAgIHZhciBoZWxwID0gcy5oZWxwO1xuICAgICAgICB2YXIgc2hvcnRjdXQgPSAnJztcbiAgICAgICAgaWYocy5zaG9ydGN1dCl7XG4gICAgICAgICAgICBzaG9ydGN1dCA9IGh1bWFuaXplX3NlcXVlbmNlKHMuc2hvcnRjdXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAkKCc8ZGl2PicpLmFkZENsYXNzKCdxdWlja2hlbHAnKS5cbiAgICAgICAgICAgIGFwcGVuZCgkKCc8c3Bhbi8+JykuYWRkQ2xhc3MoJ3Nob3J0Y3V0X2tleScpLmFwcGVuZCgkKHNob3J0Y3V0KSkpLlxuICAgICAgICAgICAgYXBwZW5kKCQoJzxzcGFuLz4nKS5hZGRDbGFzcygnc2hvcnRjdXRfZGVzY3InKS50ZXh0KCcgOiAnICsgaGVscCkpO1xuXG4gICAgfTtcblxuICAgIHZhciBidWlsZF9kaXYgPSBmdW5jdGlvbiAodGl0bGUsIHNob3J0Y3V0cykge1xuICAgICAgICB2YXIgaSwgaGFsZiwgbjtcbiAgICAgICAgdmFyIGRpdiA9ICQoJzxkaXYvPicpLmFwcGVuZCgkKHRpdGxlKSk7XG4gICAgICAgIHZhciBzdWJfZGl2ID0gJCgnPGRpdi8+JykuYWRkQ2xhc3MoJ2NvbnRhaW5lci1mbHVpZCcpO1xuICAgICAgICB2YXIgY29sMSA9ICQoJzxkaXYvPicpLmFkZENsYXNzKCdjb2wtbWQtNicpO1xuICAgICAgICB2YXIgY29sMiA9ICQoJzxkaXYvPicpLmFkZENsYXNzKCdjb2wtbWQtNicpO1xuICAgICAgICBuID0gc2hvcnRjdXRzLmxlbmd0aDtcbiAgICAgICAgaGFsZiA9IH5+KG4vMik7ICAvLyBUcnVuY2F0ZSA6KVxuICAgICAgICBmb3IgKGk9MDsgaTxoYWxmOyBpKyspIHsgY29sMS5hcHBlbmQoIGJ1aWxkX29uZShzaG9ydGN1dHNbaV0pICk7IH1cbiAgICAgICAgZm9yIChpPWhhbGY7IGk8bjsgaSsrKSB7IGNvbDIuYXBwZW5kKCBidWlsZF9vbmUoc2hvcnRjdXRzW2ldKSApOyB9XG4gICAgICAgIHN1Yl9kaXYuYXBwZW5kKGNvbDEpLmFwcGVuZChjb2wyKTtcbiAgICAgICAgZGl2LmFwcGVuZChzdWJfZGl2KTtcbiAgICAgICAgcmV0dXJuIGRpdjtcbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7J1F1aWNrSGVscCc6IFF1aWNrSGVscCxcbiAgICAgIGh1bWFuaXplX3Nob3J0Y3V0OiBodW1hbml6ZV9zaG9ydGN1dCxcbiAgICAgIGh1bWFuaXplX3NlcXVlbmNlOiBodW1hbml6ZV9zZXF1ZW5jZVxuICB9O1xuIiwiLy8gQ29weXJpZ2h0IChjKSBKdXB5dGVyIERldmVsb3BtZW50IFRlYW0uXG4vLyBEaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIE1vZGlmaWVkIEJTRCBMaWNlbnNlLlxuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgdmFyIHV0aWxzID0gcmVxdWlyZSgnYmFzZS9qcy91dGlscycpO1xuICAgIHZhciBkaWFsb2cgPSByZXF1aXJlKCdiYXNlL2pzL2RpYWxvZycpO1xuICAgIHZhciBrZXlib2FyZCA9IHJlcXVpcmUoJ2Jhc2UvanMva2V5Ym9hcmQnKTtcbiAgICB2YXIgbW9tZW50ID0gcmVxdWlyZSgnbW9tZW50Jyk7XG5cbiAgICB2YXIgU2F2ZVdpZGdldCA9IGZ1bmN0aW9uIChzZWxlY3Rvciwgb3B0aW9ucykge1xuICAgICAgICAvKipcbiAgICAgICAgICogVE9ETzogUmVtb3ZlIGNpcmN1bGFyIHJlZi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubm90ZWJvb2sgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuc2VsZWN0b3IgPSBzZWxlY3RvcjtcbiAgICAgICAgdGhpcy5ldmVudHMgPSBvcHRpb25zLmV2ZW50cztcbiAgICAgICAgdGhpcy5fY2hlY2twb2ludF9kYXRlID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmtleWJvYXJkX21hbmFnZXIgPSBvcHRpb25zLmtleWJvYXJkX21hbmFnZXI7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudCA9ICQoc2VsZWN0b3IpO1xuICAgICAgICAgICAgdGhpcy5iaW5kX2V2ZW50cygpO1xuICAgICAgICB9XG4gICAgfTtcblxuXG4gICAgU2F2ZVdpZGdldC5wcm90b3R5cGUuYmluZF9ldmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgdGhpcy5lbGVtZW50LmZpbmQoJ3NwYW4uZmlsZW5hbWUnKS5jbGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGF0LnJlbmFtZV9ub3RlYm9vayh7bm90ZWJvb2s6IHRoYXQubm90ZWJvb2t9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZXZlbnRzLm9uKCdub3RlYm9va19sb2FkZWQuTm90ZWJvb2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGF0LnVwZGF0ZV9ub3RlYm9va19uYW1lKCk7XG4gICAgICAgICAgICB0aGF0LnVwZGF0ZV9kb2N1bWVudF90aXRsZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5ldmVudHMub24oJ25vdGVib29rX3NhdmVkLk5vdGVib29rJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhhdC51cGRhdGVfbm90ZWJvb2tfbmFtZSgpO1xuICAgICAgICAgICAgdGhhdC51cGRhdGVfZG9jdW1lbnRfdGl0bGUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZXZlbnRzLm9uKCdub3RlYm9va19yZW5hbWVkLk5vdGVib29rJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhhdC51cGRhdGVfbm90ZWJvb2tfbmFtZSgpO1xuICAgICAgICAgICAgdGhhdC51cGRhdGVfZG9jdW1lbnRfdGl0bGUoKTtcbiAgICAgICAgICAgIHRoYXQudXBkYXRlX2FkZHJlc3NfYmFyKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmV2ZW50cy5vbignbm90ZWJvb2tfc2F2ZV9mYWlsZWQuTm90ZWJvb2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGF0LnNldF9zYXZlX3N0YXR1cygnQXV0b3NhdmUgRmFpbGVkIScpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5ldmVudHMub24oJ25vdGVib29rX3JlYWRfb25seS5Ob3RlYm9vaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoYXQuc2V0X3NhdmVfc3RhdHVzKCcocmVhZCBvbmx5KScpO1xuICAgICAgICAgICAgLy8gZGlzYWJsZSBmdXR1cmUgc2V0X3NhdmVfc3RhdHVzXG4gICAgICAgICAgICB0aGF0LnNldF9zYXZlX3N0YXR1cyA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5ldmVudHMub24oJ2NoZWNrcG9pbnRzX2xpc3RlZC5Ob3RlYm9vaycsIGZ1bmN0aW9uIChldmVudCwgZGF0YSkge1xuICAgICAgICAgICAgdGhhdC5fc2V0X2xhc3RfY2hlY2twb2ludChkYXRhWzBdKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5ldmVudHMub24oJ2NoZWNrcG9pbnRfY3JlYXRlZC5Ob3RlYm9vaycsIGZ1bmN0aW9uIChldmVudCwgZGF0YSkge1xuICAgICAgICAgICAgdGhhdC5fc2V0X2xhc3RfY2hlY2twb2ludChkYXRhKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZXZlbnRzLm9uKCdzZXRfZGlydHkuTm90ZWJvb2snLCBmdW5jdGlvbiAoZXZlbnQsIGRhdGEpIHtcbiAgICAgICAgICAgIHRoYXQuc2V0X2F1dG9zYXZlZChkYXRhLnZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuXG4gICAgU2F2ZVdpZGdldC5wcm90b3R5cGUucmVuYW1lX25vdGVib29rID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgdmFyIGRpYWxvZ19ib2R5ID0gJCgnPGRpdi8+JykuYXBwZW5kKFxuICAgICAgICAgICAgJChcIjxwLz5cIikuYWRkQ2xhc3MoXCJyZW5hbWUtbWVzc2FnZVwiKVxuICAgICAgICAgICAgICAgIC50ZXh0KCdFbnRlciBhIG5ldyBub3RlYm9vayBuYW1lOicpXG4gICAgICAgICkuYXBwZW5kKFxuICAgICAgICAgICAgJChcIjxici8+XCIpXG4gICAgICAgICkuYXBwZW5kKFxuICAgICAgICAgICAgJCgnPGlucHV0Lz4nKS5hdHRyKCd0eXBlJywndGV4dCcpLmF0dHIoJ3NpemUnLCcyNScpLmFkZENsYXNzKCdmb3JtLWNvbnRyb2wnKVxuICAgICAgICAgICAgLnZhbChvcHRpb25zLm5vdGVib29rLmdldF9ub3RlYm9va19uYW1lKCkpXG4gICAgICAgICk7XG4gICAgICAgIHZhciBkID0gZGlhbG9nLm1vZGFsKHtcbiAgICAgICAgICAgIHRpdGxlOiBcIlJlbmFtZSBOb3RlYm9va1wiLFxuICAgICAgICAgICAgYm9keTogZGlhbG9nX2JvZHksXG4gICAgICAgICAgICBub3RlYm9vazogb3B0aW9ucy5ub3RlYm9vayxcbiAgICAgICAgICAgIGtleWJvYXJkX21hbmFnZXI6IHRoaXMua2V5Ym9hcmRfbWFuYWdlcixcbiAgICAgICAgICAgIGJ1dHRvbnMgOiB7XG4gICAgICAgICAgICAgICAgXCJPS1wiOiB7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzOiBcImJ0bi1wcmltYXJ5XCIsXG4gICAgICAgICAgICAgICAgICAgIGNsaWNrOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3X25hbWUgPSBkLmZpbmQoJ2lucHV0JykudmFsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMubm90ZWJvb2sudGVzdF9ub3RlYm9va19uYW1lKG5ld19uYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQuZmluZCgnLnJlbmFtZS1tZXNzYWdlJykudGV4dChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJJbnZhbGlkIG5vdGVib29rIG5hbWUuIE5vdGVib29rIG5hbWVzIG11c3QgXCIrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiaGF2ZSAxIG9yIG1vcmUgY2hhcmFjdGVycyBhbmQgY2FuIGNvbnRhaW4gYW55IGNoYXJhY3RlcnMgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImV4Y2VwdCA6L1xcXFwuIFBsZWFzZSBlbnRlciBhIG5ldyBub3RlYm9vayBuYW1lOlwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQuZmluZCgnLnJlbmFtZS1tZXNzYWdlJykudGV4dChcIlJlbmFtaW5nLi4uXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQuZmluZCgnaW5wdXRbdHlwZT1cInRleHRcIl0nKS5wcm9wKCdkaXNhYmxlZCcsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQubm90ZWJvb2sucmVuYW1lKG5ld19uYW1lKS50aGVuKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkLm1vZGFsKCdoaWRlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZC5maW5kKCcucmVuYW1lLW1lc3NhZ2UnKS50ZXh0KGVycm9yLm1lc3NhZ2UgfHwgJ1Vua25vd24gZXJyb3InKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQuZmluZCgnaW5wdXRbdHlwZT1cInRleHRcIl0nKS5wcm9wKCdkaXNhYmxlZCcsIGZhbHNlKS5mb2N1cygpLnNlbGVjdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiQ2FuY2VsXCI6IHt9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9wZW4gOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogVXBvbiBFTlRFUiwgY2xpY2sgdGhlIE9LIGJ1dHRvbi5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBkLmZpbmQoJ2lucHV0W3R5cGU9XCJ0ZXh0XCJdJykua2V5ZG93bihmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50LndoaWNoID09PSBrZXlib2FyZC5rZXljb2Rlcy5lbnRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZC5maW5kKCcuYnRuLXByaW1hcnknKS5maXJzdCgpLmNsaWNrKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBkLmZpbmQoJ2lucHV0W3R5cGU9XCJ0ZXh0XCJdJykuZm9jdXMoKS5zZWxlY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuXG4gICAgU2F2ZVdpZGdldC5wcm90b3R5cGUudXBkYXRlX25vdGVib29rX25hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBuYm5hbWUgPSB0aGlzLm5vdGVib29rLmdldF9ub3RlYm9va19uYW1lKCk7XG4gICAgICAgIHRoaXMuZWxlbWVudC5maW5kKCdzcGFuLmZpbGVuYW1lJykudGV4dChuYm5hbWUpO1xuICAgIH07XG5cblxuICAgIFNhdmVXaWRnZXQucHJvdG90eXBlLnVwZGF0ZV9kb2N1bWVudF90aXRsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5ibmFtZSA9IHRoaXMubm90ZWJvb2suZ2V0X25vdGVib29rX25hbWUoKTtcbiAgICAgICAgZG9jdW1lbnQudGl0bGUgPSBuYm5hbWU7XG4gICAgfTtcblxuICAgIFNhdmVXaWRnZXQucHJvdG90eXBlLnVwZGF0ZV9hZGRyZXNzX2JhciA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciBiYXNlX3VybCA9IHRoaXMubm90ZWJvb2suYmFzZV91cmw7XG4gICAgICAgIHZhciBwYXRoID0gdGhpcy5ub3RlYm9vay5ub3RlYm9va19wYXRoO1xuICAgICAgICB2YXIgc3RhdGUgPSB7cGF0aCA6IHBhdGh9O1xuICAgICAgICB3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUoc3RhdGUsIFwiXCIsIHV0aWxzLnVybF9qb2luX2VuY29kZShcbiAgICAgICAgICAgIGJhc2VfdXJsLFxuICAgICAgICAgICAgXCJub3RlYm9va3NcIixcbiAgICAgICAgICAgIHBhdGgpXG4gICAgICAgICk7XG4gICAgfTtcblxuXG4gICAgU2F2ZVdpZGdldC5wcm90b3R5cGUuc2V0X3NhdmVfc3RhdHVzID0gZnVuY3Rpb24gKG1zZykge1xuICAgICAgICB0aGlzLmVsZW1lbnQuZmluZCgnc3Bhbi5hdXRvc2F2ZV9zdGF0dXMnKS50ZXh0KG1zZyk7XG4gICAgfTtcblxuICAgIFNhdmVXaWRnZXQucHJvdG90eXBlLl9zZXRfbGFzdF9jaGVja3BvaW50ID0gZnVuY3Rpb24gKGNoZWNrcG9pbnQpIHtcbiAgICAgICAgaWYgKGNoZWNrcG9pbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrcG9pbnRfZGF0ZSA9IG5ldyBEYXRlKGNoZWNrcG9pbnQubGFzdF9tb2RpZmllZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9jaGVja3BvaW50X2RhdGUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3JlbmRlcl9jaGVja3BvaW50KCk7XG4gICAgfTtcblxuICAgIFNhdmVXaWRnZXQucHJvdG90eXBlLl9yZW5kZXJfY2hlY2twb2ludCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyoqIGFjdHVhbGx5IHNldCB0aGUgdGV4dCBpbiB0aGUgZWxlbWVudCwgZnJvbSBvdXIgX2NoZWNrcG9pbnQgdmFsdWVcbiAgICAgICAgXG4gICAgICAgIGNhbGxlZCBkaXJlY3RseSwgYW5kIHBlcmlvZGljYWxseSBpbiB0aW1lb3V0cy5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fc2NoZWR1bGVfcmVuZGVyX2NoZWNrcG9pbnQoKTtcbiAgICAgICAgdmFyIGVsID0gdGhpcy5lbGVtZW50LmZpbmQoJ3NwYW4uY2hlY2twb2ludF9zdGF0dXMnKTtcbiAgICAgICAgaWYgKCF0aGlzLl9jaGVja3BvaW50X2RhdGUpIHtcbiAgICAgICAgICAgIGVsLnRleHQoJycpLmF0dHIoJ3RpdGxlJywgJ25vIGNoZWNrcG9pbnQnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2hrZCA9IG1vbWVudCh0aGlzLl9jaGVja3BvaW50X2RhdGUpO1xuICAgICAgICB2YXIgbG9uZ19kYXRlID0gY2hrZC5mb3JtYXQoJ2xsbGwnKTtcbiAgICAgICAgdmFyIGh1bWFuX2RhdGU7XG4gICAgICAgIHZhciB0ZGVsdGEgPSBNYXRoLmNlaWwobmV3IERhdGUoKSAtIHRoaXMuX2NoZWNrcG9pbnRfZGF0ZSk7XG4gICAgICAgIGlmICh0ZGVsdGEgPCB1dGlscy50aW1lLm1pbGxpc2Vjb25kcy5kKXtcbiAgICAgICAgICAgIC8vIGxlc3MgdGhhbiAyNCBob3VycyBvbGQsIHVzZSByZWxhdGl2ZSBkYXRlXG4gICAgICAgICAgICBodW1hbl9kYXRlID0gY2hrZC5mcm9tTm93KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBvdGhlcndpc2Ugc2hvdyBjYWxlbmRhciBcbiAgICAgICAgICAgIC8vIDxUb2RheSB8IHllc3RlcmRheXwuLi4+IGF0IGhoLG1tLHNzXG4gICAgICAgICAgICBodW1hbl9kYXRlID0gY2hrZC5jYWxlbmRhcigpO1xuICAgICAgICB9XG4gICAgICAgIGVsLnRleHQoJ0xhc3QgQ2hlY2twb2ludDogJyArIGh1bWFuX2RhdGUpLmF0dHIoJ3RpdGxlJywgbG9uZ19kYXRlKTtcbiAgICB9O1xuXG5cbiAgICBTYXZlV2lkZ2V0LnByb3RvdHlwZS5fc2NoZWR1bGVfcmVuZGVyX2NoZWNrcG9pbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qKiBzY2hlZHVsZSB0aGUgbmV4dCB1cGRhdGUgdG8gcmVsYXRpdmUgZGF0ZVxuICAgICAgICBcbiAgICAgICAgcGVyaW9kaWNhbGx5IHVwZGF0ZWQsIHNvIHNob3J0IHZhbHVlcyBsaWtlICdhIGZldyBzZWNvbmRzIGFnbycgZG9uJ3QgZ2V0IHN0YWxlLlxuICAgICAgICAqL1xuICAgICAgICBpZiAoIXRoaXMuX2NoZWNrcG9pbnRfZGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICgodGhpcy5fY2hlY2twb2ludF90aW1lb3V0KSkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX2NoZWNrcG9pbnRfdGltZW91dCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGR0ID0gTWF0aC5jZWlsKG5ldyBEYXRlKCkgLSB0aGlzLl9jaGVja3BvaW50X2RhdGUpO1xuICAgICAgICB0aGlzLl9jaGVja3BvaW50X3RpbWVvdXQgPSBzZXRUaW1lb3V0KFxuICAgICAgICAgICAgJC5wcm94eSh0aGlzLl9yZW5kZXJfY2hlY2twb2ludCwgdGhpcyksXG4gICAgICAgICAgICB1dGlscy50aW1lLnRpbWVvdXRfZnJvbV9kdChkdClcbiAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgU2F2ZVdpZGdldC5wcm90b3R5cGUuc2V0X2F1dG9zYXZlZCA9IGZ1bmN0aW9uIChkaXJ0eSkge1xuICAgICAgICBpZiAoZGlydHkpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0X3NhdmVfc3RhdHVzKFwiKHVuc2F2ZWQgY2hhbmdlcylcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNldF9zYXZlX3N0YXR1cyhcIihhdXRvc2F2ZWQpXCIpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGV4cG9ydHMuU2F2ZVdpZGdldCA9IFNhdmVXaWRnZXQ7XG4iLCIvLyBDb3B5cmlnaHQgKGMpIEp1cHl0ZXIgRGV2ZWxvcG1lbnQgVGVhbS5cbi8vIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgTW9kaWZpZWQgQlNEIExpY2Vuc2UuXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICB2YXIgU2Nyb2xsTWFuYWdlciA9IGZ1bmN0aW9uKG5vdGVib29rLCBvcHRpb25zKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQdWJsaWMgY29uc3RydWN0b3IuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5vdGVib29rID0gbm90ZWJvb2s7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9ICQoJyNzaXRlJyk7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICB0aGlzLmFuaW1hdGlvbl9zcGVlZCA9IG9wdGlvbnMuYW5pbWF0aW9uX3NwZWVkIHx8IDI1MDsgLy9tc1xuICAgIH07XG5cbiAgICBTY3JvbGxNYW5hZ2VyLnByb3RvdHlwZS5zY3JvbGwgPSBmdW5jdGlvbiAoZGVsdGEpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNjcm9sbCB0aGUgZG9jdW1lbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIFBhcmFtZXRlcnNcbiAgICAgICAgICogLS0tLS0tLS0tLVxuICAgICAgICAgKiBkZWx0YTogaW50ZWdlclxuICAgICAgICAgKiAgZGlyZWN0aW9uIHRvIHNjcm9sbCB0aGUgZG9jdW1lbnQuICBQb3NpdGl2ZSBpcyBkb3dud2FyZHMuIFxuICAgICAgICAgKiAgVW5pdCBpcyBvbmUgcGFnZSBsZW5ndGguXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNjcm9sbF9zb21lKGRlbHRhKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICBTY3JvbGxNYW5hZ2VyLnByb3RvdHlwZS5zY3JvbGxfdG8gPSBmdW5jdGlvbihzZWxlY3Rvcikge1xuICAgICAgICAvKipcbiAgICAgICAgICogU2Nyb2xsIHRvIGFuIGVsZW1lbnQgaW4gdGhlIG5vdGVib29rLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5lbGVtZW50LmFuaW1hdGUoeydzY3JvbGxUb3AnOiAkKHNlbGVjdG9yKS5vZmZzZXQoKS50b3AgKyB0aGlzLmVsZW1lbnQuc2Nyb2xsVG9wKCkgLSB0aGlzLmVsZW1lbnQub2Zmc2V0KCkudG9wfSwgdGhpcy5hbmltYXRpb25fc3BlZWQpO1xuICAgIH07XG5cbiAgICBTY3JvbGxNYW5hZ2VyLnByb3RvdHlwZS5zY3JvbGxfc29tZSA9IGZ1bmN0aW9uKHBhZ2VzKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTY3JvbGwgdXAgb3IgZG93biBhIGdpdmVuIG51bWJlciBvZiBwYWdlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogUGFyYW1ldGVyc1xuICAgICAgICAgKiAtLS0tLS0tLS0tXG4gICAgICAgICAqIHBhZ2VzOiBpbnRlZ2VyXG4gICAgICAgICAqICBudW1iZXIgb2YgcGFnZXMgdG8gc2Nyb2xsIHRoZSBkb2N1bWVudCwgbWF5IGJlIHBvc2l0aXZlIG9yIG5lZ2F0aXZlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5lbGVtZW50LmFuaW1hdGUoeydzY3JvbGxUb3AnOiB0aGlzLmVsZW1lbnQuc2Nyb2xsVG9wKCkgKyBwYWdlcyAqIHRoaXMuZWxlbWVudC5oZWlnaHQoKX0sIHRoaXMuYW5pbWF0aW9uX3NwZWVkKTtcbiAgICB9O1xuXG4gICAgU2Nyb2xsTWFuYWdlci5wcm90b3R5cGUuZ2V0X2ZpcnN0X3Zpc2libGVfY2VsbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IHZpc2libGUgY2VsbCBpbiB0aGUgZG9jdW1lbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEZpcnN0LCBhdHRlbXB0IHRvIGJlIHNtYXJ0IGJ5IGd1ZXNzaW5nIHRoZSBpbmRleCBvZiB0aGUgY2VsbCB3ZSBhcmVcbiAgICAgICAgICogc2Nyb2xsZWQgdG8uICBUaGVuLCB3YWxrIGZyb20gdGhlcmUgdXAgb3IgZG93biB1bnRpbCB0aGUgcmlnaHQgY2VsbCBcbiAgICAgICAgICogaXMgZm91bmQuICBUbyBndWVzcyB0aGUgaW5kZXgsIGdldCB0aGUgdG9wIG9mIHRoZSBsYXN0IGNlbGwsIGFuZFxuICAgICAgICAgKiBkaXZpZGUgdGhhdCBieSB0aGUgbnVtYmVyIG9mIGNlbGxzIHRvIGdldCBhbiBhdmVyYWdlIGNlbGwgaGVpZ2h0LiAgXG4gICAgICAgICAqIFRoZW4gZGl2aWRlIHRoZSBzY3JvbGwgaGVpZ2h0IGJ5IHRoZSBhdmVyYWdlIGNlbGwgaGVpZ2h0LlxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIGNlbGxfY291bnQgPSB0aGlzLm5vdGVib29rLm5jZWxscygpO1xuICAgICAgICB2YXIgZmlyc3RfY2VsbF90b3AgPSB0aGlzLm5vdGVib29rLmdldF9jZWxsKDApLmVsZW1lbnQub2Zmc2V0KCkudG9wO1xuICAgICAgICB2YXIgbGFzdF9jZWxsX3RvcCA9IHRoaXMubm90ZWJvb2suZ2V0X2NlbGwoY2VsbF9jb3VudC0xKS5lbGVtZW50Lm9mZnNldCgpLnRvcDtcbiAgICAgICAgdmFyIGF2Z19jZWxsX2hlaWdodCA9IChsYXN0X2NlbGxfdG9wIC0gZmlyc3RfY2VsbF90b3ApIC8gY2VsbF9jb3VudDtcbiAgICAgICAgdmFyIGkgPSBNYXRoLmNlaWwodGhpcy5lbGVtZW50LnNjcm9sbFRvcCgpIC8gYXZnX2NlbGxfaGVpZ2h0KTtcbiAgICAgICAgaSA9IE1hdGgubWluKE1hdGgubWF4KGkgLCAwKSwgY2VsbF9jb3VudCAtIDEpO1xuXG4gICAgICAgIHdoaWxlICh0aGlzLm5vdGVib29rLmdldF9jZWxsKGkpLmVsZW1lbnQub2Zmc2V0KCkudG9wIC0gZmlyc3RfY2VsbF90b3AgPCB0aGlzLmVsZW1lbnQuc2Nyb2xsVG9wKCkgJiYgaSA8IGNlbGxfY291bnQgLSAxKSB7XG4gICAgICAgICAgICBpICs9IDE7XG4gICAgICAgIH0gXG5cbiAgICAgICAgd2hpbGUgKHRoaXMubm90ZWJvb2suZ2V0X2NlbGwoaSkuZWxlbWVudC5vZmZzZXQoKS50b3AgLSBmaXJzdF9jZWxsX3RvcCA+IHRoaXMuZWxlbWVudC5zY3JvbGxUb3AoKSAtIDUwICYmIGkgPj0gMCkge1xuICAgICAgICAgICAgaSAtPSAxO1xuICAgICAgICB9IFxuICAgICAgICByZXR1cm4gTWF0aC5taW4oaSArIDEsIGNlbGxfY291bnQgLSAxKTtcbiAgICB9O1xuXG5cbiAgICB2YXIgVGFyZ2V0U2Nyb2xsTWFuYWdlciA9IGZ1bmN0aW9uKG5vdGVib29rLCBvcHRpb25zKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQdWJsaWMgY29uc3RydWN0b3IuXG4gICAgICAgICAqL1xuICAgICAgICBTY3JvbGxNYW5hZ2VyLmFwcGx5KHRoaXMsIFtub3RlYm9vaywgb3B0aW9uc10pO1xuICAgIH07XG4gICAgVGFyZ2V0U2Nyb2xsTWFuYWdlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNjcm9sbE1hbmFnZXIucHJvdG90eXBlKTtcblxuICAgIFRhcmdldFNjcm9sbE1hbmFnZXIucHJvdG90eXBlLmlzX3RhcmdldCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2sgaWYgYSBjZWxsIHNob3VsZCBiZSBhIHNjcm9sbCBzdG9wLlxuICAgICAgICAgKlxuICAgICAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgY2VsbCBpcyBhIGNlbGwgdGhhdCB0aGUgc2Nyb2xsIG1hbmFnZXJcbiAgICAgICAgICogc2hvdWxkIHNjcm9sbCB0by4gIE90aGVyd2lzZSwgZmFsc2UgaXMgcmV0dXJuZWQuIFxuICAgICAgICAgKlxuICAgICAgICAgKiBQYXJhbWV0ZXJzXG4gICAgICAgICAqIC0tLS0tLS0tLS1cbiAgICAgICAgICogaW5kZXg6IGludGVnZXJcbiAgICAgICAgICogIGluZGV4IG9mIHRoZSBjZWxsIHRvIHRlc3QuXG4gICAgICAgICAqL1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIFRhcmdldFNjcm9sbE1hbmFnZXIucHJvdG90eXBlLnNjcm9sbCA9IGZ1bmN0aW9uIChkZWx0YSkge1xuICAgICAgICAvKipcbiAgICAgICAgICogU2Nyb2xsIHRoZSBkb2N1bWVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogUGFyYW1ldGVyc1xuICAgICAgICAgKiAtLS0tLS0tLS0tXG4gICAgICAgICAqIGRlbHRhOiBpbnRlZ2VyXG4gICAgICAgICAqICBkaXJlY3Rpb24gdG8gc2Nyb2xsIHRoZSBkb2N1bWVudC4gIFBvc2l0aXZlIGlzIGRvd253YXJkcy5cbiAgICAgICAgICogIFVuaXRzIGFyZSB0YXJnZXRzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUcnkgdG8gc2Nyb2xsIHRvIHRoZSBuZXh0IHNsaWRlLlxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIGNlbGxfY291bnQgPSB0aGlzLm5vdGVib29rLm5jZWxscygpO1xuICAgICAgICB2YXIgc2VsZWN0ZWRfaW5kZXggPSB0aGlzLmdldF9maXJzdF92aXNpYmxlX2NlbGwoKSArIGRlbHRhO1xuICAgICAgICB3aGlsZSAoMCA8PSBzZWxlY3RlZF9pbmRleCAmJiBzZWxlY3RlZF9pbmRleCA8IGNlbGxfY291bnQgJiYgIXRoaXMuaXNfdGFyZ2V0KHNlbGVjdGVkX2luZGV4KSkge1xuICAgICAgICAgICAgc2VsZWN0ZWRfaW5kZXggKz0gZGVsdGE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VsZWN0ZWRfaW5kZXggPCAwIHx8IGNlbGxfY291bnQgPD0gc2VsZWN0ZWRfaW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiBTY3JvbGxNYW5hZ2VyLnByb3RvdHlwZS5zY3JvbGwuYXBwbHkodGhpcywgW2RlbHRhXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbF90byh0aGlzLm5vdGVib29rLmdldF9jZWxsKHNlbGVjdGVkX2luZGV4KS5lbGVtZW50KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQ2FuY2VsIGJyb3dzZXIga2V5Ym9hcmQgc2Nyb2xsLlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcblxuXG4gICAgdmFyIFNsaWRlU2Nyb2xsTWFuYWdlciA9IGZ1bmN0aW9uKG5vdGVib29rLCBvcHRpb25zKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQdWJsaWMgY29uc3RydWN0b3IuXG4gICAgICAgICAqL1xuICAgICAgICBUYXJnZXRTY3JvbGxNYW5hZ2VyLmFwcGx5KHRoaXMsIFtub3RlYm9vaywgb3B0aW9uc10pO1xuICAgIH07XG4gICAgU2xpZGVTY3JvbGxNYW5hZ2VyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoVGFyZ2V0U2Nyb2xsTWFuYWdlci5wcm90b3R5cGUpO1xuXG4gICAgU2xpZGVTY3JvbGxNYW5hZ2VyLnByb3RvdHlwZS5pc190YXJnZXQgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgdmFyIGNlbGwgPSB0aGlzLm5vdGVib29rLmdldF9jZWxsKGluZGV4KTtcbiAgICAgICAgcmV0dXJuIGNlbGwubWV0YWRhdGEgJiYgY2VsbC5tZXRhZGF0YS5zbGlkZXNob3cgJiYgXG4gICAgICAgICAgICBjZWxsLm1ldGFkYXRhLnNsaWRlc2hvdy5zbGlkZV90eXBlICYmIFxuICAgICAgICAgICAgKGNlbGwubWV0YWRhdGEuc2xpZGVzaG93LnNsaWRlX3R5cGUgPT09IFwic2xpZGVcIiB8fFxuICAgICAgICAgICAgY2VsbC5tZXRhZGF0YS5zbGlkZXNob3cuc2xpZGVfdHlwZSA9PT0gXCJzdWJzbGlkZVwiKTtcbiAgICB9O1xuXG5cbiAgICB2YXIgSGVhZGluZ1Njcm9sbE1hbmFnZXIgPSBmdW5jdGlvbihub3RlYm9vaywgb3B0aW9ucykge1xuICAgICAgICAvKipcbiAgICAgICAgICogUHVibGljIGNvbnN0cnVjdG9yLlxuICAgICAgICAgKi9cbiAgICAgICAgU2Nyb2xsTWFuYWdlci5hcHBseSh0aGlzLCBbbm90ZWJvb2ssIG9wdGlvbnNdKTtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIHRoaXMuX2xldmVsID0gb3B0aW9ucy5oZWFkaW5nX2xldmVsIHx8IDE7XG4gICAgfTtcbiAgICBIZWFkaW5nU2Nyb2xsTWFuYWdlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNjcm9sbE1hbmFnZXIucHJvdG90eXBlKTtcblxuICAgIEhlYWRpbmdTY3JvbGxNYW5hZ2VyLnByb3RvdHlwZS5zY3JvbGwgPSBmdW5jdGlvbiAoZGVsdGEpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNjcm9sbCB0aGUgZG9jdW1lbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIFBhcmFtZXRlcnNcbiAgICAgICAgICogLS0tLS0tLS0tLVxuICAgICAgICAgKiBkZWx0YTogaW50ZWdlclxuICAgICAgICAgKiAgZGlyZWN0aW9uIHRvIHNjcm9sbCB0aGUgZG9jdW1lbnQuICBQb3NpdGl2ZSBpcyBkb3dud2FyZHMuXG4gICAgICAgICAqICBVbml0cyBhcmUgaGVhZGVycy5cbiAgICAgICAgICpcbiAgICAgICAgICogR2V0IGFsbCBvZiB0aGUgaGVhZGVyIGVsZW1lbnRzIHRoYXQgbWF0Y2ggdGhlIGhlYWRpbmcgbGV2ZWwgb3IgYXJlIG9mXG4gICAgICAgICAqIGdyZWF0ZXIgbWFnbml0dWRlIChhIHNtYWxsZXIgaGVhZGVyIG51bWJlcikuXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgaGVhZGVycyA9ICQoKTtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPD0gdGhpcy5fbGV2ZWw7IGkrKykge1xuICAgICAgICAgICAgaGVhZGVycyA9IGhlYWRlcnMuYWRkKCcjbm90ZWJvb2stY29udGFpbmVyIGgnICsgaSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGaW5kIHRoZSBoZWFkZXIgdGhlIHVzZXIgaXMgb24gb3IgYmVsb3cuXG4gICAgICAgIHZhciBmaXJzdF9jZWxsX3RvcCA9IHRoaXMubm90ZWJvb2suZ2V0X2NlbGwoMCkuZWxlbWVudC5vZmZzZXQoKS50b3A7XG4gICAgICAgIHZhciBjdXJyZW50X3Njcm9sbCA9IHRoaXMuZWxlbWVudC5zY3JvbGxUb3AoKTtcbiAgICAgICAgdmFyIGhlYWRlcl9zY3JvbGwgPSAwO1xuICAgICAgICBpID0gLTE7XG4gICAgICAgIHdoaWxlIChjdXJyZW50X3Njcm9sbCA+PSBoZWFkZXJfc2Nyb2xsICYmIGkgPCBoZWFkZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKCsraSA8IGhlYWRlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyX3Njcm9sbCA9ICQoaGVhZGVyc1tpXSkub2Zmc2V0KCkudG9wIC0gZmlyc3RfY2VsbF90b3A7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaS0tO1xuXG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSB1c2VyIGlzIGJlbG93IHRoZSBoZWFkZXIuXG4gICAgICAgIGlmIChpIDwgMCB8fCBjdXJyZW50X3Njcm9sbCA+ICQoaGVhZGVyc1tpXSkub2Zmc2V0KCkudG9wIC0gZmlyc3RfY2VsbF90b3AgKyAzMCkge1xuICAgICAgICAgICAgLy8gQmVsb3cgdGhlIGhlYWRlciwgY291bnQgdGhlIGhlYWRlciBhcyBhIHRhcmdldC5cbiAgICAgICAgICAgIGlmIChkZWx0YSA8IDApIHtcbiAgICAgICAgICAgICAgICBkZWx0YSArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGkgKz0gZGVsdGE7XG5cbiAgICAgICAgLy8gU2Nyb2xsIVxuICAgICAgICBpZiAoMCA8PSBpICYmIGkgPCBoZWFkZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxfdG8oaGVhZGVyc1tpXSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBEZWZhdWx0IHRvIHRoZSBiYXNlJ3Mgc2Nyb2xsIGJlaGF2aW9yIHdoZW4gdGFyZ2V0IGhlYWRlciBkb2Vzbid0XG4gICAgICAgICAgICAvLyBleGlzdC5cbiAgICAgICAgICAgIHJldHVybiBTY3JvbGxNYW5hZ2VyLnByb3RvdHlwZS5zY3JvbGwuYXBwbHkodGhpcywgW2RlbHRhXSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gUmV0dXJuIG5hZW1zcGFjZSBmb3IgcmVxdWlyZS5qcyBsb2Fkc1xuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICAnU2Nyb2xsTWFuYWdlcic6IFNjcm9sbE1hbmFnZXIsXG4gICAgICAgICdTbGlkZVNjcm9sbE1hbmFnZXInOiBTbGlkZVNjcm9sbE1hbmFnZXIsXG4gICAgICAgICdIZWFkaW5nU2Nyb2xsTWFuYWdlcic6IEhlYWRpbmdTY3JvbGxNYW5hZ2VyLFxuICAgICAgICAnVGFyZ2V0U2Nyb2xsTWFuYWdlcic6IFRhcmdldFNjcm9sbE1hbmFnZXJcbiAgICB9O1xuIiwiLy8gQ29weXJpZ2h0IChjKSBKdXB5dGVyIERldmVsb3BtZW50IFRlYW0uXG4vLyBEaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIE1vZGlmaWVkIEJTRCBMaWNlbnNlLlxuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgdmFyIHV0aWxzID0gcmVxdWlyZSgnYmFzZS9qcy91dGlscycpO1xuICAgIHZhciBjZWxsID0gcmVxdWlyZSgnbm90ZWJvb2svanMvY2VsbCcpO1xuICAgIHZhciBzZWN1cml0eSA9IHJlcXVpcmUoJ2Jhc2UvanMvc2VjdXJpdHknKTtcbiAgICB2YXIgY29uZmlnbW9kID0gcmVxdWlyZSgnc2VydmljZXMvY29uZmlnJyk7XG4gICAgdmFyIG1hdGhqYXh1dGlscyA9IHJlcXVpcmUoJ25vdGVib29rL2pzL21hdGhqYXh1dGlscycpO1xuICAgIHZhciBjZWxsdG9vbGJhciA9IHJlcXVpcmUoJ25vdGVib29rL2pzL2NlbGx0b29sYmFyJyk7XG4gICAgdmFyIG1hcmtlZCA9IHJlcXVpcmUoJ21hcmtlZCcpO1xuXG4gICAgdmFyIENlbGwgPSBjZWxsLkNlbGw7XG5cbiAgICB2YXIgVGV4dENlbGwgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29uc3RydWN0b3JcbiAgICAgICAgICpcbiAgICAgICAgICogQ29uc3RydWN0IGEgbmV3IFRleHRDZWxsLCBjb2RlbWlycm9yIG1vZGUgaXMgYnkgZGVmYXVsdCAnaHRtbG1peGVkJywgXG4gICAgICAgICAqIGFuZCBjZWxsIHR5cGUgaXMgJ3RleHQnIGNlbGwgc3RhcnQgYXMgbm90IHJlZGVyZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIFBhcmFtZXRlcnM6XG4gICAgICAgICAqICBvcHRpb25zOiBkaWN0aW9uYXJ5XG4gICAgICAgICAqICAgICAgRGljdGlvbmFyeSBvZiBrZXl3b3JkIGFyZ3VtZW50cy5cbiAgICAgICAgICogICAgICAgICAgZXZlbnRzOiAkKEV2ZW50cykgaW5zdGFuY2UgXG4gICAgICAgICAqICAgICAgICAgIGNvbmZpZzogZGljdGlvbmFyeVxuICAgICAgICAgKiAgICAgICAgICBrZXlib2FyZF9tYW5hZ2VyOiBLZXlib2FyZE1hbmFnZXIgaW5zdGFuY2UgXG4gICAgICAgICAqICAgICAgICAgIG5vdGVib29rOiBOb3RlYm9vayBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgLy8gaW4gYWxsIFRleHRDZWxsL0NlbGwgc3ViY2xhc3Nlc1xuICAgICAgICAvLyBkbyBub3QgYXNzaWduIG1vc3Qgb2YgbWVtYmVycyBoZXJlLCBqdXN0IHBhc3MgaXQgZG93blxuICAgICAgICAvLyBpbiB0aGUgb3B0aW9ucyBkaWN0IHBvdGVudGlhbGx5IG92ZXJ3cml0aW5nIHdoYXQgeW91IHdpc2guXG4gICAgICAgIC8vIHRoZXkgd2lsbCBiZSBhc3NpZ25lZCBpbiB0aGUgYmFzZSBjbGFzcy5cbiAgICAgICAgdGhpcy5ub3RlYm9vayA9IG9wdGlvbnMubm90ZWJvb2s7XG4gICAgICAgIHRoaXMuZXZlbnRzID0gb3B0aW9ucy5ldmVudHM7XG4gICAgICAgIHRoaXMuY29uZmlnID0gb3B0aW9ucy5jb25maWc7XG4gICAgICAgIFxuICAgICAgICAvLyB3ZSBjYW5ub3QgcHV0IHRoaXMgYXMgYSBjbGFzcyBrZXkgYXMgaXQgaGFzIGhhbmRsZSB0byBcInRoaXNcIi5cbiAgICAgICAgdmFyIGNvbmZpZyA9IHV0aWxzLm1lcmdlb3B0KFRleHRDZWxsLCB0aGlzLmNvbmZpZyk7XG4gICAgICAgIENlbGwuYXBwbHkodGhpcywgW3tcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnOiBjb25maWcsIFxuICAgICAgICAgICAgICAgICAgICBrZXlib2FyZF9tYW5hZ2VyOiBvcHRpb25zLmtleWJvYXJkX21hbmFnZXIsIFxuICAgICAgICAgICAgICAgICAgICBldmVudHM6IHRoaXMuZXZlbnRzfV0pO1xuXG4gICAgICAgIHRoaXMuY2VsbF90eXBlID0gdGhpcy5jZWxsX3R5cGUgfHwgJ3RleHQnO1xuICAgICAgICBtYXRoamF4dXRpbHMgPSBtYXRoamF4dXRpbHM7XG4gICAgICAgIHRoaXMucmVuZGVyZWQgPSBmYWxzZTtcbiAgICB9O1xuXG4gICAgVGV4dENlbGwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDZWxsLnByb3RvdHlwZSk7XG5cbiAgICBUZXh0Q2VsbC5vcHRpb25zX2RlZmF1bHQgPSB7XG4gICAgICAgIGNtX2NvbmZpZyA6IHtcbiAgICAgICAgICAgIGV4dHJhS2V5czoge1wiVGFiXCI6IFwiaW5kZW50TW9yZVwiLFwiU2hpZnQtVGFiXCIgOiBcImluZGVudExlc3NcIn0sXG4gICAgICAgICAgICBtb2RlOiAnaHRtbG1peGVkJyxcbiAgICAgICAgICAgIGxpbmVXcmFwcGluZyA6IHRydWUsXG4gICAgICAgIH1cbiAgICB9O1xuXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgdGhlIERPTSBlbGVtZW50IG9mIHRoZSBUZXh0Q2VsbFxuICAgICAqIEBtZXRob2QgY3JlYXRlX2VsZW1lbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFRleHRDZWxsLnByb3RvdHlwZS5jcmVhdGVfZWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgQ2VsbC5wcm90b3R5cGUuY3JlYXRlX2VsZW1lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgIHZhciBjZWxsID0gJChcIjxkaXY+XCIpLmFkZENsYXNzKCdjZWxsIHRleHRfY2VsbCcpO1xuICAgICAgICBjZWxsLmF0dHIoJ3RhYmluZGV4JywnMicpO1xuXG4gICAgICAgIHZhciBwcm9tcHQgPSAkKCc8ZGl2Lz4nKS5hZGRDbGFzcygncHJvbXB0IGlucHV0X3Byb21wdCcpO1xuICAgICAgICBjZWxsLmFwcGVuZChwcm9tcHQpO1xuICAgICAgICB2YXIgaW5uZXJfY2VsbCA9ICQoJzxkaXYvPicpLmFkZENsYXNzKCdpbm5lcl9jZWxsJyk7XG4gICAgICAgIHRoaXMuY2VsbHRvb2xiYXIgPSBuZXcgY2VsbHRvb2xiYXIuQ2VsbFRvb2xiYXIoe1xuICAgICAgICAgICAgY2VsbDogdGhpcywgXG4gICAgICAgICAgICBub3RlYm9vazogdGhpcy5ub3RlYm9va30pO1xuICAgICAgICBpbm5lcl9jZWxsLmFwcGVuZCh0aGlzLmNlbGx0b29sYmFyLmVsZW1lbnQpO1xuICAgICAgICB2YXIgaW5wdXRfYXJlYSA9ICQoJzxkaXYvPicpLmFkZENsYXNzKCdpbnB1dF9hcmVhJyk7XG4gICAgICAgIHRoaXMuY29kZV9taXJyb3IgPSBuZXcgQ29kZU1pcnJvcihpbnB1dF9hcmVhLmdldCgwKSwgdGhpcy5fb3B0aW9ucy5jbV9jb25maWcpO1xuICAgICAgICAvLyBJbiBjYXNlIG9mIGJ1Z3MgdGhhdCBwdXQgdGhlIGtleWJvYXJkIG1hbmFnZXIgaW50byBhbiBpbmNvbnNpc3RlbnQgc3RhdGUsXG4gICAgICAgIC8vIGVuc3VyZSBLTSBpcyBlbmFibGVkIHdoZW4gQ29kZU1pcnJvciBpcyBmb2N1c2VkOlxuICAgICAgICB0aGlzLmNvZGVfbWlycm9yLm9uKCdmb2N1cycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGF0LmtleWJvYXJkX21hbmFnZXIpIHtcbiAgICAgICAgICAgICAgICB0aGF0LmtleWJvYXJkX21hbmFnZXIuZW5hYmxlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNvZGVfbWlycm9yLm9uKCdrZXlkb3duJywgJC5wcm94eSh0aGlzLmhhbmRsZV9rZXlldmVudCx0aGlzKSlcbiAgICAgICAgLy8gVGhlIHRhYmluZGV4PS0xIG1ha2VzIHRoaXMgZGl2IGZvY3VzYWJsZS5cbiAgICAgICAgdmFyIHJlbmRlcl9hcmVhID0gJCgnPGRpdi8+JykuYWRkQ2xhc3MoJ3RleHRfY2VsbF9yZW5kZXIgcmVuZGVyZWRfaHRtbCcpXG4gICAgICAgICAgICAuYXR0cigndGFiaW5kZXgnLCctMScpO1xuICAgICAgICBpbm5lcl9jZWxsLmFwcGVuZChpbnB1dF9hcmVhKS5hcHBlbmQocmVuZGVyX2FyZWEpO1xuICAgICAgICBjZWxsLmFwcGVuZChpbm5lcl9jZWxsKTtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gY2VsbDtcbiAgICB9O1xuXG5cbiAgICAvLyBDZWxsIGxldmVsIGFjdGlvbnNcblxuICAgIFRleHRDZWxsLnByb3RvdHlwZS5zZWxlY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb250ID0gQ2VsbC5wcm90b3R5cGUuc2VsZWN0LmFwcGx5KHRoaXMpO1xuICAgICAgICBpZiAoY29udCkge1xuICAgICAgICAgICAgaWYgKHRoaXMubW9kZSA9PT0gJ2VkaXQnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb2RlX21pcnJvci5yZWZyZXNoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnQ7XG4gICAgfTtcblxuICAgIFRleHRDZWxsLnByb3RvdHlwZS51bnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbnQgPSBDZWxsLnByb3RvdHlwZS51bnJlbmRlci5hcHBseSh0aGlzKTtcbiAgICAgICAgaWYgKGNvbnQpIHtcbiAgICAgICAgICAgIHZhciB0ZXh0X2NlbGwgPSB0aGlzLmVsZW1lbnQ7XG4gICAgICAgICAgICBpZiAodGhpcy5nZXRfdGV4dCgpID09PSB0aGlzLnBsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRfdGV4dCgnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29udDtcbiAgICB9O1xuXG4gICAgVGV4dENlbGwucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHNldHRlcjoge3sjY3Jvc3NMaW5rIFwiVGV4dENlbGwvc2V0X3RleHRcIn19e3svY3Jvc3NMaW5rfX1cbiAgICAgKiBAbWV0aG9kIGdldF90ZXh0XG4gICAgICogQHJldHJ1biB7c3RyaW5nfSBDb2RlTWlycm9yIGN1cnJlbnQgdGV4dCB2YWx1ZVxuICAgICAqL1xuICAgIFRleHRDZWxsLnByb3RvdHlwZS5nZXRfdGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2RlX21pcnJvci5nZXRWYWx1ZSgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIENvZGVtaXJvciB0ZXh0IHZhbHVlXG4gICAgICogQHNlZSBUZXh0Q2VsbCNnZXRfdGV4dFxuICAgICAqIEBtZXRob2Qgc2V0X3RleHRcbiAgICAgKiAqL1xuICAgIFRleHRDZWxsLnByb3RvdHlwZS5zZXRfdGV4dCA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgICAgdGhpcy5jb2RlX21pcnJvci5zZXRWYWx1ZSh0ZXh0KTtcbiAgICAgICAgdGhpcy51bnJlbmRlcigpO1xuICAgICAgICB0aGlzLmNvZGVfbWlycm9yLnJlZnJlc2goKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogc2V0dGVyIDp7eyNjcm9zc0xpbmsgXCJUZXh0Q2VsbC9zZXRfcmVuZGVyZWRcIn19e3svY3Jvc3NMaW5rfX1cbiAgICAgKiBAbWV0aG9kIGdldF9yZW5kZXJlZFxuICAgICAqICovXG4gICAgVGV4dENlbGwucHJvdG90eXBlLmdldF9yZW5kZXJlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50LmZpbmQoJ2Rpdi50ZXh0X2NlbGxfcmVuZGVyJykuaHRtbCgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAbWV0aG9kIHNldF9yZW5kZXJlZFxuICAgICAqL1xuICAgIFRleHRDZWxsLnByb3RvdHlwZS5zZXRfcmVuZGVyZWQgPSBmdW5jdGlvbih0ZXh0KSB7XG4gICAgICAgIHRoaXMuZWxlbWVudC5maW5kKCdkaXYudGV4dF9jZWxsX3JlbmRlcicpLmh0bWwodGV4dCk7XG4gICAgfTtcblxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIFRleHQgY2VsbCBmcm9tIEpTT05cbiAgICAgKiBAcGFyYW0ge2pzb259IGRhdGEgLSBKU09OIHNlcmlhbGl6ZWQgdGV4dC1jZWxsXG4gICAgICogQG1ldGhvZCBmcm9tSlNPTlxuICAgICAqL1xuICAgIFRleHRDZWxsLnByb3RvdHlwZS5mcm9tSlNPTiA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIENlbGwucHJvdG90eXBlLmZyb21KU09OLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGlmIChkYXRhLmNlbGxfdHlwZSA9PT0gdGhpcy5jZWxsX3R5cGUpIHtcbiAgICAgICAgICAgIGlmIChkYXRhLnNvdXJjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRfdGV4dChkYXRhLnNvdXJjZSk7XG4gICAgICAgICAgICAgICAgLy8gbWFrZSB0aGlzIHZhbHVlIHRoZSBzdGFydGluZyBwb2ludCwgc28gdGhhdCB3ZSBjYW4gb25seSB1bmRvXG4gICAgICAgICAgICAgICAgLy8gdG8gdGhpcyBzdGF0ZSwgaW5zdGVhZCBvZiBhIGJsYW5rIGNlbGxcbiAgICAgICAgICAgICAgICB0aGlzLmNvZGVfbWlycm9yLmNsZWFySGlzdG9yeSgpO1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IFRoaXMgSFRNTCBuZWVkcyB0byBiZSB0cmVhdGVkIGFzIHBvdGVudGlhbGx5IGRhbmdlcm91c1xuICAgICAgICAgICAgICAgIC8vIHVzZXIgaW5wdXQgYW5kIHNob3VsZCBiZSBoYW5kbGVkIGJlZm9yZSBzZXRfcmVuZGVyZWQuICAgICAgICAgXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRfcmVuZGVyZWQoZGF0YS5yZW5kZXJlZCB8fCAnJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqIEdlbmVyYXRlIEpTT04gZnJvbSBjZWxsXG4gICAgICogQHJldHVybiB7b2JqZWN0fSBjZWxsIGRhdGEgc2VyaWFsaXNlZCB0byBqc29uXG4gICAgICovXG4gICAgVGV4dENlbGwucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBDZWxsLnByb3RvdHlwZS50b0pTT04uYXBwbHkodGhpcyk7XG4gICAgICAgIGRhdGEuc291cmNlID0gdGhpcy5nZXRfdGV4dCgpO1xuICAgICAgICBpZiAoZGF0YS5zb3VyY2UgPT0gdGhpcy5wbGFjZWhvbGRlcikge1xuICAgICAgICAgICAgZGF0YS5zb3VyY2UgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH07XG5cblxuICAgIHZhciBNYXJrZG93bkNlbGwgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29uc3RydWN0b3JcbiAgICAgICAgICpcbiAgICAgICAgICogUGFyYW1ldGVyczpcbiAgICAgICAgICogIG9wdGlvbnM6IGRpY3Rpb25hcnlcbiAgICAgICAgICogICAgICBEaWN0aW9uYXJ5IG9mIGtleXdvcmQgYXJndW1lbnRzLlxuICAgICAgICAgKiAgICAgICAgICBldmVudHM6ICQoRXZlbnRzKSBpbnN0YW5jZSBcbiAgICAgICAgICogICAgICAgICAgY29uZmlnOiBDb25maWdTZWN0aW9uIGluc3RhbmNlXG4gICAgICAgICAqICAgICAgICAgIGtleWJvYXJkX21hbmFnZXI6IEtleWJvYXJkTWFuYWdlciBpbnN0YW5jZSBcbiAgICAgICAgICogICAgICAgICAgbm90ZWJvb2s6IE5vdGVib29rIGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgdmFyIGNvbmZpZyA9IHV0aWxzLm1lcmdlb3B0KE1hcmtkb3duQ2VsbCwge30pO1xuICAgICAgICB0aGlzLmNsYXNzX2NvbmZpZyA9IG5ldyBjb25maWdtb2QuQ29uZmlnV2l0aERlZmF1bHRzKG9wdGlvbnMuY29uZmlnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7fSwgJ01hcmtkb3duQ2VsbCcpO1xuICAgICAgICBUZXh0Q2VsbC5hcHBseSh0aGlzLCBbJC5leHRlbmQoe30sIG9wdGlvbnMsIHtjb25maWc6IGNvbmZpZ30pXSk7XG5cbiAgICAgICAgdGhpcy5jZWxsX3R5cGUgPSAnbWFya2Rvd24nO1xuICAgIH07XG5cbiAgICBNYXJrZG93bkNlbGwub3B0aW9uc19kZWZhdWx0ID0ge1xuICAgICAgICBjbV9jb25maWc6IHtcbiAgICAgICAgICAgIG1vZGU6ICdpcHl0aG9uZ2ZtJ1xuICAgICAgICB9LFxuICAgICAgICBwbGFjZWhvbGRlcjogXCJUeXBlICpNYXJrZG93biogYW5kIExhVGVYOiAkXFxcXGFscGhhXjIkXCJcbiAgICB9O1xuXG4gICAgTWFya2Rvd25DZWxsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoVGV4dENlbGwucHJvdG90eXBlKTtcblxuICAgIE1hcmtkb3duQ2VsbC5wcm90b3R5cGUuc2V0X2hlYWRpbmdfbGV2ZWwgPSBmdW5jdGlvbiAobGV2ZWwpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIG1ha2UgYSBtYXJrZG93biBjZWxsIGEgaGVhZGluZ1xuICAgICAgICAgKi9cbiAgICAgICAgbGV2ZWwgPSBsZXZlbCB8fCAxO1xuICAgICAgICB2YXIgc291cmNlID0gdGhpcy5nZXRfdGV4dCgpO1xuICAgICAgICBzb3VyY2UgPSBzb3VyY2UucmVwbGFjZSgvXigjKilcXHM/LyxcbiAgICAgICAgICAgIG5ldyBBcnJheShsZXZlbCArIDEpLmpvaW4oJyMnKSArICcgJyk7XG4gICAgICAgIHRoaXMuc2V0X3RleHQoc291cmNlKTtcbiAgICAgICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgICAgIGlmICh0aGlzLnJlbmRlcmVkKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBtZXRob2QgcmVuZGVyXG4gICAgICovXG4gICAgTWFya2Rvd25DZWxsLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb250ID0gVGV4dENlbGwucHJvdG90eXBlLnJlbmRlci5hcHBseSh0aGlzKTtcbiAgICAgICAgaWYgKGNvbnQpIHtcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgIHZhciB0ZXh0ID0gdGhpcy5nZXRfdGV4dCgpO1xuICAgICAgICAgICAgdmFyIG1hdGggPSBudWxsO1xuICAgICAgICAgICAgaWYgKHRleHQgPT09IFwiXCIpIHsgdGV4dCA9IHRoaXMucGxhY2Vob2xkZXI7IH1cbiAgICAgICAgICAgIHZhciB0ZXh0X2FuZF9tYXRoID0gbWF0aGpheHV0aWxzLnJlbW92ZV9tYXRoKHRleHQpO1xuICAgICAgICAgICAgdGV4dCA9IHRleHRfYW5kX21hdGhbMF07XG4gICAgICAgICAgICBtYXRoID0gdGV4dF9hbmRfbWF0aFsxXTtcbiAgICAgICAgICAgIG1hcmtlZCh0ZXh0LCBmdW5jdGlvbiAoZXJyLCBodG1sKSB7XG4gICAgICAgICAgICAgICAgaHRtbCA9IG1hdGhqYXh1dGlscy5yZXBsYWNlX21hdGgoaHRtbCwgbWF0aCk7XG4gICAgICAgICAgICAgICAgaHRtbCA9IHNlY3VyaXR5LnNhbml0aXplX2h0bWwoaHRtbCk7XG4gICAgICAgICAgICAgICAgaHRtbCA9ICQoJC5wYXJzZUhUTUwoaHRtbCkpO1xuICAgICAgICAgICAgICAgIC8vIGFkZCBhbmNob3JzIHRvIGhlYWRpbmdzXG4gICAgICAgICAgICAgICAgaHRtbC5maW5kKFwiOmhlYWRlclwiKS5hZGRCYWNrKFwiOmhlYWRlclwiKS5lYWNoKGZ1bmN0aW9uIChpLCBoKSB7XG4gICAgICAgICAgICAgICAgICAgIGggPSAkKGgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaGFzaCA9IGgudGV4dCgpLnJlcGxhY2UoLyAvZywgJy0nKTtcbiAgICAgICAgICAgICAgICAgICAgaC5hdHRyKCdpZCcsIGhhc2gpO1xuICAgICAgICAgICAgICAgICAgICBoLmFwcGVuZChcbiAgICAgICAgICAgICAgICAgICAgICAgICQoJzxhLz4nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcygnYW5jaG9yLWxpbmsnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdocmVmJywgJyMnICsgaGFzaClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGV4dCgnwrYnKVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIGxpbmtzIGluIG1hcmtkb3duIGNlbGxzIHNob3VsZCBvcGVuIGluIG5ldyB0YWJzXG4gICAgICAgICAgICAgICAgaHRtbC5maW5kKFwiYVtocmVmXVwiKS5ub3QoJ1tocmVmXj1cIiNcIl0nKS5hdHRyKFwidGFyZ2V0XCIsIFwiX2JsYW5rXCIpO1xuICAgICAgICAgICAgICAgIHRoYXQuc2V0X3JlbmRlcmVkKGh0bWwpO1xuICAgICAgICAgICAgICAgIHRoYXQudHlwZXNldCgpO1xuICAgICAgICAgICAgICAgIHRoYXQuZXZlbnRzLnRyaWdnZXIoXCJyZW5kZXJlZC5NYXJrZG93bkNlbGxcIiwge2NlbGw6IHRoYXR9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb250O1xuICAgIH07XG5cblxuICAgIHZhciBSYXdDZWxsID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnN0cnVjdG9yXG4gICAgICAgICAqXG4gICAgICAgICAqIFBhcmFtZXRlcnM6XG4gICAgICAgICAqICBvcHRpb25zOiBkaWN0aW9uYXJ5XG4gICAgICAgICAqICAgICAgRGljdGlvbmFyeSBvZiBrZXl3b3JkIGFyZ3VtZW50cy5cbiAgICAgICAgICogICAgICAgICAgZXZlbnRzOiAkKEV2ZW50cykgaW5zdGFuY2UgXG4gICAgICAgICAqICAgICAgICAgIGNvbmZpZzogQ29uZmlnU2VjdGlvbiBpbnN0YW5jZVxuICAgICAgICAgKiAgICAgICAgICBrZXlib2FyZF9tYW5hZ2VyOiBLZXlib2FyZE1hbmFnZXIgaW5zdGFuY2UgXG4gICAgICAgICAqICAgICAgICAgIG5vdGVib29rOiBOb3RlYm9vayBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIHZhciBjb25maWcgPSB1dGlscy5tZXJnZW9wdChSYXdDZWxsLCB7fSk7XG4gICAgICAgIFRleHRDZWxsLmFwcGx5KHRoaXMsIFskLmV4dGVuZCh7fSwgb3B0aW9ucywge2NvbmZpZzogY29uZmlnfSldKTtcblxuICAgICAgICB0aGlzLmNsYXNzX2NvbmZpZyA9IG5ldyBjb25maWdtb2QuQ29uZmlnV2l0aERlZmF1bHRzKG9wdGlvbnMuY29uZmlnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBSYXdDZWxsLmNvbmZpZ19kZWZhdWx0cywgJ1Jhd0NlbGwnKTtcbiAgICAgICAgdGhpcy5jZWxsX3R5cGUgPSAncmF3JztcbiAgICB9O1xuXG4gICAgUmF3Q2VsbC5vcHRpb25zX2RlZmF1bHQgPSB7XG4gICAgICAgIHBsYWNlaG9sZGVyIDogXCJXcml0ZSByYXcgTGFUZVggb3Igb3RoZXIgZm9ybWF0cyBoZXJlLCBmb3IgdXNlIHdpdGggbmJjb252ZXJ0LiBcIiArXG4gICAgICAgICAgICBcIkl0IHdpbGwgbm90IGJlIHJlbmRlcmVkIGluIHRoZSBub3RlYm9vay4gXCIgKyBcbiAgICAgICAgICAgIFwiV2hlbiBwYXNzaW5nIHRocm91Z2ggbmJjb252ZXJ0LCBhIFJhdyBDZWxsJ3MgY29udGVudCBpcyBhZGRlZCB0byB0aGUgb3V0cHV0IHVubW9kaWZpZWQuXCJcbiAgICB9O1xuXG4gICAgUmF3Q2VsbC5jb25maWdfZGVmYXVsdHMgPSAge1xuICAgICAgICBoaWdobGlnaHRfbW9kZXMgOiB7XG4gICAgICAgICAgICAnZGlmZicgICAgICAgICA6eydyZWcnOlsvXmRpZmYvXX1cbiAgICAgICAgfSxcbiAgICB9O1xuXG4gICAgUmF3Q2VsbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFRleHRDZWxsLnByb3RvdHlwZSk7XG5cbiAgICAvKiogQG1ldGhvZCBiaW5kX2V2ZW50cyAqKi9cbiAgICBSYXdDZWxsLnByb3RvdHlwZS5iaW5kX2V2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgVGV4dENlbGwucHJvdG90eXBlLmJpbmRfZXZlbnRzLmFwcGx5KHRoaXMpO1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIHRoaXMuZWxlbWVudC5mb2N1c291dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoYXQuYXV0b19oaWdobGlnaHQoKTtcbiAgICAgICAgICAgIHRoYXQucmVuZGVyKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuY29kZV9taXJyb3Iub24oJ2ZvY3VzJywgZnVuY3Rpb24oKSB7IHRoYXQudW5yZW5kZXIoKTsgfSk7XG4gICAgfTtcblxuICAgIC8qKiBAbWV0aG9kIHJlbmRlciAqKi9cbiAgICBSYXdDZWxsLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb250ID0gVGV4dENlbGwucHJvdG90eXBlLnJlbmRlci5hcHBseSh0aGlzKTtcbiAgICAgICAgaWYgKGNvbnQpe1xuICAgICAgICAgICAgdmFyIHRleHQgPSB0aGlzLmdldF90ZXh0KCk7XG4gICAgICAgICAgICBpZiAodGV4dCA9PT0gXCJcIikgeyB0ZXh0ID0gdGhpcy5wbGFjZWhvbGRlcjsgfVxuICAgICAgICAgICAgdGhpcy5zZXRfdGV4dCh0ZXh0KTtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5yZW1vdmVDbGFzcygncmVuZGVyZWQnKTtcbiAgICAgICAgICAgIHRoaXMuYXV0b19oaWdobGlnaHQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29udDtcbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIFRleHRDZWxsOiBUZXh0Q2VsbCxcbiAgICAgICAgTWFya2Rvd25DZWxsOiBNYXJrZG93bkNlbGwsXG4gICAgICAgIFJhd0NlbGw6IFJhd0NlbGxcbiAgICB9O1xuIiwiLy8gQ29weXJpZ2h0IChjKSBKdXB5dGVyIERldmVsb3BtZW50IFRlYW0uXG4vLyBEaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIE1vZGlmaWVkIEJTRCBMaWNlbnNlLlxuXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAvKipcbiAgICAgKiBBIGdlbmVyaWMgdG9vbGJhciBvbiB3aGljaCBvbmUgY2FuIGFkZCBidXR0b25cbiAgICAgKiBAY2xhc3MgVG9vbEJhclxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7RG9tX29iamVjdH0gc2VsZWN0b3JcbiAgICAgKi9cbiAgICB2YXIgVG9vbEJhciA9IGZ1bmN0aW9uIChzZWxlY3Rvciwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLnNlbGVjdG9yID0gc2VsZWN0b3I7XG4gICAgICAgIHRoaXMuYWN0aW9ucyA9IChvcHRpb25zfHx7fSkuYWN0aW9ucztcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0b3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50ID0gJChzZWxlY3Rvcik7XG4gICAgICAgICAgICB0aGlzLnN0eWxlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgVG9vbEJhci5wcm90b3R5cGUuX3BzZXVkb19hY3Rpb25zPXt9O1xuXG5cbiAgICBUb29sQmFyLnByb3RvdHlwZS5jb25zdHJ1Y3QgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIGZvcih2YXIgaz0wOyBrPGNvbmZpZy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgdGhpcy5hZGRfYnV0dG9uc19ncm91cChjb25maWdba11bMF0sY29uZmlnW2tdWzFdKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiAgQWRkIGEgZ3JvdXAgb2YgYnV0dG9uIGludG8gdGhlIGN1cnJlbnQgdG9vbGJhci5cbiAgICAgKlxuICAgICAqICBVc2UgYSBbZGljdCBvZiBbbGlzdCBvZiBhY3Rpb24gbmFtZV1dIHRvIHRyaWdnZXJcbiAgICAgKiAgb24gY2xpY2sgdG8gdGhlIGJ1dHRvblxuICAgICAqXG4gICAgICogIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAgICAgIC4uLiB0b2RvLCBtYXliZSB1c2UgYSBsaXN0IG9mICBsaXN0IHRvIGtlZXAgb3JkZXJpbmcuXG4gICAgICpcbiAgICAgKiAgICAgIFtcbiAgICAgKiAgICAgICAgICBbXG4gICAgICogICAgICAgICAgICBbXG4gICAgICogICAgICAgICAgICAgIGFjdGlvbl9uYW1lXzEsXG4gICAgICogICAgICAgICAgICAgIGFjdGlvbl9uYW1lXzIsXG4gICAgICogICAgICAgICAgICAgIGFjdGlvbl9uYW1lXzMsXG4gICAgICogICAgICAgICAgICBdLFxuICAgICAqICAgICAgICAgICAgb3B0aW9uYWxfZ3JvdXBfbmFtZVxuICAgICAqICAgICAgICAgIF0sXG4gICAgICogICAgICAgICAgLi4uXG4gICAgICogICAgICBdXG4gICAgICpcbiAgICAgKiAgQHBhcmFtIGxpc3Qge0xpc3R9XG4gICAgICogICAgICBMaXN0IG9mIGJ1dHRvbiBvZiB0aGUgZ3JvdXAsIHdpdGggdGhlIGZvbGxvd2luZyBwYXJhbXRlciBmb3IgZWFjaCA6XG4gICAgICogICAgICBAcGFyYW0gbGlzdC5sYWJlbCB7c3RyaW5nfSB0ZXh0IHRvIHNob3cgb24gYnV0dG9uIGhvdmVyXG4gICAgICogICAgICBAcGFyYW0gbGlzdC5pY29uIHtzdHJpbmd9IGljb24gdG8gY2hvb3NlIGZyb20gW0ZvbnQgQXdlc29tZV0oaHR0cDovL2ZvcnRhd2Vzb21lLmdpdGh1Yi5pby9Gb250LUF3ZXNvbWUpXG4gICAgICogICAgICBAcGFyYW0gbGlzdC5jYWxsYmFjayB7ZnVuY3Rpb259IGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBvbiBidXR0b24gY2xpY2tcbiAgICAgKiAgICAgIEBwYXJhbSBbbGlzdC5pZF0ge1N0cmluZ30gaWQgdG8gZ2l2ZSB0byB0aGUgYnV0dG9uXG4gICAgICogIEBwYXJhbSBbZ3JvdXBfaWRdIHtTdHJpbmd9IG9wdGlvbm5hbCBpZCB0byBnaXZlIHRvIHRoZSBncm91cFxuICAgICAqXG4gICAgICpcbiAgICAgKiAgZm9yIHByaXZhdGUgdXNhZ2UsIHRoZSBrZXkgY2FuIGFsc28gYmUgc3RyaW5ncyBzdGFydGluZyB3aXRoICc8JyBhbmQgZW5kaW5nIHdpdGggJz4nIHRvIGluamVjdCBjdXN0b20gZWxlbWVudCB0aGF0IGNhbm5vdFxuICAgICAqICBiZSBib3VuZCB0byBhbiBhY3Rpb24uXG4gICAgICpcbiAgICAgKi9cbiAgICAvLyBUT0RPIEpVUFlURVI6XG4gICAgLy8gZ2V0IHJpZCBvZiBsZWdhY3kgY29kZSB0aGF0IGhhbmRsZSB0aGluZ3MgdGhhdCBhcmUgbm90IGFjdGlvbnMuXG4gICAgVG9vbEJhci5wcm90b3R5cGUuYWRkX2J1dHRvbnNfZ3JvdXAgPSBmdW5jdGlvbiAobGlzdCwgZ3JvdXBfaWQpIHtcbiAgICAgICAgLy8gaGFuZGxlIGN1c3RvbSBjYWxsIG9mIHBzZXVkb2FjdGlvbiBiaW5kaW5nLlxuICAgICAgICBpZih0eXBlb2YobGlzdCkgPT09ICdzdHJpbmcnICYmIGxpc3Quc2xpY2UoMCwxKSA9PT0gJzwnICYmIGxpc3Quc2xpY2UoLTEpID09PSAnPicpe1xuICAgICAgICAgICAgdmFyIF9wc2V1ZG9fYWN0aW9uO1xuICAgICAgICAgICAgdHJ5e1xuICAgICAgICAgICAgICAgIF9wc2V1ZG9fYWN0aW9uID0gbGlzdC5zbGljZSgxLC0xKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kKHRoaXMuX3BzZXVkb19hY3Rpb25zW19wc2V1ZG9fYWN0aW9uXS5jYWxsKHRoaXMpKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ291Y2gsIGNhbGxpbmcgJywgX3BzZXVkb19hY3Rpb24sICdkb2VzIG5vdCBzZWVtIHRvIHdvcmsuLi46JywgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgdmFyIGJ0bl9ncm91cCA9ICQoJzxkaXYvPicpLmFkZENsYXNzKFwiYnRuLWdyb3VwXCIpO1xuICAgICAgICBpZiggZ3JvdXBfaWQgIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgIGJ0bl9ncm91cC5hdHRyKCdpZCcsZ3JvdXBfaWQpO1xuICAgICAgICB9XG4gICAgICAgIGZvcih2YXIgaT0wOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuXG4gICAgICAgICAgICAvLyBJSUZFIGJlY2F1c2UgamF2YXNjcmlwdCBkb24ndCBoYXZlIGxvb3Agc2NvcGUgc29cbiAgICAgICAgICAgIC8vIGFjdGlvbl9uYW1lIHdvdWxkIG90aGVyd2lzZSBiZSB0aGUgc2FtZSBvbiBhbGwgaXRlcmF0aW9uXG4gICAgICAgICAgICAvLyBvZiB0aGUgbG9vcFxuICAgICAgICAgICAgKGZ1bmN0aW9uKGksbGlzdCl7XG4gICAgICAgICAgICAgICAgdmFyIGVsID0gbGlzdFtpXTtcbiAgICAgICAgICAgICAgICB2YXIgYWN0aW9uX25hbWU7XG4gICAgICAgICAgICAgICAgdmFyIGFjdGlvbjtcbiAgICAgICAgICAgICAgICBpZih0eXBlb2YoZWwpID09PSAnc3RyaW5nJyl7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbiA9IHRoYXQuYWN0aW9ucy5nZXQoZWwpO1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb25fbmFtZSA9IGVsO1xuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBidXR0b24gID0gJCgnPGJ1dHRvbi8+JylcbiAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKCdidG4gYnRuLWRlZmF1bHQnKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcInRpdGxlXCIsIGVsLmxhYmVsfHxhY3Rpb24uaGVscClcbiAgICAgICAgICAgICAgICAgICAgLmFwcGVuZChcbiAgICAgICAgICAgICAgICAgICAgICAgICQoXCI8aS8+XCIpLmFkZENsYXNzKGVsLmljb258fChhY3Rpb258fHtpY29uOidmYS1leGNsYW1hdGlvbi10cmlhbmdsZSd9KS5pY29uKS5hZGRDbGFzcygnZmEnKVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHZhciBpZCA9IGVsLmlkO1xuICAgICAgICAgICAgICAgIGlmKCBpZCAhPT0gdW5kZWZpbmVkICl7XG4gICAgICAgICAgICAgICAgICAgIGJ1dHRvbi5hdHRyKCdpZCcsaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBidXR0b24uYXR0cignZGF0YS1qdXB5dGVyLWFjdGlvbicsIGFjdGlvbl9uYW1lKTtcbiAgICAgICAgICAgICAgICB2YXIgZnVuID0gZWwuY2FsbGJhY2t8fCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICB0aGF0LmFjdGlvbnMuY2FsbChhY3Rpb25fbmFtZSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBidXR0b24uY2xpY2soZnVuKTtcbiAgICAgICAgICAgICAgICBidG5fZ3JvdXAuYXBwZW5kKGJ1dHRvbik7XG4gICAgICAgICAgICB9KShpLGxpc3QpO1xuICAgICAgICAgICAgLy8gRU5EIElJRkVcbiAgICAgICAgfVxuICAgICAgICAkKHRoaXMuc2VsZWN0b3IpLmFwcGVuZChidG5fZ3JvdXApO1xuICAgIH07XG5cbiAgICBUb29sQmFyLnByb3RvdHlwZS5zdHlsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50LmFkZENsYXNzKCd0b29sYmFyJyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNob3cgYW5kIGhpZGUgdG9vbGJhclxuICAgICAqIEBtZXRob2QgdG9nZ2xlXG4gICAgICovXG4gICAgVG9vbEJhci5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmVsZW1lbnQudG9nZ2xlKCk7XG4gICAgfTtcblxuICAgIGV4cG9ydHMuVG9vbEJhciA9IFRvb2xCYXI7XG4iLCIvLyBDb3B5cmlnaHQgKGMpIEp1cHl0ZXIgRGV2ZWxvcG1lbnQgVGVhbS5cbi8vIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgTW9kaWZpZWQgQlNEIExpY2Vuc2UuXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICB2YXIgdXRpbHMgPSByZXF1aXJlKCdiYXNlL2pzL3V0aWxzJyk7XG5cbiAgICAvLyB0b29sdGlwIGNvbnN0cnVjdG9yXG4gICAgdmFyIFRvb2x0aXAgPSBmdW5jdGlvbiAoZXZlbnRzKSB7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgdGhpcy5ldmVudHMgPSBldmVudHM7XG4gICAgICAgIHRoaXMudGltZV9iZWZvcmVfdG9vbHRpcCA9IDEyMDA7XG5cbiAgICAgICAgLy8gaGFuZGxlIHRvIGh0bWxcbiAgICAgICAgdGhpcy50b29sdGlwID0gJCgnI3Rvb2x0aXAnKTtcbiAgICAgICAgdGhpcy5faGlkZGVuID0gdHJ1ZTtcblxuICAgICAgICAvLyB2YXJpYWJsZSBmb3IgY29uc2VjdXRpdmUgY2FsbFxuICAgICAgICB0aGlzLl9vbGRfY2VsbCA9IG51bGw7XG4gICAgICAgIHRoaXMuX29sZF9yZXF1ZXN0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fY29uc2VjdXRpdmVfY291bnRlciA9IDA7XG5cbiAgICAgICAgLy8gJ3N0aWNreSA/J1xuICAgICAgICB0aGlzLl9zdGlja3kgPSBmYWxzZTtcblxuICAgICAgICAvLyBkaXNwbGF5IHRvb2x0aXAgaWYgdGhlIGRvY3N0cmluZyBpcyBlbXB0eT9cbiAgICAgICAgdGhpcy5faGlkZV9pZl9ub19kb2NzdHJpbmcgPSBmYWxzZTtcblxuICAgICAgICAvLyBjb250YWluIHRoZSBidXR0b24gaW4gdGhlIHVwcGVyIHJpZ2h0IGNvcm5lclxuICAgICAgICB0aGlzLmJ1dHRvbnMgPSAkKCc8ZGl2Lz4nKS5hZGRDbGFzcygndG9vbHRpcGJ1dHRvbnMnKTtcblxuICAgICAgICAvLyB3aWxsIGNvbnRhaW4gdGhlIGRvY3N0cmluZ1xuICAgICAgICB0aGlzLnRleHQgPSAkKCc8ZGl2Lz4nKS5hZGRDbGFzcygndG9vbHRpcHRleHQnKS5hZGRDbGFzcygnc21hbGx0b29sdGlwJyk7XG5cbiAgICAgICAgLy8gYnVpbGQgdGhlIGJ1dHRvbnMgbWVudSBvbiB0aGUgdXBwZXIgcmlnaHRcbiAgICAgICAgLy8gZXhwYW5kIHRoZSB0b29sdGlwIHRvIHNlZSBtb3JlXG4gICAgICAgIHZhciBleHBhbmRsaW5rID0gJCgnPGEvPicpLmF0dHIoJ2hyZWYnLCBcIiNcIikuYWRkQ2xhc3MoXCJ1aS1jb3JuZXItYWxsXCIpIC8vcm91bmRlZCBjb3JuZXJcbiAgICAgICAgLmF0dHIoJ3JvbGUnLCBcImJ1dHRvblwiKS5hdHRyKCdpZCcsICdleHBhbmJ1dHRvbicpLmF0dHIoJ3RpdGxlJywgJ0dyb3cgdGhlIHRvb2x0aXAgdmVydGljYWxseSAocHJlc3Mgc2hpZnQtdGFiIHR3aWNlKScpLmNsaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoYXQuZXhwYW5kKCk7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9KS5hcHBlbmQoXG4gICAgICAgICQoJzxzcGFuLz4nKS50ZXh0KCdFeHBhbmQnKS5hZGRDbGFzcygndWktaWNvbicpLmFkZENsYXNzKCd1aS1pY29uLXBsdXMnKSk7XG5cbiAgICAgICAgLy8gb3BlbiBpbiBwYWdlclxuICAgICAgICB2YXIgbW9yZWxpbmsgPSAkKCc8YS8+JykuYXR0cignaHJlZicsIFwiI1wiKS5hdHRyKCdyb2xlJywgXCJidXR0b25cIikuYWRkQ2xhc3MoJ3VpLWJ1dHRvbicpLmF0dHIoJ3RpdGxlJywgJ3Nob3cgdGhlIGN1cnJlbnQgZG9jc3RyaW5nIGluIHBhZ2VyIChwcmVzcyBzaGlmdC10YWIgNCB0aW1lcyknKTtcbiAgICAgICAgdmFyIG1vcmVzcGFuID0gJCgnPHNwYW4vPicpLnRleHQoJ09wZW4gaW4gUGFnZXInKS5hZGRDbGFzcygndWktaWNvbicpLmFkZENsYXNzKCd1aS1pY29uLWFycm93c3RvcC1sLW4nKTtcbiAgICAgICAgbW9yZWxpbmsuYXBwZW5kKG1vcmVzcGFuKTtcbiAgICAgICAgbW9yZWxpbmsuY2xpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhhdC5zaG93SW5QYWdlcih0aGF0Ll9vbGRfY2VsbCk7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBjbG9zZSB0aGUgdG9vbHRpcFxuICAgICAgICB2YXIgY2xvc2VsaW5rID0gJCgnPGEvPicpLmF0dHIoJ2hyZWYnLCBcIiNcIikuYXR0cigncm9sZScsIFwiYnV0dG9uXCIpLmFkZENsYXNzKCd1aS1idXR0b24nKTtcbiAgICAgICAgdmFyIGNsb3Nlc3BhbiA9ICQoJzxzcGFuLz4nKS50ZXh0KCdDbG9zZScpLmFkZENsYXNzKCd1aS1pY29uJykuYWRkQ2xhc3MoJ3VpLWljb24tY2xvc2UnKTtcbiAgICAgICAgY2xvc2VsaW5rLmFwcGVuZChjbG9zZXNwYW4pO1xuICAgICAgICBjbG9zZWxpbmsuY2xpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhhdC5yZW1vdmVfYW5kX2NhbmNlbF90b29sdGlwKHRydWUpO1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5fY2xvY2tsaW5rID0gJCgnPGEvPicpLmF0dHIoJ2hyZWYnLCBcIiNcIik7XG4gICAgICAgIHRoaXMuX2Nsb2NrbGluay5hdHRyKCdyb2xlJywgXCJidXR0b25cIik7XG4gICAgICAgIHRoaXMuX2Nsb2NrbGluay5hZGRDbGFzcygndWktYnV0dG9uJyk7XG4gICAgICAgIHRoaXMuX2Nsb2NrbGluay5hdHRyKCd0aXRsZScsICdUb29sdGlwIHdpbGwgbGluZ2VyIGZvciAxMCBzZWNvbmRzIHdoaWxlIHlvdSB0eXBlJyk7XG4gICAgICAgIHZhciBjbG9ja3NwYW4gPSAkKCc8c3Bhbi8+JykudGV4dCgnQ2xvc2UnKTtcbiAgICAgICAgY2xvY2tzcGFuLmFkZENsYXNzKCd1aS1pY29uJyk7XG4gICAgICAgIGNsb2Nrc3Bhbi5hZGRDbGFzcygndWktaWNvbi1jbG9jaycpO1xuICAgICAgICB0aGlzLl9jbG9ja2xpbmsuYXBwZW5kKGNsb2Nrc3Bhbik7XG4gICAgICAgIHRoaXMuX2Nsb2NrbGluay5jbGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGF0LmNhbmNlbF9zdGljaygpO1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfSk7XG5cblxuXG5cbiAgICAgICAgLy9jb25zdHJ1Y3QgdGhlIHRvb2x0aXBcbiAgICAgICAgLy8gYWRkIGluIHRoZSByZXZlcnNlIG9yZGVyIHlvdSB3YW50IHRoZW0gdG8gYXBwZWFyXG4gICAgICAgIHRoaXMuYnV0dG9ucy5hcHBlbmQoY2xvc2VsaW5rKTtcbiAgICAgICAgdGhpcy5idXR0b25zLmFwcGVuZChleHBhbmRsaW5rKTtcbiAgICAgICAgdGhpcy5idXR0b25zLmFwcGVuZChtb3JlbGluayk7XG4gICAgICAgIHRoaXMuYnV0dG9ucy5hcHBlbmQodGhpcy5fY2xvY2tsaW5rKTtcbiAgICAgICAgdGhpcy5fY2xvY2tsaW5rLmhpZGUoKTtcblxuXG4gICAgICAgIC8vIHdlIG5lZWQgYSBwaG9ueSBlbGVtZW50IHRvIG1ha2UgdGhlIHNtYWxsIGFycm93XG4gICAgICAgIC8vIG9mIHRoZSB0b29sdGlwIGluIGNzc1xuICAgICAgICAvLyB3ZSB3aWxsIG1vdmUgdGhlIGFycm93IGxhdGVyXG4gICAgICAgIHRoaXMuYXJyb3cgPSAkKCc8ZGl2Lz4nKS5hZGRDbGFzcygncHJldG9vbHRpcGFycm93Jyk7XG4gICAgICAgIHRoaXMudG9vbHRpcC5hcHBlbmQodGhpcy5idXR0b25zKTtcbiAgICAgICAgdGhpcy50b29sdGlwLmFwcGVuZCh0aGlzLmFycm93KTtcbiAgICAgICAgdGhpcy50b29sdGlwLmFwcGVuZCh0aGlzLnRleHQpO1xuXG4gICAgICAgIC8vIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgaWYgeW91IHByZXNzIHRhYiAxLCAyLCAzLi4uIHRpbWVzIGluIGEgcm93XG4gICAgICAgIHRoaXMudGFic19mdW5jdGlvbnMgPSBbZnVuY3Rpb24gKGNlbGwsIHRleHQsIGN1cnNvcikge1xuICAgICAgICAgICAgdGhhdC5fcmVxdWVzdF90b29sdGlwKGNlbGwsIHRleHQsIGN1cnNvcik7XG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoYXQuZXhwYW5kKCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoYXQuc3RpY2soKTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGNlbGwpIHtcbiAgICAgICAgICAgIHRoYXQuY2FuY2VsX3N0aWNrKCk7XG4gICAgICAgICAgICB0aGF0LnNob3dJblBhZ2VyKGNlbGwpO1xuICAgICAgICB9XTtcbiAgICAgICAgLy8gY2FsbCBhZnRlciBhbGwgdGhlIHRhYnMgZnVuY3Rpb24gYWJvdmUgaGF2ZSBiZWUgY2FsbCB0byBjbGVhbiB0aGVpciBlZmZlY3RzXG4gICAgICAgIC8vIGlmIG5lY2Vzc2FyeVxuICAgICAgICB0aGlzLnJlc2V0X3RhYnNfZnVuY3Rpb24gPSBmdW5jdGlvbiAoY2VsbCwgdGV4dCkge1xuICAgICAgICAgICAgdGhpcy5fb2xkX2NlbGwgPSAoY2VsbCkgPyBjZWxsIDogbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX29sZF9yZXF1ZXN0ID0gKHRleHQpID8gdGV4dCA6IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9jb25zZWN1dGl2ZV9jb3VudGVyID0gMDtcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgVG9vbHRpcC5wcm90b3R5cGUuaXNfdmlzaWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLl9oaWRkZW47XG4gICAgfTtcblxuICAgIFRvb2x0aXAucHJvdG90eXBlLnNob3dJblBhZ2VyID0gZnVuY3Rpb24gKGNlbGwpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHJlZXhlY3V0ZSBsYXN0IGNhbGwgaW4gcGFnZXIgYnkgYXBwZW5kaW5nID8gdG8gc2hvdyBiYWNrIGluIHBhZ2VyXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmV2ZW50cy50cmlnZ2VyKCdvcGVuX3dpdGhfdGV4dC5QYWdlcicsIHRoaXMuX3JlcGx5LmNvbnRlbnQpO1xuICAgICAgICB0aGlzLnJlbW92ZV9hbmRfY2FuY2VsX3Rvb2x0aXAoKTtcbiAgICB9O1xuXG4gICAgLy8gZ3JvdyB0aGUgdG9vbHRpcCB2ZXJ0aWNhbHlcbiAgICBUb29sdGlwLnByb3RvdHlwZS5leHBhbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudGV4dC5yZW1vdmVDbGFzcygnc21hbGx0b29sdGlwJyk7XG4gICAgICAgIHRoaXMudGV4dC5hZGRDbGFzcygnYmlndG9vbHRpcCcpO1xuICAgICAgICAkKCcjZXhwYW5idXR0b24nKS5oaWRlKCdzbG93Jyk7XG4gICAgfTtcblxuICAgIC8vIGRlYWwgd2l0aCBhbGwgdGhlIGxvZ2ljIG9mIGhpZGluZyB0aGUgdG9vbHRpcFxuICAgIC8vIGFuZCByZXNldCBpdCdzIHN0YXR1c1xuICAgIFRvb2x0aXAucHJvdG90eXBlLl9oaWRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9oaWRkZW4gPSB0cnVlO1xuICAgICAgICB0aGlzLnRvb2x0aXAuZmFkZU91dCgnZmFzdCcpO1xuICAgICAgICAkKCcjZXhwYW5idXR0b24nKS5zaG93KCdzbG93Jyk7XG4gICAgICAgIHRoaXMudGV4dC5yZW1vdmVDbGFzcygnYmlndG9vbHRpcCcpO1xuICAgICAgICB0aGlzLnRleHQuYWRkQ2xhc3MoJ3NtYWxsdG9vbHRpcCcpO1xuICAgICAgICAvLyBrZWVwIHNjcm9sbCB0b3AgdG8gYmUgc3VyZSB0byBhbHdheXMgc2VlIHRoZSBmaXJzdCBsaW5lXG4gICAgICAgIHRoaXMudGV4dC5zY3JvbGxUb3AoMCk7XG4gICAgICAgIHRoaXMuY29kZV9taXJyb3IgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyByZXR1cm4gdHJ1ZSBvbiBzdWNjZXNzZnVsbHkgcmVtb3ZpbmcgYSB2aXNpYmxlIHRvb2x0aXA7IG90aGVyd2lzZSByZXR1cm5cbiAgICAvLyBmYWxzZS5cbiAgICBUb29sdGlwLnByb3RvdHlwZS5yZW1vdmVfYW5kX2NhbmNlbF90b29sdGlwID0gZnVuY3Rpb24gKGZvcmNlKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBub3RlIHRoYXQgd2UgZG9uJ3QgaGFuZGxlIGNsb3NpbmcgZGlyZWN0bHkgaW5zaWRlIHRoZSBjYWxsdGlwXG4gICAgICAgICAqIGFzIGluIHRoZSBjb21wbGV0ZXIsIGJlY2F1c2UgaXQgaXMgbm90IGZvY3VzYWJsZSwgc28gd29uJ3RcbiAgICAgICAgICogZ2V0IHRoZSBldmVudC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2FuY2VsX3BlbmRpbmcoKTtcbiAgICAgICAgaWYgKCF0aGlzLl9oaWRkZW4pIHtcbiAgICAgICAgICBpZiAoZm9yY2UgfHwgIXRoaXMuX3N0aWNreSkge1xuICAgICAgICAgICAgICB0aGlzLmNhbmNlbF9zdGljaygpO1xuICAgICAgICAgICAgICB0aGlzLl9oaWRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMucmVzZXRfdGFic19mdW5jdGlvbigpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBjYW5jZWwgYXV0b2NhbGwgZG9uZSBhZnRlciAnKCcgZm9yIGV4YW1wbGUuXG4gICAgVG9vbHRpcC5wcm90b3R5cGUuY2FuY2VsX3BlbmRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl90b29sdGlwX3RpbWVvdXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl90b29sdGlwX3RpbWVvdXQpO1xuICAgICAgICAgICAgdGhpcy5fdG9vbHRpcF90aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyB3aWxsIHRyaWdnZXIgdG9vbHRpcCBhZnRlciB0aW1lb3V0XG4gICAgVG9vbHRpcC5wcm90b3R5cGUucGVuZGluZyA9IGZ1bmN0aW9uIChjZWxsLCBoaWRlX2lmX25vX2RvY3N0cmluZykge1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIHRoaXMuX3Rvb2x0aXBfdGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhhdC5yZXF1ZXN0KGNlbGwsIGhpZGVfaWZfbm9fZG9jc3RyaW5nKTtcbiAgICAgICAgfSwgdGhhdC50aW1lX2JlZm9yZV90b29sdGlwKTtcbiAgICB9O1xuXG4gICAgLy8gZWFzeSBhY2Nlc3MgZm9yIGp1bGlhIG1vbmtleSBwYXRjaGluZy5cbiAgICBUb29sdGlwLmxhc3RfdG9rZW5fcmUgPSAvW2Etel9dWzAtOWEtei5fXSokL2dpO1xuXG4gICAgVG9vbHRpcC5wcm90b3R5cGUuX3JlcXVlc3RfdG9vbHRpcCA9IGZ1bmN0aW9uIChjZWxsLCB0ZXh0LCBjdXJzb3JfcG9zKSB7XG4gICAgICAgIHZhciBjYWxsYmFja3MgPSAkLnByb3h5KHRoaXMuX3Nob3csIHRoaXMpO1xuICAgICAgICB2YXIgbXNnX2lkID0gY2VsbC5rZXJuZWwuaW5zcGVjdCh0ZXh0LCBjdXJzb3JfcG9zLCBjYWxsYmFja3MpO1xuICAgIH07XG5cbiAgICAvLyBtYWtlIGFuIGltbWVkaWF0ZSBjb21wbGV0aW9uIHJlcXVlc3RcbiAgICBUb29sdGlwLnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24gKGNlbGwsIGhpZGVfaWZfbm9fZG9jc3RyaW5nKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiByZXF1ZXN0KGNvZGVjZWxsKVxuICAgICAgICAgKiBEZWFsIHdpdGggZXh0cmFjdGluZyB0aGUgdGV4dCBmcm9tIHRoZSBjZWxsIGFuZCBjb3VudGluZ1xuICAgICAgICAgKiBjYWxsIGluIGEgcm93XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNhbmNlbF9wZW5kaW5nKCk7XG4gICAgICAgIHZhciBlZGl0b3IgPSBjZWxsLmNvZGVfbWlycm9yO1xuICAgICAgICB2YXIgY3Vyc29yID0gZWRpdG9yLmdldEN1cnNvcigpO1xuICAgICAgICB2YXIgY3Vyc29yX3BvcyA9IHV0aWxzLnRvX2Fic29sdXRlX2N1cnNvcl9wb3MoZWRpdG9yLCBjdXJzb3IpO1xuICAgICAgICB2YXIgdGV4dCA9IGNlbGwuZ2V0X3RleHQoKTtcblxuICAgICAgICB0aGlzLl9oaWRlX2lmX25vX2RvY3N0cmluZyA9IGhpZGVfaWZfbm9fZG9jc3RyaW5nO1xuXG4gICAgICAgIGlmKGVkaXRvci5zb21ldGhpbmdTZWxlY3RlZCgpKXtcbiAgICAgICAgICAgIC8vIGdldCBvbmx5IHRoZSBtb3N0IHJlY2VudCBzZWxlY3Rpb24uXG4gICAgICAgICAgICB0ZXh0ID0gZWRpdG9yLmdldFNlbGVjdGlvbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbmVlZCBhIHBlcm1hbmVudCBoYW5kbGUgdG8gY29kZV9taXJyb3IgZm9yIGZ1dHVyZSBhdXRvIHJlY2FsbFxuICAgICAgICB0aGlzLmNvZGVfbWlycm9yID0gZWRpdG9yO1xuXG4gICAgICAgIC8vIG5vdyB3ZSB0cmVhdCB0aGUgZGlmZmVyZW50IG51bWJlciBvZiBrZXlwcmVzc1xuICAgICAgICAvLyBmaXJzdCBpZiBzYW1lIGNlbGwsIHNhbWUgdGV4dCwgaW5jcmVtZW50IGNvdW50ZXIgYnkgMVxuICAgICAgICBpZiAodGhpcy5fb2xkX2NlbGwgPT0gY2VsbCAmJiB0aGlzLl9vbGRfcmVxdWVzdCA9PSB0ZXh0ICYmIHRoaXMuX2hpZGRlbiA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbnNlY3V0aXZlX2NvdW50ZXIrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGVsc2UgcmVzZXRcbiAgICAgICAgICAgIHRoaXMuY2FuY2VsX3N0aWNrKCk7XG4gICAgICAgICAgICB0aGlzLnJlc2V0X3RhYnNfZnVuY3Rpb24gKGNlbGwsIHRleHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50YWJzX2Z1bmN0aW9uc1t0aGlzLl9jb25zZWN1dGl2ZV9jb3VudGVyXShjZWxsLCB0ZXh0LCBjdXJzb3JfcG9zKTtcblxuICAgICAgICAvLyB0aGVuIGlmIHdlIGFyZSBhdCB0aGUgZW5kIG9mIGxpc3QgZnVuY3Rpb24sIHJlc2V0XG4gICAgICAgIGlmICh0aGlzLl9jb25zZWN1dGl2ZV9jb3VudGVyID09IHRoaXMudGFic19mdW5jdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2V0X3RhYnNfZnVuY3Rpb24gKGNlbGwsIHRleHQsIGN1cnNvcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgfTtcblxuICAgIC8vIGNhbmNlbCB0aGUgb3B0aW9uIG9mIGhhdmluZyB0aGUgdG9vbHRpcCB0byBzdGlja1xuICAgIFRvb2x0aXAucHJvdG90eXBlLmNhbmNlbF9zdGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3N0aWNrX3RpbWVvdXQpO1xuICAgICAgICB0aGlzLl9zdGlja190aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fY2xvY2tsaW5rLmhpZGUoJ3Nsb3cnKTtcbiAgICAgICAgdGhpcy5fc3RpY2t5ID0gZmFsc2U7XG4gICAgfTtcblxuICAgIC8vIHB1dCB0aGUgdG9vbHRpcCBpbiBhIHNpY2t5IHN0YXRlIGZvciAxMCBzZWNvbmRzXG4gICAgLy8gaXQgd29uJ3QgYmUgcmVtb3ZlZCBieSByZW1vdmVfYW5kX2NhbmNlbGwoKSB1bmxlc3MgeW91IGNhbGxlZCB3aXRoXG4gICAgLy8gdGhlIGZpcnN0IHBhcmFtZXRlciBzZXQgdG8gdHJ1ZS5cbiAgICAvLyByZW1vdmVfYW5kX2NhbmNlbGxfdG9vbHRpcCh0cnVlKVxuICAgIFRvb2x0aXAucHJvdG90eXBlLnN0aWNrID0gZnVuY3Rpb24gKHRpbWUpIHtcbiAgICAgICAgdGltZSA9ICh0aW1lICE9PSB1bmRlZmluZWQpID8gdGltZSA6IDEwO1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIHRoaXMuX3N0aWNreSA9IHRydWU7XG4gICAgICAgIHRoaXMuX2Nsb2NrbGluay5zaG93KCdzbG93Jyk7XG4gICAgICAgIHRoaXMuX3N0aWNrX3RpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoYXQuX3N0aWNreSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhhdC5fY2xvY2tsaW5rLmhpZGUoJ3Nsb3cnKTtcbiAgICAgICAgfSwgdGltZSAqIDEwMDApO1xuICAgIH07XG5cbiAgICAvLyBzaG91bGQgYmUgY2FsbGVkIHdpdGggdGhlIGtlcm5lbCByZXBseSB0byBhY3R1YWxseSBzaG93IHRoZSB0b29sdGlwXG4gICAgVG9vbHRpcC5wcm90b3R5cGUuX3Nob3cgPSBmdW5jdGlvbiAocmVwbHkpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIG1vdmUgdGhlIGJ1YmJsZSBpZiBpdCBpcyBub3QgaGlkZGVuXG4gICAgICAgICAqIG90aGVyd2lzZSBmYWRlIGl0XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9yZXBseSA9IHJlcGx5O1xuICAgICAgICB2YXIgY29udGVudCA9IHJlcGx5LmNvbnRlbnQ7XG4gICAgICAgIGlmICghY29udGVudC5mb3VuZCkge1xuICAgICAgICAgICAgLy8gb2JqZWN0IG5vdCBmb3VuZCwgbm90aGluZyB0byBzaG93XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5uYW1lID0gY29udGVudC5uYW1lO1xuXG4gICAgICAgIC8vIGRvIHNvbWUgbWF0aCB0byBoYXZlIHRoZSB0b29sdGlwIGFycm93IG9uIG1vcmUgb3IgbGVzcyBvbiBsZWZ0IG9yIHJpZ2h0XG4gICAgICAgIC8vIHBvc2l0aW9uIG9mIHRoZSBlZGl0b3JcbiAgICAgICAgdmFyIGNtX3BvcyA9ICQodGhpcy5jb2RlX21pcnJvci5nZXRXcmFwcGVyRWxlbWVudCgpKS5wb3NpdGlvbigpO1xuXG4gICAgICAgIC8vIGFuY2hvciBhbmQgaGVhZCBwb3NpdGlvbnMgYXJlIGxvY2FsIHdpdGhpbiBDb2RlTWlycm9yIGVsZW1lbnRcbiAgICAgICAgdmFyIGFuY2hvciA9IHRoaXMuY29kZV9taXJyb3IuY3Vyc29yQ29vcmRzKGZhbHNlLCAnbG9jYWwnKTtcbiAgICAgICAgdmFyIGhlYWQgPSB0aGlzLmNvZGVfbWlycm9yLmN1cnNvckNvb3Jkcyh0cnVlLCAnbG9jYWwnKTtcbiAgICAgICAgLy8gbG9jYXRlIHRoZSB0YXJnZXQgYXQgdGhlIGNlbnRlciBvZiBhbmNob3IsIGhlYWRcbiAgICAgICAgdmFyIGNlbnRlcl9sZWZ0ID0gKGhlYWQubGVmdCArIGFuY2hvci5sZWZ0KSAvIDI7XG4gICAgICAgIC8vIGxvY2F0ZSB0aGUgbGVmdCBlZGdlIG9mIHRoZSB0b29sdGlwLCBhdCBtb3N0IDQ1MCBweCBsZWZ0IG9mIHRoZSBhcnJvd1xuICAgICAgICB2YXIgZWRnZV9sZWZ0ID0gTWF0aC5tYXgoY2VudGVyX2xlZnQgLSA0NTAsIDApO1xuICAgICAgICAvLyBsb2NhdGUgdGhlIGFycm93IGF0IHRoZSBjdXJzb3IuIEEgMjQgcHggb2Zmc2V0IHNlZW1zIG5lY2Vzc2FyeS5cbiAgICAgICAgdmFyIGFycm93X2xlZnQgPSBjZW50ZXJfbGVmdCAtIGVkZ2VfbGVmdCAtIDI0O1xuICAgICAgICBcbiAgICAgICAgLy8gbG9jYXRlIGxlZnQsIHRvcCB3aXRoaW4gY29udGFpbmVyIGVsZW1lbnRcbiAgICAgICAgdmFyIGxlZnQgPSAoY21fcG9zLmxlZnQgKyBlZGdlX2xlZnQpICsgJ3B4JztcbiAgICAgICAgdmFyIHRvcCA9IChjbV9wb3MudG9wICsgaGVhZC5ib3R0b20gKyAxMCkgKyAncHgnO1xuXG4gICAgICAgIGlmICh0aGlzLl9oaWRkZW4gPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aGlzLnRvb2x0aXAuYW5pbWF0ZSh7XG4gICAgICAgICAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgICAgICAgICB0b3A6IHRvcFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnRvb2x0aXAuY3NzKHtcbiAgICAgICAgICAgICAgICBsZWZ0OiBsZWZ0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMudG9vbHRpcC5jc3Moe1xuICAgICAgICAgICAgICAgIHRvcDogdG9wXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFycm93LmFuaW1hdGUoe1xuICAgICAgICAgICAgJ2xlZnQnOiBhcnJvd19sZWZ0ICsgJ3B4J1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuX2hpZGRlbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLnRvb2x0aXAuZmFkZUluKCdmYXN0Jyk7XG4gICAgICAgIHRoaXMudGV4dC5jaGlsZHJlbigpLnJlbW92ZSgpO1xuICAgICAgICBcbiAgICAgICAgLy8gVGhpcyBzaG91bGQgc3VwcG9ydCByaWNoIGRhdGEgdHlwZXMsIGJ1dCBvbmx5IHRleHQvcGxhaW4gZm9yIG5vd1xuICAgICAgICAvLyBBbnkgSFRNTCB3aXRoaW4gdGhlIGRvY3N0cmluZyBpcyBlc2NhcGVkIGJ5IHRoZSBmaXhDb25zb2xlKCkgbWV0aG9kLlxuICAgICAgICB2YXIgcHJlID0gJCgnPHByZS8+JykuaHRtbCh1dGlscy5maXhDb25zb2xlKGNvbnRlbnQuZGF0YVsndGV4dC9wbGFpbiddKSk7XG4gICAgICAgIHRoaXMudGV4dC5hcHBlbmQocHJlKTtcbiAgICAgICAgLy8ga2VlcCBzY3JvbGwgdG9wIHRvIGJlIHN1cmUgdG8gYWx3YXlzIHNlZSB0aGUgZmlyc3QgbGluZVxuICAgICAgICB0aGlzLnRleHQuc2Nyb2xsVG9wKDApO1xuICAgIH07XG5cbiAgICBleHBvcnRzLlRvb2x0aXAgPSBUb29sdGlwO1xuIiwiLy8gQ29weXJpZ2h0IChjKSBKdXB5dGVyIERldmVsb3BtZW50IFRlYW0uXG4vLyBEaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIE1vZGlmaWVkIEJTRCBMaWNlbnNlLlxuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgdmFyIHRvdXJfc3R5bGUgPSBcIjxkaXYgY2xhc3M9J3BvcG92ZXIgdG91cic+XFxuXCIgK1xuICAgICAgICBcIjxkaXYgY2xhc3M9J2Fycm93Jz48L2Rpdj5cXG5cIiArXG4gICAgICAgIFwiPGRpdiBzdHlsZT0ncG9zaXRpb246YWJzb2x1dGU7IHRvcDo3cHg7IHJpZ2h0OjdweCc+XFxuXCIgK1xuICAgICAgICAgICAgXCI8YnV0dG9uIGNsYXNzPSdidG4gYnRuLWRlZmF1bHQgYnRuLXNtIGZhIGZhLXRpbWVzJyBkYXRhLXJvbGU9J2VuZCc+PC9idXR0b24+XFxuXCIgK1xuICAgICAgICBcIjwvZGl2PjxoMyBjbGFzcz0ncG9wb3Zlci10aXRsZSc+PC9oMz5cXG5cIiArXG4gICAgICAgIFwiPGRpdiBjbGFzcz0ncG9wb3Zlci1jb250ZW50Jz48L2Rpdj5cXG5cIiArXG4gICAgICAgIFwiPGRpdiBjbGFzcz0ncG9wb3Zlci1uYXZpZ2F0aW9uJz5cXG5cIiArXG4gICAgICAgICAgICBcIjxidXR0b24gY2xhc3M9J2J0biBidG4tZGVmYXVsdCBmYSBmYS1zdGVwLWJhY2t3YXJkJyBkYXRhLXJvbGU9J3ByZXYnPjwvYnV0dG9uPlxcblwiICtcbiAgICAgICAgICAgIFwiPGJ1dHRvbiBjbGFzcz0nYnRuIGJ0bi1kZWZhdWx0IGZhIGZhLXN0ZXAtZm9yd2FyZCBwdWxsLXJpZ2h0JyBkYXRhLXJvbGU9J25leHQnPjwvYnV0dG9uPlxcblwiICtcbiAgICAgICAgICAgIFwiPGJ1dHRvbiBpZD0ndG91ci1wYXVzZScgY2xhc3M9J2J0biBidG4tc20gYnRuLWRlZmF1bHQgZmEgZmEtcGF1c2UnIGRhdGEtcmVzdW1lLXRleHQ9JycgZGF0YS1wYXVzZS10ZXh0PScnIGRhdGEtcm9sZT0ncGF1c2UtcmVzdW1lJz48L2J1dHRvbj5cXG5cIiArXG4gICAgICAgIFwiPC9kaXY+XFxuXCIgK1xuICAgIFwiPC9kaXY+XCI7XG5cbiAgICB2YXIgTm90ZWJvb2tUb3VyID0gZnVuY3Rpb24gKG5vdGVib29rLCBldmVudHMpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICB0aGlzLm5vdGVib29rID0gbm90ZWJvb2s7XG4gICAgICAgIHRoaXMuc3RlcF9kdXJhdGlvbiA9IDA7XG4gICAgICAgIHRoaXMuZXZlbnRzID0gZXZlbnRzO1xuICAgICAgICB0aGlzLnRvdXJfc3RlcHMgPSBbXG4gICAgICAgICAgICB7IFxuICAgICAgICAgICAgICAgIHRpdGxlOiBcIldlbGNvbWUgdG8gdGhlIE5vdGVib29rIFRvdXJcIixcbiAgICAgICAgICAgICAgICBwbGFjZW1lbnQ6ICdib3R0b20nLFxuICAgICAgICAgICAgICAgIG9ycGhhbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjb250ZW50OiBcIllvdSBjYW4gdXNlIHRoZSBsZWZ0IGFuZCByaWdodCBhcnJvdyBrZXlzIHRvIGdvIGJhY2t3YXJkcyBhbmQgZm9yd2FyZHMuXCJcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50OiBcIiNub3RlYm9va19uYW1lXCIsXG4gICAgICAgICAgICAgICAgdGl0bGU6IFwiRmlsZW5hbWVcIixcbiAgICAgICAgICAgICAgICBwbGFjZW1lbnQ6ICdib3R0b20nLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IFwiQ2xpY2sgaGVyZSB0byBjaGFuZ2UgdGhlIGZpbGVuYW1lIGZvciB0aGlzIG5vdGVib29rLlwiXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgZWxlbWVudDogJChcIiNtZW51c1wiKS5wYXJlbnQoKSxcbiAgICAgICAgICAgICAgICBwbGFjZW1lbnQ6ICdib3R0b20nLFxuICAgICAgICAgICAgICAgIHRpdGxlOiBcIk5vdGVib29rIE1lbnViYXJcIixcbiAgICAgICAgICAgICAgICBjb250ZW50OiBcIlRoZSBtZW51YmFyIGhhcyBtZW51cyBmb3IgYWN0aW9ucyBvbiB0aGUgbm90ZWJvb2ssIGl0cyBjZWxscywgYW5kIHRoZSBrZXJuZWwgaXQgY29tbXVuaWNhdGVzIHdpdGguXCJcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50OiBcIiNtYWludG9vbGJhclwiLFxuICAgICAgICAgICAgICAgIHBsYWNlbWVudDogJ2JvdHRvbScsXG4gICAgICAgICAgICAgICAgdGl0bGU6IFwiTm90ZWJvb2sgVG9vbGJhclwiLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IFwiVGhlIHRvb2xiYXIgaGFzIGJ1dHRvbnMgZm9yIHRoZSBtb3N0IGNvbW1vbiBhY3Rpb25zLiBIb3ZlciB5b3VyIG1vdXNlIG92ZXIgZWFjaCBidXR0b24gZm9yIG1vcmUgaW5mb3JtYXRpb24uXCJcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50OiBcIiNtb2RhbF9pbmRpY2F0b3JcIixcbiAgICAgICAgICAgICAgICB0aXRsZTogXCJNb2RlIEluZGljYXRvclwiLFxuICAgICAgICAgICAgICAgIHBsYWNlbWVudDogJ2JvdHRvbScsXG4gICAgICAgICAgICAgICAgY29udGVudDogXCJUaGUgTm90ZWJvb2sgaGFzIHR3byBtb2RlczogRWRpdCBNb2RlIGFuZCBDb21tYW5kIE1vZGUuIEluIHRoaXMgYXJlYSwgYW4gaW5kaWNhdG9yIGNhbiBhcHBlYXIgdG8gdGVsbCB5b3Ugd2hpY2ggbW9kZSB5b3UgYXJlIGluLlwiLFxuICAgICAgICAgICAgICAgIG9uU2hvdzogZnVuY3Rpb24odG91cikgeyB0aGF0LmNvbW1hbmRfaWNvbl9oYWNrKCk7IH1cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50OiBcIiNtb2RhbF9pbmRpY2F0b3JcIixcbiAgICAgICAgICAgICAgICB0aXRsZTogXCJDb21tYW5kIE1vZGVcIixcbiAgICAgICAgICAgICAgICBwbGFjZW1lbnQ6ICdib3R0b20nLFxuICAgICAgICAgICAgICAgIG9uU2hvdzogZnVuY3Rpb24odG91cikgeyBub3RlYm9vay5jb21tYW5kX21vZGUoKTsgdGhhdC5jb21tYW5kX2ljb25faGFjaygpOyB9LFxuICAgICAgICAgICAgICAgIG9uTmV4dDogZnVuY3Rpb24odG91cikgeyB0aGF0LmVkaXRfbW9kZSgpOyB9LFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IFwiUmlnaHQgbm93IHlvdSBhcmUgaW4gQ29tbWFuZCBNb2RlLCBhbmQgbWFueSBrZXlib2FyZCBzaG9ydGN1dHMgYXJlIGF2YWlsYWJsZS4gSW4gdGhpcyBtb2RlLCBubyBpY29uIGlzIGRpc3BsYXllZCBpbiB0aGUgaW5kaWNhdG9yIGFyZWEuXCJcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50OiBcIiNtb2RhbF9pbmRpY2F0b3JcIixcbiAgICAgICAgICAgICAgICB0aXRsZTogXCJFZGl0IE1vZGVcIixcbiAgICAgICAgICAgICAgICBwbGFjZW1lbnQ6ICdib3R0b20nLFxuICAgICAgICAgICAgICAgIG9uU2hvdzogZnVuY3Rpb24odG91cikgeyB0aGF0LmVkaXRfbW9kZSgpOyB9LFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IFwiUHJlc3NpbmcgPGNvZGU+RW50ZXI8L2NvZGU+IG9yIGNsaWNraW5nIGluIHRoZSBpbnB1dCB0ZXh0IGFyZWEgb2YgdGhlIGNlbGwgc3dpdGNoZXMgdG8gRWRpdCBNb2RlLlwiXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgZWxlbWVudDogJy5zZWxlY3RlZCcsXG4gICAgICAgICAgICAgICAgdGl0bGU6IFwiRWRpdCBNb2RlXCIsXG4gICAgICAgICAgICAgICAgcGxhY2VtZW50OiAnYm90dG9tJyxcbiAgICAgICAgICAgICAgICBvblNob3c6IGZ1bmN0aW9uKHRvdXIpIHsgdGhhdC5lZGl0X21vZGUoKTsgfSxcbiAgICAgICAgICAgICAgICBjb250ZW50OiBcIk5vdGljZSB0aGF0IHRoZSBib3JkZXIgYXJvdW5kIHRoZSBjdXJyZW50bHkgYWN0aXZlIGNlbGwgY2hhbmdlZCBjb2xvci4gVHlwaW5nIHdpbGwgaW5zZXJ0IHRleHQgaW50byB0aGUgY3VycmVudGx5IGFjdGl2ZSBjZWxsLlwiXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgZWxlbWVudDogJy5zZWxlY3RlZCcsXG4gICAgICAgICAgICAgICAgdGl0bGU6IFwiQmFjayB0byBDb21tYW5kIE1vZGVcIixcbiAgICAgICAgICAgICAgICBwbGFjZW1lbnQ6ICdib3R0b20nLFxuICAgICAgICAgICAgICAgIG9uU2hvdzogZnVuY3Rpb24odG91cikgeyBub3RlYm9vay5jb21tYW5kX21vZGUoKTsgfSxcbiAgICAgICAgICAgICAgICBvbkhpZGU6IGZ1bmN0aW9uKHRvdXIpIHsgJCgnI2hlbHBfbWVudScpLnBhcmVudCgpLmNoaWxkcmVuKCdhJykuY2xpY2soKTsgfSxcbiAgICAgICAgICAgICAgICBjb250ZW50OiBcIlByZXNzaW5nIDxjb2RlPkVzYzwvY29kZT4gb3IgY2xpY2tpbmcgb3V0c2lkZSBvZiB0aGUgaW5wdXQgdGV4dCBhcmVhIHRha2VzIHlvdSBiYWNrIHRvIENvbW1hbmQgTW9kZS5cIlxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQ6ICcja2V5Ym9hcmRfc2hvcnRjdXRzJyxcbiAgICAgICAgICAgICAgICB0aXRsZTogXCJLZXlib2FyZCBTaG9ydGN1dHNcIixcbiAgICAgICAgICAgICAgICBwbGFjZW1lbnQ6ICdib3R0b20nLFxuICAgICAgICAgICAgICAgIG9uSGlkZTogZnVuY3Rpb24odG91cikgeyAkKCcjaGVscF9tZW51JykucGFyZW50KCkuY2hpbGRyZW4oJ2EnKS5jbGljaygpOyB9LFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IFwiWW91IGNhbiBjbGljayBoZXJlIHRvIGdldCBhIGxpc3Qgb2YgYWxsIG9mIHRoZSBrZXlib2FyZCBzaG9ydGN1dHMuXCJcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50OiBcIiNrZXJuZWxfaW5kaWNhdG9yX2ljb25cIixcbiAgICAgICAgICAgICAgICB0aXRsZTogXCJLZXJuZWwgSW5kaWNhdG9yXCIsXG4gICAgICAgICAgICAgICAgcGxhY2VtZW50OiAnYm90dG9tJyxcbiAgICAgICAgICAgICAgICBvblNob3c6IGZ1bmN0aW9uKHRvdXIpIHsgZXZlbnRzLnRyaWdnZXIoJ2tlcm5lbF9pZGxlLktlcm5lbCcpO30sXG4gICAgICAgICAgICAgICAgY29udGVudDogXCJUaGlzIGlzIHRoZSBLZXJuZWwgaW5kaWNhdG9yLiBJdCBsb29rcyBsaWtlIHRoaXMgd2hlbiB0aGUgS2VybmVsIGlzIGlkbGUuXCJcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50OiBcIiNrZXJuZWxfaW5kaWNhdG9yX2ljb25cIixcbiAgICAgICAgICAgICAgICB0aXRsZTogXCJLZXJuZWwgSW5kaWNhdG9yXCIsXG4gICAgICAgICAgICAgICAgcGxhY2VtZW50OiAnYm90dG9tJyxcbiAgICAgICAgICAgICAgICBvblNob3c6IGZ1bmN0aW9uKHRvdXIpIHsgZXZlbnRzLnRyaWdnZXIoJ2tlcm5lbF9idXN5Lktlcm5lbCcpOyB9LFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IFwiVGhlIEtlcm5lbCBpbmRpY2F0b3IgbG9va3MgbGlrZSB0aGlzIHdoZW4gdGhlIEtlcm5lbCBpcyBidXN5LlwiXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgZWxlbWVudDogXCIuZmEtc3RvcFwiLFxuICAgICAgICAgICAgICAgIHBsYWNlbWVudDogJ2JvdHRvbScsXG4gICAgICAgICAgICAgICAgdGl0bGU6IFwiSW50ZXJydXB0aW5nIHRoZSBLZXJuZWxcIixcbiAgICAgICAgICAgICAgICBvbkhpZGU6IGZ1bmN0aW9uKHRvdXIpIHsgZXZlbnRzLnRyaWdnZXIoJ2tlcm5lbF9pZGxlLktlcm5lbCcpOyB9LFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IFwiVG8gY2FuY2VsIGEgY29tcHV0YXRpb24gaW4gcHJvZ3Jlc3MsIHlvdSBjYW4gY2xpY2sgaGVyZS5cIlxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IFwiI25vdGlmaWNhdGlvbl9rZXJuZWxcIixcbiAgICAgICAgICAgICAgICBwbGFjZW1lbnQ6ICdib3R0b20nLFxuICAgICAgICAgICAgICAgIG9uU2hvdzogZnVuY3Rpb24odG91cikgeyAkKCcuZmEtc3RvcCcpLmNsaWNrKCk7IH0sXG4gICAgICAgICAgICAgICAgdGl0bGU6IFwiTm90aWZpY2F0aW9uIEFyZWFcIixcbiAgICAgICAgICAgICAgICBjb250ZW50OiBcIk1lc3NhZ2VzIGluIHJlc3BvbnNlIHRvIHVzZXIgYWN0aW9ucyAoU2F2ZSwgSW50ZXJydXB0LCBldGMpIGFwcGVhciBoZXJlLlwiXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgdGl0bGU6IFwiRmluLlwiLFxuICAgICAgICAgICAgICAgIHBsYWNlbWVudDogJ2JvdHRvbScsXG4gICAgICAgICAgICAgICAgb3JwaGFuOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IFwiVGhpcyBjb25jbHVkZXMgdGhlIEp1cHl0ZXIgTm90ZWJvb2sgVXNlciBJbnRlcmZhY2UgVG91ci4gSGFwcHkgaGFja2luZyFcIlxuICAgICAgICAgICAgfVxuICAgICAgICBdO1xuXG4gICAgICAgIHJlcXVpcmVqcyhbJ2Jvb3RzdHJhcHRvdXInXSwgZnVuY3Rpb24gYXNzaWduVG91cihUb3VyKSB7XG4gICAgICAgICAgICB0aGF0LnRvdXIgPSBuZXcgVG91cih7XG4gICAgICAgICAgICAgICAgc3RvcmFnZTogZmFsc2UsIC8vIHN0YXJ0IHRvdXIgZnJvbSBiZWdpbm5pbmcgZXZlcnkgdGltZVxuICAgICAgICAgICAgICAgIGRlYnVnOiB0cnVlLFxuICAgICAgICAgICAgICAgIHJlZmxleDogdHJ1ZSwgLy8gY2xpY2sgb24gZWxlbWVudCB0byBjb250aW51ZSB0b3VyXG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogdGhhdC5zdGVwX2R1cmF0aW9uLFxuICAgICAgICAgICAgICAgIG9uU3RhcnQ6IGZ1bmN0aW9uKCkgeyBjb25zb2xlLmxvZygndG91ciBzdGFydGVkJyk7IH0sXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogcmVtb3ZlIHRoZSBvblBhdXNlL29uUmVzdW1lIGxvZ2ljIG9uY2UgcGkncyBwYXRjaCBoYXMgYmVlblxuICAgICAgICAgICAgICAgIC8vIG1lcmdlZCB1cHN0cmVhbSB0byBtYWtlIHRoaXMgd29yayB2aWEgZGF0YS1yZXN1bWUtY2xhc3MgYW5kIFxuICAgICAgICAgICAgICAgIC8vIGRhdGEtcmVzdW1lLXRleHQgYXR0cmlidXRlcy5cbiAgICAgICAgICAgICAgICBvblBhdXNlOiB0aGF0LnRvZ2dsZV9wYXVzZV9wbGF5LFxuICAgICAgICAgICAgICAgIG9uUmVzdW1lOiB0aGF0LnRvZ2dsZV9wYXVzZV9wbGF5LFxuICAgICAgICAgICAgICAgIHN0ZXBzOiB0aGF0LnRvdXJfc3RlcHMsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IHRvdXJfc3R5bGUsXG4gICAgICAgICAgICAgICAgb3JwaGFuOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIE5vdGVib29rVG91ci5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwibGV0J3Mgc3RhcnQgdGhlIHRvdXJcIik7XG4gICAgICAgIHRoaXMudG91ci5pbml0KCk7XG4gICAgICAgIHRoaXMudG91ci5zdGFydCgpO1xuICAgICAgICBpZiAodGhpcy50b3VyLmVuZGVkKCkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMudG91ci5yZXN0YXJ0KCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgTm90ZWJvb2tUb3VyLnByb3RvdHlwZS5jb21tYW5kX2ljb25faGFjayA9ICBmdW5jdGlvbigpIHtcbiAgICAgICAgJCgnI21vZGFsX2luZGljYXRvcicpLmNzcygnbWluLWhlaWdodCcsIDIwKTtcbiAgICB9O1xuXG4gICAgTm90ZWJvb2tUb3VyLnByb3RvdHlwZS50b2dnbGVfcGF1c2VfcGxheSA9IGZ1bmN0aW9uICgpIHsgXG4gICAgICAgICQoJyN0b3VyLXBhdXNlJykudG9nZ2xlQ2xhc3MoJ2ZhLXBhdXNlIGZhLXBsYXknKTsgXG4gICAgfTtcblxuICAgIE5vdGVib29rVG91ci5wcm90b3R5cGUuZWRpdF9tb2RlID0gZnVuY3Rpb24oKSB7IFxuICAgICAgICB0aGlzLm5vdGVib29rLmZvY3VzX2NlbGwoKTsgXG4gICAgICAgIHRoaXMubm90ZWJvb2suZWRpdF9tb2RlKCk7XG4gICAgfTtcblxuICAgIGV4cG9ydHMuTm90ZWJvb2tUb3VyID0gTm90ZWJvb2tUb3VyO1xuICAgICIsIi8vIENvcHlyaWdodCAoYykgSnVweXRlciBEZXZlbG9wbWVudCBUZWFtLlxuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBNb2RpZmllZCBCU0QgTGljZW5zZS5cbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIHZhciB1dGlscyA9IHJlcXVpcmUoJ2Jhc2UvanMvdXRpbHMnKTtcblxuICAgIHZhciBDb25maWdTZWN0aW9uID0gZnVuY3Rpb24oc2VjdGlvbl9uYW1lLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuc2VjdGlvbl9uYW1lID0gc2VjdGlvbl9uYW1lO1xuICAgICAgICB0aGlzLmJhc2VfdXJsID0gb3B0aW9ucy5iYXNlX3VybDtcbiAgICAgICAgdGhpcy5kYXRhID0ge307XG4gICAgICAgIFxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIFxuICAgICAgICAvKiAubG9hZGVkIGlzIGEgcHJvbWlzZSwgZnVsZmlsbGVkIHRoZSBmaXJzdCB0aW1lIHRoZSBjb25maWcgaXMgbG9hZGVkXG4gICAgICAgICAqIGZyb20gdGhlIHNlcnZlci4gQ29kZSBjYW4gZG86XG4gICAgICAgICAqICAgICAgY29uZi5sb2FkZWQudGhlbihmdW5jdGlvbigpIHsgLi4uIHVzaW5nIGNvbmYuZGF0YSAuLi4gfSk7XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9vbmVfbG9hZF9maW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxvYWRlZCA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgdGhhdC5fZmluaXNoX2ZpcnN0bG9hZCA9IHJlc29sdmU7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBDb25maWdTZWN0aW9uLnByb3RvdHlwZS5hcGlfdXJsID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB1dGlscy51cmxfam9pbl9lbmNvZGUodGhpcy5iYXNlX3VybCwgJ2FwaS9jb25maWcnLCB0aGlzLnNlY3Rpb25fbmFtZSk7XG4gICAgfTtcblxuICAgIENvbmZpZ1NlY3Rpb24ucHJvdG90eXBlLl9sb2FkX2RvbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9vbmVfbG9hZF9maW5pc2hlZCkge1xuICAgICAgICAgICAgdGhpcy5fb25lX2xvYWRfZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fZmluaXNoX2ZpcnN0bG9hZCgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIENvbmZpZ1NlY3Rpb24ucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdXRpbHMucHJvbWlzaW5nX2FqYXgodGhpcy5hcGlfdXJsKCksIHtcbiAgICAgICAgICAgIGNhY2hlOiBmYWxzZSxcbiAgICAgICAgICAgIHR5cGU6IFwiR0VUXCIsXG4gICAgICAgICAgICBkYXRhVHlwZTogXCJqc29uXCIsXG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgdGhhdC5kYXRhID0gZGF0YTtcbiAgICAgICAgICAgIHRoYXQuX2xvYWRfZG9uZSgpO1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBNb2RpZnkgdGhlIGNvbmZpZyB2YWx1ZXMgc3RvcmVkLiBVcGRhdGUgdGhlIGxvY2FsIGRhdGEgaW1tZWRpYXRlbHksXG4gICAgICogc2VuZCB0aGUgY2hhbmdlIHRvIHRoZSBzZXJ2ZXIsIGFuZCB1c2UgdGhlIHVwZGF0ZWQgZGF0YSBmcm9tIHRoZSBzZXJ2ZXJcbiAgICAgKiB3aGVuIHRoZSByZXBseSBjb21lcy5cbiAgICAgKi9cbiAgICBDb25maWdTZWN0aW9uLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbihuZXdkYXRhKSB7XG4gICAgICAgICQuZXh0ZW5kKHRydWUsIHRoaXMuZGF0YSwgbmV3ZGF0YSk7ICAvLyB0cnVlIC0+IHJlY3Vyc2l2ZSB1cGRhdGVcbiAgICAgICAgXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHV0aWxzLnByb21pc2luZ19hamF4KHRoaXMuYXBpX3VybCgpLCB7XG4gICAgICAgICAgICBwcm9jZXNzRGF0YTogZmFsc2UsXG4gICAgICAgICAgICB0eXBlIDogXCJQQVRDSFwiLFxuICAgICAgICAgICAgZGF0YTogSlNPTi5zdHJpbmdpZnkobmV3ZGF0YSksXG4gICAgICAgICAgICBkYXRhVHlwZSA6IFwianNvblwiLFxuICAgICAgICAgICAgY29udGVudFR5cGU6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICB0aGF0LmRhdGEgPSBkYXRhO1xuICAgICAgICAgICAgdGhhdC5fbG9hZF9kb25lKCk7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuXG4gICAgdmFyIENvbmZpZ1dpdGhEZWZhdWx0cyA9IGZ1bmN0aW9uKHNlY3Rpb24sIGRlZmF1bHRzLCBjbGFzc25hbWUpIHtcbiAgICAgICAgdGhpcy5zZWN0aW9uID0gc2VjdGlvbjtcbiAgICAgICAgdGhpcy5kZWZhdWx0cyA9IGRlZmF1bHRzO1xuICAgICAgICB0aGlzLmNsYXNzbmFtZSA9IGNsYXNzbmFtZTtcbiAgICB9O1xuXG4gICAgQ29uZmlnV2l0aERlZmF1bHRzLnByb3RvdHlwZS5fY2xhc3NfZGF0YSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5jbGFzc25hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlY3Rpb24uZGF0YVt0aGlzLmNsYXNzbmFtZV0gfHwge307XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZWN0aW9uLmRhdGFcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBXYWl0IGZvciBjb25maWcgdG8gaGF2ZSBsb2FkZWQsIHRoZW4gZ2V0IGEgdmFsdWUgb3IgdGhlIGRlZmF1bHQuXG4gICAgICogUmV0dXJucyBhIHByb21pc2UuXG4gICAgICovXG4gICAgQ29uZmlnV2l0aERlZmF1bHRzLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5zZWN0aW9uLmxvYWRlZC50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NsYXNzX2RhdGEoKVtrZXldIHx8IHRoaXMuZGVmYXVsdHNba2V5XVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgY29uZmlnIHZhbHVlLiBJZiBjb25maWcgaXMgbm90IHlldCBsb2FkZWQsIHJldHVybiB0aGUgZGVmYXVsdFxuICAgICAqIGluc3RlYWQgb2Ygd2FpdGluZyBmb3IgaXQgdG8gbG9hZC5cbiAgICAgKi9cbiAgICBDb25maWdXaXRoRGVmYXVsdHMucHJvdG90eXBlLmdldF9zeW5jID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbGFzc19kYXRhKClba2V5XSB8fCB0aGlzLmRlZmF1bHRzW2tleV07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldCBhIGNvbmZpZyB2YWx1ZS4gU2VuZCB0aGUgdXBkYXRlIHRvIHRoZSBzZXJ2ZXIsIGFuZCBjaGFuZ2Ugb3VyXG4gICAgICogbG9jYWwgY29weSBvZiB0aGUgZGF0YSBpbW1lZGlhdGVseS5cbiAgICAgKiBSZXR1cm5zIGEgcHJvbWlzZSB3aGljaCBpcyBmdWxmaWxsZWQgd2hlbiB0aGUgc2VydmVyIHJlcGxpZXMgdG8gdGhlXG4gICAgICogY2hhbmdlLlxuICAgICAqL1xuICAgICBDb25maWdXaXRoRGVmYXVsdHMucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgIHZhciBkID0ge307XG4gICAgICAgICBkW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgIGlmICh0aGlzLmNsYXNzbmFtZSkge1xuICAgICAgICAgICAgdmFyIGQyID0ge307XG4gICAgICAgICAgICBkMlt0aGlzLmNsYXNzbmFtZV0gPSBkO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VjdGlvbi51cGRhdGUoZDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VjdGlvbi51cGRhdGUoZCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIENvbmZpZ1NlY3Rpb246IENvbmZpZ1NlY3Rpb24sXG4gICAgICAgIENvbmZpZ1dpdGhEZWZhdWx0czogQ29uZmlnV2l0aERlZmF1bHRzLFxuICAgIH07XG4iLCIvLyBDb3B5cmlnaHQgKGMpIEp1cHl0ZXIgRGV2ZWxvcG1lbnQgVGVhbS5cbi8vIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgTW9kaWZpZWQgQlNEIExpY2Vuc2UuXG5cbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIHZhciB1dGlscyA9IHJlcXVpcmUoJ2Jhc2UvanMvdXRpbHMnKTtcblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBDb21tTWFuYWdlciBjbGFzc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHZhciBDb21tTWFuYWdlciA9IGZ1bmN0aW9uIChrZXJuZWwpIHtcbiAgICAgICAgdGhpcy5jb21tcyA9IHt9O1xuICAgICAgICB0aGlzLnRhcmdldHMgPSB7fTtcbiAgICAgICAgaWYgKGtlcm5lbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmluaXRfa2VybmVsKGtlcm5lbCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgQ29tbU1hbmFnZXIucHJvdG90eXBlLmluaXRfa2VybmVsID0gZnVuY3Rpb24gKGtlcm5lbCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogY29ubmVjdCB0aGUga2VybmVsLCBhbmQgcmVnaXN0ZXIgbWVzc2FnZSBoYW5kbGVyc1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5rZXJuZWwgPSBrZXJuZWw7XG4gICAgICAgIHZhciBtc2dfdHlwZXMgPSBbJ2NvbW1fb3BlbicsICdjb21tX21zZycsICdjb21tX2Nsb3NlJ107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnX3R5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbXNnX3R5cGUgPSBtc2dfdHlwZXNbaV07XG4gICAgICAgICAgICBrZXJuZWwucmVnaXN0ZXJfaW9wdWJfaGFuZGxlcihtc2dfdHlwZSwgJC5wcm94eSh0aGlzW21zZ190eXBlXSwgdGhpcykpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIENvbW1NYW5hZ2VyLnByb3RvdHlwZS5uZXdfY29tbSA9IGZ1bmN0aW9uICh0YXJnZXRfbmFtZSwgZGF0YSwgY2FsbGJhY2tzLCBtZXRhZGF0YSwgY29tbV9pZCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgbmV3IENvbW0sIHJlZ2lzdGVyIGl0LCBhbmQgb3BlbiBpdHMgS2VybmVsLXNpZGUgY291bnRlcnBhcnRcbiAgICAgICAgICogTWltaWNzIHRoZSBhdXRvLXJlZ2lzdHJhdGlvbiBpbiBgQ29tbS5fX2luaXRfX2AgaW4gdGhlIEp1cHl0ZXIgQ29tbS5cbiAgICAgICAgICpcbiAgICAgICAgICogYXJndW1lbnQgY29tbV9pZCBpcyBvcHRpb25hbFxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIGNvbW0gPSBuZXcgQ29tbSh0YXJnZXRfbmFtZSwgY29tbV9pZCk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJfY29tbShjb21tKTtcbiAgICAgICAgY29tbS5vcGVuKGRhdGEsIGNhbGxiYWNrcywgbWV0YWRhdGEpO1xuICAgICAgICByZXR1cm4gY29tbTtcbiAgICB9O1xuXG4gICAgQ29tbU1hbmFnZXIucHJvdG90eXBlLnJlZ2lzdGVyX3RhcmdldCA9IGZ1bmN0aW9uICh0YXJnZXRfbmFtZSwgZikge1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVnaXN0ZXIgYSB0YXJnZXQgZnVuY3Rpb24gZm9yIGEgZ2l2ZW4gdGFyZ2V0IG5hbWVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudGFyZ2V0c1t0YXJnZXRfbmFtZV0gPSBmO1xuICAgIH07XG5cbiAgICBDb21tTWFuYWdlci5wcm90b3R5cGUudW5yZWdpc3Rlcl90YXJnZXQgPSBmdW5jdGlvbiAodGFyZ2V0X25hbWUsIGYpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVucmVnaXN0ZXIgYSB0YXJnZXQgZnVuY3Rpb24gZm9yIGEgZ2l2ZW4gdGFyZ2V0IG5hbWVcbiAgICAgICAgICovXG4gICAgICAgIGRlbGV0ZSB0aGlzLnRhcmdldHNbdGFyZ2V0X25hbWVdO1xuICAgIH07XG5cbiAgICBDb21tTWFuYWdlci5wcm90b3R5cGUucmVnaXN0ZXJfY29tbSA9IGZ1bmN0aW9uIChjb21tKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWdpc3RlciBhIGNvbW0gaW4gdGhlIG1hcHBpbmdcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29tbXNbY29tbS5jb21tX2lkXSA9IFByb21pc2UucmVzb2x2ZShjb21tKTtcbiAgICAgICAgY29tbS5rZXJuZWwgPSB0aGlzLmtlcm5lbDtcbiAgICAgICAgcmV0dXJuIGNvbW0uY29tbV9pZDtcbiAgICB9O1xuXG4gICAgQ29tbU1hbmFnZXIucHJvdG90eXBlLnVucmVnaXN0ZXJfY29tbSA9IGZ1bmN0aW9uIChjb21tKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmUgYSBjb21tIGZyb20gdGhlIG1hcHBpbmdcbiAgICAgICAgICovXG4gICAgICAgIGRlbGV0ZSB0aGlzLmNvbW1zW2NvbW0uY29tbV9pZF07XG4gICAgfTtcblxuICAgIC8vIGNvbW0gbWVzc2FnZSBoYW5kbGVyc1xuXG4gICAgQ29tbU1hbmFnZXIucHJvdG90eXBlLmNvbW1fb3BlbiA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgdmFyIGNvbnRlbnQgPSBtc2cuY29udGVudDtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICB2YXIgY29tbV9pZCA9IGNvbnRlbnQuY29tbV9pZDtcblxuICAgICAgICB0aGlzLmNvbW1zW2NvbW1faWRdID0gdXRpbHMubG9hZF9jbGFzcyhjb250ZW50LnRhcmdldF9uYW1lLCBjb250ZW50LnRhcmdldF9tb2R1bGUsIFxuICAgICAgICAgICAgdGhpcy50YXJnZXRzKS50aGVuKGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgICAgICAgICAgIHZhciBjb21tID0gbmV3IENvbW0oY29udGVudC50YXJnZXRfbmFtZSwgY29tbV9pZCk7XG4gICAgICAgICAgICAgICAgY29tbS5rZXJuZWwgPSB0aGF0Lmtlcm5lbDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzcG9uc2UgPSB0YXJnZXQoY29tbSwgbXNnKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbW0uY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC51bnJlZ2lzdGVyX2NvbW0oY29tbSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB3cmFwcGVkX2Vycm9yID0gbmV3IHV0aWxzLldyYXBwZWRFcnJvcihcIkV4Y2VwdGlvbiBvcGVuaW5nIG5ldyBjb21tXCIsIGUpO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKHdyYXBwZWRfZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3Qod3JhcHBlZF9lcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFJlZ2FyZGxlc3Mgb2YgdGhlIHRhcmdldCByZXR1cm4gdmFsdWUsIHdlIG5lZWQgdG9cbiAgICAgICAgICAgICAgICAvLyB0aGVuIHJldHVybiB0aGUgY29tbVxuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzcG9uc2UpLnRoZW4oZnVuY3Rpb24oKSB7cmV0dXJuIGNvbW07fSk7XG4gICAgICAgICAgICB9LCB1dGlscy5yZWplY3QoJ0NvdWxkIG5vdCBvcGVuIGNvbW0nLCB0cnVlKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbW1zW2NvbW1faWRdO1xuICAgIH07XG5cbiAgICBDb21tTWFuYWdlci5wcm90b3R5cGUuY29tbV9jbG9zZSA9IGZ1bmN0aW9uKG1zZykge1xuICAgICAgICB2YXIgY29udGVudCA9IG1zZy5jb250ZW50O1xuICAgICAgICBpZiAodGhpcy5jb21tc1tjb250ZW50LmNvbW1faWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0NvbW0gcHJvbWlzZSBub3QgZm91bmQgZm9yIGNvbW0gaWQgJyArIGNvbnRlbnQuY29tbV9pZCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICB0aGlzLmNvbW1zW2NvbnRlbnQuY29tbV9pZF0gPSB0aGlzLmNvbW1zW2NvbnRlbnQuY29tbV9pZF0udGhlbihmdW5jdGlvbihjb21tKSB7XG4gICAgICAgICAgICB0aGF0LnVucmVnaXN0ZXJfY29tbShjb21tKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29tbS5oYW5kbGVfY2xvc2UobXNnKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkV4Y2VwdGlvbiBjbG9zaW5nIGNvbW06IFwiLCBlLCBlLnN0YWNrLCBtc2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZG9uJ3QgcmV0dXJuIGEgY29tbSwgc28gdGhhdCBmdXJ0aGVyIC50aGVuKCkgZnVuY3Rpb25zXG4gICAgICAgICAgICAvLyBnZXQgYW4gdW5kZWZpbmVkIGNvbW0gaW5wdXRcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbW1zW2NvbnRlbnQuY29tbV9pZF07XG4gICAgfTtcblxuICAgIENvbW1NYW5hZ2VyLnByb3RvdHlwZS5jb21tX21zZyA9IGZ1bmN0aW9uKG1zZykge1xuICAgICAgICB2YXIgY29udGVudCA9IG1zZy5jb250ZW50O1xuICAgICAgICBpZiAodGhpcy5jb21tc1tjb250ZW50LmNvbW1faWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0NvbW0gcHJvbWlzZSBub3QgZm91bmQgZm9yIGNvbW0gaWQgJyArIGNvbnRlbnQuY29tbV9pZCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNvbW1zW2NvbnRlbnQuY29tbV9pZF0gPSB0aGlzLmNvbW1zW2NvbnRlbnQuY29tbV9pZF0udGhlbihmdW5jdGlvbihjb21tKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbW0uaGFuZGxlX21zZyhtc2cpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRXhjZXB0aW9uIGhhbmRsaW5nIGNvbW0gbXNnOiBcIiwgZSwgZS5zdGFjaywgbXNnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb21tO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tbXNbY29udGVudC5jb21tX2lkXTtcbiAgICB9O1xuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIENvbW0gYmFzZSBjbGFzc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHZhciBDb21tID0gZnVuY3Rpb24gKHRhcmdldF9uYW1lLCBjb21tX2lkKSB7XG4gICAgICAgIHRoaXMudGFyZ2V0X25hbWUgPSB0YXJnZXRfbmFtZTtcbiAgICAgICAgdGhpcy5jb21tX2lkID0gY29tbV9pZCB8fCB1dGlscy51dWlkKCk7XG4gICAgICAgIHRoaXMuX21zZ19jYWxsYmFjayA9IHRoaXMuX2Nsb3NlX2NhbGxiYWNrID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gbWV0aG9kcyBmb3Igc2VuZGluZyBtZXNzYWdlc1xuICAgIENvbW0ucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbiAoZGF0YSwgY2FsbGJhY2tzLCBtZXRhZGF0YSkge1xuICAgICAgICB2YXIgY29udGVudCA9IHtcbiAgICAgICAgICAgIGNvbW1faWQgOiB0aGlzLmNvbW1faWQsXG4gICAgICAgICAgICB0YXJnZXRfbmFtZSA6IHRoaXMudGFyZ2V0X25hbWUsXG4gICAgICAgICAgICBkYXRhIDogZGF0YSB8fCB7fSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMua2VybmVsLnNlbmRfc2hlbGxfbWVzc2FnZShcImNvbW1fb3BlblwiLCBjb250ZW50LCBjYWxsYmFja3MsIG1ldGFkYXRhKTtcbiAgICB9O1xuXG4gICAgQ29tbS5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uIChkYXRhLCBjYWxsYmFja3MsIG1ldGFkYXRhLCBidWZmZXJzKSB7XG4gICAgICAgIHZhciBjb250ZW50ID0ge1xuICAgICAgICAgICAgY29tbV9pZCA6IHRoaXMuY29tbV9pZCxcbiAgICAgICAgICAgIGRhdGEgOiBkYXRhIHx8IHt9LFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5rZXJuZWwuc2VuZF9zaGVsbF9tZXNzYWdlKFwiY29tbV9tc2dcIiwgY29udGVudCwgY2FsbGJhY2tzLCBtZXRhZGF0YSwgYnVmZmVycyk7XG4gICAgfTtcblxuICAgIENvbW0ucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKGRhdGEsIGNhbGxiYWNrcywgbWV0YWRhdGEpIHtcbiAgICAgICAgdmFyIGNvbnRlbnQgPSB7XG4gICAgICAgICAgICBjb21tX2lkIDogdGhpcy5jb21tX2lkLFxuICAgICAgICAgICAgZGF0YSA6IGRhdGEgfHwge30sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmtlcm5lbC5zZW5kX3NoZWxsX21lc3NhZ2UoXCJjb21tX2Nsb3NlXCIsIGNvbnRlbnQsIGNhbGxiYWNrcywgbWV0YWRhdGEpO1xuICAgIH07XG5cbiAgICAvLyBtZXRob2RzIGZvciByZWdpc3RlcmluZyBjYWxsYmFja3MgZm9yIGluY29taW5nIG1lc3NhZ2VzXG4gICAgQ29tbS5wcm90b3R5cGUuX3JlZ2lzdGVyX2NhbGxiYWNrID0gZnVuY3Rpb24gKGtleSwgY2FsbGJhY2spIHtcbiAgICAgICAgdGhpc1snXycgKyBrZXkgKyAnX2NhbGxiYWNrJ10gPSBjYWxsYmFjaztcbiAgICB9O1xuXG4gICAgQ29tbS5wcm90b3R5cGUub25fbXNnID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyX2NhbGxiYWNrKCdtc2cnLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIENvbW0ucHJvdG90eXBlLm9uX2Nsb3NlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyX2NhbGxiYWNrKCdjbG9zZScsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgLy8gbWV0aG9kcyBmb3IgaGFuZGxpbmcgaW5jb21pbmcgbWVzc2FnZXNcblxuICAgIENvbW0ucHJvdG90eXBlLl9jYWxsYmFjayA9IGZ1bmN0aW9uIChrZXksIG1zZykge1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSB0aGlzWydfJyArIGtleSArICdfY2FsbGJhY2snXTtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG1zZyk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJFeGNlcHRpb24gaW4gQ29tbSBjYWxsYmFja1wiLCBlLCBlLnN0YWNrLCBtc2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIENvbW0ucHJvdG90eXBlLmhhbmRsZV9tc2cgPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgIHRoaXMuX2NhbGxiYWNrKCdtc2cnLCBtc2cpO1xuICAgIH07XG5cbiAgICBDb21tLnByb3RvdHlwZS5oYW5kbGVfY2xvc2UgPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgIHRoaXMuX2NhbGxiYWNrKCdjbG9zZScsIG1zZyk7XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICAnQ29tbU1hbmFnZXInOiBDb21tTWFuYWdlcixcbiAgICAgICAgJ0NvbW0nOiBDb21tXG4gICAgfTtcbiIsIi8vIENvcHlyaWdodCAoYykgSnVweXRlciBEZXZlbG9wbWVudCBUZWFtLlxuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBNb2RpZmllZCBCU0QgTGljZW5zZS5cbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIHZhciB1dGlscyA9IHJlcXVpcmUoJ2Jhc2UvanMvdXRpbHMnKTtcbiAgICB2YXIgY29tbSA9IHJlcXVpcmUoJy4vY29tbScpO1xuICAgIHZhciBzZXJpYWxpemUgPSByZXF1aXJlKCcuL3NlcmlhbGl6ZScpO1xuICAgIHZhciBldmVudHMgPSByZXF1aXJlKCdiYXNlL2pzL2V2ZW50cycpO1xuXG4gICAgLyoqXG4gICAgICogQSBLZXJuZWwgY2xhc3MgdG8gY29tbXVuaWNhdGUgd2l0aCB0aGUgUHl0aG9uIGtlcm5lbC4gVGhpc1xuICAgICAqIHNob3VsZCBnZW5lcmFsbHkgbm90IGJlIGNvbnN0cnVjdGVkIGRpcmVjdGx5LCBidXQgYmUgY3JlYXRlZFxuICAgICAqIGJ5LiAgdGhlIGBTZXNzaW9uYCBvYmplY3QuIE9uY2UgY3JlYXRlZCwgdGhpcyBvYmplY3Qgc2hvdWxkIGJlXG4gICAgICogdXNlZCB0byBjb21tdW5pY2F0ZSB3aXRoIHRoZSBrZXJuZWwuXG4gICAgICogXG4gICAgICogUHJlbGltaW5hcnkgZG9jdW1lbnRhdGlvbiBmb3IgdGhlIFJFU1QgQVBJIGlzIGF0XG4gICAgICogaHR0cHM6Ly9naXRodWIuY29tL2lweXRob24vaXB5dGhvbi93aWtpL0lQRVAtMTYlM0EtTm90ZWJvb2stbXVsdGktZGlyZWN0b3J5LWRhc2hib2FyZC1hbmQtVVJMLW1hcHBpbmcja2VybmVscy1hcGlcbiAgICAgKiBcbiAgICAgKiBAY2xhc3MgS2VybmVsXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtlcm5lbF9zZXJ2aWNlX3VybCAtIHRoZSBVUkwgdG8gYWNjZXNzIHRoZSBrZXJuZWwgUkVTVCBhcGlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gd3NfdXJsIC0gdGhlIHdlYnNvY2tldHMgVVJMXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSB0aGUga2VybmVsIHR5cGUgKGUuZy4gcHl0aG9uMylcbiAgICAgKi9cbiAgICB2YXIgS2VybmVsID0gZnVuY3Rpb24gKGtlcm5lbF9zZXJ2aWNlX3VybCwgd3NfdXJsLCBuYW1lKSB7XG4gICAgICAgIHRoaXMuZXZlbnRzID0gZXZlbnRzO1xuXG4gICAgICAgIHRoaXMuaWQgPSBudWxsO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLndzID0gbnVsbDtcblxuICAgICAgICB0aGlzLmtlcm5lbF9zZXJ2aWNlX3VybCA9IGtlcm5lbF9zZXJ2aWNlX3VybDtcbiAgICAgICAgdGhpcy5rZXJuZWxfdXJsID0gbnVsbDtcbiAgICAgICAgdGhpcy53c191cmwgPSB3c191cmwgfHwgdXRpbHMuZ2V0X2JvZHlfZGF0YShcIndzVXJsXCIpO1xuICAgICAgICBpZiAoIXRoaXMud3NfdXJsKSB7XG4gICAgICAgICAgICAvLyB0cmFpbGluZyAncycgaW4gaHR0cHMgd2lsbCBiZWNvbWUgd3NzIGZvciBzZWN1cmUgd2ViIHNvY2tldHNcbiAgICAgICAgICAgIHRoaXMud3NfdXJsID0gbG9jYXRpb24ucHJvdG9jb2wucmVwbGFjZSgnaHR0cCcsICd3cycpICsgXCIvL1wiICsgbG9jYXRpb24uaG9zdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudXNlcm5hbWUgPSBcInVzZXJuYW1lXCI7XG4gICAgICAgIHRoaXMuc2Vzc2lvbl9pZCA9IHV0aWxzLnV1aWQoKTtcbiAgICAgICAgdGhpcy5fbXNnX2NhbGxiYWNrcyA9IHt9O1xuICAgICAgICB0aGlzLl9tc2dfcXVldWUgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgdGhpcy5pbmZvX3JlcGx5ID0ge307IC8vIGtlcm5lbF9pbmZvX3JlcGx5IHN0b3JlZCBoZXJlIGFmdGVyIHN0YXJ0aW5nXG5cbiAgICAgICAgaWYgKHR5cGVvZihXZWJTb2NrZXQpICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhpcy5XZWJTb2NrZXQgPSBXZWJTb2NrZXQ7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mKE1veldlYlNvY2tldCkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aGlzLldlYlNvY2tldCA9IE1veldlYlNvY2tldDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFsZXJ0KCdZb3VyIGJyb3dzZXIgZG9lcyBub3QgaGF2ZSBXZWJTb2NrZXQgc3VwcG9ydCwgcGxlYXNlIHRyeSBDaHJvbWUsIFNhZmFyaSBvciBGaXJlZm94IOKJpSA2LiBGaXJlZm94IDQgYW5kIDUgYXJlIGFsc28gc3VwcG9ydGVkIGJ5IHlvdSBoYXZlIHRvIGVuYWJsZSBXZWJTb2NrZXRzIGluIGFib3V0OmNvbmZpZy4nKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdGhpcy5iaW5kX2V2ZW50cygpO1xuICAgICAgICB0aGlzLmluaXRfaW9wdWJfaGFuZGxlcnMoKTtcbiAgICAgICAgdGhpcy5jb21tX21hbmFnZXIgPSBuZXcgY29tbS5Db21tTWFuYWdlcih0aGlzKTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMubGFzdF9tc2dfaWQgPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3RfbXNnX2NhbGxiYWNrcyA9IHt9O1xuXG4gICAgICAgIHRoaXMuX2F1dG9yZXN0YXJ0X2F0dGVtcHQgPSAwO1xuICAgICAgICB0aGlzLl9yZWNvbm5lY3RfYXR0ZW1wdCA9IDA7XG4gICAgICAgIHRoaXMucmVjb25uZWN0X2xpbWl0ID0gNztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIF9nZXRfbXNnXG4gICAgICovXG4gICAgS2VybmVsLnByb3RvdHlwZS5fZ2V0X21zZyA9IGZ1bmN0aW9uIChtc2dfdHlwZSwgY29udGVudCwgbWV0YWRhdGEsIGJ1ZmZlcnMpIHtcbiAgICAgICAgdmFyIG1zZyA9IHtcbiAgICAgICAgICAgIGhlYWRlciA6IHtcbiAgICAgICAgICAgICAgICBtc2dfaWQgOiB1dGlscy51dWlkKCksXG4gICAgICAgICAgICAgICAgdXNlcm5hbWUgOiB0aGlzLnVzZXJuYW1lLFxuICAgICAgICAgICAgICAgIHNlc3Npb24gOiB0aGlzLnNlc3Npb25faWQsXG4gICAgICAgICAgICAgICAgbXNnX3R5cGUgOiBtc2dfdHlwZSxcbiAgICAgICAgICAgICAgICB2ZXJzaW9uIDogXCI1LjBcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1ldGFkYXRhIDogbWV0YWRhdGEgfHwge30sXG4gICAgICAgICAgICBjb250ZW50IDogY29udGVudCxcbiAgICAgICAgICAgIGJ1ZmZlcnMgOiBidWZmZXJzIHx8IFtdLFxuICAgICAgICAgICAgcGFyZW50X2hlYWRlciA6IHt9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBtc2c7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBiaW5kX2V2ZW50c1xuICAgICAqL1xuICAgIEtlcm5lbC5wcm90b3R5cGUuYmluZF9ldmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgdGhpcy5ldmVudHMub24oJ3NlbmRfaW5wdXRfcmVwbHkuS2VybmVsJywgZnVuY3Rpb24oZXZ0LCBkYXRhKSB7IFxuICAgICAgICAgICAgdGhhdC5zZW5kX2lucHV0X3JlcGx5KGRhdGEpO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgcmVjb3JkX3N0YXR1cyA9IGZ1bmN0aW9uIChldnQsIGluZm8pIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdLZXJuZWw6ICcgKyBldnQudHlwZSArICcgKCcgKyBpbmZvLmtlcm5lbC5pZCArICcpJyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5ldmVudHMub24oJ2tlcm5lbF9jcmVhdGVkLktlcm5lbCcsIHJlY29yZF9zdGF0dXMpO1xuICAgICAgICB0aGlzLmV2ZW50cy5vbigna2VybmVsX3JlY29ubmVjdGluZy5LZXJuZWwnLCByZWNvcmRfc3RhdHVzKTtcbiAgICAgICAgdGhpcy5ldmVudHMub24oJ2tlcm5lbF9jb25uZWN0ZWQuS2VybmVsJywgcmVjb3JkX3N0YXR1cyk7XG4gICAgICAgIHRoaXMuZXZlbnRzLm9uKCdrZXJuZWxfc3RhcnRpbmcuS2VybmVsJywgcmVjb3JkX3N0YXR1cyk7XG4gICAgICAgIHRoaXMuZXZlbnRzLm9uKCdrZXJuZWxfcmVzdGFydGluZy5LZXJuZWwnLCByZWNvcmRfc3RhdHVzKTtcbiAgICAgICAgdGhpcy5ldmVudHMub24oJ2tlcm5lbF9hdXRvcmVzdGFydGluZy5LZXJuZWwnLCByZWNvcmRfc3RhdHVzKTtcbiAgICAgICAgdGhpcy5ldmVudHMub24oJ2tlcm5lbF9pbnRlcnJ1cHRpbmcuS2VybmVsJywgcmVjb3JkX3N0YXR1cyk7XG4gICAgICAgIHRoaXMuZXZlbnRzLm9uKCdrZXJuZWxfZGlzY29ubmVjdGVkLktlcm5lbCcsIHJlY29yZF9zdGF0dXMpO1xuICAgICAgICAvLyB0aGVzZSBhcmUgY29tbWVudGVkIG91dCBiZWNhdXNlIHRoZXkgYXJlIHRyaWdnZXJlZCBhIGxvdCwgYnV0IGNhblxuICAgICAgICAvLyBiZSB1bmNvbW1lbnRlZCBmb3IgZGVidWdnaW5nIHB1cnBvc2VzXG4gICAgICAgIC8vdGhpcy5ldmVudHMub24oJ2tlcm5lbF9pZGxlLktlcm5lbCcsIHJlY29yZF9zdGF0dXMpO1xuICAgICAgICAvL3RoaXMuZXZlbnRzLm9uKCdrZXJuZWxfYnVzeS5LZXJuZWwnLCByZWNvcmRfc3RhdHVzKTtcbiAgICAgICAgdGhpcy5ldmVudHMub24oJ2tlcm5lbF9yZWFkeS5LZXJuZWwnLCByZWNvcmRfc3RhdHVzKTtcbiAgICAgICAgdGhpcy5ldmVudHMub24oJ2tlcm5lbF9raWxsZWQuS2VybmVsJywgcmVjb3JkX3N0YXR1cyk7XG4gICAgICAgIHRoaXMuZXZlbnRzLm9uKCdrZXJuZWxfZGVhZC5LZXJuZWwnLCByZWNvcmRfc3RhdHVzKTtcblxuICAgICAgICB0aGlzLmV2ZW50cy5vbigna2VybmVsX3JlYWR5Lktlcm5lbCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoYXQuX2F1dG9yZXN0YXJ0X2F0dGVtcHQgPSAwO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5ldmVudHMub24oJ2tlcm5lbF9jb25uZWN0ZWQuS2VybmVsJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhhdC5fcmVjb25uZWN0X2F0dGVtcHQgPSAwO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSB0aGUgaW9wdWIgaGFuZGxlcnMuXG4gICAgICpcbiAgICAgKiBAZnVuY3Rpb24gaW5pdF9pb3B1Yl9oYW5kbGVyc1xuICAgICAqL1xuICAgIEtlcm5lbC5wcm90b3R5cGUuaW5pdF9pb3B1Yl9oYW5kbGVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG91dHB1dF9tc2dfdHlwZXMgPSBbJ3N0cmVhbScsICdkaXNwbGF5X2RhdGEnLCAnZXhlY3V0ZV9yZXN1bHQnLCAnZXJyb3InXTtcbiAgICAgICAgdGhpcy5faW9wdWJfaGFuZGxlcnMgPSB7fTtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcl9pb3B1Yl9oYW5kbGVyKCdzdGF0dXMnLCAkLnByb3h5KHRoaXMuX2hhbmRsZV9zdGF0dXNfbWVzc2FnZSwgdGhpcykpO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyX2lvcHViX2hhbmRsZXIoJ2NsZWFyX291dHB1dCcsICQucHJveHkodGhpcy5faGFuZGxlX2NsZWFyX291dHB1dCwgdGhpcykpO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyX2lvcHViX2hhbmRsZXIoJ2V4ZWN1dGVfaW5wdXQnLCAkLnByb3h5KHRoaXMuX2hhbmRsZV9pbnB1dF9tZXNzYWdlLCB0aGlzKSk7XG4gICAgICAgIFxuICAgICAgICBmb3IgKHZhciBpPTA7IGkgPCBvdXRwdXRfbXNnX3R5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyX2lvcHViX2hhbmRsZXIob3V0cHV0X21zZ190eXBlc1tpXSwgJC5wcm94eSh0aGlzLl9oYW5kbGVfb3V0cHV0X21lc3NhZ2UsIHRoaXMpKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHRVQgL2FwaS9rZXJuZWxzXG4gICAgICpcbiAgICAgKiBHZXQgdGhlIGxpc3Qgb2YgcnVubmluZyBrZXJuZWxzLlxuICAgICAqXG4gICAgICogQGZ1bmN0aW9uIGxpc3RcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbc3VjY2Vzc10gLSBmdW5jdGlvbiBleGVjdXRlZCBvbiBhamF4IHN1Y2Nlc3NcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbZXJyb3JdIC0gZnVuY3RvbiBleGVjdXRlZCBvbiBhamF4IGVycm9yXG4gICAgICovXG4gICAgS2VybmVsLnByb3RvdHlwZS5saXN0ID0gZnVuY3Rpb24gKHN1Y2Nlc3MsIGVycm9yKSB7XG4gICAgICAgICQuYWpheCh0aGlzLmtlcm5lbF9zZXJ2aWNlX3VybCwge1xuICAgICAgICAgICAgcHJvY2Vzc0RhdGE6IGZhbHNlLFxuICAgICAgICAgICAgY2FjaGU6IGZhbHNlLFxuICAgICAgICAgICAgdHlwZTogXCJHRVRcIixcbiAgICAgICAgICAgIGRhdGFUeXBlOiBcImpzb25cIixcbiAgICAgICAgICAgIHN1Y2Nlc3M6IHN1Y2Nlc3MsXG4gICAgICAgICAgICBlcnJvcjogdGhpcy5fb25fZXJyb3IoZXJyb3IpXG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBQT1NUIC9hcGkva2VybmVsc1xuICAgICAqXG4gICAgICogU3RhcnQgYSBuZXcga2VybmVsLlxuICAgICAqXG4gICAgICogSW4gZ2VuZXJhbCB0aGlzIHNob3VsZG4ndCBiZSB1c2VkIC0tIHRoZSBrZXJuZWwgc2hvdWxkIGJlXG4gICAgICogc3RhcnRlZCB0aHJvdWdoIHRoZSBzZXNzaW9uIEFQSS4gSWYgeW91IHVzZSB0aGlzIGZ1bmN0aW9uIGFuZFxuICAgICAqIGFyZSBhbHNvIHVzaW5nIHRoZSBzZXNzaW9uIEFQSSB0aGVuIHlvdXIgc2Vzc2lvbiBhbmQga2VybmVsXG4gICAgICogV0lMTCBiZSBvdXQgb2Ygc3luYyFcbiAgICAgKlxuICAgICAqIEBmdW5jdGlvbiBzdGFydFxuICAgICAqIEBwYXJhbSB7cGFyYW1zfSBbT2JqZWN0XSAtIHBhcmFtZXRlcnMgdG8gaW5jbHVkZSBpbiB0aGUgcXVlcnkgc3RyaW5nXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gW3N1Y2Nlc3NdIC0gZnVuY3Rpb24gZXhlY3V0ZWQgb24gYWpheCBzdWNjZXNzXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2Vycm9yXSAtIGZ1bmN0b24gZXhlY3V0ZWQgb24gYWpheCBlcnJvclxuICAgICAqL1xuICAgIEtlcm5lbC5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiAocGFyYW1zLCBzdWNjZXNzLCBlcnJvcikge1xuICAgICAgICB2YXIgdXJsID0gdGhpcy5rZXJuZWxfc2VydmljZV91cmw7XG4gICAgICAgIHZhciBxcyA9ICQucGFyYW0ocGFyYW1zIHx8IHt9KTsgLy8gcXVlcnkgc3RyaW5nIGZvciBzYWdlIG1hdGggc3R1ZmZcbiAgICAgICAgaWYgKHFzICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB1cmwgPSB1cmwgKyBcIj9cIiArIHFzO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ldmVudHMudHJpZ2dlcigna2VybmVsX3N0YXJ0aW5nLktlcm5lbCcsIHtrZXJuZWw6IHRoaXN9KTtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICB2YXIgb25fc3VjY2VzcyA9IGZ1bmN0aW9uIChkYXRhLCBzdGF0dXMsIHhocikge1xuICAgICAgICAgICAgdGhhdC5ldmVudHMudHJpZ2dlcigna2VybmVsX2NyZWF0ZWQuS2VybmVsJywge2tlcm5lbDogdGhhdH0pO1xuICAgICAgICAgICAgdGhhdC5fa2VybmVsX2NyZWF0ZWQoZGF0YSk7XG4gICAgICAgICAgICBpZiAoc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3MoZGF0YSwgc3RhdHVzLCB4aHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgICQuYWpheCh1cmwsIHtcbiAgICAgICAgICAgIHByb2Nlc3NEYXRhOiBmYWxzZSxcbiAgICAgICAgICAgIGNhY2hlOiBmYWxzZSxcbiAgICAgICAgICAgIHR5cGU6IFwiUE9TVFwiLFxuICAgICAgICAgICAgZGF0YTogSlNPTi5zdHJpbmdpZnkoe25hbWU6IHRoaXMubmFtZX0pLFxuICAgICAgICAgICAgY29udGVudFR5cGU6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgIGRhdGFUeXBlOiBcImpzb25cIixcbiAgICAgICAgICAgIHN1Y2Nlc3M6IHRoaXMuX29uX3N1Y2Nlc3Mob25fc3VjY2VzcyksXG4gICAgICAgICAgICBlcnJvcjogdGhpcy5fb25fZXJyb3IoZXJyb3IpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB1cmw7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdFVCAvYXBpL2tlcm5lbHMvWzprZXJuZWxfaWRdXG4gICAgICpcbiAgICAgKiBHZXQgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGtlcm5lbC5cbiAgICAgKlxuICAgICAqIEBmdW5jdGlvbiBnZXRfaW5mb1xuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtzdWNjZXNzXSAtIGZ1bmN0aW9uIGV4ZWN1dGVkIG9uIGFqYXggc3VjY2Vzc1xuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtlcnJvcl0gLSBmdW5jdG9uIGV4ZWN1dGVkIG9uIGFqYXggZXJyb3JcbiAgICAgKi9cbiAgICBLZXJuZWwucHJvdG90eXBlLmdldF9pbmZvID0gZnVuY3Rpb24gKHN1Y2Nlc3MsIGVycm9yKSB7XG4gICAgICAgICQuYWpheCh0aGlzLmtlcm5lbF91cmwsIHtcbiAgICAgICAgICAgIHByb2Nlc3NEYXRhOiBmYWxzZSxcbiAgICAgICAgICAgIGNhY2hlOiBmYWxzZSxcbiAgICAgICAgICAgIHR5cGU6IFwiR0VUXCIsXG4gICAgICAgICAgICBkYXRhVHlwZTogXCJqc29uXCIsXG4gICAgICAgICAgICBzdWNjZXNzOiB0aGlzLl9vbl9zdWNjZXNzKHN1Y2Nlc3MpLFxuICAgICAgICAgICAgZXJyb3I6IHRoaXMuX29uX2Vycm9yKGVycm9yKVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogREVMRVRFIC9hcGkva2VybmVscy9bOmtlcm5lbF9pZF1cbiAgICAgKlxuICAgICAqIFNodXRkb3duIHRoZSBrZXJuZWwuXG4gICAgICpcbiAgICAgKiBJZiB5b3UgYXJlIGFsc28gdXNpbmcgc2Vzc2lvbnMsIHRoZW4gdGhpcyBmdW5jdGlvbiBzaG91bCBOT1QgYmVcbiAgICAgKiB1c2VkLiBJbnN0ZWFkLCB1c2UgU2Vzc2lvbi5kZWxldGUuIE90aGVyd2lzZSwgdGhlIHNlc3Npb24gYW5kXG4gICAgICoga2VybmVsIFdJTEwgYmUgb3V0IG9mIHN5bmMuXG4gICAgICpcbiAgICAgKiBAZnVuY3Rpb24ga2lsbFxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtzdWNjZXNzXSAtIGZ1bmN0aW9uIGV4ZWN1dGVkIG9uIGFqYXggc3VjY2Vzc1xuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtlcnJvcl0gLSBmdW5jdG9uIGV4ZWN1dGVkIG9uIGFqYXggZXJyb3JcbiAgICAgKi9cbiAgICBLZXJuZWwucHJvdG90eXBlLmtpbGwgPSBmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcbiAgICAgICAgdGhpcy5ldmVudHMudHJpZ2dlcigna2VybmVsX2tpbGxlZC5LZXJuZWwnLCB7a2VybmVsOiB0aGlzfSk7XG4gICAgICAgIHRoaXMuX2tlcm5lbF9kZWFkKCk7XG4gICAgICAgICQuYWpheCh0aGlzLmtlcm5lbF91cmwsIHtcbiAgICAgICAgICAgIHByb2Nlc3NEYXRhOiBmYWxzZSxcbiAgICAgICAgICAgIGNhY2hlOiBmYWxzZSxcbiAgICAgICAgICAgIHR5cGU6IFwiREVMRVRFXCIsXG4gICAgICAgICAgICBkYXRhVHlwZTogXCJqc29uXCIsXG4gICAgICAgICAgICBzdWNjZXNzOiB0aGlzLl9vbl9zdWNjZXNzKHN1Y2Nlc3MpLFxuICAgICAgICAgICAgZXJyb3I6IHRoaXMuX29uX2Vycm9yKGVycm9yKVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUE9TVCAvYXBpL2tlcm5lbHMvWzprZXJuZWxfaWRdL2ludGVycnVwdFxuICAgICAqXG4gICAgICogSW50ZXJydXB0IHRoZSBrZXJuZWwuXG4gICAgICpcbiAgICAgKiBAZnVuY3Rpb24gaW50ZXJydXB0XG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gW3N1Y2Nlc3NdIC0gZnVuY3Rpb24gZXhlY3V0ZWQgb24gYWpheCBzdWNjZXNzXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2Vycm9yXSAtIGZ1bmN0b24gZXhlY3V0ZWQgb24gYWpheCBlcnJvclxuICAgICAqL1xuICAgIEtlcm5lbC5wcm90b3R5cGUuaW50ZXJydXB0ID0gZnVuY3Rpb24gKHN1Y2Nlc3MsIGVycm9yKSB7XG4gICAgICAgIHRoaXMuZXZlbnRzLnRyaWdnZXIoJ2tlcm5lbF9pbnRlcnJ1cHRpbmcuS2VybmVsJywge2tlcm5lbDogdGhpc30pO1xuXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgdmFyIG9uX3N1Y2Nlc3MgPSBmdW5jdGlvbiAoZGF0YSwgc3RhdHVzLCB4aHIpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogZ2V0IGtlcm5lbCBpbmZvIHNvIHdlIGtub3cgd2hhdCBzdGF0ZSB0aGUga2VybmVsIGlzIGluXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoYXQua2VybmVsX2luZm8oKTtcbiAgICAgICAgICAgIGlmIChzdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgc3VjY2VzcyhkYXRhLCBzdGF0dXMsIHhocik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHVybCA9IHV0aWxzLnVybF9qb2luX2VuY29kZSh0aGlzLmtlcm5lbF91cmwsICdpbnRlcnJ1cHQnKTtcbiAgICAgICAgJC5hamF4KHVybCwge1xuICAgICAgICAgICAgcHJvY2Vzc0RhdGE6IGZhbHNlLFxuICAgICAgICAgICAgY2FjaGU6IGZhbHNlLFxuICAgICAgICAgICAgdHlwZTogXCJQT1NUXCIsXG4gICAgICAgICAgICBjb250ZW50VHlwZTogZmFsc2UsICAvLyB0aGVyZSdzIG5vIGRhdGEgd2l0aCB0aGlzXG4gICAgICAgICAgICBkYXRhVHlwZTogXCJqc29uXCIsXG4gICAgICAgICAgICBzdWNjZXNzOiB0aGlzLl9vbl9zdWNjZXNzKG9uX3N1Y2Nlc3MpLFxuICAgICAgICAgICAgZXJyb3I6IHRoaXMuX29uX2Vycm9yKGVycm9yKVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgS2VybmVsLnByb3RvdHlwZS5yZXN0YXJ0ID0gZnVuY3Rpb24gKHN1Y2Nlc3MsIGVycm9yKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQT1NUIC9hcGkva2VybmVscy9bOmtlcm5lbF9pZF0vcmVzdGFydFxuICAgICAgICAgKlxuICAgICAgICAgKiBSZXN0YXJ0IHRoZSBrZXJuZWwuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBmdW5jdGlvbiBpbnRlcnJ1cHRcbiAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbn0gW3N1Y2Nlc3NdIC0gZnVuY3Rpb24gZXhlY3V0ZWQgb24gYWpheCBzdWNjZXNzXG4gICAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtlcnJvcl0gLSBmdW5jdG9uIGV4ZWN1dGVkIG9uIGFqYXggZXJyb3JcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZXZlbnRzLnRyaWdnZXIoJ2tlcm5lbF9yZXN0YXJ0aW5nLktlcm5lbCcsIHtrZXJuZWw6IHRoaXN9KTtcbiAgICAgICAgdGhpcy5zdG9wX2NoYW5uZWxzKCk7XG5cbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICB2YXIgb25fc3VjY2VzcyA9IGZ1bmN0aW9uIChkYXRhLCBzdGF0dXMsIHhocikge1xuICAgICAgICAgICAgdGhhdC5ldmVudHMudHJpZ2dlcigna2VybmVsX2NyZWF0ZWQuS2VybmVsJywge2tlcm5lbDogdGhhdH0pO1xuICAgICAgICAgICAgdGhhdC5fa2VybmVsX2NyZWF0ZWQoZGF0YSk7XG4gICAgICAgICAgICBpZiAoc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3MoZGF0YSwgc3RhdHVzLCB4aHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBvbl9lcnJvciA9IGZ1bmN0aW9uICh4aHIsIHN0YXR1cywgZXJyKSB7XG4gICAgICAgICAgICB0aGF0LmV2ZW50cy50cmlnZ2VyKCdrZXJuZWxfZGVhZC5LZXJuZWwnLCB7a2VybmVsOiB0aGF0fSk7XG4gICAgICAgICAgICB0aGF0Ll9rZXJuZWxfZGVhZCgpO1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IoeGhyLCBzdGF0dXMsIGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHVybCA9IHV0aWxzLnVybF9qb2luX2VuY29kZSh0aGlzLmtlcm5lbF91cmwsICdyZXN0YXJ0Jyk7XG4gICAgICAgICQuYWpheCh1cmwsIHtcbiAgICAgICAgICAgIHByb2Nlc3NEYXRhOiBmYWxzZSxcbiAgICAgICAgICAgIGNhY2hlOiBmYWxzZSxcbiAgICAgICAgICAgIHR5cGU6IFwiUE9TVFwiLFxuICAgICAgICAgICAgY29udGVudFR5cGU6IGZhbHNlLCAgLy8gdGhlcmUncyBubyBkYXRhIHdpdGggdGhpc1xuICAgICAgICAgICAgZGF0YVR5cGU6IFwianNvblwiLFxuICAgICAgICAgICAgc3VjY2VzczogdGhpcy5fb25fc3VjY2Vzcyhvbl9zdWNjZXNzKSxcbiAgICAgICAgICAgIGVycm9yOiB0aGlzLl9vbl9lcnJvcihvbl9lcnJvcilcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIEtlcm5lbC5wcm90b3R5cGUucmVjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVjb25uZWN0IHRvIGEgZGlzY29ubmVjdGVkIGtlcm5lbC4gVGhpcyBpcyBub3QgYWN0dWFsbHkgYVxuICAgICAgICAgKiBzdGFuZGFyZCBIVFRQIHJlcXVlc3QsIGJ1dCB1c2VmdWwgZnVuY3Rpb24gbm9uZXRoZWxlc3MgZm9yXG4gICAgICAgICAqIHJlY29ubmVjdGluZyB0byB0aGUga2VybmVsIGlmIHRoZSBjb25uZWN0aW9uIGlzIHNvbWVob3cgbG9zdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGZ1bmN0aW9uIHJlY29ubmVjdFxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHRoaXMuaXNfY29ubmVjdGVkKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZWNvbm5lY3RfYXR0ZW1wdCA9IHRoaXMuX3JlY29ubmVjdF9hdHRlbXB0ICsgMTtcbiAgICAgICAgdGhpcy5ldmVudHMudHJpZ2dlcigna2VybmVsX3JlY29ubmVjdGluZy5LZXJuZWwnLCB7XG4gICAgICAgICAgICBrZXJuZWw6IHRoaXMsXG4gICAgICAgICAgICBhdHRlbXB0OiB0aGlzLl9yZWNvbm5lY3RfYXR0ZW1wdCxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc3RhcnRfY2hhbm5lbHMoKTtcbiAgICB9O1xuXG4gICAgS2VybmVsLnByb3RvdHlwZS5fb25fc3VjY2VzcyA9IGZ1bmN0aW9uIChzdWNjZXNzKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIYW5kbGUgYSBzdWNjZXNzZnVsIEFKQVggcmVxdWVzdCBieSB1cGRhdGluZyB0aGUga2VybmVsIGlkIGFuZFxuICAgICAgICAgKiBuYW1lIGZyb20gdGhlIHJlc3BvbnNlLCBhbmQgdGhlbiBvcHRpb25hbGx5IGNhbGxpbmcgYSBwcm92aWRlZFxuICAgICAgICAgKiBjYWxsYmFjay5cbiAgICAgICAgICpcbiAgICAgICAgICogQGZ1bmN0aW9uIF9vbl9zdWNjZXNzXG4gICAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IHN1Y2Nlc3MgLSBjYWxsYmFja1xuICAgICAgICAgKi9cbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGRhdGEsIHN0YXR1cywgeGhyKSB7XG4gICAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIHRoYXQuaWQgPSBkYXRhLmlkO1xuICAgICAgICAgICAgICAgIHRoYXQubmFtZSA9IGRhdGEubmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoYXQua2VybmVsX3VybCA9IHV0aWxzLnVybF9qb2luX2VuY29kZSh0aGF0Lmtlcm5lbF9zZXJ2aWNlX3VybCwgdGhhdC5pZCk7XG4gICAgICAgICAgICBpZiAoc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3MoZGF0YSwgc3RhdHVzLCB4aHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICBLZXJuZWwucHJvdG90eXBlLl9vbl9lcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAvKipcbiAgICAgICAgICogSGFuZGxlIGEgZmFpbGVkIEFKQVggcmVxdWVzdCBieSBsb2dnaW5nIHRoZSBlcnJvciBtZXNzYWdlLCBhbmRcbiAgICAgICAgICogdGhlbiBvcHRpb25hbGx5IGNhbGxpbmcgYSBwcm92aWRlZCBjYWxsYmFjay5cbiAgICAgICAgICpcbiAgICAgICAgICogQGZ1bmN0aW9uIF9vbl9lcnJvclxuICAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBlcnJvciAtIGNhbGxiYWNrXG4gICAgICAgICAqL1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHhociwgc3RhdHVzLCBlcnIpIHtcbiAgICAgICAgICAgIHV0aWxzLmxvZ19hamF4X2Vycm9yKHhociwgc3RhdHVzLCBlcnIpO1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IoeGhyLCBzdGF0dXMsIGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIEtlcm5lbC5wcm90b3R5cGUuX2tlcm5lbF9jcmVhdGVkID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBlcmZvcm0gbmVjZXNzYXJ5IHRhc2tzIG9uY2UgdGhlIGtlcm5lbCBoYXMgYmVlbiBzdGFydGVkLFxuICAgICAgICAgKiBpbmNsdWRpbmcgYWN0dWFsbHkgY29ubmVjdGluZyB0byB0aGUga2VybmVsLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZnVuY3Rpb24gX2tlcm5lbF9jcmVhdGVkXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gaW5mb3JtYXRpb24gYWJvdXQgdGhlIGtlcm5lbCBpbmNsdWRpbmcgaWRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaWQgPSBkYXRhLmlkO1xuICAgICAgICB0aGlzLmtlcm5lbF91cmwgPSB1dGlscy51cmxfam9pbl9lbmNvZGUodGhpcy5rZXJuZWxfc2VydmljZV91cmwsIHRoaXMuaWQpO1xuICAgICAgICB0aGlzLnN0YXJ0X2NoYW5uZWxzKCk7XG4gICAgfTtcblxuICAgIEtlcm5lbC5wcm90b3R5cGUuX2tlcm5lbF9jb25uZWN0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQZXJmb3JtIG5lY2Vzc2FyeSB0YXNrcyBvbmNlIHRoZSBjb25uZWN0aW9uIHRvIHRoZSBrZXJuZWwgaGFzXG4gICAgICAgICAqIGJlZW4gZXN0YWJsaXNoZWQuIFRoaXMgaW5jbHVkZXMgcmVxdWVzdGluZyBpbmZvcm1hdGlvbiBhYm91dFxuICAgICAgICAgKiB0aGUga2VybmVsLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZnVuY3Rpb24gX2tlcm5lbF9jb25uZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZXZlbnRzLnRyaWdnZXIoJ2tlcm5lbF9jb25uZWN0ZWQuS2VybmVsJywge2tlcm5lbDogdGhpc30pO1xuICAgICAgICAvLyBnZXQga2VybmVsIGluZm8gc28gd2Uga25vdyB3aGF0IHN0YXRlIHRoZSBrZXJuZWwgaXMgaW5cbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICB0aGlzLmtlcm5lbF9pbmZvKGZ1bmN0aW9uIChyZXBseSkge1xuICAgICAgICAgICAgdGhhdC5pbmZvX3JlcGx5ID0gcmVwbHkuY29udGVudDtcbiAgICAgICAgICAgIHRoYXQuZXZlbnRzLnRyaWdnZXIoJ2tlcm5lbF9yZWFkeS5LZXJuZWwnLCB7a2VybmVsOiB0aGF0fSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBLZXJuZWwucHJvdG90eXBlLl9rZXJuZWxfZGVhZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBlcmZvcm0gbmVjZXNzYXJ5IHRhc2tzIGFmdGVyIHRoZSBrZXJuZWwgaGFzIGRpZWQuIFRoaXMgY2xvc2luZ1xuICAgICAgICAgKiBjb21tdW5pY2F0aW9uIGNoYW5uZWxzIHRvIHRoZSBrZXJuZWwgaWYgdGhleSBhcmUgc3RpbGwgc29tZWhvd1xuICAgICAgICAgKiBvcGVuLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZnVuY3Rpb24gX2tlcm5lbF9kZWFkXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0b3BfY2hhbm5lbHMoKTtcbiAgICB9O1xuXG4gICAgS2VybmVsLnByb3RvdHlwZS5zdGFydF9jaGFubmVscyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0YXJ0IHRoZSB3ZWJzb2NrZXQgY2hhbm5lbHMuXG4gICAgICAgICAqIFdpbGwgc3RvcCBhbmQgcmVzdGFydCB0aGVtIGlmIHRoZXkgYWxyZWFkeSBleGlzdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGZ1bmN0aW9uIHN0YXJ0X2NoYW5uZWxzXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIHRoaXMuc3RvcF9jaGFubmVscygpO1xuICAgICAgICB2YXIgd3NfaG9zdF91cmwgPSB0aGlzLndzX3VybCArIHRoaXMua2VybmVsX3VybDtcblxuICAgICAgICBjb25zb2xlLmxvZyhcIlN0YXJ0aW5nIFdlYlNvY2tldHM6XCIsIHdzX2hvc3RfdXJsKTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMud3MgPSBuZXcgdGhpcy5XZWJTb2NrZXQoW1xuICAgICAgICAgICAgICAgIHRoYXQud3NfdXJsLFxuICAgICAgICAgICAgICAgIHV0aWxzLnVybF9qb2luX2VuY29kZSh0aGF0Lmtlcm5lbF91cmwsICdjaGFubmVscycpLFxuICAgICAgICAgICAgICAgIFwiP3Nlc3Npb25faWQ9XCIgKyB0aGF0LnNlc3Npb25faWRcbiAgICAgICAgICAgIF0uam9pbignJylcbiAgICAgICAgKTtcbiAgICAgICAgXG4gICAgICAgIHZhciBhbHJlYWR5X2NhbGxlZF9vbmNsb3NlID0gZmFsc2U7IC8vIG9ubHkgYWxlcnQgb25jZVxuICAgICAgICB2YXIgd3NfY2xvc2VkX2Vhcmx5ID0gZnVuY3Rpb24oZXZ0KXtcbiAgICAgICAgICAgIGlmIChhbHJlYWR5X2NhbGxlZF9vbmNsb3NlKXtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhbHJlYWR5X2NhbGxlZF9vbmNsb3NlID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICggISBldnQud2FzQ2xlYW4gKXtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgd2Vic29ja2V0IHdhcyBjbG9zZWQgZWFybHksIHRoYXQgY291bGQgbWVhblxuICAgICAgICAgICAgICAgIC8vIHRoYXQgdGhlIGtlcm5lbCBpcyBhY3R1YWxseSBkZWFkLiBUcnkgZ2V0dGluZ1xuICAgICAgICAgICAgICAgIC8vIGluZm9ybWF0aW9uIGFib3V0IHRoZSBrZXJuZWwgZnJvbSB0aGUgQVBJIGNhbGwgLS1cbiAgICAgICAgICAgICAgICAvLyBpZiB0aGF0IGZhaWxzLCB0aGVuIGFzc3VtZSB0aGUga2VybmVsIGlzIGRlYWQsXG4gICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGp1c3QgZm9sbG93IHRoZSB0eXBpY2FsIHdlYnNvY2tldCBjbG9zZWRcbiAgICAgICAgICAgICAgICAvLyBwcm90b2NvbC5cbiAgICAgICAgICAgICAgICB0aGF0LmdldF9pbmZvKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5fd3NfY2xvc2VkKHdzX2hvc3RfdXJsLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGF0LmV2ZW50cy50cmlnZ2VyKCdrZXJuZWxfZGVhZC5LZXJuZWwnLCB7a2VybmVsOiB0aGF0fSk7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQuX2tlcm5lbF9kZWFkKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciB3c19jbG9zZWRfbGF0ZSA9IGZ1bmN0aW9uKGV2dCl7XG4gICAgICAgICAgICBpZiAoYWxyZWFkeV9jYWxsZWRfb25jbG9zZSl7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWxyZWFkeV9jYWxsZWRfb25jbG9zZSA9IHRydWU7XG4gICAgICAgICAgICBpZiAoICEgZXZ0Lndhc0NsZWFuICl7XG4gICAgICAgICAgICAgICAgdGhhdC5fd3NfY2xvc2VkKHdzX2hvc3RfdXJsLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciB3c19lcnJvciA9IGZ1bmN0aW9uKGV2dCl7XG4gICAgICAgICAgICBpZiAoYWxyZWFkeV9jYWxsZWRfb25jbG9zZSl7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWxyZWFkeV9jYWxsZWRfb25jbG9zZSA9IHRydWU7XG4gICAgICAgICAgICB0aGF0Ll93c19jbG9zZWQod3NfaG9zdF91cmwsIHRydWUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMud3Mub25vcGVuID0gJC5wcm94eSh0aGlzLl93c19vcGVuZWQsIHRoaXMpO1xuICAgICAgICB0aGlzLndzLm9uY2xvc2UgPSB3c19jbG9zZWRfZWFybHk7XG4gICAgICAgIHRoaXMud3Mub25lcnJvciA9IHdzX2Vycm9yO1xuICAgICAgICAvLyBzd2l0Y2ggZnJvbSBlYXJseS1jbG9zZSB0byBsYXRlLWNsb3NlIG1lc3NhZ2UgYWZ0ZXIgMXNcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICh0aGF0LndzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhhdC53cy5vbmNsb3NlID0gd3NfY2xvc2VkX2xhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIDEwMDApO1xuICAgICAgICB0aGlzLndzLm9ubWVzc2FnZSA9ICQucHJveHkodGhpcy5faGFuZGxlX3dzX21lc3NhZ2UsIHRoaXMpO1xuICAgIH07XG5cbiAgICBLZXJuZWwucHJvdG90eXBlLl93c19vcGVuZWQgPSBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIYW5kbGUgYSB3ZWJzb2NrZXQgZW50ZXJpbmcgdGhlIG9wZW4gc3RhdGUsXG4gICAgICAgICAqIHNpZ25hbGluZyB0aGF0IHRoZSBrZXJuZWwgaXMgY29ubmVjdGVkIHdoZW4gd2Vic29ja2V0IGlzIG9wZW4uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBmdW5jdGlvbiBfd3Nfb3BlbmVkXG4gICAgICAgICAqL1xuICAgICAgICBpZiAodGhpcy5pc19jb25uZWN0ZWQoKSkge1xuICAgICAgICAgICAgLy8gYWxsIGV2ZW50cyByZWFkeSwgdHJpZ2dlciBzdGFydGVkIGV2ZW50LlxuICAgICAgICAgICAgdGhpcy5fa2VybmVsX2Nvbm5lY3RlZCgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIEtlcm5lbC5wcm90b3R5cGUuX3dzX2Nsb3NlZCA9IGZ1bmN0aW9uKHdzX3VybCwgZXJyb3IpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhhbmRsZSBhIHdlYnNvY2tldCBlbnRlcmluZyB0aGUgY2xvc2VkIHN0YXRlLiAgSWYgdGhlIHdlYnNvY2tldFxuICAgICAgICAgKiB3YXMgbm90IGNsb3NlZCBkdWUgdG8gYW4gZXJyb3IsIHRyeSB0byByZWNvbm5lY3QgdG8gdGhlIGtlcm5lbC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGZ1bmN0aW9uIF93c19jbG9zZWRcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdzX3VybCAtIHRoZSB3ZWJzb2NrZXQgdXJsXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbH0gZXJyb3IgLSB3aGV0aGVyIHRoZSBjb25uZWN0aW9uIHdhcyBjbG9zZWQgZHVlIHRvIGFuIGVycm9yXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0b3BfY2hhbm5lbHMoKTtcblxuICAgICAgICB0aGlzLmV2ZW50cy50cmlnZ2VyKCdrZXJuZWxfZGlzY29ubmVjdGVkLktlcm5lbCcsIHtrZXJuZWw6IHRoaXN9KTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnV2ViU29ja2V0IGNvbm5lY3Rpb24gZmFpbGVkOiAnLCB3c191cmwpO1xuICAgICAgICAgICAgdGhpcy5ldmVudHMudHJpZ2dlcigna2VybmVsX2Nvbm5lY3Rpb25fZmFpbGVkLktlcm5lbCcsIHtrZXJuZWw6IHRoaXMsIHdzX3VybDogd3NfdXJsLCBhdHRlbXB0OiB0aGlzLl9yZWNvbm5lY3RfYXR0ZW1wdH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NjaGVkdWxlX3JlY29ubmVjdCgpO1xuICAgIH07XG5cbiAgICBLZXJuZWwucHJvdG90eXBlLl9zY2hlZHVsZV9yZWNvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBmdW5jdGlvbiB0byBjYWxsIHdoZW4ga2VybmVsIGNvbm5lY3Rpb24gaXMgbG9zdFxuICAgICAgICAgKiBzY2hlZHVsZXMgcmVjb25uZWN0LCBvciBmaXJlcyAnY29ubmVjdGlvbl9kZWFkJyBpZiByZWNvbm5lY3QgbGltaXQgaXMgaGl0XG4gICAgICAgICAqL1xuICAgICAgICBpZiAodGhpcy5fcmVjb25uZWN0X2F0dGVtcHQgPCB0aGlzLnJlY29ubmVjdF9saW1pdCkge1xuICAgICAgICAgICAgdmFyIHRpbWVvdXQgPSBNYXRoLnBvdygyLCB0aGlzLl9yZWNvbm5lY3RfYXR0ZW1wdCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkNvbm5lY3Rpb24gbG9zdCwgcmVjb25uZWN0aW5nIGluIFwiICsgdGltZW91dCArIFwiIHNlY29uZHMuXCIpO1xuICAgICAgICAgICAgc2V0VGltZW91dCgkLnByb3h5KHRoaXMucmVjb25uZWN0LCB0aGlzKSwgMWUzICogdGltZW91dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50cy50cmlnZ2VyKCdrZXJuZWxfY29ubmVjdGlvbl9kZWFkLktlcm5lbCcsIHtcbiAgICAgICAgICAgICAgICBrZXJuZWw6IHRoaXMsXG4gICAgICAgICAgICAgICAgcmVjb25uZWN0X2F0dGVtcHQ6IHRoaXMuX3JlY29ubmVjdF9hdHRlbXB0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkZhaWxlZCB0byByZWNvbm5lY3QsIGdpdmluZyB1cC5cIik7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgS2VybmVsLnByb3RvdHlwZS5zdG9wX2NoYW5uZWxzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2xvc2UgdGhlIHdlYnNvY2tldC4gQWZ0ZXIgc3VjY2Vzc2Z1bCBjbG9zZSwgdGhlIHZhbHVlXG4gICAgICAgICAqIGluIGB0aGlzLndzYCB3aWxsIGJlIG51bGwuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBmdW5jdGlvbiBzdG9wX2NoYW5uZWxzXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIHZhciBjbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGF0LndzICYmIHRoYXQud3MucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNMT1NFRCkge1xuICAgICAgICAgICAgICAgIHRoYXQud3MgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy53cyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMud3MucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0Lk9QRU4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLndzLm9uY2xvc2UgPSBjbG9zZTtcbiAgICAgICAgICAgICAgICB0aGlzLndzLmNsb3NlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgS2VybmVsLnByb3RvdHlwZS5pc19jb25uZWN0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVjayB3aGV0aGVyIHRoZXJlIGlzIGEgY29ubmVjdGlvbiB0byB0aGUga2VybmVsLiBUaGlzXG4gICAgICAgICAqIGZ1bmN0aW9uIG9ubHkgcmV0dXJucyB0cnVlIGlmIHdlYnNvY2tldCBoYXMgYmVlblxuICAgICAgICAgKiBjcmVhdGVkIGFuZCBoYXMgYSBzdGF0ZSBvZiBXZWJTb2NrZXQuT1BFTi5cbiAgICAgICAgICpcbiAgICAgICAgICogQGZ1bmN0aW9uIGlzX2Nvbm5lY3RlZFxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbH0gLSB3aGV0aGVyIHRoZXJlIGlzIGEgY29ubmVjdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgLy8gaWYgYW55IGNoYW5uZWwgaXMgbm90IHJlYWR5LCB0aGVuIHdlJ3JlIG5vdCBjb25uZWN0ZWRcbiAgICAgICAgaWYgKHRoaXMud3MgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy53cy5yZWFkeVN0YXRlICE9PSBXZWJTb2NrZXQuT1BFTikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICBLZXJuZWwucHJvdG90eXBlLmlzX2Z1bGx5X2Rpc2Nvbm5lY3RlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrIHdoZXRoZXIgdGhlIGNvbm5lY3Rpb24gdG8gdGhlIGtlcm5lbCBoYXMgYmVlbiBjb21wbGV0ZWx5XG4gICAgICAgICAqIHNldmVyZWQuIFRoaXMgZnVuY3Rpb24gb25seSByZXR1cm5zIHRydWUgaWYgYWxsIGNoYW5uZWwgb2JqZWN0c1xuICAgICAgICAgKiBhcmUgbnVsbC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGZ1bmN0aW9uIGlzX2Z1bGx5X2Rpc2Nvbm5lY3RlZFxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbH0gLSB3aGV0aGVyIHRoZSBrZXJuZWwgaXMgZnVsbHkgZGlzY29ubmVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICByZXR1cm4gKHRoaXMud3MgPT09IG51bGwpO1xuICAgIH07XG5cbiAgICBLZXJuZWwucHJvdG90eXBlLnNlbmRfc2hlbGxfbWVzc2FnZSA9IGZ1bmN0aW9uIChtc2dfdHlwZSwgY29udGVudCwgY2FsbGJhY2tzLCBtZXRhZGF0YSwgYnVmZmVycykge1xuICAgICAgICAvKipcbiAgICAgICAgICogU2VuZCBhIG1lc3NhZ2Ugb24gdGhlIEtlcm5lbCdzIHNoZWxsIGNoYW5uZWxcbiAgICAgICAgICpcbiAgICAgICAgICogQGZ1bmN0aW9uIHNlbmRfc2hlbGxfbWVzc2FnZVxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKCF0aGlzLmlzX2Nvbm5lY3RlZCgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJrZXJuZWwgaXMgbm90IGNvbm5lY3RlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbXNnID0gdGhpcy5fZ2V0X21zZyhtc2dfdHlwZSwgY29udGVudCwgbWV0YWRhdGEsIGJ1ZmZlcnMpO1xuICAgICAgICBtc2cuY2hhbm5lbCA9ICdzaGVsbCc7XG4gICAgICAgIHRoaXMud3Muc2VuZChzZXJpYWxpemUuc2VyaWFsaXplKG1zZykpO1xuICAgICAgICB0aGlzLnNldF9jYWxsYmFja3NfZm9yX21zZyhtc2cuaGVhZGVyLm1zZ19pZCwgY2FsbGJhY2tzKTtcbiAgICAgICAgcmV0dXJuIG1zZy5oZWFkZXIubXNnX2lkO1xuICAgIH07XG5cbiAgICBLZXJuZWwucHJvdG90eXBlLmtlcm5lbF9pbmZvID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQga2VybmVsIGluZm9cbiAgICAgICAgICpcbiAgICAgICAgICogQGZ1bmN0aW9uIGtlcm5lbF9pbmZvXG4gICAgICAgICAqIEBwYXJhbSBjYWxsYmFjayB7ZnVuY3Rpb259XG4gICAgICAgICAqXG4gICAgICAgICAqIFdoZW4gY2FsbGluZyB0aGlzIG1ldGhvZCwgcGFzcyBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgZXhwZWN0cyBvbmUgYXJndW1lbnQuXG4gICAgICAgICAqIFRoZSBjYWxsYmFjayB3aWxsIGJlIHBhc3NlZCB0aGUgY29tcGxldGUgYGtlcm5lbF9pbmZvX3JlcGx5YCBtZXNzYWdlIGRvY3VtZW50ZWRcbiAgICAgICAgICogW2hlcmVdKGh0dHA6Ly9pcHl0aG9uLm9yZy9pcHl0aG9uLWRvYy9kZXYvZGV2ZWxvcG1lbnQvbWVzc2FnaW5nLmh0bWwja2VybmVsLWluZm8pXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgY2FsbGJhY2tzO1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrcyA9IHsgc2hlbGwgOiB7IHJlcGx5IDogY2FsbGJhY2sgfSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmRfc2hlbGxfbWVzc2FnZShcImtlcm5lbF9pbmZvX3JlcXVlc3RcIiwge30sIGNhbGxiYWNrcyk7XG4gICAgfTtcblxuICAgIEtlcm5lbC5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIChjb2RlLCBjdXJzb3JfcG9zLCBjYWxsYmFjaykge1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGluZm8gb24gYW4gb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIFdoZW4gY2FsbGluZyB0aGlzIG1ldGhvZCwgcGFzcyBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgZXhwZWN0cyBvbmUgYXJndW1lbnQuXG4gICAgICAgICAqIFRoZSBjYWxsYmFjayB3aWxsIGJlIHBhc3NlZCB0aGUgY29tcGxldGUgYGluc3BlY3RfcmVwbHlgIG1lc3NhZ2UgZG9jdW1lbnRlZFxuICAgICAgICAgKiBbaGVyZV0oaHR0cDovL2lweXRob24ub3JnL2lweXRob24tZG9jL2Rldi9kZXZlbG9wbWVudC9tZXNzYWdpbmcuaHRtbCNvYmplY3QtaW5mb3JtYXRpb24pXG4gICAgICAgICAqXG4gICAgICAgICAqIEBmdW5jdGlvbiBpbnNwZWN0XG4gICAgICAgICAqIEBwYXJhbSBjb2RlIHtzdHJpbmd9XG4gICAgICAgICAqIEBwYXJhbSBjdXJzb3JfcG9zIHtpbnRlZ2VyfVxuICAgICAgICAgKiBAcGFyYW0gY2FsbGJhY2sge2Z1bmN0aW9ufVxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIGNhbGxiYWNrcztcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjYWxsYmFja3MgPSB7IHNoZWxsIDogeyByZXBseSA6IGNhbGxiYWNrIH0gfTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdmFyIGNvbnRlbnQgPSB7XG4gICAgICAgICAgICBjb2RlIDogY29kZSxcbiAgICAgICAgICAgIGN1cnNvcl9wb3MgOiBjdXJzb3JfcG9zLFxuICAgICAgICAgICAgZGV0YWlsX2xldmVsIDogMFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kX3NoZWxsX21lc3NhZ2UoXCJpbnNwZWN0X3JlcXVlc3RcIiwgY29udGVudCwgY2FsbGJhY2tzKTtcbiAgICB9O1xuXG4gICAgS2VybmVsLnByb3RvdHlwZS5leGVjdXRlID0gZnVuY3Rpb24gKGNvZGUsIGNhbGxiYWNrcywgb3B0aW9ucykge1xuICAgICAgICAvKipcbiAgICAgICAgICogRXhlY3V0ZSBnaXZlbiBjb2RlIGludG8ga2VybmVsLCBhbmQgcGFzcyByZXN1bHQgdG8gY2FsbGJhY2suXG4gICAgICAgICAqXG4gICAgICAgICAqIEBhc3luY1xuICAgICAgICAgKiBAZnVuY3Rpb24gZXhlY3V0ZVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29kZVxuICAgICAgICAgKiBAcGFyYW0gW2NhbGxiYWNrc10ge09iamVjdH0gV2l0aCB0aGUgZm9sbG93aW5nIGtleXMgKGFsbCBvcHRpb25hbClcbiAgICAgICAgICogICAgICBAcGFyYW0gY2FsbGJhY2tzLnNoZWxsLnJlcGx5IHtmdW5jdGlvbn1cbiAgICAgICAgICogICAgICBAcGFyYW0gY2FsbGJhY2tzLnNoZWxsLnBheWxvYWQuW3BheWxvYWRfbmFtZV0ge2Z1bmN0aW9ufVxuICAgICAgICAgKiAgICAgIEBwYXJhbSBjYWxsYmFja3MuaW9wdWIub3V0cHV0IHtmdW5jdGlvbn1cbiAgICAgICAgICogICAgICBAcGFyYW0gY2FsbGJhY2tzLmlvcHViLmNsZWFyX291dHB1dCB7ZnVuY3Rpb259XG4gICAgICAgICAqICAgICAgQHBhcmFtIGNhbGxiYWNrcy5pbnB1dCB7ZnVuY3Rpb259XG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAgICAgICAgICogICAgICBAcGFyYW0gW29wdGlvbnMuc2lsZW50PWZhbHNlXSB7Qm9vbGVhbn1cbiAgICAgICAgICogICAgICBAcGFyYW0gW29wdGlvbnMudXNlcl9leHByZXNzaW9ucz1lbXB0eV9kaWN0XSB7RGljdH1cbiAgICAgICAgICogICAgICBAcGFyYW0gW29wdGlvbnMuYWxsb3dfc3RkaW49ZmFsc2VdIHtCb29sZWFufSB0cnVlfGZhbHNlXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBvcHRpb25zIG9iamVjdCBzaG91bGQgY29udGFpbiB0aGUgb3B0aW9ucyBmb3IgdGhlIGV4ZWN1dGVcbiAgICAgICAgICogY2FsbC4gSXRzIGRlZmF1bHQgdmFsdWVzIGFyZTpcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICBvcHRpb25zID0ge1xuICAgICAgICAgKiAgICAgICAgc2lsZW50IDogdHJ1ZSxcbiAgICAgICAgICogICAgICAgIHVzZXJfZXhwcmVzc2lvbnMgOiB7fSxcbiAgICAgICAgICogICAgICAgIGFsbG93X3N0ZGluIDogZmFsc2VcbiAgICAgICAgICogICAgICB9XG4gICAgICAgICAqXG4gICAgICAgICAqIFdoZW4gY2FsbGluZyB0aGlzIG1ldGhvZCBwYXNzIGEgY2FsbGJhY2tzIHN0cnVjdHVyZSBvZiB0aGVcbiAgICAgICAgICogZm9ybTpcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICBjYWxsYmFja3MgPSB7XG4gICAgICAgICAqICAgICAgIHNoZWxsIDoge1xuICAgICAgICAgKiAgICAgICAgIHJlcGx5IDogZXhlY3V0ZV9yZXBseV9jYWxsYmFjayxcbiAgICAgICAgICogICAgICAgICBwYXlsb2FkIDoge1xuICAgICAgICAgKiAgICAgICAgICAgc2V0X25leHRfaW5wdXQgOiBzZXRfbmV4dF9pbnB1dF9jYWxsYmFjayxcbiAgICAgICAgICogICAgICAgICB9XG4gICAgICAgICAqICAgICAgIH0sXG4gICAgICAgICAqICAgICAgIGlvcHViIDoge1xuICAgICAgICAgKiAgICAgICAgIG91dHB1dCA6IG91dHB1dF9jYWxsYmFjayxcbiAgICAgICAgICogICAgICAgICBjbGVhcl9vdXRwdXQgOiBjbGVhcl9vdXRwdXRfY2FsbGJhY2ssXG4gICAgICAgICAqICAgICAgIH0sXG4gICAgICAgICAqICAgICAgIGlucHV0IDogcmF3X2lucHV0X2NhbGxiYWNrXG4gICAgICAgICAqICAgICAgfVxuICAgICAgICAgKlxuICAgICAgICAgKiBFYWNoIGNhbGxiYWNrIHdpbGwgYmUgcGFzc2VkIHRoZSBlbnRpcmUgbWVzc2FnZSBhcyBhIHNpbmdsZVxuICAgICAgICAgKiBhcnVnbWVudC4gIFBheWxvYWQgaGFuZGxlcnMgd2lsbCBiZSBwYXNzZWQgdGhlIGNvcnJlc3BvbmRpbmdcbiAgICAgICAgICogcGF5bG9hZCBhbmQgdGhlIGV4ZWN1dGVfcmVwbHkgbWVzc2FnZS5cbiAgICAgICAgICovXG4gICAgICAgIHZhciBjb250ZW50ID0ge1xuICAgICAgICAgICAgY29kZSA6IGNvZGUsXG4gICAgICAgICAgICBzaWxlbnQgOiB0cnVlLFxuICAgICAgICAgICAgc3RvcmVfaGlzdG9yeSA6IGZhbHNlLFxuICAgICAgICAgICAgdXNlcl9leHByZXNzaW9ucyA6IHt9LFxuICAgICAgICAgICAgYWxsb3dfc3RkaW4gOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICBjYWxsYmFja3MgPSBjYWxsYmFja3MgfHwge307XG4gICAgICAgIGlmIChjYWxsYmFja3MuaW5wdXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29udGVudC5hbGxvd19zdGRpbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgJC5leHRlbmQodHJ1ZSwgY29udGVudCwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuZXZlbnRzLnRyaWdnZXIoJ2V4ZWN1dGlvbl9yZXF1ZXN0Lktlcm5lbCcsIHtrZXJuZWw6IHRoaXMsIGNvbnRlbnQ6IGNvbnRlbnR9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZF9zaGVsbF9tZXNzYWdlKFwiZXhlY3V0ZV9yZXF1ZXN0XCIsIGNvbnRlbnQsIGNhbGxiYWNrcyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFdoZW4gY2FsbGluZyB0aGlzIG1ldGhvZCwgcGFzcyBhIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB3aXRoIHRoZVxuICAgICAqIGBjb21wbGV0ZV9yZXBseWAgbWVzc2FnZSBhcyBpdHMgb25seSBhcmd1bWVudCB3aGVuIGl0IGFycml2ZXMuXG4gICAgICpcbiAgICAgKiBgY29tcGxldGVfcmVwbHlgIGlzIGRvY3VtZW50ZWRcbiAgICAgKiBbaGVyZV0oaHR0cDovL2lweXRob24ub3JnL2lweXRob24tZG9jL2Rldi9kZXZlbG9wbWVudC9tZXNzYWdpbmcuaHRtbCNjb21wbGV0ZSlcbiAgICAgKlxuICAgICAqIEBmdW5jdGlvbiBjb21wbGV0ZVxuICAgICAqIEBwYXJhbSBjb2RlIHtzdHJpbmd9XG4gICAgICogQHBhcmFtIGN1cnNvcl9wb3Mge2ludGVnZXJ9XG4gICAgICogQHBhcmFtIGNhbGxiYWNrIHtmdW5jdGlvbn1cbiAgICAgKi9cbiAgICBLZXJuZWwucHJvdG90eXBlLmNvbXBsZXRlID0gZnVuY3Rpb24gKGNvZGUsIGN1cnNvcl9wb3MsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBjYWxsYmFja3M7XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgY2FsbGJhY2tzID0geyBzaGVsbCA6IHsgcmVwbHkgOiBjYWxsYmFjayB9IH07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbnRlbnQgPSB7XG4gICAgICAgICAgICBjb2RlIDogY29kZSxcbiAgICAgICAgICAgIGN1cnNvcl9wb3MgOiBjdXJzb3JfcG9zXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmRfc2hlbGxfbWVzc2FnZShcImNvbXBsZXRlX3JlcXVlc3RcIiwgY29udGVudCwgY2FsbGJhY2tzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIHNlbmRfaW5wdXRfcmVwbHlcbiAgICAgKi9cbiAgICBLZXJuZWwucHJvdG90eXBlLnNlbmRfaW5wdXRfcmVwbHkgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzX2Nvbm5lY3RlZCgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJrZXJuZWwgaXMgbm90IGNvbm5lY3RlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29udGVudCA9IHtcbiAgICAgICAgICAgIHZhbHVlIDogaW5wdXRcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5ldmVudHMudHJpZ2dlcignaW5wdXRfcmVwbHkuS2VybmVsJywge2tlcm5lbDogdGhpcywgY29udGVudDogY29udGVudH0pO1xuICAgICAgICB2YXIgbXNnID0gdGhpcy5fZ2V0X21zZyhcImlucHV0X3JlcGx5XCIsIGNvbnRlbnQpO1xuICAgICAgICBtc2cuY2hhbm5lbCA9ICdzdGRpbic7XG4gICAgICAgIHRoaXMud3Muc2VuZChzZXJpYWxpemUuc2VyaWFsaXplKG1zZykpO1xuICAgICAgICByZXR1cm4gbXNnLmhlYWRlci5tc2dfaWQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiByZWdpc3Rlcl9pb3B1Yl9oYW5kbGVyXG4gICAgICovXG4gICAgS2VybmVsLnByb3RvdHlwZS5yZWdpc3Rlcl9pb3B1Yl9oYW5kbGVyID0gZnVuY3Rpb24gKG1zZ190eXBlLCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLl9pb3B1Yl9oYW5kbGVyc1ttc2dfdHlwZV0gPSBjYWxsYmFjaztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBpb3B1YiBoYW5kbGVyIGZvciBhIHNwZWNpZmljIG1lc3NhZ2UgdHlwZS5cbiAgICAgKlxuICAgICAqIEBmdW5jdGlvbiBnZXRfaW9wdWJfaGFuZGxlclxuICAgICAqL1xuICAgIEtlcm5lbC5wcm90b3R5cGUuZ2V0X2lvcHViX2hhbmRsZXIgPSBmdW5jdGlvbiAobXNnX3R5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lvcHViX2hhbmRsZXJzW21zZ190eXBlXTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IGNhbGxiYWNrcyBmb3IgYSBzcGVjaWZpYyBtZXNzYWdlLlxuICAgICAqXG4gICAgICogQGZ1bmN0aW9uIGdldF9jYWxsYmFja3NfZm9yX21zZ1xuICAgICAqL1xuICAgIEtlcm5lbC5wcm90b3R5cGUuZ2V0X2NhbGxiYWNrc19mb3JfbXNnID0gZnVuY3Rpb24gKG1zZ19pZCkge1xuICAgICAgICBpZiAobXNnX2lkID09IHRoaXMubGFzdF9tc2dfaWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxhc3RfbXNnX2NhbGxiYWNrcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tc2dfY2FsbGJhY2tzW21zZ19pZF07XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2xlYXIgY2FsbGJhY2tzIGZvciBhIHNwZWNpZmljIG1lc3NhZ2UuXG4gICAgICpcbiAgICAgKiBAZnVuY3Rpb24gY2xlYXJfY2FsbGJhY2tzX2Zvcl9tc2dcbiAgICAgKi9cbiAgICBLZXJuZWwucHJvdG90eXBlLmNsZWFyX2NhbGxiYWNrc19mb3JfbXNnID0gZnVuY3Rpb24gKG1zZ19pZCkge1xuICAgICAgICBpZiAodGhpcy5fbXNnX2NhbGxiYWNrc1ttc2dfaWRdICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fbXNnX2NhbGxiYWNrc1ttc2dfaWRdO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBfZmluaXNoX3NoZWxsXG4gICAgICovXG4gICAgS2VybmVsLnByb3RvdHlwZS5fZmluaXNoX3NoZWxsID0gZnVuY3Rpb24gKG1zZ19pZCkge1xuICAgICAgICB2YXIgY2FsbGJhY2tzID0gdGhpcy5fbXNnX2NhbGxiYWNrc1ttc2dfaWRdO1xuICAgICAgICBpZiAoY2FsbGJhY2tzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrcy5zaGVsbF9kb25lID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChjYWxsYmFja3MuaW9wdWJfZG9uZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJfY2FsbGJhY2tzX2Zvcl9tc2cobXNnX2lkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gX2ZpbmlzaF9pb3B1YlxuICAgICAqL1xuICAgIEtlcm5lbC5wcm90b3R5cGUuX2ZpbmlzaF9pb3B1YiA9IGZ1bmN0aW9uIChtc2dfaWQpIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuX21zZ19jYWxsYmFja3NbbXNnX2lkXTtcbiAgICAgICAgaWYgKGNhbGxiYWNrcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjYWxsYmFja3MuaW9wdWJfZG9uZSA9IHRydWU7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2tzLnNoZWxsX2RvbmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFyX2NhbGxiYWNrc19mb3JfbXNnKG1zZ19pZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0IGNhbGxiYWNrcyBmb3IgYSBwYXJ0aWN1bGFyIG1lc3NhZ2UuXG4gICAgICogQ2FsbGJhY2tzIHNob3VsZCBiZSBhIHN0cnVjdCBvZiB0aGUgZm9sbG93aW5nIGZvcm06XG4gICAgICogc2hlbGwgOiB7XG4gICAgICogXG4gICAgICogfVxuICAgICAqXG4gICAgICogQGZ1bmN0aW9uIHNldF9jYWxsYmFja3NfZm9yX21zZ1xuICAgICAqL1xuICAgIEtlcm5lbC5wcm90b3R5cGUuc2V0X2NhbGxiYWNrc19mb3JfbXNnID0gZnVuY3Rpb24gKG1zZ19pZCwgY2FsbGJhY2tzKSB7XG4gICAgICAgIHRoaXMubGFzdF9tc2dfaWQgPSBtc2dfaWQ7XG4gICAgICAgIGlmIChjYWxsYmFja3MpIHtcbiAgICAgICAgICAgIC8vIHNoYWxsb3ctY29weSBtYXBwaW5nLCBiZWNhdXNlIHdlIHdpbGwgbW9kaWZ5IGl0IGF0IHRoZSB0b3AgbGV2ZWxcbiAgICAgICAgICAgIHZhciBjYmNvcHkgPSB0aGlzLl9tc2dfY2FsbGJhY2tzW21zZ19pZF0gPSB0aGlzLmxhc3RfbXNnX2NhbGxiYWNrcyA9IHt9O1xuICAgICAgICAgICAgY2Jjb3B5LnNoZWxsID0gY2FsbGJhY2tzLnNoZWxsO1xuICAgICAgICAgICAgY2Jjb3B5LmlvcHViID0gY2FsbGJhY2tzLmlvcHViO1xuICAgICAgICAgICAgY2Jjb3B5LmlucHV0ID0gY2FsbGJhY2tzLmlucHV0O1xuICAgICAgICAgICAgY2Jjb3B5LnNoZWxsX2RvbmUgPSAoIWNhbGxiYWNrcy5zaGVsbCk7XG4gICAgICAgICAgICBjYmNvcHkuaW9wdWJfZG9uZSA9ICghY2FsbGJhY2tzLmlvcHViKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubGFzdF9tc2dfY2FsbGJhY2tzID0ge307XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgS2VybmVsLnByb3RvdHlwZS5faGFuZGxlX3dzX21lc3NhZ2UgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIHRoaXMuX21zZ19xdWV1ZSA9IHRoaXMuX21zZ19xdWV1ZS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZS5kZXNlcmlhbGl6ZShlLmRhdGEpO1xuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKG1zZykge3JldHVybiB0aGF0Ll9maW5pc2hfd3NfbWVzc2FnZShtc2cpO30pXG4gICAgICAgIC5jYXRjaCh1dGlscy5yZWplY3QoXCJDb3VsZG4ndCBwcm9jZXNzIGtlcm5lbCBtZXNzYWdlXCIsIHRydWUpKTtcbiAgICB9O1xuXG4gICAgS2VybmVsLnByb3RvdHlwZS5fZmluaXNoX3dzX21lc3NhZ2UgPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgIHN3aXRjaCAobXNnLmNoYW5uZWwpIHtcbiAgICAgICAgICAgIGNhc2UgJ3NoZWxsJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faGFuZGxlX3NoZWxsX3JlcGx5KG1zZyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdpb3B1Yic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZV9pb3B1Yl9tZXNzYWdlKG1zZyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzdGRpbic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZV9pbnB1dF9yZXF1ZXN0KG1zZyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJ1bnJlY29nbml6ZWQgbWVzc2FnZSBjaGFubmVsXCIsIG1zZy5jaGFubmVsLCBtc2cpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIEtlcm5lbC5wcm90b3R5cGUuX2hhbmRsZV9zaGVsbF9yZXBseSA9IGZ1bmN0aW9uIChyZXBseSkge1xuICAgICAgICB0aGlzLmV2ZW50cy50cmlnZ2VyKCdzaGVsbF9yZXBseS5LZXJuZWwnLCB7a2VybmVsOiB0aGlzLCByZXBseTpyZXBseX0pO1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIHZhciBjb250ZW50ID0gcmVwbHkuY29udGVudDtcbiAgICAgICAgdmFyIG1ldGFkYXRhID0gcmVwbHkubWV0YWRhdGE7XG4gICAgICAgIHZhciBwYXJlbnRfaWQgPSByZXBseS5wYXJlbnRfaGVhZGVyLm1zZ19pZDtcbiAgICAgICAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuZ2V0X2NhbGxiYWNrc19mb3JfbXNnKHBhcmVudF9pZCk7XG4gICAgICAgIHZhciBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIGlmICghY2FsbGJhY2tzIHx8ICFjYWxsYmFja3Muc2hlbGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2hlbGxfY2FsbGJhY2tzID0gY2FsbGJhY2tzLnNoZWxsO1xuICAgICAgICBcbiAgICAgICAgLy8gc2lnbmFsIHRoYXQgc2hlbGwgY2FsbGJhY2tzIGFyZSBkb25lXG4gICAgICAgIHRoaXMuX2ZpbmlzaF9zaGVsbChwYXJlbnRfaWQpO1xuICAgICAgICBcbiAgICAgICAgaWYgKHNoZWxsX2NhbGxiYWNrcy5yZXBseSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKCkge3JldHVybiBzaGVsbF9jYWxsYmFja3MucmVwbHkocmVwbHkpfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnRlbnQucGF5bG9hZCAmJiBzaGVsbF9jYWxsYmFja3MucGF5bG9hZCkge1xuICAgICAgICAgICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhhdC5faGFuZGxlX3BheWxvYWRzKGNvbnRlbnQucGF5bG9hZCwgc2hlbGxfY2FsbGJhY2tzLnBheWxvYWQsIHJlcGx5KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gX2hhbmRsZV9wYXlsb2Fkc1xuICAgICAqL1xuICAgIEtlcm5lbC5wcm90b3R5cGUuX2hhbmRsZV9wYXlsb2FkcyA9IGZ1bmN0aW9uIChwYXlsb2FkcywgcGF5bG9hZF9jYWxsYmFja3MsIG1zZykge1xuICAgICAgICB2YXIgcHJvbWlzZSA9IFtdO1xuICAgICAgICB2YXIgbCA9IHBheWxvYWRzLmxlbmd0aDtcbiAgICAgICAgLy8gUGF5bG9hZHMgYXJlIGhhbmRsZWQgYnkgdHJpZ2dlcmluZyBldmVudHMgYmVjYXVzZSB3ZSBkb24ndCB3YW50IHRoZSBLZXJuZWxcbiAgICAgICAgLy8gdG8gZGVwZW5kIG9uIHRoZSBOb3RlYm9vayBvciBQYWdlciBjbGFzc2VzLlxuICAgICAgICBmb3IgKHZhciBpPTA7IGk8bDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcGF5bG9hZCA9IHBheWxvYWRzW2ldO1xuICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gcGF5bG9hZF9jYWxsYmFja3NbcGF5bG9hZC5zb3VyY2VdO1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZS5wdXNoKGNhbGxiYWNrKHBheWxvYWQsIG1zZykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIF9oYW5kbGVfc3RhdHVzX21lc3NhZ2VcbiAgICAgKi9cbiAgICBLZXJuZWwucHJvdG90eXBlLl9oYW5kbGVfc3RhdHVzX21lc3NhZ2UgPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgIHZhciBleGVjdXRpb25fc3RhdGUgPSBtc2cuY29udGVudC5leGVjdXRpb25fc3RhdGU7XG4gICAgICAgIHZhciBwYXJlbnRfaWQgPSBtc2cucGFyZW50X2hlYWRlci5tc2dfaWQ7XG4gICAgICAgIFxuICAgICAgICAvLyBkaXNwYXRjaCBzdGF0dXMgbXNnIGNhbGxiYWNrcywgaWYgYW55XG4gICAgICAgIHZhciBjYWxsYmFja3MgPSB0aGlzLmdldF9jYWxsYmFja3NfZm9yX21zZyhwYXJlbnRfaWQpO1xuICAgICAgICBpZiAoY2FsbGJhY2tzICYmIGNhbGxiYWNrcy5pb3B1YiAmJiBjYWxsYmFja3MuaW9wdWIuc3RhdHVzKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrcy5pb3B1Yi5zdGF0dXMobXNnKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkV4Y2VwdGlvbiBpbiBzdGF0dXMgbXNnIGhhbmRsZXJcIiwgZSwgZS5zdGFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmIChleGVjdXRpb25fc3RhdGUgPT09ICdidXN5Jykge1xuICAgICAgICAgICAgdGhpcy5ldmVudHMudHJpZ2dlcigna2VybmVsX2J1c3kuS2VybmVsJywge2tlcm5lbDogdGhpc30pO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoZXhlY3V0aW9uX3N0YXRlID09PSAnaWRsZScpIHtcbiAgICAgICAgICAgIC8vIHNpZ25hbCB0aGF0IGlvcHViIGNhbGxiYWNrcyBhcmUgKHByb2JhYmx5KSBkb25lXG4gICAgICAgICAgICAvLyBhc3luYyBvdXRwdXQgbWF5IHN0aWxsIGFycml2ZSxcbiAgICAgICAgICAgIC8vIGJ1dCBvbmx5IGZvciB0aGUgbW9zdCByZWNlbnQgcmVxdWVzdFxuICAgICAgICAgICAgdGhpcy5fZmluaXNoX2lvcHViKHBhcmVudF9pZCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIHRyaWdnZXIgc3RhdHVzX2lkbGUgZXZlbnRcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzLnRyaWdnZXIoJ2tlcm5lbF9pZGxlLktlcm5lbCcsIHtrZXJuZWw6IHRoaXN9KTtcblxuICAgICAgICB9IGVsc2UgaWYgKGV4ZWN1dGlvbl9zdGF0ZSA9PT0gJ3N0YXJ0aW5nJykge1xuICAgICAgICAgICAgdGhpcy5ldmVudHMudHJpZ2dlcigna2VybmVsX3N0YXJ0aW5nLktlcm5lbCcsIHtrZXJuZWw6IHRoaXN9KTtcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMua2VybmVsX2luZm8oZnVuY3Rpb24gKHJlcGx5KSB7XG4gICAgICAgICAgICAgICAgdGhhdC5pbmZvX3JlcGx5ID0gcmVwbHkuY29udGVudDtcbiAgICAgICAgICAgICAgICB0aGF0LmV2ZW50cy50cmlnZ2VyKCdrZXJuZWxfcmVhZHkuS2VybmVsJywge2tlcm5lbDogdGhhdH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChleGVjdXRpb25fc3RhdGUgPT09ICdyZXN0YXJ0aW5nJykge1xuICAgICAgICAgICAgLy8gYXV0b3Jlc3RhcnRpbmcgaXMgZGlzdGluY3QgZnJvbSByZXN0YXJ0aW5nLFxuICAgICAgICAgICAgLy8gaW4gdGhhdCBpdCBtZWFucyB0aGUga2VybmVsIGRpZWQgYW5kIHRoZSBzZXJ2ZXIgaXMgcmVzdGFydGluZyBpdC5cbiAgICAgICAgICAgIC8vIGtlcm5lbF9yZXN0YXJ0aW5nIHNldHMgdGhlIG5vdGlmaWNhdGlvbiB3aWRnZXQsXG4gICAgICAgICAgICAvLyBhdXRvcmVzdGFydCBzaG93cyB0aGUgbW9yZSBwcm9taW5lbnQgZGlhbG9nLlxuICAgICAgICAgICAgdGhpcy5fYXV0b3Jlc3RhcnRfYXR0ZW1wdCA9IHRoaXMuX2F1dG9yZXN0YXJ0X2F0dGVtcHQgKyAxO1xuICAgICAgICAgICAgdGhpcy5ldmVudHMudHJpZ2dlcigna2VybmVsX3Jlc3RhcnRpbmcuS2VybmVsJywge2tlcm5lbDogdGhpc30pO1xuICAgICAgICAgICAgdGhpcy5ldmVudHMudHJpZ2dlcigna2VybmVsX2F1dG9yZXN0YXJ0aW5nLktlcm5lbCcsIHtrZXJuZWw6IHRoaXMsIGF0dGVtcHQ6IHRoaXMuX2F1dG9yZXN0YXJ0X2F0dGVtcHR9KTtcblxuICAgICAgICB9IGVsc2UgaWYgKGV4ZWN1dGlvbl9zdGF0ZSA9PT0gJ2RlYWQnKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50cy50cmlnZ2VyKCdrZXJuZWxfZGVhZC5LZXJuZWwnLCB7a2VybmVsOiB0aGlzfSk7XG4gICAgICAgICAgICB0aGlzLl9rZXJuZWxfZGVhZCgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEhhbmRsZSBjbGVhcl9vdXRwdXQgbWVzc2FnZVxuICAgICAqXG4gICAgICogQGZ1bmN0aW9uIF9oYW5kbGVfY2xlYXJfb3V0cHV0XG4gICAgICovXG4gICAgS2VybmVsLnByb3RvdHlwZS5faGFuZGxlX2NsZWFyX291dHB1dCA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuZ2V0X2NhbGxiYWNrc19mb3JfbXNnKG1zZy5wYXJlbnRfaGVhZGVyLm1zZ19pZCk7XG4gICAgICAgIGlmICghY2FsbGJhY2tzIHx8ICFjYWxsYmFja3MuaW9wdWIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2FsbGJhY2sgPSBjYWxsYmFja3MuaW9wdWIuY2xlYXJfb3V0cHV0O1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG1zZyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogaGFuZGxlIGFuIG91dHB1dCBtZXNzYWdlIChleGVjdXRlX3Jlc3VsdCwgZGlzcGxheV9kYXRhLCBldGMuKVxuICAgICAqXG4gICAgICogQGZ1bmN0aW9uIF9oYW5kbGVfb3V0cHV0X21lc3NhZ2VcbiAgICAgKi9cbiAgICBLZXJuZWwucHJvdG90eXBlLl9oYW5kbGVfb3V0cHV0X21lc3NhZ2UgPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgIHZhciBjYWxsYmFja3MgPSB0aGlzLmdldF9jYWxsYmFja3NfZm9yX21zZyhtc2cucGFyZW50X2hlYWRlci5tc2dfaWQpO1xuICAgICAgICBpZiAoIWNhbGxiYWNrcyB8fCAhY2FsbGJhY2tzLmlvcHViKSB7XG4gICAgICAgICAgICAvLyBUaGUgbWVzc2FnZSBjYW1lIGZyb20gYW5vdGhlciBjbGllbnQuIExldCB0aGUgVUkgZGVjaWRlIHdoYXQgdG9cbiAgICAgICAgICAgIC8vIGRvIHdpdGggaXQuXG4gICAgICAgICAgICB0aGlzLmV2ZW50cy50cmlnZ2VyKCdyZWNlaXZlZF91bnNvbGljaXRlZF9tZXNzYWdlLktlcm5lbCcsIG1zZyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNhbGxiYWNrID0gY2FsbGJhY2tzLmlvcHViLm91dHB1dDtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhtc2cpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEhhbmRsZSBhbiBpbnB1dCBtZXNzYWdlIChleGVjdXRlX2lucHV0KS5cbiAgICAgKlxuICAgICAqIEBmdW5jdGlvbiBfaGFuZGxlX2lucHV0IG1lc3NhZ2VcbiAgICAgKi9cbiAgICBLZXJuZWwucHJvdG90eXBlLl9oYW5kbGVfaW5wdXRfbWVzc2FnZSA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuZ2V0X2NhbGxiYWNrc19mb3JfbXNnKG1zZy5wYXJlbnRfaGVhZGVyLm1zZ19pZCk7XG4gICAgICAgIGlmICghY2FsbGJhY2tzKSB7XG4gICAgICAgICAgICAvLyBUaGUgbWVzc2FnZSBjYW1lIGZyb20gYW5vdGhlciBjbGllbnQuIExldCB0aGUgVUkgZGVjaWRlIHdoYXQgdG9cbiAgICAgICAgICAgIC8vIGRvIHdpdGggaXQuXG4gICAgICAgICAgICB0aGlzLmV2ZW50cy50cmlnZ2VyKCdyZWNlaXZlZF91bnNvbGljaXRlZF9tZXNzYWdlLktlcm5lbCcsIG1zZyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGlzcGF0Y2ggSU9QdWIgbWVzc2FnZXMgdG8gcmVzcGVjdGl2ZSBoYW5kbGVycy4gRWFjaCBtZXNzYWdlXG4gICAgICogdHlwZSBzaG91bGQgaGF2ZSBhIGhhbmRsZXIuXG4gICAgICpcbiAgICAgKiBAZnVuY3Rpb24gX2hhbmRsZV9pb3B1Yl9tZXNzYWdlXG4gICAgICovXG4gICAgS2VybmVsLnByb3RvdHlwZS5faGFuZGxlX2lvcHViX21lc3NhZ2UgPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgIHZhciBoYW5kbGVyID0gdGhpcy5nZXRfaW9wdWJfaGFuZGxlcihtc2cuaGVhZGVyLm1zZ190eXBlKTtcbiAgICAgICAgaWYgKGhhbmRsZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZXIobXNnKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gX2hhbmRsZV9pbnB1dF9yZXF1ZXN0XG4gICAgICovXG4gICAgS2VybmVsLnByb3RvdHlwZS5faGFuZGxlX2lucHV0X3JlcXVlc3QgPSBmdW5jdGlvbiAocmVxdWVzdCkge1xuICAgICAgICB2YXIgaGVhZGVyID0gcmVxdWVzdC5oZWFkZXI7XG4gICAgICAgIHZhciBjb250ZW50ID0gcmVxdWVzdC5jb250ZW50O1xuICAgICAgICB2YXIgbWV0YWRhdGEgPSByZXF1ZXN0Lm1ldGFkYXRhO1xuICAgICAgICB2YXIgbXNnX3R5cGUgPSBoZWFkZXIubXNnX3R5cGU7XG4gICAgICAgIGlmIChtc2dfdHlwZSAhPT0gJ2lucHV0X3JlcXVlc3QnKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkludmFsaWQgaW5wdXQgcmVxdWVzdCFcIiwgcmVxdWVzdCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuZ2V0X2NhbGxiYWNrc19mb3JfbXNnKHJlcXVlc3QucGFyZW50X2hlYWRlci5tc2dfaWQpO1xuICAgICAgICBpZiAoY2FsbGJhY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2tzLmlucHV0KSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2tzLmlucHV0KHJlcXVlc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIGV4cG9ydHMuS2VybmVsID0gS2VybmVsO1xuIiwiLy8gQ29weXJpZ2h0IChjKSBKdXB5dGVyIERldmVsb3BtZW50IFRlYW0uXG4vLyBEaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIE1vZGlmaWVkIEJTRCBMaWNlbnNlLlxuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgdmFyIF9kZXNlcmlhbGl6ZV9hcnJheV9idWZmZXIgPSBmdW5jdGlvbiAoYnVmKSB7XG4gICAgICAgIHZhciBkYXRhID0gbmV3IERhdGFWaWV3KGJ1Zik7XG4gICAgICAgIC8vIHJlYWQgdGhlIGhlYWRlcjogMSArIG5idWZzIDMyYiBpbnRlZ2Vyc1xuICAgICAgICB2YXIgbmJ1ZnMgPSBkYXRhLmdldFVpbnQzMigwKTtcbiAgICAgICAgdmFyIG9mZnNldHMgPSBbXTtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPD0gbmJ1ZnM7IGkrKykge1xuICAgICAgICAgICAgb2Zmc2V0cy5wdXNoKGRhdGEuZ2V0VWludDMyKGkgKiA0KSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGpzb25fYnl0ZXMgPSBuZXcgVWludDhBcnJheShidWYuc2xpY2Uob2Zmc2V0c1swXSwgb2Zmc2V0c1sxXSkpO1xuICAgICAgICB2YXIgbXNnID0gSlNPTi5wYXJzZShcbiAgICAgICAgICAgIChuZXcgVGV4dERlY29kZXIoJ3V0ZjgnKSkuZGVjb2RlKGpzb25fYnl0ZXMpXG4gICAgICAgICk7XG4gICAgICAgIC8vIHRoZSByZW1haW5pbmcgY2h1bmtzIGFyZSBzdG9yZWQgYXMgRGF0YVZpZXdzIGluIG1zZy5idWZmZXJzXG4gICAgICAgIG1zZy5idWZmZXJzID0gW107XG4gICAgICAgIHZhciBzdGFydCwgc3RvcDtcbiAgICAgICAgZm9yIChpID0gMTsgaSA8IG5idWZzOyBpKyspIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gb2Zmc2V0c1tpXTtcbiAgICAgICAgICAgIHN0b3AgPSBvZmZzZXRzW2krMV0gfHwgYnVmLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICBtc2cuYnVmZmVycy5wdXNoKG5ldyBEYXRhVmlldyhidWYuc2xpY2Uoc3RhcnQsIHN0b3ApKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1zZztcbiAgICB9O1xuXG4gICAgdmFyIF9kZXNlcmlhbGl6ZV9iaW5hcnkgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBkZXNlcmlhbGl6ZSB0aGUgYmluYXJ5IG1lc3NhZ2UgZm9ybWF0XG4gICAgICAgICAqIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHdpdGggYSBtZXNzYWdlIHdob3NlIGJ1ZmZlcnMgYXR0cmlidXRlXG4gICAgICAgICAqIHdpbGwgYmUgYW4gYXJyYXkgb2YgRGF0YVZpZXdzLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgICAgICAgICAvLyBkYXRhIGlzIEJsb2IsIGhhdmUgdG8gZGVzZXJpYWxpemUgZnJvbSBBcnJheUJ1ZmZlciBpbiByZWFkZXIgY2FsbGJhY2tcbiAgICAgICAgICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICByZWFkZXIub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbXNnID0gX2Rlc2VyaWFsaXplX2FycmF5X2J1ZmZlcih0aGlzLnJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUobXNnKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoZGF0YSk7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGRhdGEgaXMgQXJyYXlCdWZmZXIsIGNhbiBkZXNlcmlhbGl6ZSBkaXJlY3RseVxuICAgICAgICAgICAgdmFyIG1zZyA9IF9kZXNlcmlhbGl6ZV9hcnJheV9idWZmZXIoZGF0YSk7XG4gICAgICAgICAgICByZXR1cm4gbXNnO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBkZXNlcmlhbGl6ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBkZXNlcmlhbGl6ZSBhIG1lc3NhZ2UgYW5kIHJldHVybiBhIHByb21pc2UgZm9yIHRoZSB1bnBhY2tlZCBtZXNzYWdlXG4gICAgICAgICAqL1xuICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIC8vIHRleHQgSlNPTiBtZXNzYWdlXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKEpTT04ucGFyc2UoZGF0YSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gYmluYXJ5IG1lc3NhZ2VcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoX2Rlc2VyaWFsaXplX2JpbmFyeShkYXRhKSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIF9zZXJpYWxpemVfYmluYXJ5ID0gZnVuY3Rpb24gKG1zZykge1xuICAgICAgICAvKipcbiAgICAgICAgICogaW1wbGVtZW50IHRoZSBiaW5hcnkgc2VyaWFsaXphdGlvbiBwcm90b2NvbFxuICAgICAgICAgKiBzZXJpYWxpemVzIEpTT04gbWVzc2FnZSB0byBBcnJheUJ1ZmZlclxuICAgICAgICAgKi9cbiAgICAgICAgbXNnID0gXy5jbG9uZShtc2cpO1xuICAgICAgICB2YXIgb2Zmc2V0cyA9IFtdO1xuICAgICAgICB2YXIgYnVmZmVycyA9IFtdO1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG1zZy5idWZmZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBtc2cuYnVmZmVycyBlbGVtZW50cyBjb3VsZCBiZSBlaXRoZXIgdmlld3Mgb3IgQXJyYXlCdWZmZXJzXG4gICAgICAgICAgICAvLyBidWZmZXJzIGVsZW1lbnRzIGFyZSBBcnJheUJ1ZmZlcnNcbiAgICAgICAgICAgIHZhciBiID0gbXNnLmJ1ZmZlcnNbaV07XG4gICAgICAgICAgICBidWZmZXJzLnB1c2goYi5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciA/IGIuYnVmZmVyIDogYik7XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIG1zZy5idWZmZXJzO1xuICAgICAgICB2YXIganNvbl91dGY4ID0gKG5ldyBUZXh0RW5jb2RlcigndXRmOCcpKS5lbmNvZGUoSlNPTi5zdHJpbmdpZnkobXNnKSk7XG4gICAgICAgIGJ1ZmZlcnMudW5zaGlmdChqc29uX3V0ZjgpO1xuICAgICAgICB2YXIgbmJ1ZnMgPSBidWZmZXJzLmxlbmd0aDtcbiAgICAgICAgb2Zmc2V0cy5wdXNoKDQgKiAobmJ1ZnMgKyAxKSk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgKyAxIDwgYnVmZmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgb2Zmc2V0cy5wdXNoKG9mZnNldHNbb2Zmc2V0cy5sZW5ndGgtMV0gKyBidWZmZXJzW2ldLmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtc2dfYnVmID0gbmV3IFVpbnQ4QXJyYXkoXG4gICAgICAgICAgICBvZmZzZXRzW29mZnNldHMubGVuZ3RoLTFdICsgYnVmZmVyc1tidWZmZXJzLmxlbmd0aC0xXS5ieXRlTGVuZ3RoXG4gICAgICAgICk7XG4gICAgICAgIC8vIHVzZSBEYXRhVmlldy5zZXRVaW50MzIgZm9yIG5ldHdvcmsgYnl0ZS1vcmRlclxuICAgICAgICB2YXIgdmlldyA9IG5ldyBEYXRhVmlldyhtc2dfYnVmLmJ1ZmZlcik7XG4gICAgICAgIC8vIHdyaXRlIG5idWZzIHRvIGZpcnN0IDQgYnl0ZXNcbiAgICAgICAgdmlldy5zZXRVaW50MzIoMCwgbmJ1ZnMpO1xuICAgICAgICAvLyB3cml0ZSBvZmZzZXRzIHRvIG5leHQgNCAqIG5idWZzIGJ5dGVzXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBvZmZzZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2aWV3LnNldFVpbnQzMig0ICogKGkrMSksIG9mZnNldHNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHdyaXRlIGFsbCB0aGUgYnVmZmVycyBhdCB0aGVpciByZXNwZWN0aXZlIG9mZnNldHNcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGJ1ZmZlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG1zZ19idWYuc2V0KG5ldyBVaW50OEFycmF5KGJ1ZmZlcnNbaV0pLCBvZmZzZXRzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gcmV0dXJuIHJhdyBBcnJheUJ1ZmZlclxuICAgICAgICByZXR1cm4gbXNnX2J1Zi5idWZmZXI7XG4gICAgfTtcblxuICAgIHZhciBzZXJpYWxpemUgPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgIGlmIChtc2cuYnVmZmVycyAmJiBtc2cuYnVmZmVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBfc2VyaWFsaXplX2JpbmFyeShtc2cpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG1zZyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIGRlc2VyaWFsaXplIDogZGVzZXJpYWxpemUsXG4gICAgICAgIHNlcmlhbGl6ZTogc2VyaWFsaXplXG4gICAgfTtcbiIsIi8vIENvcHlyaWdodCAoYykgSnVweXRlciBEZXZlbG9wbWVudCBUZWFtLlxuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBNb2RpZmllZCBCU0QgTGljZW5zZS5cbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIHZhciB1dGlscyA9IHJlcXVpcmUoJ2Jhc2UvanMvdXRpbHMnKTtcbiAgICB2YXIga2VybmVsID0gcmVxdWlyZSgnc2VydmljZXMva2VybmVscy9rZXJuZWwnKTtcblxuICAgIC8qKlxuICAgICAqIFNlc3Npb24gb2JqZWN0IGZvciBhY2Nlc3NpbmcgdGhlIHNlc3Npb24gUkVTVCBhcGkuIFRoZSBzZXNzaW9uXG4gICAgICogc2hvdWxkIGJlIHVzZWQgdG8gc3RhcnQga2VybmVscyBhbmQgdGhlbiBzaHV0IHRoZW0gZG93biAtLSBmb3JcbiAgICAgKiBhbGwgb3RoZXIgb3BlcmF0aW9ucywgdGhlIGtlcm5lbCBvYmplY3Qgc2hvdWxkIGJlIHVzZWQuXG4gICAgICpcbiAgICAgKiBQcmVsaW1pbmFyeSBkb2N1bWVudGF0aW9uIGZvciB0aGUgUkVTVCBBUEkgaXMgYXQgXG4gICAgICogaHR0cHM6Ly9naXRodWIuY29tL2lweXRob24vaXB5dGhvbi93aWtpL0lQRVAtMTYlM0EtTm90ZWJvb2stbXVsdGktZGlyZWN0b3J5LWRhc2hib2FyZC1hbmQtVVJMLW1hcHBpbmcjc2Vzc2lvbnMtYXBpXG4gICAgICpcbiAgICAgKiBPcHRpb25zIHNob3VsZCBpbmNsdWRlOlxuICAgICAqICAtIG5vdGVib29rX3BhdGg6IHRoZSBwYXRoIChub3QgaW5jbHVkaW5nIG5hbWUpIHRvIHRoZSBub3RlYm9va1xuICAgICAqICAtIGtlcm5lbF9uYW1lOiB0aGUgdHlwZSBvZiBrZXJuZWwgKGUuZy4gcHl0aG9uMylcbiAgICAgKiAgLSBiYXNlX3VybDogdGhlIHJvb3QgdXJsIG9mIHRoZSBub3RlYm9vayBzZXJ2ZXJcbiAgICAgKiAgLSB3c191cmw6IHRoZSB1cmwgdG8gYWNjZXNzIHdlYnNvY2tldHNcbiAgICAgKiAgLSBub3RlYm9vazogTm90ZWJvb2sgb2JqZWN0XG4gICAgICpcbiAgICAgKiBAY2xhc3MgU2Vzc2lvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICovXG4gICAgdmFyIFNlc3Npb24gPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLmlkID0gbnVsbDtcbiAgICAgICAgdGhpcy5ub3RlYm9va19tb2RlbCA9IHtcbiAgICAgICAgICAgIHBhdGg6IG9wdGlvbnMubm90ZWJvb2tfcGF0aFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmtlcm5lbF9tb2RlbCA9IHtcbiAgICAgICAgICAgIGlkOiBudWxsLFxuICAgICAgICAgICAgbmFtZTogb3B0aW9ucy5rZXJuZWxfbmFtZVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuYmFzZV91cmwgPSBvcHRpb25zLmJhc2VfdXJsO1xuICAgICAgICB0aGlzLndzX3VybCA9IG9wdGlvbnMud3NfdXJsO1xuICAgICAgICB0aGlzLnNlc3Npb25fc2VydmljZV91cmwgPSB1dGlscy51cmxfam9pbl9lbmNvZGUodGhpcy5iYXNlX3VybCwgJ2FwaS9zZXNzaW9ucycpO1xuICAgICAgICB0aGlzLnNlc3Npb25fdXJsID0gbnVsbDtcblxuICAgICAgICB0aGlzLm5vdGVib29rID0gb3B0aW9ucy5ub3RlYm9vaztcbiAgICAgICAgdGhpcy5rZXJuZWwgPSBudWxsO1xuICAgICAgICB0aGlzLmV2ZW50cyA9IG9wdGlvbnMubm90ZWJvb2suZXZlbnRzO1xuXG4gICAgICAgIHRoaXMuYmluZF9ldmVudHMoKTtcbiAgICB9O1xuXG4gICAgU2Vzc2lvbi5wcm90b3R5cGUuYmluZF9ldmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgdmFyIHJlY29yZF9zdGF0dXMgPSBmdW5jdGlvbiAoZXZ0LCBpbmZvKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnU2Vzc2lvbjogJyArIGV2dC50eXBlICsgJyAoJyArIGluZm8uc2Vzc2lvbi5pZCArICcpJyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5ldmVudHMub24oJ2tlcm5lbF9jcmVhdGVkLlNlc3Npb24nLCByZWNvcmRfc3RhdHVzKTtcbiAgICAgICAgdGhpcy5ldmVudHMub24oJ2tlcm5lbF9kZWFkLlNlc3Npb24nLCByZWNvcmRfc3RhdHVzKTtcbiAgICAgICAgdGhpcy5ldmVudHMub24oJ2tlcm5lbF9raWxsZWQuU2Vzc2lvbicsIHJlY29yZF9zdGF0dXMpO1xuXG4gICAgICAgIC8vIGlmIHRoZSBrZXJuZWwgZGllcywgdGhlbiBhbHNvIHJlbW92ZSB0aGUgc2Vzc2lvblxuICAgICAgICB0aGlzLmV2ZW50cy5vbigna2VybmVsX2RlYWQuS2VybmVsJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhhdC5kZWxldGUoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuXG4gICAgLy8gUHVibGljIFJFU1QgYXBpIGZ1bmN0aW9uc1xuXG4gICAgLyoqXG4gICAgICogR0VUIC9hcGkvc2Vzc2lvbnNcbiAgICAgKlxuICAgICAqIEdldCBhIGxpc3Qgb2YgdGhlIGN1cnJlbnQgc2Vzc2lvbnMuXG4gICAgICpcbiAgICAgKiBAZnVuY3Rpb24gbGlzdFxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtzdWNjZXNzXSAtIGZ1bmN0aW9uIGV4ZWN1dGVkIG9uIGFqYXggc3VjY2Vzc1xuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtlcnJvcl0gLSBmdW5jdG9uIGV4ZWN1dGVkIG9uIGFqYXggZXJyb3JcbiAgICAgKi9cbiAgICBTZXNzaW9uLnByb3RvdHlwZS5saXN0ID0gZnVuY3Rpb24gKHN1Y2Nlc3MsIGVycm9yKSB7XG4gICAgICAgICQuYWpheCh0aGlzLnNlc3Npb25fc2VydmljZV91cmwsIHtcbiAgICAgICAgICAgIHByb2Nlc3NEYXRhOiBmYWxzZSxcbiAgICAgICAgICAgIGNhY2hlOiBmYWxzZSxcbiAgICAgICAgICAgIHR5cGU6IFwiR0VUXCIsXG4gICAgICAgICAgICBkYXRhVHlwZTogXCJqc29uXCIsXG4gICAgICAgICAgICBzdWNjZXNzOiBzdWNjZXNzLFxuICAgICAgICAgICAgZXJyb3I6IHRoaXMuX29uX2Vycm9yKGVycm9yKVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUE9TVCAvYXBpL3Nlc3Npb25zXG4gICAgICpcbiAgICAgKiBTdGFydCBhIG5ldyBzZXNzaW9uLiBUaGlzIGZ1bmN0aW9uIGNhbiBvbmx5IGV4ZWN1dGVkIG9uY2UuXG4gICAgICpcbiAgICAgKiBAZnVuY3Rpb24gc3RhcnRcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbc3VjY2Vzc10gLSBmdW5jdGlvbiBleGVjdXRlZCBvbiBhamF4IHN1Y2Nlc3NcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbZXJyb3JdIC0gZnVuY3RvbiBleGVjdXRlZCBvbiBhamF4IGVycm9yXG4gICAgICovXG4gICAgU2Vzc2lvbi5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICB2YXIgb25fc3VjY2VzcyA9IGZ1bmN0aW9uIChkYXRhLCBzdGF0dXMsIHhocikge1xuICAgICAgICAgICAgaWYgKHRoYXQua2VybmVsKSB7XG4gICAgICAgICAgICAgICAgdGhhdC5rZXJuZWwubmFtZSA9IHRoYXQua2VybmVsX21vZGVsLm5hbWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBrZXJuZWxfc2VydmljZV91cmwgPSB1dGlscy51cmxfcGF0aF9qb2luKHRoYXQuYmFzZV91cmwsIFwiYXBpL2tlcm5lbHNcIik7XG4gICAgICAgICAgICAgICAgdGhhdC5rZXJuZWwgPSBuZXcga2VybmVsLktlcm5lbChrZXJuZWxfc2VydmljZV91cmwsIHRoYXQud3NfdXJsLCB0aGF0Lmtlcm5lbF9tb2RlbC5uYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoYXQuZXZlbnRzLnRyaWdnZXIoJ2tlcm5lbF9jcmVhdGVkLlNlc3Npb24nLCB7c2Vzc2lvbjogdGhhdCwga2VybmVsOiB0aGF0Lmtlcm5lbH0pO1xuICAgICAgICAgICAgdGhhdC5rZXJuZWwuX2tlcm5lbF9jcmVhdGVkKGRhdGEua2VybmVsKTtcbiAgICAgICAgICAgIGlmIChzdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgc3VjY2VzcyhkYXRhLCBzdGF0dXMsIHhocik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciBvbl9lcnJvciA9IGZ1bmN0aW9uICh4aHIsIHN0YXR1cywgZXJyKSB7XG4gICAgICAgICAgICB0aGF0LmV2ZW50cy50cmlnZ2VyKCdrZXJuZWxfZGVhZC5TZXNzaW9uJywge3Nlc3Npb246IHRoYXQsIHhocjogeGhyLCBzdGF0dXM6IHN0YXR1cywgZXJyb3I6IGVycn0pO1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IoeGhyLCBzdGF0dXMsIGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgJC5hamF4KHRoaXMuc2Vzc2lvbl9zZXJ2aWNlX3VybCwge1xuICAgICAgICAgICAgcHJvY2Vzc0RhdGE6IGZhbHNlLFxuICAgICAgICAgICAgY2FjaGU6IGZhbHNlLFxuICAgICAgICAgICAgdHlwZTogXCJQT1NUXCIsXG4gICAgICAgICAgICBkYXRhOiBKU09OLnN0cmluZ2lmeSh0aGlzLl9nZXRfbW9kZWwoKSksXG4gICAgICAgICAgICBjb250ZW50VHlwZTogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgZGF0YVR5cGU6IFwianNvblwiLFxuICAgICAgICAgICAgc3VjY2VzczogdGhpcy5fb25fc3VjY2Vzcyhvbl9zdWNjZXNzKSxcbiAgICAgICAgICAgIGVycm9yOiB0aGlzLl9vbl9lcnJvcihvbl9lcnJvcilcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdFVCAvYXBpL3Nlc3Npb25zL1s6c2Vzc2lvbl9pZF1cbiAgICAgKlxuICAgICAqIEdldCBpbmZvcm1hdGlvbiBhYm91dCBhIHNlc3Npb24uXG4gICAgICpcbiAgICAgKiBAZnVuY3Rpb24gZ2V0X2luZm9cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbc3VjY2Vzc10gLSBmdW5jdGlvbiBleGVjdXRlZCBvbiBhamF4IHN1Y2Nlc3NcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbZXJyb3JdIC0gZnVuY3RvbiBleGVjdXRlZCBvbiBhamF4IGVycm9yXG4gICAgICovXG4gICAgU2Vzc2lvbi5wcm90b3R5cGUuZ2V0X2luZm8gPSBmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcbiAgICAgICAgJC5hamF4KHRoaXMuc2Vzc2lvbl91cmwsIHtcbiAgICAgICAgICAgIHByb2Nlc3NEYXRhOiBmYWxzZSxcbiAgICAgICAgICAgIGNhY2hlOiBmYWxzZSxcbiAgICAgICAgICAgIHR5cGU6IFwiR0VUXCIsXG4gICAgICAgICAgICBkYXRhVHlwZTogXCJqc29uXCIsXG4gICAgICAgICAgICBzdWNjZXNzOiB0aGlzLl9vbl9zdWNjZXNzKHN1Y2Nlc3MpLFxuICAgICAgICAgICAgZXJyb3I6IHRoaXMuX29uX2Vycm9yKGVycm9yKVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUEFUQ0ggL2FwaS9zZXNzaW9ucy9bOnNlc3Npb25faWRdXG4gICAgICpcbiAgICAgKiBSZW5hbWUgb3IgbW92ZSBhIG5vdGVib29rLiBJZiB0aGUgZ2l2ZW4gbmFtZSBvciBwYXRoIGFyZVxuICAgICAqIHVuZGVmaW5lZCwgdGhlbiB0aGV5IHdpbGwgbm90IGJlIGNoYW5nZWQuXG4gICAgICpcbiAgICAgKiBAZnVuY3Rpb24gcmVuYW1lX25vdGVib29rXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYXRoXSAtIG5ldyBub3RlYm9vayBwYXRoXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gW3N1Y2Nlc3NdIC0gZnVuY3Rpb24gZXhlY3V0ZWQgb24gYWpheCBzdWNjZXNzXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2Vycm9yXSAtIGZ1bmN0b24gZXhlY3V0ZWQgb24gYWpheCBlcnJvclxuICAgICAqL1xuICAgIFNlc3Npb24ucHJvdG90eXBlLnJlbmFtZV9ub3RlYm9vayA9IGZ1bmN0aW9uIChwYXRoLCBzdWNjZXNzLCBlcnJvcikge1xuICAgICAgICBpZiAocGF0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLm5vdGVib29rX21vZGVsLnBhdGggPSBwYXRoO1xuICAgICAgICB9XG5cbiAgICAgICAgJC5hamF4KHRoaXMuc2Vzc2lvbl91cmwsIHtcbiAgICAgICAgICAgIHByb2Nlc3NEYXRhOiBmYWxzZSxcbiAgICAgICAgICAgIGNhY2hlOiBmYWxzZSxcbiAgICAgICAgICAgIHR5cGU6IFwiUEFUQ0hcIixcbiAgICAgICAgICAgIGRhdGE6IEpTT04uc3RyaW5naWZ5KHRoaXMuX2dldF9tb2RlbCgpKSxcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICBkYXRhVHlwZTogXCJqc29uXCIsXG4gICAgICAgICAgICBzdWNjZXNzOiB0aGlzLl9vbl9zdWNjZXNzKHN1Y2Nlc3MpLFxuICAgICAgICAgICAgZXJyb3I6IHRoaXMuX29uX2Vycm9yKGVycm9yKVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogREVMRVRFIC9hcGkvc2Vzc2lvbnMvWzpzZXNzaW9uX2lkXVxuICAgICAqXG4gICAgICogS2lsbCB0aGUga2VybmVsIGFuZCBzaHV0ZG93biB0aGUgc2Vzc2lvbi5cbiAgICAgKlxuICAgICAqIEBmdW5jdGlvbiBkZWxldGVcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbc3VjY2Vzc10gLSBmdW5jdGlvbiBleGVjdXRlZCBvbiBhamF4IHN1Y2Nlc3NcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbZXJyb3JdIC0gZnVuY3RvbiBleGVjdXRlZCBvbiBhamF4IGVycm9yXG4gICAgICovXG4gICAgU2Vzc2lvbi5wcm90b3R5cGUuZGVsZXRlID0gZnVuY3Rpb24gKHN1Y2Nlc3MsIGVycm9yKSB7XG4gICAgICAgIGlmICh0aGlzLmtlcm5lbCkge1xuICAgICAgICAgICAgdGhpcy5ldmVudHMudHJpZ2dlcigna2VybmVsX2tpbGxlZC5TZXNzaW9uJywge3Nlc3Npb246IHRoaXMsIGtlcm5lbDogdGhpcy5rZXJuZWx9KTtcbiAgICAgICAgICAgIHRoaXMua2VybmVsLl9rZXJuZWxfZGVhZCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgJC5hamF4KHRoaXMuc2Vzc2lvbl91cmwsIHtcbiAgICAgICAgICAgIHByb2Nlc3NEYXRhOiBmYWxzZSxcbiAgICAgICAgICAgIGNhY2hlOiBmYWxzZSxcbiAgICAgICAgICAgIHR5cGU6IFwiREVMRVRFXCIsXG4gICAgICAgICAgICBkYXRhVHlwZTogXCJqc29uXCIsXG4gICAgICAgICAgICBzdWNjZXNzOiB0aGlzLl9vbl9zdWNjZXNzKHN1Y2Nlc3MpLFxuICAgICAgICAgICAgZXJyb3I6IHRoaXMuX29uX2Vycm9yKGVycm9yKVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVzdGFydCB0aGUgc2Vzc2lvbiBieSBkZWxldGluZyBpdCBhbmQgdGhlIHN0YXJ0aW5nIGl0XG4gICAgICogZnJlc2guIElmIG9wdGlvbnMgYXJlIGdpdmVuLCB0aGV5IGNhbiBpbmNsdWRlIGFueSBvZiB0aGVcbiAgICAgKiBmb2xsb3dpbmc6XG4gICAgICpcbiAgICAgKiAtIG5vdGVib29rX3BhdGggLSB0aGUgcGF0aCB0byB0aGUgbm90ZWJvb2tcbiAgICAgKiAtIGtlcm5lbF9uYW1lIC0gdGhlIG5hbWUgKHR5cGUpIG9mIHRoZSBrZXJuZWxcbiAgICAgKlxuICAgICAqIEBmdW5jdGlvbiByZXN0YXJ0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIG9wdGlvbnMgZm9yIHRoZSBuZXcga2VybmVsXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gW3N1Y2Nlc3NdIC0gZnVuY3Rpb24gZXhlY3V0ZWQgb24gYWpheCBzdWNjZXNzXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2Vycm9yXSAtIGZ1bmN0b24gZXhlY3V0ZWQgb24gYWpheCBlcnJvclxuICAgICAqL1xuICAgIFNlc3Npb24ucHJvdG90eXBlLnJlc3RhcnQgPSBmdW5jdGlvbiAob3B0aW9ucywgc3VjY2VzcywgZXJyb3IpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICB2YXIgc3RhcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLm5vdGVib29rX3BhdGgpIHtcbiAgICAgICAgICAgICAgICB0aGF0Lm5vdGVib29rX21vZGVsLnBhdGggPSBvcHRpb25zLm5vdGVib29rX3BhdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmtlcm5lbF9uYW1lKSB7XG4gICAgICAgICAgICAgICAgdGhhdC5rZXJuZWxfbW9kZWwubmFtZSA9IG9wdGlvbnMua2VybmVsX25hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGF0Lmtlcm5lbF9tb2RlbC5pZCA9IG51bGw7XG4gICAgICAgICAgICB0aGF0LnN0YXJ0KHN1Y2Nlc3MsIGVycm9yKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kZWxldGUoc3RhcnQsIHN0YXJ0KTtcbiAgICB9O1xuXG4gICAgLy8gSGVscGVyIGZ1bmN0aW9uc1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBkYXRhIG1vZGVsIGZvciB0aGUgc2Vzc2lvbiwgd2hpY2ggaW5jbHVkZXMgdGhlIG5vdGVib29rIHBhdGhcbiAgICAgKiBhbmQga2VybmVsIChuYW1lIGFuZCBpZCkuXG4gICAgICpcbiAgICAgKiBAZnVuY3Rpb24gX2dldF9tb2RlbFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IC0gdGhlIGRhdGEgbW9kZWxcbiAgICAgKi9cbiAgICBTZXNzaW9uLnByb3RvdHlwZS5fZ2V0X21vZGVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbm90ZWJvb2s6IHRoaXMubm90ZWJvb2tfbW9kZWwsXG4gICAgICAgICAgICBrZXJuZWw6IHRoaXMua2VybmVsX21vZGVsXG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgZGF0YSBtb2RlbCBmcm9tIHRoZSBnaXZlbiBKU09OIG9iamVjdCwgd2hpY2ggc2hvdWxkXG4gICAgICogaGF2ZSBhdHRyaWJ1dGVzIG9mIGBpZGAsIGBub3RlYm9va2AsIGFuZC9vciBga2VybmVsYC4gSWZcbiAgICAgKiBwcm92aWRlZCwgdGhlIG5vdGVib29rIGRhdGEgbXVzdCBpbmNsdWRlIG5hbWUgYW5kIHBhdGgsIGFuZCB0aGVcbiAgICAgKiBrZXJuZWwgZGF0YSBtdXN0IGluY2x1ZGUgbmFtZSBhbmQgaWQuXG4gICAgICpcbiAgICAgKiBAZnVuY3Rpb24gX3VwZGF0ZV9tb2RlbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gdXBkYXRlZCBkYXRhIG1vZGVsXG4gICAgICovXG4gICAgU2Vzc2lvbi5wcm90b3R5cGUuX3VwZGF0ZV9tb2RlbCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIGlmIChkYXRhICYmIGRhdGEuaWQpIHtcbiAgICAgICAgICAgIHRoaXMuaWQgPSBkYXRhLmlkO1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uX3VybCA9IHV0aWxzLnVybF9qb2luX2VuY29kZSh0aGlzLnNlc3Npb25fc2VydmljZV91cmwsIHRoaXMuaWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhICYmIGRhdGEubm90ZWJvb2spIHtcbiAgICAgICAgICAgIHRoaXMubm90ZWJvb2tfbW9kZWwucGF0aCA9IGRhdGEubm90ZWJvb2sucGF0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YSAmJiBkYXRhLmtlcm5lbCkge1xuICAgICAgICAgICAgdGhpcy5rZXJuZWxfbW9kZWwubmFtZSA9IGRhdGEua2VybmVsLm5hbWU7XG4gICAgICAgICAgICB0aGlzLmtlcm5lbF9tb2RlbC5pZCA9IGRhdGEua2VybmVsLmlkO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEhhbmRsZSBhIHN1Y2Nlc3NmdWwgQUpBWCByZXF1ZXN0IGJ5IHVwZGF0aW5nIHRoZSBzZXNzaW9uIGRhdGFcbiAgICAgKiBtb2RlbCB3aXRoIHRoZSByZXNwb25zZSwgYW5kIHRoZW4gb3B0aW9uYWxseSBjYWxsaW5nIGEgcHJvdmlkZWRcbiAgICAgKiBjYWxsYmFjay5cbiAgICAgKlxuICAgICAqIEBmdW5jdGlvbiBfb25fc3VjY2Vzc1xuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IHN1Y2Nlc3MgLSBjYWxsYmFja1xuICAgICAqL1xuICAgIFNlc3Npb24ucHJvdG90eXBlLl9vbl9zdWNjZXNzID0gZnVuY3Rpb24gKHN1Y2Nlc3MpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGRhdGEsIHN0YXR1cywgeGhyKSB7XG4gICAgICAgICAgICB0aGF0Ll91cGRhdGVfbW9kZWwoZGF0YSk7XG4gICAgICAgICAgICBpZiAoc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3MoZGF0YSwgc3RhdHVzLCB4aHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgYSBmYWlsZWQgQUpBWCByZXF1ZXN0IGJ5IGxvZ2dpbmcgdGhlIGVycm9yIG1lc3NhZ2UsIGFuZFxuICAgICAqIHRoZW4gb3B0aW9uYWxseSBjYWxsaW5nIGEgcHJvdmlkZWQgY2FsbGJhY2suXG4gICAgICpcbiAgICAgKiBAZnVuY3Rpb24gX29uX2Vycm9yXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZXJyb3IgLSBjYWxsYmFja1xuICAgICAqL1xuICAgIFNlc3Npb24ucHJvdG90eXBlLl9vbl9lcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHhociwgc3RhdHVzLCBlcnIpIHtcbiAgICAgICAgICAgIHV0aWxzLmxvZ19hamF4X2Vycm9yKHhociwgc3RhdHVzLCBlcnIpO1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IoeGhyLCBzdGF0dXMsIGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEVycm9yIHR5cGUgaW5kaWNhdGluZyB0aGF0IHRoZSBzZXNzaW9uIGlzIGFscmVhZHkgc3RhcnRpbmcuXG4gICAgICovXG4gICAgdmFyIFNlc3Npb25BbHJlYWR5U3RhcnRpbmcgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICB0aGlzLm5hbWUgPSBcIlNlc3Npb25BbHJlYWR5U3RhcnRpbmdcIjtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gKG1lc3NhZ2UgfHwgXCJcIik7XG4gICAgfTtcblxuICAgIFNlc3Npb25BbHJlYWR5U3RhcnRpbmcucHJvdG90eXBlID0gRXJyb3IucHJvdG90eXBlO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIFNlc3Npb246IFNlc3Npb24sXG4gICAgICAgIFNlc3Npb25BbHJlYWR5U3RhcnRpbmc6IFNlc3Npb25BbHJlYWR5U3RhcnRpbmdcbiAgICB9O1xuIiwiLy8gQ29weXJpZ2h0IChjKSBKdXB5dGVyIERldmVsb3BtZW50IFRlYW0uXG4vLyBEaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIE1vZGlmaWVkIEJTRCBMaWNlbnNlLlxuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgdmFyIHV0aWxzID0gcmVxdWlyZSgnYmFzZS9qcy91dGlscycpO1xuXG4gICAgdmFyIFNlc3NzaW9uTGlzdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAgICAgKlxuICAgICAgICAgKiBQYXJhbWV0ZXJzOlxuICAgICAgICAgKiAgb3B0aW9uczogZGljdGlvbmFyeVxuICAgICAgICAgKiAgICAgIERpY3Rpb25hcnkgb2Yga2V5d29yZCBhcmd1bWVudHMuXG4gICAgICAgICAqICAgICAgICAgIGV2ZW50czogJChFdmVudHMpIGluc3RhbmNlXG4gICAgICAgICAqICAgICAgICAgIGJhc2VfdXJsIDogc3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmV2ZW50cyA9IG9wdGlvbnMuZXZlbnRzO1xuICAgICAgICB0aGlzLnNlc3Npb25zID0ge307XG4gICAgICAgIHRoaXMuYmFzZV91cmwgPSBvcHRpb25zLmJhc2VfdXJsIHx8IHV0aWxzLmdldF9ib2R5X2RhdGEoXCJiYXNlVXJsXCIpO1xuXG4gICAgICAgIC8vIEFkZCBjb2xsYXBzZSBhcnJvd3MuXG4gICAgICAgICQoJyNydW5uaW5nIC5wYW5lbC1ncm91cCAucGFuZWwgLnBhbmVsLWhlYWRpbmcgYScpLmVhY2goZnVuY3Rpb24oaW5kZXgsIGVsKSB7XG4gICAgICAgICAgICB2YXIgJGxpbmsgPSAkKGVsKTtcbiAgICAgICAgICAgIHZhciAkaWNvbiA9ICQoJzxpIC8+JylcbiAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoJ2ZhIGZhLWNhcmV0LWRvd24nKTtcbiAgICAgICAgICAgICRsaW5rLmFwcGVuZCgkaWNvbik7XG4gICAgICAgICAgICAkbGluay5kb3duID0gdHJ1ZTtcbiAgICAgICAgICAgICRsaW5rLmNsaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoJGxpbmsuZG93bikge1xuICAgICAgICAgICAgICAgICAgICAkbGluay5kb3duID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIC8vIGpRZXVyeSBkb2Vzbid0IGtub3cgaG93IHRvIGFuaW1hdGUgcm90YXRpb25zLiAgQWJ1c2VcbiAgICAgICAgICAgICAgICAgICAgLy8galF1ZXJpZXMgYW5pbWF0ZSBmdW5jdGlvbiBieSB1c2luZyBhbiB1bnVzZWQgY3NzIGF0dHJpYnV0ZVxuICAgICAgICAgICAgICAgICAgICAvLyB0byBkbyB0aGUgYW5pbWF0aW9uIChib3JkZXJTcGFjaW5nKS5cbiAgICAgICAgICAgICAgICAgICAgJGljb24uYW5pbWF0ZSh7IGJvcmRlclNwYWNpbmc6IDkwIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ZXA6IGZ1bmN0aW9uKG5vdyxmeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRpY29uLmNzcygndHJhbnNmb3JtJywncm90YXRlKC0nICsgbm93ICsgJ2RlZyknKTsgXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIDI1MCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgJGxpbmsuZG93biA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNlZSBjb21tZW50IGFib3ZlLlxuICAgICAgICAgICAgICAgICAgICAkaWNvbi5hbmltYXRlKHsgYm9yZGVyU3BhY2luZzogMCB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGVwOiBmdW5jdGlvbihub3csZngpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkaWNvbi5jc3MoJ3RyYW5zZm9ybScsJ3JvdGF0ZSgtJyArIG5vdyArICdkZWcpJyk7IFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCAyNTApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgU2Vzc3Npb25MaXN0LnByb3RvdHlwZS5sb2FkX3Nlc3Npb25zID0gZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICB2YXIgc2V0dGluZ3MgPSB7XG4gICAgICAgICAgICBwcm9jZXNzRGF0YSA6IGZhbHNlLFxuICAgICAgICAgICAgY2FjaGUgOiBmYWxzZSxcbiAgICAgICAgICAgIHR5cGUgOiBcIkdFVFwiLFxuICAgICAgICAgICAgZGF0YVR5cGUgOiBcImpzb25cIixcbiAgICAgICAgICAgIHN1Y2Nlc3MgOiAkLnByb3h5KHRoYXQuc2Vzc2lvbnNfbG9hZGVkLCB0aGlzKSxcbiAgICAgICAgICAgIGVycm9yIDogdXRpbHMubG9nX2FqYXhfZXJyb3IsXG4gICAgICAgIH07XG4gICAgICAgIHZhciB1cmwgPSB1dGlscy51cmxfam9pbl9lbmNvZGUodGhpcy5iYXNlX3VybCwgJ2FwaS9zZXNzaW9ucycpO1xuICAgICAgICAkLmFqYXgodXJsLCBzZXR0aW5ncyk7XG4gICAgfTtcblxuICAgIFNlc3NzaW9uTGlzdC5wcm90b3R5cGUuc2Vzc2lvbnNfbG9hZGVkID0gZnVuY3Rpb24oZGF0YSl7XG4gICAgICAgIHRoaXMuc2Vzc2lvbnMgPSB7fTtcbiAgICAgICAgdmFyIGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgICAgICB2YXIgbmJfcGF0aDtcbiAgICAgICAgZm9yICh2YXIgaT0wOyBpPGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBuYl9wYXRoID0gZGF0YVtpXS5ub3RlYm9vay5wYXRoO1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uc1tuYl9wYXRoXSA9IGRhdGFbaV0uaWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ldmVudHMudHJpZ2dlcignc2Vzc2lvbnNfbG9hZGVkLkRhc2hib2FyZCcsIHRoaXMuc2Vzc2lvbnMpO1xuICAgIH07XG5cbiAgICBleHBvcnRzLlNlc3NzaW9uTGlzdCA9IFNlc3NzaW9uTGlzdDtcbiIsInZhciBDU1NfUFJPUF9CSVRfUVVBTlRJVFk9MTt2YXIgQ1NTX1BST1BfQklUX0hBU0hfVkFMVUU9Mjt2YXIgQ1NTX1BST1BfQklUX05FR0FUSVZFX1FVQU5USVRZPTQ7dmFyIENTU19QUk9QX0JJVF9RU1RSSU5HPTg7dmFyIENTU19QUk9QX0JJVF9VUkw9MTY7dmFyIENTU19QUk9QX0JJVF9VTlJFU0VSVkVEX1dPUkQ9NjQ7dmFyIENTU19QUk9QX0JJVF9VTklDT0RFX1JBTkdFPTEyODt2YXIgQ1NTX1BST1BfQklUX0dMT0JBTF9OQU1FPTUxMjt2YXIgQ1NTX1BST1BfQklUX1BST1BFUlRZX05BTUU9MTAyNDt2YXIgY3NzU2NoZW1hPWZ1bmN0aW9uKCl7dmFyIEw9W1tcImFsaWNlYmx1ZVwiLFwiYW50aXF1ZXdoaXRlXCIsXCJhcXVhXCIsXCJhcXVhbWFyaW5lXCIsXCJhenVyZVwiLFwiYmVpZ2VcIixcImJpc3F1ZVwiLFwiYmxhY2tcIixcImJsYW5jaGVkYWxtb25kXCIsXCJibHVlXCIsXCJibHVldmlvbGV0XCIsXCJicm93blwiLFwiYnVybHl3b29kXCIsXCJjYWRldGJsdWVcIixcImNoYXJ0cmV1c2VcIixcImNob2NvbGF0ZVwiLFwiY29yYWxcIixcImNvcm5mbG93ZXJibHVlXCIsXCJjb3Juc2lsa1wiLFwiY3JpbXNvblwiLFwiY3lhblwiLFwiZGFya2JsdWVcIixcImRhcmtjeWFuXCIsXCJkYXJrZ29sZGVucm9kXCIsXCJkYXJrZ3JheVwiLFwiZGFya2dyZWVuXCIsXCJkYXJra2hha2lcIixcImRhcmttYWdlbnRhXCIsXCJkYXJrb2xpdmVncmVlblwiLFwiZGFya29yYW5nZVwiLFwiZGFya29yY2hpZFwiLFwiZGFya3JlZFwiLFwiZGFya3NhbG1vblwiLFwiZGFya3NlYWdyZWVuXCIsXCJkYXJrc2xhdGVibHVlXCIsXCJkYXJrc2xhdGVncmF5XCIsXCJkYXJrdHVycXVvaXNlXCIsXCJkYXJrdmlvbGV0XCIsXCJkZWVwcGlua1wiLFwiZGVlcHNreWJsdWVcIixcImRpbWdyYXlcIixcImRvZGdlcmJsdWVcIixcImZpcmVicmlja1wiLFwiZmxvcmFsd2hpdGVcIixcImZvcmVzdGdyZWVuXCIsXCJmdWNoc2lhXCIsXCJnYWluc2Jvcm9cIixcImdob3N0d2hpdGVcIixcImdvbGRcIixcImdvbGRlbnJvZFwiLFwiZ3JheVwiLFwiZ3JlZW5cIixcImdyZWVueWVsbG93XCIsXCJob25leWRld1wiLFwiaG90cGlua1wiLFwiaW5kaWFucmVkXCIsXCJpbmRpZ29cIixcIml2b3J5XCIsXCJraGFraVwiLFwibGF2ZW5kZXJcIixcImxhdmVuZGVyYmx1c2hcIixcImxhd25ncmVlblwiLFwibGVtb25jaGlmZm9uXCIsXCJsaWdodGJsdWVcIixcImxpZ2h0Y29yYWxcIixcImxpZ2h0Y3lhblwiLFwibGlnaHRnb2xkZW5yb2R5ZWxsb3dcIixcImxpZ2h0Z3JlZW5cIixcImxpZ2h0Z3JleVwiLFwibGlnaHRwaW5rXCIsXCJsaWdodHNhbG1vblwiLFwibGlnaHRzZWFncmVlblwiLFwibGlnaHRza3libHVlXCIsXCJsaWdodHNsYXRlZ3JheVwiLFwibGlnaHRzdGVlbGJsdWVcIixcImxpZ2h0eWVsbG93XCIsXCJsaW1lXCIsXCJsaW1lZ3JlZW5cIixcImxpbmVuXCIsXCJtYWdlbnRhXCIsXCJtYXJvb25cIixcIm1lZGl1bWFxdWFtYXJpbmVcIixcIm1lZGl1bWJsdWVcIixcIm1lZGl1bW9yY2hpZFwiLFwibWVkaXVtcHVycGxlXCIsXCJtZWRpdW1zZWFncmVlblwiLFwibWVkaXVtc2xhdGVibHVlXCIsXCJtZWRpdW1zcHJpbmdncmVlblwiLFwibWVkaXVtdHVycXVvaXNlXCIsXCJtZWRpdW12aW9sZXRyZWRcIixcIm1pZG5pZ2h0Ymx1ZVwiLFwibWludGNyZWFtXCIsXCJtaXN0eXJvc2VcIixcIm1vY2Nhc2luXCIsXCJuYXZham93aGl0ZVwiLFwibmF2eVwiLFwib2xkbGFjZVwiLFwib2xpdmVcIixcIm9saXZlZHJhYlwiLFwib3JhbmdlXCIsXCJvcmFuZ2VyZWRcIixcIm9yY2hpZFwiLFwicGFsZWdvbGRlbnJvZFwiLFwicGFsZWdyZWVuXCIsXCJwYWxldHVycXVvaXNlXCIsXCJwYWxldmlvbGV0cmVkXCIsXCJwYXBheWF3aGlwXCIsXCJwZWFjaHB1ZmZcIixcInBlcnVcIixcInBpbmtcIixcInBsdW1cIixcInBvd2RlcmJsdWVcIixcInB1cnBsZVwiLFwicmVkXCIsXCJyb3N5YnJvd25cIixcInJveWFsYmx1ZVwiLFwic2FkZGxlYnJvd25cIixcInNhbG1vblwiLFwic2FuZHlicm93blwiLFwic2VhZ3JlZW5cIixcInNlYXNoZWxsXCIsXCJzaWVubmFcIixcInNpbHZlclwiLFwic2t5Ymx1ZVwiLFwic2xhdGVibHVlXCIsXCJzbGF0ZWdyYXlcIixcInNub3dcIixcInNwcmluZ2dyZWVuXCIsXCJzdGVlbGJsdWVcIixcInRhblwiLFwidGVhbFwiLFwidGhpc3RsZVwiLFwidG9tYXRvXCIsXCJ0cmFuc3BhcmVudFwiLFwidHVycXVvaXNlXCIsXCJ2aW9sZXRcIixcIndoZWF0XCIsXCJ3aGl0ZVwiLFwid2hpdGVzbW9rZVwiLFwieWVsbG93XCIsXCJ5ZWxsb3dncmVlblwiXSxbXCJhbGwtc2Nyb2xsXCIsXCJjb2wtcmVzaXplXCIsXCJjcm9zc2hhaXJcIixcImRlZmF1bHRcIixcImUtcmVzaXplXCIsXCJoYW5kXCIsXCJoZWxwXCIsXCJtb3ZlXCIsXCJuLXJlc2l6ZVwiLFwibmUtcmVzaXplXCIsXCJuby1kcm9wXCIsXCJub3QtYWxsb3dlZFwiLFwibnctcmVzaXplXCIsXCJwb2ludGVyXCIsXCJwcm9ncmVzc1wiLFwicm93LXJlc2l6ZVwiLFwicy1yZXNpemVcIixcInNlLXJlc2l6ZVwiLFwic3ctcmVzaXplXCIsXCJ0ZXh0XCIsXCJ2ZXJ0aWNhbC10ZXh0XCIsXCJ3LXJlc2l6ZVwiLFwid2FpdFwiXSxbXCJhcm1lbmlhblwiLFwiZGVjaW1hbFwiLFwiZGVjaW1hbC1sZWFkaW5nLXplcm9cIixcImRpc2NcIixcImdlb3JnaWFuXCIsXCJsb3dlci1hbHBoYVwiLFwibG93ZXItZ3JlZWtcIixcImxvd2VyLWxhdGluXCIsXCJsb3dlci1yb21hblwiLFwic3F1YXJlXCIsXCJ1cHBlci1hbHBoYVwiLFwidXBwZXItbGF0aW5cIixcInVwcGVyLXJvbWFuXCJdLFtcIjEwMFwiLFwiMjAwXCIsXCIzMDBcIixcIjQwMFwiLFwiNTAwXCIsXCI2MDBcIixcIjcwMFwiLFwiODAwXCIsXCI5MDBcIixcImJvbGRcIixcImJvbGRlclwiLFwibGlnaHRlclwiXSxbXCJibG9jay1sZXZlbFwiLFwiaW5saW5lLWxldmVsXCIsXCJ0YWJsZS1jYXB0aW9uXCIsXCJ0YWJsZS1jZWxsXCIsXCJ0YWJsZS1jb2x1bW5cIixcInRhYmxlLWNvbHVtbi1ncm91cFwiLFwidGFibGUtZm9vdGVyLWdyb3VwXCIsXCJ0YWJsZS1oZWFkZXItZ3JvdXBcIixcInRhYmxlLXJvd1wiLFwidGFibGUtcm93LWdyb3VwXCJdLFtcImNvbmRlbnNlZFwiLFwiZXhwYW5kZWRcIixcImV4dHJhLWNvbmRlbnNlZFwiLFwiZXh0cmEtZXhwYW5kZWRcIixcIm5hcnJvd2VyXCIsXCJzZW1pLWNvbmRlbnNlZFwiLFwic2VtaS1leHBhbmRlZFwiLFwidWx0cmEtY29uZGVuc2VkXCIsXCJ1bHRyYS1leHBhbmRlZFwiLFwid2lkZXJcIl0sW1wiaW5oZXJpdFwiLFwiaW5saW5lXCIsXCJpbmxpbmUtYmxvY2tcIixcImlubGluZS1ib3hcIixcImlubGluZS1mbGV4XCIsXCJpbmxpbmUtZ3JpZFwiLFwiaW5saW5lLWxpc3QtaXRlbVwiLFwiaW5saW5lLXN0YWNrXCIsXCJpbmxpbmUtdGFibGVcIixcInJ1bi1pblwiXSxbXCJiZWhpbmRcIixcImNlbnRlci1sZWZ0XCIsXCJjZW50ZXItcmlnaHRcIixcImZhci1sZWZ0XCIsXCJmYXItcmlnaHRcIixcImxlZnQtc2lkZVwiLFwibGVmdHdhcmRzXCIsXCJyaWdodC1zaWRlXCIsXCJyaWdodHdhcmRzXCJdLFtcImxhcmdlXCIsXCJsYXJnZXJcIixcInNtYWxsXCIsXCJzbWFsbGVyXCIsXCJ4LWxhcmdlXCIsXCJ4LXNtYWxsXCIsXCJ4eC1sYXJnZVwiLFwieHgtc21hbGxcIl0sW1wiZGFzaGVkXCIsXCJkb3R0ZWRcIixcImRvdWJsZVwiLFwiZ3Jvb3ZlXCIsXCJvdXRzZXRcIixcInJpZGdlXCIsXCJzb2xpZFwiXSxbXCJlYXNlXCIsXCJlYXNlLWluXCIsXCJlYXNlLWluLW91dFwiLFwiZWFzZS1vdXRcIixcImxpbmVhclwiLFwic3RlcC1lbmRcIixcInN0ZXAtc3RhcnRcIl0sW1wiYXRcIixcImNsb3Nlc3QtY29ybmVyXCIsXCJjbG9zZXN0LXNpZGVcIixcImVsbGlwc2VcIixcImZhcnRoZXN0LWNvcm5lclwiLFwiZmFydGhlc3Qtc2lkZVwiXSxbXCJiYXNlbGluZVwiLFwibWlkZGxlXCIsXCJzdWJcIixcInN1cGVyXCIsXCJ0ZXh0LWJvdHRvbVwiLFwidGV4dC10b3BcIl0sW1wiY2FwdGlvblwiLFwiaWNvblwiLFwibWVudVwiLFwibWVzc2FnZS1ib3hcIixcInNtYWxsLWNhcHRpb25cIixcInN0YXR1cy1iYXJcIl0sW1wiZmFzdFwiLFwiZmFzdGVyXCIsXCJzbG93XCIsXCJzbG93ZXJcIixcIngtZmFzdFwiLFwieC1zbG93XCJdLFtcImFib3ZlXCIsXCJiZWxvd1wiLFwiaGlnaGVyXCIsXCJsZXZlbFwiLFwibG93ZXJcIl0sW1wiY3Vyc2l2ZVwiLFwiZmFudGFzeVwiLFwibW9ub3NwYWNlXCIsXCJzYW5zLXNlcmlmXCIsXCJzZXJpZlwiXSxbXCJsb3VkXCIsXCJzaWxlbnRcIixcInNvZnRcIixcIngtbG91ZFwiLFwieC1zb2Z0XCJdLFtcIm5vLXJlcGVhdFwiLFwicmVwZWF0LXhcIixcInJlcGVhdC15XCIsXCJyb3VuZFwiLFwic3BhY2VcIl0sW1wiYmxpbmtcIixcImxpbmUtdGhyb3VnaFwiLFwib3ZlcmxpbmVcIixcInVuZGVybGluZVwiXSxbXCJibG9ja1wiLFwiZmxleFwiLFwiZ3JpZFwiLFwidGFibGVcIl0sW1wiaGlnaFwiLFwibG93XCIsXCJ4LWhpZ2hcIixcIngtbG93XCJdLFtcIm5vd3JhcFwiLFwicHJlXCIsXCJwcmUtbGluZVwiLFwicHJlLXdyYXBcIl0sW1wiYWJzb2x1dGVcIixcInJlbGF0aXZlXCIsXCJzdGF0aWNcIl0sW1wiYWx0ZXJuYXRlXCIsXCJhbHRlcm5hdGUtcmV2ZXJzZVwiLFwicmV2ZXJzZVwiXSxbXCJib3JkZXItYm94XCIsXCJjb250ZW50LWJveFwiLFwicGFkZGluZy1ib3hcIl0sW1wiY2FwaXRhbGl6ZVwiLFwibG93ZXJjYXNlXCIsXCJ1cHBlcmNhc2VcIl0sW1wiY2hpbGRcIixcImZlbWFsZVwiLFwibWFsZVwiXSxbXCI9XCIsXCJvcGFjaXR5XCJdLFtcImJhY2t3YXJkc1wiLFwiZm9yd2FyZHNcIl0sW1wiYmlkaS1vdmVycmlkZVwiLFwiZW1iZWRcIl0sW1wiYm90dG9tXCIsXCJ0b3BcIl0sW1wiYnJlYWstYWxsXCIsXCJrZWVwLWFsbFwiXSxbXCJjbGlwXCIsXCJlbGxpcHNpc1wiXSxbXCJjb250YWluXCIsXCJjb3ZlclwiXSxbXCJjb250aW51b3VzXCIsXCJkaWdpdHNcIl0sW1wiZW5kXCIsXCJzdGFydFwiXSxbXCJmbGF0XCIsXCJwcmVzZXJ2ZS0zZFwiXSxbXCJoaWRlXCIsXCJzaG93XCJdLFtcImhvcml6b250YWxcIixcInZlcnRpY2FsXCJdLFtcImluc2lkZVwiLFwib3V0c2lkZVwiXSxbXCJpdGFsaWNcIixcIm9ibGlxdWVcIl0sW1wibGVmdFwiLFwicmlnaHRcIl0sW1wibHRyXCIsXCJydGxcIl0sW1wibm8tY29udGVudFwiLFwibm8tZGlzcGxheVwiXSxbXCJwYXVzZWRcIixcInJ1bm5pbmdcIl0sW1wic3VwcHJlc3NcIixcInVucmVzdHJpY3RlZFwiXSxbXCJ0aGlja1wiLFwidGhpblwiXSxbXCIsXCJdLFtcIi9cIl0sW1wiYWxsXCJdLFtcImFsd2F5c1wiXSxbXCJhdXRvXCJdLFtcImF2b2lkXCJdLFtcImJvdGhcIl0sW1wiYnJlYWstd29yZFwiXSxbXCJjZW50ZXJcIl0sW1wiY2lyY2xlXCJdLFtcImNvZGVcIl0sW1wiY29sbGFwc2VcIl0sW1wiY29udGVudHNcIl0sW1wiZml4ZWRcIl0sW1wiaGlkZGVuXCJdLFtcImluZmluaXRlXCJdLFtcImluc2V0XCJdLFtcImludmVydFwiXSxbXCJqdXN0aWZ5XCJdLFtcImxpc3QtaXRlbVwiXSxbXCJsb2NhbFwiXSxbXCJtZWRpdW1cIl0sW1wibWl4XCJdLFtcIm5vbmVcIl0sW1wibm9ybWFsXCJdLFtcIm9uY2VcIl0sW1wicmVwZWF0XCJdLFtcInNjcm9sbFwiXSxbXCJzZXBhcmF0ZVwiXSxbXCJzbWFsbC1jYXBzXCJdLFtcInNwZWxsLW91dFwiXSxbXCJ0b1wiXSxbXCJ2aXNpYmxlXCJdXTt2YXIgc2NoZW1hPXthbmltYXRpb246e2Nzc1Byb3BCaXRzOjUxNyxjc3NMaXRHcm91cDpbTFsxMF0sTFsyNF0sTFsyOV0sTFs0NV0sTFs0OF0sTFs1NF0sTFs2M10sTFs3MV0sTFs3Ml1dLGNzc0ZuczpbXCJjdWJpYy1iZXppZXIoKVwiLFwic3RlcHMoKVwiXX0sXCJhbmltYXRpb24tZGVsYXlcIjp7Y3NzUHJvcEJpdHM6NSxjc3NMaXRHcm91cDpbTFs0OF1dLGNzc0ZuczpbXX0sXCJhbmltYXRpb24tZGlyZWN0aW9uXCI6e2Nzc1Byb3BCaXRzOjAsY3NzTGl0R3JvdXA6W0xbMjRdLExbNDhdLExbNzJdXSxjc3NGbnM6W119LFwiYW5pbWF0aW9uLWR1cmF0aW9uXCI6XCJhbmltYXRpb24tZGVsYXlcIixcImFuaW1hdGlvbi1maWxsLW1vZGVcIjp7Y3NzUHJvcEJpdHM6MCxjc3NMaXRHcm91cDpbTFsyOV0sTFs0OF0sTFs1NF0sTFs3MV1dLGNzc0ZuczpbXX0sXCJhbmltYXRpb24taXRlcmF0aW9uLWNvdW50XCI6e2Nzc1Byb3BCaXRzOjUsY3NzTGl0R3JvdXA6W0xbNDhdLExbNjNdXSxjc3NGbnM6W119LFwiYW5pbWF0aW9uLW5hbWVcIjp7Y3NzUHJvcEJpdHM6NTEyLGNzc0xpdEdyb3VwOltMWzQ4XSxMWzcxXV0sY3NzRm5zOltdfSxcImFuaW1hdGlvbi1wbGF5LXN0YXRlXCI6e2Nzc1Byb3BCaXRzOjAsY3NzTGl0R3JvdXA6W0xbNDVdLExbNDhdXSxjc3NGbnM6W119LFwiYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvblwiOntjc3NQcm9wQml0czowLGNzc0xpdEdyb3VwOltMWzEwXSxMWzQ4XV0sY3NzRm5zOltcImN1YmljLWJlemllcigpXCIsXCJzdGVwcygpXCJdfSxhcHBlYXJhbmNlOntjc3NQcm9wQml0czowLGNzc0xpdEdyb3VwOltMWzcxXV0sY3NzRm5zOltdfSxhemltdXRoOntjc3NQcm9wQml0czo1LGNzc0xpdEdyb3VwOltMWzddLExbNDJdLExbNTZdXSxjc3NGbnM6W119LFwiYmFja2ZhY2UtdmlzaWJpbGl0eVwiOntjc3NQcm9wQml0czowLGNzc0xpdEdyb3VwOltMWzU5XSxMWzYyXSxMWzgwXV0sY3NzRm5zOltdfSxiYWNrZ3JvdW5kOntjc3NQcm9wQml0czoyMyxjc3NMaXRHcm91cDpbTFswXSxMWzE4XSxMWzI1XSxMWzMxXSxMWzM0XSxMWzQyXSxMWzQ4XSxMWzQ5XSxMWzUyXSxMWzU2XSxMWzYxXSxMWzY4XSxMWzcxXSxMWzc0XSxMWzc1XV0sY3NzRm5zOltcImltYWdlKClcIixcImxpbmVhci1ncmFkaWVudCgpXCIsXCJyYWRpYWwtZ3JhZGllbnQoKVwiLFwicmVwZWF0aW5nLWxpbmVhci1ncmFkaWVudCgpXCIsXCJyZXBlYXRpbmctcmFkaWFsLWdyYWRpZW50KClcIixcInJnYigpXCIsXCJyZ2JhKClcIl19LFwiYmFja2dyb3VuZC1hdHRhY2htZW50XCI6e2Nzc1Byb3BCaXRzOjAsY3NzTGl0R3JvdXA6W0xbNDhdLExbNjFdLExbNjhdLExbNzVdXSxjc3NGbnM6W119LFwiYmFja2dyb3VuZC1jb2xvclwiOntjc3NQcm9wQml0czoyLGNzc0xpdEdyb3VwOltMWzBdXSxjc3NGbnM6W1wicmdiKClcIixcInJnYmEoKVwiXX0sXCJiYWNrZ3JvdW5kLWltYWdlXCI6e2Nzc1Byb3BCaXRzOjE2LGNzc0xpdEdyb3VwOltMWzQ4XSxMWzcxXV0sY3NzRm5zOltcImltYWdlKClcIixcImxpbmVhci1ncmFkaWVudCgpXCIsXCJyYWRpYWwtZ3JhZGllbnQoKVwiLFwicmVwZWF0aW5nLWxpbmVhci1ncmFkaWVudCgpXCIsXCJyZXBlYXRpbmctcmFkaWFsLWdyYWRpZW50KClcIl19LFwiYmFja2dyb3VuZC1wb3NpdGlvblwiOntjc3NQcm9wQml0czo1LGNzc0xpdEdyb3VwOltMWzMxXSxMWzQyXSxMWzQ4XSxMWzU2XV0sY3NzRm5zOltdfSxcImJhY2tncm91bmQtcmVwZWF0XCI6e2Nzc1Byb3BCaXRzOjAsY3NzTGl0R3JvdXA6W0xbMThdLExbNDhdLExbNzRdXSxjc3NGbnM6W119LFwiYmFja2dyb3VuZC1zaXplXCI6e2Nzc1Byb3BCaXRzOjUsY3NzTGl0R3JvdXA6W0xbMzRdLExbNDhdLExbNTJdXSxjc3NGbnM6W119LGJvcmRlcjp7Y3NzUHJvcEJpdHM6Nyxjc3NMaXRHcm91cDpbTFswXSxMWzldLExbNDddLExbNjJdLExbNjRdLExbNjldLExbNzFdXSxjc3NGbnM6W1wicmdiKClcIixcInJnYmEoKVwiXX0sXCJib3JkZXItYm90dG9tXCI6XCJib3JkZXJcIixcImJvcmRlci1ib3R0b20tY29sb3JcIjpcImJhY2tncm91bmQtY29sb3JcIixcImJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXNcIjp7Y3NzUHJvcEJpdHM6NSxjc3NGbnM6W119LFwiYm9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXNcIjpcImJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXNcIixcImJvcmRlci1ib3R0b20tc3R5bGVcIjp7Y3NzUHJvcEJpdHM6MCxjc3NMaXRHcm91cDpbTFs5XSxMWzYyXSxMWzY0XSxMWzcxXV0sY3NzRm5zOltdfSxcImJvcmRlci1ib3R0b20td2lkdGhcIjp7Y3NzUHJvcEJpdHM6NSxjc3NMaXRHcm91cDpbTFs0N10sTFs2OV1dLGNzc0ZuczpbXX0sXCJib3JkZXItY29sbGFwc2VcIjp7Y3NzUHJvcEJpdHM6MCxjc3NMaXRHcm91cDpbTFs1OV0sTFs3Nl1dLGNzc0ZuczpbXX0sXCJib3JkZXItY29sb3JcIjpcImJhY2tncm91bmQtY29sb3JcIixcImJvcmRlci1sZWZ0XCI6XCJib3JkZXJcIixcImJvcmRlci1sZWZ0LWNvbG9yXCI6XCJiYWNrZ3JvdW5kLWNvbG9yXCIsXCJib3JkZXItbGVmdC1zdHlsZVwiOlwiYm9yZGVyLWJvdHRvbS1zdHlsZVwiLFwiYm9yZGVyLWxlZnQtd2lkdGhcIjpcImJvcmRlci1ib3R0b20td2lkdGhcIixcImJvcmRlci1yYWRpdXNcIjp7Y3NzUHJvcEJpdHM6NSxjc3NMaXRHcm91cDpbTFs0OV1dLGNzc0ZuczpbXX0sXCJib3JkZXItcmlnaHRcIjpcImJvcmRlclwiLFwiYm9yZGVyLXJpZ2h0LWNvbG9yXCI6XCJiYWNrZ3JvdW5kLWNvbG9yXCIsXCJib3JkZXItcmlnaHQtc3R5bGVcIjpcImJvcmRlci1ib3R0b20tc3R5bGVcIixcImJvcmRlci1yaWdodC13aWR0aFwiOlwiYm9yZGVyLWJvdHRvbS13aWR0aFwiLFwiYm9yZGVyLXNwYWNpbmdcIjpcImJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXNcIixcImJvcmRlci1zdHlsZVwiOlwiYm9yZGVyLWJvdHRvbS1zdHlsZVwiLFwiYm9yZGVyLXRvcFwiOlwiYm9yZGVyXCIsXCJib3JkZXItdG9wLWNvbG9yXCI6XCJiYWNrZ3JvdW5kLWNvbG9yXCIsXCJib3JkZXItdG9wLWxlZnQtcmFkaXVzXCI6XCJib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzXCIsXCJib3JkZXItdG9wLXJpZ2h0LXJhZGl1c1wiOlwiYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1c1wiLFwiYm9yZGVyLXRvcC1zdHlsZVwiOlwiYm9yZGVyLWJvdHRvbS1zdHlsZVwiLFwiYm9yZGVyLXRvcC13aWR0aFwiOlwiYm9yZGVyLWJvdHRvbS13aWR0aFwiLFwiYm9yZGVyLXdpZHRoXCI6XCJib3JkZXItYm90dG9tLXdpZHRoXCIsYm90dG9tOntjc3NQcm9wQml0czo1LGNzc0xpdEdyb3VwOltMWzUyXV0sY3NzRm5zOltdfSxib3g6e2Nzc1Byb3BCaXRzOjAsY3NzTGl0R3JvdXA6W0xbNjBdLExbNzFdLExbNzJdXSxjc3NGbnM6W119LFwiYm94LXNoYWRvd1wiOntjc3NQcm9wQml0czo3LGNzc0xpdEdyb3VwOltMWzBdLExbNDhdLExbNjRdLExbNzFdXSxjc3NGbnM6W1wicmdiKClcIixcInJnYmEoKVwiXX0sXCJib3gtc2l6aW5nXCI6e2Nzc1Byb3BCaXRzOjAsY3NzTGl0R3JvdXA6W0xbMjVdXSxjc3NGbnM6W119LFwiY2FwdGlvbi1zaWRlXCI6e2Nzc1Byb3BCaXRzOjAsY3NzTGl0R3JvdXA6W0xbMzFdXSxjc3NGbnM6W119LGNsZWFyOntjc3NQcm9wQml0czowLGNzc0xpdEdyb3VwOltMWzQyXSxMWzU0XSxMWzcxXV0sY3NzRm5zOltdfSxjbGlwOntjc3NQcm9wQml0czowLGNzc0xpdEdyb3VwOltMWzUyXV0sY3NzRm5zOltcInJlY3QoKVwiXX0sY29sb3I6XCJiYWNrZ3JvdW5kLWNvbG9yXCIsY29udGVudDp7Y3NzUHJvcEJpdHM6OCxjc3NMaXRHcm91cDpbTFs3MV0sTFs3Ml1dLGNzc0ZuczpbXX0sY3VlOntjc3NQcm9wQml0czoxNixjc3NMaXRHcm91cDpbTFs3MV1dLGNzc0ZuczpbXX0sXCJjdWUtYWZ0ZXJcIjpcImN1ZVwiLFwiY3VlLWJlZm9yZVwiOlwiY3VlXCIsY3Vyc29yOntjc3NQcm9wQml0czoxNixjc3NMaXRHcm91cDpbTFsxXSxMWzQ4XSxMWzUyXV0sY3NzRm5zOltdfSxkaXJlY3Rpb246e2Nzc1Byb3BCaXRzOjAsY3NzTGl0R3JvdXA6W0xbNDNdXSxjc3NGbnM6W119LGRpc3BsYXk6e2Nzc1Byb3BCaXRzOjAsY3NzTGl0R3JvdXA6W0xbNF0sTFs2XSxMWzIwXSxMWzUyXSxMWzY3XSxMWzcxXV0sY3NzRm5zOltdfSxcImRpc3BsYXktZXh0cmFzXCI6e2Nzc1Byb3BCaXRzOjAsY3NzTGl0R3JvdXA6W0xbNjddLExbNzFdXSxjc3NGbnM6W119LFwiZGlzcGxheS1pbnNpZGVcIjp7Y3NzUHJvcEJpdHM6MCxjc3NMaXRHcm91cDpbTFsyMF0sTFs1Ml1dLGNzc0ZuczpbXX0sXCJkaXNwbGF5LW91dHNpZGVcIjp7Y3NzUHJvcEJpdHM6MCxjc3NMaXRHcm91cDpbTFs0XSxMWzcxXV0sY3NzRm5zOltdfSxlbGV2YXRpb246e2Nzc1Byb3BCaXRzOjUsY3NzTGl0R3JvdXA6W0xbMTVdXSxjc3NGbnM6W119LFwiZW1wdHktY2VsbHNcIjp7Y3NzUHJvcEJpdHM6MCxjc3NMaXRHcm91cDpbTFszOF1dLGNzc0ZuczpbXX0sZmlsdGVyOntjc3NQcm9wQml0czowLGNzc0ZuczpbXCJhbHBoYSgpXCJdfSxcImZsb2F0XCI6e2Nzc1Byb3BCaXRzOjAsY3NzTGl0R3JvdXA6W0xbNDJdLExbNzFdXSxjc3NGbnM6W119LGZvbnQ6e2Nzc1Byb3BCaXRzOjczLGNzc0xpdEdyb3VwOltMWzNdLExbOF0sTFsxM10sTFsxNl0sTFs0MV0sTFs0OF0sTFs0OV0sTFs2OV0sTFs3Ml0sTFs3N11dLGNzc0ZuczpbXX0sXCJmb250LWZhbWlseVwiOntjc3NQcm9wQml0czo3Mixjc3NMaXRHcm91cDpbTFsxNl0sTFs0OF1dLGNzc0ZuczpbXX0sXCJmb250LXNpemVcIjp7Y3NzUHJvcEJpdHM6MSxjc3NMaXRHcm91cDpbTFs4XSxMWzY5XV0sY3NzRm5zOltdfSxcImZvbnQtc3RyZXRjaFwiOntjc3NQcm9wQml0czowLGNzc0xpdEdyb3VwOltMWzVdLExbNzJdXSxjc3NGbnM6W119LFwiZm9udC1zdHlsZVwiOntjc3NQcm9wQml0czowLGNzc0xpdEdyb3VwOltMWzQxXSxMWzcyXV0sY3NzRm5zOltdfSxcImZvbnQtdmFyaWFudFwiOntjc3NQcm9wQml0czowLGNzc0xpdEdyb3VwOltMWzcyXSxMWzc3XV0sY3NzRm5zOltdfSxcImZvbnQtd2VpZ2h0XCI6e2Nzc1Byb3BCaXRzOjAsY3NzTGl0R3JvdXA6W0xbM10sTFs3Ml1dLGNzc0ZuczpbXX0saGVpZ2h0OlwiYm90dG9tXCIsbGVmdDpcImJvdHRvbVwiLFwibGV0dGVyLXNwYWNpbmdcIjp7Y3NzUHJvcEJpdHM6NSxjc3NMaXRHcm91cDpbTFs3Ml1dLGNzc0ZuczpbXX0sXCJsaW5lLWhlaWdodFwiOntjc3NQcm9wQml0czoxLGNzc0xpdEdyb3VwOltMWzcyXV0sY3NzRm5zOltdfSxcImxpc3Qtc3R5bGVcIjp7Y3NzUHJvcEJpdHM6MTYsY3NzTGl0R3JvdXA6W0xbMl0sTFs0MF0sTFs1N10sTFs3MV1dLGNzc0ZuczpbXCJpbWFnZSgpXCIsXCJsaW5lYXItZ3JhZGllbnQoKVwiLFwicmFkaWFsLWdyYWRpZW50KClcIixcInJlcGVhdGluZy1saW5lYXItZ3JhZGllbnQoKVwiLFwicmVwZWF0aW5nLXJhZGlhbC1ncmFkaWVudCgpXCJdfSxcImxpc3Qtc3R5bGUtaW1hZ2VcIjp7Y3NzUHJvcEJpdHM6MTYsY3NzTGl0R3JvdXA6W0xbNzFdXSxjc3NGbnM6W1wiaW1hZ2UoKVwiLFwibGluZWFyLWdyYWRpZW50KClcIixcInJhZGlhbC1ncmFkaWVudCgpXCIsXCJyZXBlYXRpbmctbGluZWFyLWdyYWRpZW50KClcIixcInJlcGVhdGluZy1yYWRpYWwtZ3JhZGllbnQoKVwiXX0sXCJsaXN0LXN0eWxlLXBvc2l0aW9uXCI6e2Nzc1Byb3BCaXRzOjAsY3NzTGl0R3JvdXA6W0xbNDBdXSxjc3NGbnM6W119LFwibGlzdC1zdHlsZS10eXBlXCI6e2Nzc1Byb3BCaXRzOjAsY3NzTGl0R3JvdXA6W0xbMl0sTFs1N10sTFs3MV1dLGNzc0ZuczpbXX0sbWFyZ2luOlwiYm90dG9tXCIsXCJtYXJnaW4tYm90dG9tXCI6XCJib3R0b21cIixcIm1hcmdpbi1sZWZ0XCI6XCJib3R0b21cIixcIm1hcmdpbi1yaWdodFwiOlwiYm90dG9tXCIsXCJtYXJnaW4tdG9wXCI6XCJib3R0b21cIixcIm1heC1oZWlnaHRcIjp7Y3NzUHJvcEJpdHM6MSxjc3NMaXRHcm91cDpbTFs1Ml0sTFs3MV1dLGNzc0ZuczpbXX0sXCJtYXgtd2lkdGhcIjpcIm1heC1oZWlnaHRcIixcIm1pbi1oZWlnaHRcIjp7Y3NzUHJvcEJpdHM6MSxjc3NMaXRHcm91cDpbTFs1Ml1dLGNzc0ZuczpbXX0sXCJtaW4td2lkdGhcIjpcIm1pbi1oZWlnaHRcIixvcGFjaXR5Ontjc3NQcm9wQml0czoxLGNzc0ZuczpbXX0sb3V0bGluZTp7Y3NzUHJvcEJpdHM6Nyxjc3NMaXRHcm91cDpbTFswXSxMWzldLExbNDddLExbNjJdLExbNjRdLExbNjVdLExbNjldLExbNzFdXSxjc3NGbnM6W1wicmdiKClcIixcInJnYmEoKVwiXX0sXCJvdXRsaW5lLWNvbG9yXCI6e2Nzc1Byb3BCaXRzOjIsY3NzTGl0R3JvdXA6W0xbMF0sTFs2NV1dLGNzc0ZuczpbXCJyZ2IoKVwiLFwicmdiYSgpXCJdfSxcIm91dGxpbmUtc3R5bGVcIjpcImJvcmRlci1ib3R0b20tc3R5bGVcIixcIm91dGxpbmUtd2lkdGhcIjpcImJvcmRlci1ib3R0b20td2lkdGhcIixvdmVyZmxvdzp7Y3NzUHJvcEJpdHM6MCxjc3NMaXRHcm91cDpbTFs1Ml0sTFs2Ml0sTFs3NV0sTFs4MF1dLGNzc0ZuczpbXX0sXCJvdmVyZmxvdy13cmFwXCI6e2Nzc1Byb3BCaXRzOjAsY3NzTGl0R3JvdXA6W0xbNTVdLExbNzJdXSxjc3NGbnM6W119LFwib3ZlcmZsb3cteFwiOntjc3NQcm9wQml0czowLGNzc0xpdEdyb3VwOltMWzQ0XSxMWzUyXSxMWzYyXSxMWzc1XSxMWzgwXV0sY3NzRm5zOltdfSxcIm92ZXJmbG93LXlcIjpcIm92ZXJmbG93LXhcIixwYWRkaW5nOlwib3BhY2l0eVwiLFwicGFkZGluZy1ib3R0b21cIjpcIm9wYWNpdHlcIixcInBhZGRpbmctbGVmdFwiOlwib3BhY2l0eVwiLFwicGFkZGluZy1yaWdodFwiOlwib3BhY2l0eVwiLFwicGFkZGluZy10b3BcIjpcIm9wYWNpdHlcIixcInBhZ2UtYnJlYWstYWZ0ZXJcIjp7Y3NzUHJvcEJpdHM6MCxjc3NMaXRHcm91cDpbTFs0Ml0sTFs1MV0sTFs1Ml0sTFs1M11dLGNzc0ZuczpbXX0sXCJwYWdlLWJyZWFrLWJlZm9yZVwiOlwicGFnZS1icmVhay1hZnRlclwiLFwicGFnZS1icmVhay1pbnNpZGVcIjp7Y3NzUHJvcEJpdHM6MCxjc3NMaXRHcm91cDpbTFs1Ml0sTFs1M11dLGNzc0ZuczpbXX0scGF1c2U6XCJib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzXCIsXCJwYXVzZS1hZnRlclwiOlwiYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1c1wiLFwicGF1c2UtYmVmb3JlXCI6XCJib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzXCIscGVyc3BlY3RpdmU6e2Nzc1Byb3BCaXRzOjUsY3NzTGl0R3JvdXA6W0xbNzFdXSxjc3NGbnM6W119LFwicGVyc3BlY3RpdmUtb3JpZ2luXCI6e2Nzc1Byb3BCaXRzOjUsY3NzTGl0R3JvdXA6W0xbMzFdLExbNDJdLExbNTZdXSxjc3NGbnM6W119LHBpdGNoOntjc3NQcm9wQml0czo1LGNzc0xpdEdyb3VwOltMWzIxXSxMWzY5XV0sY3NzRm5zOltdfSxcInBpdGNoLXJhbmdlXCI6XCJib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzXCIsXCJwbGF5LWR1cmluZ1wiOntjc3NQcm9wQml0czoxNixjc3NMaXRHcm91cDpbTFs1Ml0sTFs3MF0sTFs3MV0sTFs3NF1dLGNzc0ZuczpbXX0scG9zaXRpb246e2Nzc1Byb3BCaXRzOjAsY3NzTGl0R3JvdXA6W0xbMjNdXSxjc3NGbnM6W119LHF1b3Rlczp7Y3NzUHJvcEJpdHM6OCxjc3NMaXRHcm91cDpbTFs3MV1dLGNzc0ZuczpbXX0scmVzaXplOntjc3NQcm9wQml0czowLGNzc0xpdEdyb3VwOltMWzM5XSxMWzU0XSxMWzcxXV0sY3NzRm5zOltdfSxyaWNobmVzczpcImJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXNcIixyaWdodDpcImJvdHRvbVwiLHNwZWFrOntjc3NQcm9wQml0czowLGNzc0xpdEdyb3VwOltMWzcxXSxMWzcyXSxMWzc4XV0sY3NzRm5zOltdfSxcInNwZWFrLWhlYWRlclwiOntjc3NQcm9wQml0czowLGNzc0xpdEdyb3VwOltMWzUxXSxMWzczXV0sY3NzRm5zOltdfSxcInNwZWFrLW51bWVyYWxcIjp7Y3NzUHJvcEJpdHM6MCxjc3NMaXRHcm91cDpbTFszNV1dLGNzc0ZuczpbXX0sXCJzcGVhay1wdW5jdHVhdGlvblwiOntjc3NQcm9wQml0czowLGNzc0xpdEdyb3VwOltMWzU4XSxMWzcxXV0sY3NzRm5zOltdfSxcInNwZWVjaC1yYXRlXCI6e2Nzc1Byb3BCaXRzOjUsY3NzTGl0R3JvdXA6W0xbMTRdLExbNjldXSxjc3NGbnM6W119LHN0cmVzczpcImJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXNcIixcInRhYmxlLWxheW91dFwiOntjc3NQcm9wQml0czowLGNzc0xpdEdyb3VwOltMWzUyXSxMWzYxXV0sY3NzRm5zOltdfSxcInRleHQtYWxpZ25cIjp7Y3NzUHJvcEJpdHM6MCxjc3NMaXRHcm91cDpbTFs0Ml0sTFs1Nl0sTFs2Nl1dLGNzc0ZuczpbXX0sXCJ0ZXh0LWRlY29yYXRpb25cIjp7Y3NzUHJvcEJpdHM6MCxjc3NMaXRHcm91cDpbTFsxOV0sTFs3MV1dLGNzc0ZuczpbXX0sXCJ0ZXh0LWluZGVudFwiOlwiYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1c1wiLFwidGV4dC1vdmVyZmxvd1wiOntjc3NQcm9wQml0czo4LGNzc0xpdEdyb3VwOltMWzMzXV0sY3NzRm5zOltdfSxcInRleHQtc2hhZG93XCI6XCJib3gtc2hhZG93XCIsXCJ0ZXh0LXRyYW5zZm9ybVwiOntjc3NQcm9wQml0czowLGNzc0xpdEdyb3VwOltMWzI2XSxMWzcxXV0sY3NzRm5zOltdfSxcInRleHQtd3JhcFwiOntjc3NQcm9wQml0czowLGNzc0xpdEdyb3VwOltMWzQ2XSxMWzcxXSxMWzcyXV0sY3NzRm5zOltdfSx0b3A6XCJib3R0b21cIix0cmFuc2Zvcm06e2Nzc1Byb3BCaXRzOjAsY3NzTGl0R3JvdXA6W0xbNzFdXSxjc3NGbnM6W1wibWF0cml4KClcIixcInBlcnNwZWN0aXZlKClcIixcInJvdGF0ZSgpXCIsXCJyb3RhdGUzZCgpXCIsXCJyb3RhdGV4KClcIixcInJvdGF0ZXkoKVwiLFwicm90YXRleigpXCIsXCJzY2FsZSgpXCIsXCJzY2FsZTNkKClcIixcInNjYWxleCgpXCIsXCJzY2FsZXkoKVwiLFwic2NhbGV6KClcIixcInNrZXcoKVwiLFwic2tld3goKVwiLFwic2tld3koKVwiLFwidHJhbnNsYXRlKClcIixcInRyYW5zbGF0ZTNkKClcIixcInRyYW5zbGF0ZXgoKVwiLFwidHJhbnNsYXRleSgpXCIsXCJ0cmFuc2xhdGV6KClcIl19LFwidHJhbnNmb3JtLW9yaWdpblwiOlwicGVyc3BlY3RpdmUtb3JpZ2luXCIsXCJ0cmFuc2Zvcm0tc3R5bGVcIjp7Y3NzUHJvcEJpdHM6MCxjc3NMaXRHcm91cDpbTFszN11dLGNzc0ZuczpbXX0sdHJhbnNpdGlvbjp7Y3NzUHJvcEJpdHM6MTAyOSxjc3NMaXRHcm91cDpbTFsxMF0sTFs0OF0sTFs1MF0sTFs3MV1dLGNzc0ZuczpbXCJjdWJpYy1iZXppZXIoKVwiLFwic3RlcHMoKVwiXX0sXCJ0cmFuc2l0aW9uLWRlbGF5XCI6XCJhbmltYXRpb24tZGVsYXlcIixcInRyYW5zaXRpb24tZHVyYXRpb25cIjpcImFuaW1hdGlvbi1kZWxheVwiLFwidHJhbnNpdGlvbi1wcm9wZXJ0eVwiOntjc3NQcm9wQml0czoxMDI0LGNzc0xpdEdyb3VwOltMWzQ4XSxMWzUwXV0sY3NzRm5zOltdfSxcInRyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uXCI6XCJhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uXCIsXCJ1bmljb2RlLWJpZGlcIjp7Y3NzUHJvcEJpdHM6MCxjc3NMaXRHcm91cDpbTFszMF0sTFs3Ml1dLGNzc0ZuczpbXX0sXCJ2ZXJ0aWNhbC1hbGlnblwiOntjc3NQcm9wQml0czo1LGNzc0xpdEdyb3VwOltMWzEyXSxMWzMxXV0sY3NzRm5zOltdfSx2aXNpYmlsaXR5OlwiYmFja2ZhY2UtdmlzaWJpbGl0eVwiLFwidm9pY2UtZmFtaWx5XCI6e2Nzc1Byb3BCaXRzOjgsY3NzTGl0R3JvdXA6W0xbMjddLExbNDhdXSxjc3NGbnM6W119LHZvbHVtZTp7Y3NzUHJvcEJpdHM6MSxjc3NMaXRHcm91cDpbTFsxN10sTFs2OV1dLGNzc0ZuczpbXX0sXCJ3aGl0ZS1zcGFjZVwiOntjc3NQcm9wQml0czowLGNzc0xpdEdyb3VwOltMWzIyXSxMWzcyXV0sY3NzRm5zOltdfSx3aWR0aDpcIm1pbi1oZWlnaHRcIixcIndvcmQtYnJlYWtcIjp7Y3NzUHJvcEJpdHM6MCxjc3NMaXRHcm91cDpbTFszMl0sTFs3Ml1dLGNzc0ZuczpbXX0sXCJ3b3JkLXNwYWNpbmdcIjpcImxldHRlci1zcGFjaW5nXCIsXCJ3b3JkLXdyYXBcIjpcIm92ZXJmbG93LXdyYXBcIixcInotaW5kZXhcIjpcImJvdHRvbVwiLHpvb206XCJsaW5lLWhlaWdodFwiLFwiY3ViaWMtYmV6aWVyKClcIjpcImFuaW1hdGlvbi1kZWxheVwiLFwic3RlcHMoKVwiOntjc3NQcm9wQml0czo1LGNzc0xpdEdyb3VwOltMWzM2XSxMWzQ4XV0sY3NzRm5zOltdfSxcImltYWdlKClcIjp7Y3NzUHJvcEJpdHM6MTgsY3NzTGl0R3JvdXA6W0xbMF0sTFs0OF1dLGNzc0ZuczpbXCJyZ2IoKVwiLFwicmdiYSgpXCJdfSxcImxpbmVhci1ncmFkaWVudCgpXCI6e2Nzc1Byb3BCaXRzOjcsY3NzTGl0R3JvdXA6W0xbMF0sTFszMV0sTFs0Ml0sTFs0OF0sTFs3OV1dLGNzc0ZuczpbXCJyZ2IoKVwiLFwicmdiYSgpXCJdfSxcInJhZGlhbC1ncmFkaWVudCgpXCI6e2Nzc1Byb3BCaXRzOjcsY3NzTGl0R3JvdXA6W0xbMF0sTFsxMV0sTFszMV0sTFs0Ml0sTFs0OF0sTFs1Nl0sTFs1N11dLGNzc0ZuczpbXCJyZ2IoKVwiLFwicmdiYSgpXCJdfSxcInJlcGVhdGluZy1saW5lYXItZ3JhZGllbnQoKVwiOlwibGluZWFyLWdyYWRpZW50KClcIixcInJlcGVhdGluZy1yYWRpYWwtZ3JhZGllbnQoKVwiOlwicmFkaWFsLWdyYWRpZW50KClcIixcInJnYigpXCI6e2Nzc1Byb3BCaXRzOjEsY3NzTGl0R3JvdXA6W0xbNDhdXSxjc3NGbnM6W119LFwicmdiYSgpXCI6XCJyZ2IoKVwiLFwicmVjdCgpXCI6e2Nzc1Byb3BCaXRzOjUsY3NzTGl0R3JvdXA6W0xbNDhdLExbNTJdXSxjc3NGbnM6W119LFwiYWxwaGEoKVwiOntjc3NQcm9wQml0czoxLGNzc0xpdEdyb3VwOltMWzI4XV0sY3NzRm5zOltdfSxcIm1hdHJpeCgpXCI6XCJhbmltYXRpb24tZGVsYXlcIixcInBlcnNwZWN0aXZlKClcIjpcImJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXNcIixcInJvdGF0ZSgpXCI6XCJib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzXCIsXCJyb3RhdGUzZCgpXCI6XCJhbmltYXRpb24tZGVsYXlcIixcInJvdGF0ZXgoKVwiOlwiYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1c1wiLFwicm90YXRleSgpXCI6XCJib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzXCIsXCJyb3RhdGV6KClcIjpcImJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXNcIixcInNjYWxlKClcIjpcImFuaW1hdGlvbi1kZWxheVwiLFwic2NhbGUzZCgpXCI6XCJhbmltYXRpb24tZGVsYXlcIixcInNjYWxleCgpXCI6XCJib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzXCIsXCJzY2FsZXkoKVwiOlwiYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1c1wiLFwic2NhbGV6KClcIjpcImJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXNcIixcInNrZXcoKVwiOlwiYW5pbWF0aW9uLWRlbGF5XCIsXCJza2V3eCgpXCI6XCJib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzXCIsXCJza2V3eSgpXCI6XCJib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzXCIsXCJ0cmFuc2xhdGUoKVwiOlwiYW5pbWF0aW9uLWRlbGF5XCIsXCJ0cmFuc2xhdGUzZCgpXCI6XCJhbmltYXRpb24tZGVsYXlcIixcInRyYW5zbGF0ZXgoKVwiOlwiYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1c1wiLFwidHJhbnNsYXRleSgpXCI6XCJib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzXCIsXCJ0cmFuc2xhdGV6KClcIjpcImJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXNcIn07aWYodHJ1ZSl7Zm9yKHZhciBrZXkgaW4gc2NoZW1hKXtpZihcInN0cmluZ1wiPT09dHlwZW9mIHNjaGVtYVtrZXldJiZPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChzY2hlbWEsa2V5KSl7c2NoZW1hW2tleV09c2NoZW1hW3NjaGVtYVtrZXldXX19fXJldHVybiBzY2hlbWF9KCk7aWYodHlwZW9mIHdpbmRvdyE9PVwidW5kZWZpbmVkXCIpe3dpbmRvd1tcImNzc1NjaGVtYVwiXT1jc3NTY2hlbWF9dmFyIGxleENzczt2YXIgZGVjb2RlQ3NzOyhmdW5jdGlvbigpe2Z1bmN0aW9uIGRlY29kZUNzc0VzY2FwZShzKXt2YXIgaT1wYXJzZUludChzLnN1YnN0cmluZygxKSwxNik7aWYoaT42NTUzNSl7cmV0dXJuIGktPTY1NTM2LFN0cmluZy5mcm9tQ2hhckNvZGUoNTUyOTYrKGk+PjEwKSw1NjMyMCsoaSYxMDIzKSl9ZWxzZSBpZihpPT1pKXtyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShpKX1lbHNlIGlmKHNbMV08XCIgXCIpe3JldHVyblwiXCJ9ZWxzZXtyZXR1cm4gc1sxXX19ZnVuY3Rpb24gZXNjYXBlQ3NzU3RyaW5nKHMscmVwbGFjZXIpe3JldHVybidcIicrcy5yZXBsYWNlKC9bXFx1MDAwMC1cXHUwMDFmXFxcXFxcXCI8Pl0vZyxyZXBsYWNlcikrJ1wiJ31mdW5jdGlvbiBlc2NhcGVDc3NTdHJDaGFyKGNoKXtyZXR1cm4gY3NzU3RyQ2hhcnNbY2hdfHwoY3NzU3RyQ2hhcnNbY2hdPVwiXFxcXFwiK2NoLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpK1wiIFwiKX1mdW5jdGlvbiBlc2NhcGVDc3NVcmxDaGFyKGNoKXtyZXR1cm4gY3NzVXJsQ2hhcnNbY2hdfHwoY3NzVXJsQ2hhcnNbY2hdPShjaDxcIlx1MDAxMFwiP1wiJTBcIjpcIiVcIikrY2guY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikpfXZhciBjc3NTdHJDaGFycz17XCJcXFxcXCI6XCJcXFxcXFxcXFwifTt2YXIgY3NzVXJsQ2hhcnM9e1wiXFxcXFwiOlwiJTVjXCJ9O3ZhciBXQz1cIltcXFxcdFxcXFxuXFxcXGYgXVwiO3ZhciBXPVdDK1wiKlwiO3ZhciBOTD1cIltcXFxcblxcXFxmXVwiO3ZhciBTVVJST0dBVEVfUEFJUj1cIltcXFxcdWQ4MDAtXFxcXHVkYmZmXVtcXFxcdWRjMDAtXFxcXHVkZmZmXVwiO3ZhciBOT05BU0NJST1cIltcXFxcdTAwODAtXFxcXHVkN2ZmXFxcXHVlMDAwLVxcXFx1ZmZmZF18XCIrU1VSUk9HQVRFX1BBSVI7dmFyIFVOSUNPREVfVEFJTD1cIlswLTlhLWZBLUZdezEsNn1cIitXQytcIj9cIjt2YXIgVU5JQ09ERT1cIlxcXFxcXFxcXCIrVU5JQ09ERV9UQUlMO3ZhciBFU0NBUEVfVEFJTD1cIig/OlwiK1VOSUNPREVfVEFJTCtcInxbXFxcXHUwMDIwLVxcXFx1MDA3ZVxcXFx1MDA4MC1cXFxcdWQ3ZmZcXFxcdWUwMDBcXFxcdWZmZmRdfFwiK1NVUlJPR0FURV9QQUlSK1wiKVwiO3ZhciBFU0NBUEU9XCJcXFxcXFxcXFwiK0VTQ0FQRV9UQUlMO3ZhciBVUkxDSEFSPVwiKD86W1xcXFx0XFxcXHgyMVxcXFx4MjMtXFxcXHgyNlxcXFx4MjgtXFxcXHg1YlxcXFx4NWQtXFxcXHg3ZV18XCIrTk9OQVNDSUkrXCJ8XCIrRVNDQVBFK1wiKVwiO3ZhciBTVFJJTkdDSEFSPVwiW14nXFxcIlxcXFxuXFxcXGZcXFxcXFxcXF18XFxcXFxcXFxbXFxcXHNcXFxcU11cIjt2YXIgU1RSSU5HPVwiXFxcIig/Oid8XCIrU1RSSU5HQ0hBUisnKSpcIicrXCJ8Jyg/OlxcXCJ8XCIrU1RSSU5HQ0hBUitcIikqJ1wiO3ZhciBOVU09XCJbLStdPyg/OlswLTldKyg/OlsuXVswLTldKyk/fFsuXVswLTldKylcIjt2YXIgTk1TVEFSVD1cIig/OlthLXpBLVpfXXxcIitOT05BU0NJSStcInxcIitFU0NBUEUrXCIpXCI7dmFyIE5NQ0hBUj1cIig/OlthLXpBLVowLTlfLV18XCIrTk9OQVNDSUkrXCJ8XCIrRVNDQVBFK1wiKVwiO3ZhciBOQU1FPU5NQ0hBUitcIitcIjt2YXIgSURFTlQ9XCItP1wiK05NU1RBUlQrTk1DSEFSK1wiKlwiO3ZhciBBVEtFWVdPUkQ9XCJAXCIrSURFTlQ7dmFyIEhBU0g9XCIjXCIrTkFNRTt2YXIgTlVNQkVSPU5VTTt2YXIgV09SRF9URVJNPVwiKD86QD8tP1wiK05NU1RBUlQrXCJ8IylcIitOTUNIQVIrXCIqXCI7dmFyIFBFUkNFTlRBR0U9TlVNK1wiJVwiO3ZhciBESU1FTlNJT049TlVNK0lERU5UO3ZhciBOVU1FUklDX1ZBTFVFPU5VTStcIig/OiV8XCIrSURFTlQrXCIpP1wiO3ZhciBVUkk9XCJ1cmxbKF1cIitXK1wiKD86XCIrU1RSSU5HK1wifFwiK1VSTENIQVIrXCIqKVwiK1crXCJbKV1cIjt2YXIgVU5JQ09ERV9SQU5HRT1cIlVbK11bMC05QS1GP117MSw2fSg/Oi1bMC05QS1GXXsxLDZ9KT9cIjt2YXIgQ0RPPVwiPCEtLVwiO3ZhciBDREM9XCItLT5cIjt2YXIgUz1XQytcIitcIjt2YXIgQ09NTUVOVD1cIi8oPzpbKl1bXipdKlsqXSsoPzpbXi9dW14qXSpbKl0rKSovfC9bXlxcXFxuXFxcXGZdKilcIjt2YXIgRlVOQ1RJT049XCIoPyF1cmxbKF0pXCIrSURFTlQrXCJbKF1cIjt2YXIgSU5DTFVERVM9XCJ+PVwiO3ZhciBEQVNITUFUQ0g9XCJbfF09XCI7dmFyIFBSRUZJWE1BVENIPVwiW15dPVwiO3ZhciBTVUZGSVhNQVRDSD1cIlskXT1cIjt2YXIgU1VCU1RSSU5HTUFUQ0g9XCJbKl09XCI7dmFyIENNUF9PUFM9XCJbfnxeJCpdPVwiO3ZhciBDSEFSPVwiW15cXFwiJ1xcXFxcXFxcL118Lyg/IVsvKl0pXCI7dmFyIEJPTT1cIlxcXFx1RkVGRlwiO3ZhciBDU1NfVE9LRU49bmV3IFJlZ0V4cChbQk9NLFVOSUNPREVfUkFOR0UsVVJJLEZVTkNUSU9OLFdPUkRfVEVSTSxTVFJJTkcsTlVNRVJJQ19WQUxVRSxDRE8sQ0RDLFMsQ09NTUVOVCxDTVBfT1BTLENIQVJdLmpvaW4oXCJ8XCIpLFwiZ2lcIik7dmFyIENTU19ERUNPREVSPW5ldyBSZWdFeHAoXCJcXFxcXFxcXCg/OlwiK0VTQ0FQRV9UQUlMK1wifFwiK05MK1wiKVwiLFwiZ1wiKTt2YXIgVVJMX1JFPW5ldyBSZWdFeHAoXCJedXJsXFxcXChcIitXK1wiW1xcXCInXT98W1xcXCInXT9cIitXK1wiXFxcXCkkXCIsXCJnaVwiKTtkZWNvZGVDc3M9ZnVuY3Rpb24oY3NzKXtyZXR1cm4gY3NzLnJlcGxhY2UoQ1NTX0RFQ09ERVIsZGVjb2RlQ3NzRXNjYXBlKX07bGV4Q3NzPWZ1bmN0aW9uKGNzc1RleHQpe2Nzc1RleHQ9XCJcIitjc3NUZXh0O3ZhciB0b2tlbnM9Y3NzVGV4dC5yZXBsYWNlKC9cXHJcXG4/L2csXCJcXG5cIikubWF0Y2goQ1NTX1RPS0VOKXx8W107dmFyIGo9MDt2YXIgbGFzdD1cIiBcIjtmb3IodmFyIGk9MCxuPXRva2Vucy5sZW5ndGg7aTxuOysraSl7dmFyIHRvaz1kZWNvZGVDc3ModG9rZW5zW2ldKTt2YXIgbGVuPXRvay5sZW5ndGg7dmFyIGNjPXRvay5jaGFyQ29kZUF0KDApO3Rvaz1jYz09J1wiJy5jaGFyQ29kZUF0KDApfHxjYz09XCInXCIuY2hhckNvZGVBdCgwKT9lc2NhcGVDc3NTdHJpbmcodG9rLnN1YnN0cmluZygxLGxlbi0xKSxlc2NhcGVDc3NTdHJDaGFyKTpjYz09XCIvXCIuY2hhckNvZGVBdCgwKSYmbGVuPjF8fHRvaz09XCJcXFxcXCJ8fHRvaz09Q0RDfHx0b2s9PUNET3x8dG9rPT1cIu+7v1wifHxjYzw9XCIgXCIuY2hhckNvZGVBdCgwKT9cIiBcIjovdXJsXFwoL2kudGVzdCh0b2spP1widXJsKFwiK2VzY2FwZUNzc1N0cmluZyh0b2sucmVwbGFjZShVUkxfUkUsXCJcIiksZXNjYXBlQ3NzVXJsQ2hhcikrXCIpXCI6dG9rO2lmKGxhc3QhPXRva3x8dG9rIT1cIiBcIil7dG9rZW5zW2orK109bGFzdD10b2t9fXRva2Vucy5sZW5ndGg9ajtyZXR1cm4gdG9rZW5zfX0pKCk7aWYodHlwZW9mIHdpbmRvdyE9PVwidW5kZWZpbmVkXCIpe3dpbmRvd1tcImxleENzc1wiXT1sZXhDc3M7d2luZG93W1wiZGVjb2RlQ3NzXCJdPWRlY29kZUNzc312YXIgVVJJPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gcGFyc2UodXJpU3RyKXt2YXIgbT0oXCJcIit1cmlTdHIpLm1hdGNoKFVSSV9SRV8pO2lmKCFtKXtyZXR1cm4gbnVsbH1yZXR1cm4gbmV3IFVSSShudWxsSWZBYnNlbnQobVsxXSksbnVsbElmQWJzZW50KG1bMl0pLG51bGxJZkFic2VudChtWzNdKSxudWxsSWZBYnNlbnQobVs0XSksbnVsbElmQWJzZW50KG1bNV0pLG51bGxJZkFic2VudChtWzZdKSxudWxsSWZBYnNlbnQobVs3XSkpfWZ1bmN0aW9uIGNyZWF0ZShzY2hlbWUsY3JlZGVudGlhbHMsZG9tYWluLHBvcnQscGF0aCxxdWVyeSxmcmFnbWVudCl7dmFyIHVyaT1uZXcgVVJJKGVuY29kZUlmRXhpc3RzMihzY2hlbWUsVVJJX0RJU0FMTE9XRURfSU5fU0NIRU1FX09SX0NSRURFTlRJQUxTXyksZW5jb2RlSWZFeGlzdHMyKGNyZWRlbnRpYWxzLFVSSV9ESVNBTExPV0VEX0lOX1NDSEVNRV9PUl9DUkVERU5USUFMU18pLGVuY29kZUlmRXhpc3RzKGRvbWFpbikscG9ydD4wP3BvcnQudG9TdHJpbmcoKTpudWxsLGVuY29kZUlmRXhpc3RzMihwYXRoLFVSSV9ESVNBTExPV0VEX0lOX1BBVEhfKSxudWxsLGVuY29kZUlmRXhpc3RzKGZyYWdtZW50KSk7aWYocXVlcnkpe2lmKFwic3RyaW5nXCI9PT10eXBlb2YgcXVlcnkpe3VyaS5zZXRSYXdRdWVyeShxdWVyeS5yZXBsYWNlKC9bXj8mPTAtOUEtWmEtel9cXC1+LiVdL2csZW5jb2RlT25lKSl9ZWxzZXt1cmkuc2V0QWxsUGFyYW1ldGVycyhxdWVyeSl9fXJldHVybiB1cml9ZnVuY3Rpb24gZW5jb2RlSWZFeGlzdHModW5lc2NhcGVkUGFydCl7aWYoXCJzdHJpbmdcIj09dHlwZW9mIHVuZXNjYXBlZFBhcnQpe3JldHVybiBlbmNvZGVVUklDb21wb25lbnQodW5lc2NhcGVkUGFydCl9cmV0dXJuIG51bGx9ZnVuY3Rpb24gZW5jb2RlSWZFeGlzdHMyKHVuZXNjYXBlZFBhcnQsZXh0cmEpe2lmKFwic3RyaW5nXCI9PXR5cGVvZiB1bmVzY2FwZWRQYXJ0KXtyZXR1cm4gZW5jb2RlVVJJKHVuZXNjYXBlZFBhcnQpLnJlcGxhY2UoZXh0cmEsZW5jb2RlT25lKX1yZXR1cm4gbnVsbH1mdW5jdGlvbiBlbmNvZGVPbmUoY2gpe3ZhciBuPWNoLmNoYXJDb2RlQXQoMCk7cmV0dXJuXCIlXCIrXCIwMTIzNDU2Nzg5QUJDREVGXCIuY2hhckF0KG4+PjQmMTUpK1wiMDEyMzQ1Njc4OUFCQ0RFRlwiLmNoYXJBdChuJjE1KX1mdW5jdGlvbiBub3JtUGF0aChwYXRoKXtyZXR1cm4gcGF0aC5yZXBsYWNlKC8oXnxcXC8pXFwuKD86XFwvfCQpL2csXCIkMVwiKS5yZXBsYWNlKC9cXC97Mix9L2csXCIvXCIpfXZhciBQQVJFTlRfRElSRUNUT1JZX0hBTkRMRVI9bmV3IFJlZ0V4cChcIlwiK1wiKC98XilcIitcIig/OlteLi9dW14vXSp8XFxcXC57Mix9KD86W14uL11bXi9dKil8XFxcXC57Myx9W14vXSopXCIrXCIvXFxcXC5cXFxcLig/Oi98JClcIik7dmFyIFBBUkVOVF9ESVJFQ1RPUllfSEFORExFUl9SRT1uZXcgUmVnRXhwKFBBUkVOVF9ESVJFQ1RPUllfSEFORExFUik7dmFyIEVYVFJBX1BBUkVOVF9QQVRIU19SRT0vXig/OlxcLlxcLlxcLykqKD86XFwuXFwuJCk/LztmdW5jdGlvbiBjb2xsYXBzZV9kb3RzKHBhdGgpe2lmKHBhdGg9PT1udWxsKXtyZXR1cm4gbnVsbH12YXIgcD1ub3JtUGF0aChwYXRoKTt2YXIgcj1QQVJFTlRfRElSRUNUT1JZX0hBTkRMRVJfUkU7Zm9yKHZhciBxOyhxPXAucmVwbGFjZShyLFwiJDFcIikpIT1wO3A9cSl7fXJldHVybiBwfWZ1bmN0aW9uIHJlc29sdmUoYmFzZVVyaSxyZWxhdGl2ZVVyaSl7dmFyIGFic29sdXRlVXJpPWJhc2VVcmkuY2xvbmUoKTt2YXIgb3ZlcnJpZGRlbj1yZWxhdGl2ZVVyaS5oYXNTY2hlbWUoKTtpZihvdmVycmlkZGVuKXthYnNvbHV0ZVVyaS5zZXRSYXdTY2hlbWUocmVsYXRpdmVVcmkuZ2V0UmF3U2NoZW1lKCkpfWVsc2V7b3ZlcnJpZGRlbj1yZWxhdGl2ZVVyaS5oYXNDcmVkZW50aWFscygpfWlmKG92ZXJyaWRkZW4pe2Fic29sdXRlVXJpLnNldFJhd0NyZWRlbnRpYWxzKHJlbGF0aXZlVXJpLmdldFJhd0NyZWRlbnRpYWxzKCkpfWVsc2V7b3ZlcnJpZGRlbj1yZWxhdGl2ZVVyaS5oYXNEb21haW4oKX1pZihvdmVycmlkZGVuKXthYnNvbHV0ZVVyaS5zZXRSYXdEb21haW4ocmVsYXRpdmVVcmkuZ2V0UmF3RG9tYWluKCkpfWVsc2V7b3ZlcnJpZGRlbj1yZWxhdGl2ZVVyaS5oYXNQb3J0KCl9dmFyIHJhd1BhdGg9cmVsYXRpdmVVcmkuZ2V0UmF3UGF0aCgpO3ZhciBzaW1wbGlmaWVkUGF0aD1jb2xsYXBzZV9kb3RzKHJhd1BhdGgpO2lmKG92ZXJyaWRkZW4pe2Fic29sdXRlVXJpLnNldFBvcnQocmVsYXRpdmVVcmkuZ2V0UG9ydCgpKTtzaW1wbGlmaWVkUGF0aD1zaW1wbGlmaWVkUGF0aCYmc2ltcGxpZmllZFBhdGgucmVwbGFjZShFWFRSQV9QQVJFTlRfUEFUSFNfUkUsXCJcIil9ZWxzZXtvdmVycmlkZGVuPSEhcmF3UGF0aDtpZihvdmVycmlkZGVuKXtpZihzaW1wbGlmaWVkUGF0aC5jaGFyQ29kZUF0KDApIT09NDcpe3ZhciBhYnNSYXdQYXRoPWNvbGxhcHNlX2RvdHMoYWJzb2x1dGVVcmkuZ2V0UmF3UGF0aCgpfHxcIlwiKS5yZXBsYWNlKEVYVFJBX1BBUkVOVF9QQVRIU19SRSxcIlwiKTt2YXIgc2xhc2g9YWJzUmF3UGF0aC5sYXN0SW5kZXhPZihcIi9cIikrMTtzaW1wbGlmaWVkUGF0aD1jb2xsYXBzZV9kb3RzKChzbGFzaD9hYnNSYXdQYXRoLnN1YnN0cmluZygwLHNsYXNoKTpcIlwiKStjb2xsYXBzZV9kb3RzKHJhd1BhdGgpKS5yZXBsYWNlKEVYVFJBX1BBUkVOVF9QQVRIU19SRSxcIlwiKX19ZWxzZXtzaW1wbGlmaWVkUGF0aD1zaW1wbGlmaWVkUGF0aCYmc2ltcGxpZmllZFBhdGgucmVwbGFjZShFWFRSQV9QQVJFTlRfUEFUSFNfUkUsXCJcIik7aWYoc2ltcGxpZmllZFBhdGghPT1yYXdQYXRoKXthYnNvbHV0ZVVyaS5zZXRSYXdQYXRoKHNpbXBsaWZpZWRQYXRoKX19fWlmKG92ZXJyaWRkZW4pe2Fic29sdXRlVXJpLnNldFJhd1BhdGgoc2ltcGxpZmllZFBhdGgpfWVsc2V7b3ZlcnJpZGRlbj1yZWxhdGl2ZVVyaS5oYXNRdWVyeSgpfWlmKG92ZXJyaWRkZW4pe2Fic29sdXRlVXJpLnNldFJhd1F1ZXJ5KHJlbGF0aXZlVXJpLmdldFJhd1F1ZXJ5KCkpfWVsc2V7b3ZlcnJpZGRlbj1yZWxhdGl2ZVVyaS5oYXNGcmFnbWVudCgpfWlmKG92ZXJyaWRkZW4pe2Fic29sdXRlVXJpLnNldFJhd0ZyYWdtZW50KHJlbGF0aXZlVXJpLmdldFJhd0ZyYWdtZW50KCkpfXJldHVybiBhYnNvbHV0ZVVyaX1mdW5jdGlvbiBVUkkocmF3U2NoZW1lLHJhd0NyZWRlbnRpYWxzLHJhd0RvbWFpbixwb3J0LHJhd1BhdGgscmF3UXVlcnkscmF3RnJhZ21lbnQpe3RoaXMuc2NoZW1lXz1yYXdTY2hlbWU7dGhpcy5jcmVkZW50aWFsc189cmF3Q3JlZGVudGlhbHM7dGhpcy5kb21haW5fPXJhd0RvbWFpbjt0aGlzLnBvcnRfPXBvcnQ7dGhpcy5wYXRoXz1yYXdQYXRoO3RoaXMucXVlcnlfPXJhd1F1ZXJ5O3RoaXMuZnJhZ21lbnRfPXJhd0ZyYWdtZW50O3RoaXMucGFyYW1DYWNoZV89bnVsbH1VUkkucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7dmFyIG91dD1bXTtpZihudWxsIT09dGhpcy5zY2hlbWVfKXtvdXQucHVzaCh0aGlzLnNjaGVtZV8sXCI6XCIpfWlmKG51bGwhPT10aGlzLmRvbWFpbl8pe291dC5wdXNoKFwiLy9cIik7aWYobnVsbCE9PXRoaXMuY3JlZGVudGlhbHNfKXtvdXQucHVzaCh0aGlzLmNyZWRlbnRpYWxzXyxcIkBcIil9b3V0LnB1c2godGhpcy5kb21haW5fKTtpZihudWxsIT09dGhpcy5wb3J0Xyl7b3V0LnB1c2goXCI6XCIsdGhpcy5wb3J0Xy50b1N0cmluZygpKX19aWYobnVsbCE9PXRoaXMucGF0aF8pe291dC5wdXNoKHRoaXMucGF0aF8pfWlmKG51bGwhPT10aGlzLnF1ZXJ5Xyl7b3V0LnB1c2goXCI/XCIsdGhpcy5xdWVyeV8pfWlmKG51bGwhPT10aGlzLmZyYWdtZW50Xyl7b3V0LnB1c2goXCIjXCIsdGhpcy5mcmFnbWVudF8pfXJldHVybiBvdXQuam9pbihcIlwiKX07VVJJLnByb3RvdHlwZS5jbG9uZT1mdW5jdGlvbigpe3JldHVybiBuZXcgVVJJKHRoaXMuc2NoZW1lXyx0aGlzLmNyZWRlbnRpYWxzXyx0aGlzLmRvbWFpbl8sdGhpcy5wb3J0Xyx0aGlzLnBhdGhfLHRoaXMucXVlcnlfLHRoaXMuZnJhZ21lbnRfKX07VVJJLnByb3RvdHlwZS5nZXRTY2hlbWU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zY2hlbWVfJiZkZWNvZGVVUklDb21wb25lbnQodGhpcy5zY2hlbWVfKS50b0xvd2VyQ2FzZSgpfTtVUkkucHJvdG90eXBlLmdldFJhd1NjaGVtZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnNjaGVtZV99O1VSSS5wcm90b3R5cGUuc2V0U2NoZW1lPWZ1bmN0aW9uKG5ld1NjaGVtZSl7dGhpcy5zY2hlbWVfPWVuY29kZUlmRXhpc3RzMihuZXdTY2hlbWUsVVJJX0RJU0FMTE9XRURfSU5fU0NIRU1FX09SX0NSRURFTlRJQUxTXyk7cmV0dXJuIHRoaXN9O1VSSS5wcm90b3R5cGUuc2V0UmF3U2NoZW1lPWZ1bmN0aW9uKG5ld1NjaGVtZSl7dGhpcy5zY2hlbWVfPW5ld1NjaGVtZT9uZXdTY2hlbWU6bnVsbDtyZXR1cm4gdGhpc307VVJJLnByb3RvdHlwZS5oYXNTY2hlbWU9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbCE9PXRoaXMuc2NoZW1lX307VVJJLnByb3RvdHlwZS5nZXRDcmVkZW50aWFscz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNyZWRlbnRpYWxzXyYmZGVjb2RlVVJJQ29tcG9uZW50KHRoaXMuY3JlZGVudGlhbHNfKX07VVJJLnByb3RvdHlwZS5nZXRSYXdDcmVkZW50aWFscz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNyZWRlbnRpYWxzX307VVJJLnByb3RvdHlwZS5zZXRDcmVkZW50aWFscz1mdW5jdGlvbihuZXdDcmVkZW50aWFscyl7dGhpcy5jcmVkZW50aWFsc189ZW5jb2RlSWZFeGlzdHMyKG5ld0NyZWRlbnRpYWxzLFVSSV9ESVNBTExPV0VEX0lOX1NDSEVNRV9PUl9DUkVERU5USUFMU18pO3JldHVybiB0aGlzfTtVUkkucHJvdG90eXBlLnNldFJhd0NyZWRlbnRpYWxzPWZ1bmN0aW9uKG5ld0NyZWRlbnRpYWxzKXt0aGlzLmNyZWRlbnRpYWxzXz1uZXdDcmVkZW50aWFscz9uZXdDcmVkZW50aWFsczpudWxsO3JldHVybiB0aGlzfTtVUkkucHJvdG90eXBlLmhhc0NyZWRlbnRpYWxzPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGwhPT10aGlzLmNyZWRlbnRpYWxzX307VVJJLnByb3RvdHlwZS5nZXREb21haW49ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kb21haW5fJiZkZWNvZGVVUklDb21wb25lbnQodGhpcy5kb21haW5fKX07VVJJLnByb3RvdHlwZS5nZXRSYXdEb21haW49ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kb21haW5ffTtVUkkucHJvdG90eXBlLnNldERvbWFpbj1mdW5jdGlvbihuZXdEb21haW4pe3JldHVybiB0aGlzLnNldFJhd0RvbWFpbihuZXdEb21haW4mJmVuY29kZVVSSUNvbXBvbmVudChuZXdEb21haW4pKX07VVJJLnByb3RvdHlwZS5zZXRSYXdEb21haW49ZnVuY3Rpb24obmV3RG9tYWluKXt0aGlzLmRvbWFpbl89bmV3RG9tYWluP25ld0RvbWFpbjpudWxsO3JldHVybiB0aGlzLnNldFJhd1BhdGgodGhpcy5wYXRoXyl9O1VSSS5wcm90b3R5cGUuaGFzRG9tYWluPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGwhPT10aGlzLmRvbWFpbl99O1VSSS5wcm90b3R5cGUuZ2V0UG9ydD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnBvcnRfJiZkZWNvZGVVUklDb21wb25lbnQodGhpcy5wb3J0Xyl9O1VSSS5wcm90b3R5cGUuc2V0UG9ydD1mdW5jdGlvbihuZXdQb3J0KXtpZihuZXdQb3J0KXtuZXdQb3J0PU51bWJlcihuZXdQb3J0KTtpZihuZXdQb3J0IT09KG5ld1BvcnQmNjU1MzUpKXt0aHJvdyBuZXcgRXJyb3IoXCJCYWQgcG9ydCBudW1iZXIgXCIrbmV3UG9ydCl9dGhpcy5wb3J0Xz1cIlwiK25ld1BvcnR9ZWxzZXt0aGlzLnBvcnRfPW51bGx9cmV0dXJuIHRoaXN9O1VSSS5wcm90b3R5cGUuaGFzUG9ydD1mdW5jdGlvbigpe3JldHVybiBudWxsIT09dGhpcy5wb3J0X307VVJJLnByb3RvdHlwZS5nZXRQYXRoPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucGF0aF8mJmRlY29kZVVSSUNvbXBvbmVudCh0aGlzLnBhdGhfKX07VVJJLnByb3RvdHlwZS5nZXRSYXdQYXRoPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucGF0aF99O1VSSS5wcm90b3R5cGUuc2V0UGF0aD1mdW5jdGlvbihuZXdQYXRoKXtyZXR1cm4gdGhpcy5zZXRSYXdQYXRoKGVuY29kZUlmRXhpc3RzMihuZXdQYXRoLFVSSV9ESVNBTExPV0VEX0lOX1BBVEhfKSl9O1VSSS5wcm90b3R5cGUuc2V0UmF3UGF0aD1mdW5jdGlvbihuZXdQYXRoKXtpZihuZXdQYXRoKXtuZXdQYXRoPVN0cmluZyhuZXdQYXRoKTt0aGlzLnBhdGhfPSF0aGlzLmRvbWFpbl98fC9eXFwvLy50ZXN0KG5ld1BhdGgpP25ld1BhdGg6XCIvXCIrbmV3UGF0aH1lbHNle3RoaXMucGF0aF89bnVsbH1yZXR1cm4gdGhpc307VVJJLnByb3RvdHlwZS5oYXNQYXRoPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGwhPT10aGlzLnBhdGhffTtVUkkucHJvdG90eXBlLmdldFF1ZXJ5PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucXVlcnlfJiZkZWNvZGVVUklDb21wb25lbnQodGhpcy5xdWVyeV8pLnJlcGxhY2UoL1xcKy9nLFwiIFwiKX07VVJJLnByb3RvdHlwZS5nZXRSYXdRdWVyeT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnF1ZXJ5X307VVJJLnByb3RvdHlwZS5zZXRRdWVyeT1mdW5jdGlvbihuZXdRdWVyeSl7dGhpcy5wYXJhbUNhY2hlXz1udWxsO3RoaXMucXVlcnlfPWVuY29kZUlmRXhpc3RzKG5ld1F1ZXJ5KTtyZXR1cm4gdGhpc307VVJJLnByb3RvdHlwZS5zZXRSYXdRdWVyeT1mdW5jdGlvbihuZXdRdWVyeSl7dGhpcy5wYXJhbUNhY2hlXz1udWxsO3RoaXMucXVlcnlfPW5ld1F1ZXJ5P25ld1F1ZXJ5Om51bGw7cmV0dXJuIHRoaXN9O1VSSS5wcm90b3R5cGUuaGFzUXVlcnk9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbCE9PXRoaXMucXVlcnlffTtVUkkucHJvdG90eXBlLnNldEFsbFBhcmFtZXRlcnM9ZnVuY3Rpb24ocGFyYW1zKXtpZih0eXBlb2YgcGFyYW1zPT09XCJvYmplY3RcIil7aWYoIShwYXJhbXMgaW5zdGFuY2VvZiBBcnJheSkmJihwYXJhbXMgaW5zdGFuY2VvZiBPYmplY3R8fE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChwYXJhbXMpIT09XCJbb2JqZWN0IEFycmF5XVwiKSl7dmFyIG5ld1BhcmFtcz1bXTt2YXIgaT0tMTtmb3IodmFyIGsgaW4gcGFyYW1zKXt2YXIgdj1wYXJhbXNba107aWYoXCJzdHJpbmdcIj09PXR5cGVvZiB2KXtuZXdQYXJhbXNbKytpXT1rO25ld1BhcmFtc1srK2ldPXZ9fXBhcmFtcz1uZXdQYXJhbXN9fXRoaXMucGFyYW1DYWNoZV89bnVsbDt2YXIgcXVlcnlCdWY9W107dmFyIHNlcGFyYXRvcj1cIlwiO2Zvcih2YXIgaj0wO2o8cGFyYW1zLmxlbmd0aDspe3ZhciBrPXBhcmFtc1tqKytdO3ZhciB2PXBhcmFtc1tqKytdO3F1ZXJ5QnVmLnB1c2goc2VwYXJhdG9yLGVuY29kZVVSSUNvbXBvbmVudChrLnRvU3RyaW5nKCkpKTtzZXBhcmF0b3I9XCImXCI7aWYodil7cXVlcnlCdWYucHVzaChcIj1cIixlbmNvZGVVUklDb21wb25lbnQodi50b1N0cmluZygpKSl9fXRoaXMucXVlcnlfPXF1ZXJ5QnVmLmpvaW4oXCJcIik7cmV0dXJuIHRoaXN9O1VSSS5wcm90b3R5cGUuY2hlY2tQYXJhbWV0ZXJDYWNoZV89ZnVuY3Rpb24oKXtpZighdGhpcy5wYXJhbUNhY2hlXyl7dmFyIHE9dGhpcy5xdWVyeV87aWYoIXEpe3RoaXMucGFyYW1DYWNoZV89W119ZWxzZXt2YXIgY2dpUGFyYW1zPXEuc3BsaXQoL1smXFw/XS8pO3ZhciBvdXQ9W107dmFyIGs9LTE7Zm9yKHZhciBpPTA7aTxjZ2lQYXJhbXMubGVuZ3RoOysraSl7dmFyIG09Y2dpUGFyYW1zW2ldLm1hdGNoKC9eKFtePV0qKSg/Oj0oLiopKT8kLyk7b3V0Wysra109ZGVjb2RlVVJJQ29tcG9uZW50KG1bMV0pLnJlcGxhY2UoL1xcKy9nLFwiIFwiKTtvdXRbKytrXT1kZWNvZGVVUklDb21wb25lbnQobVsyXXx8XCJcIikucmVwbGFjZSgvXFwrL2csXCIgXCIpfXRoaXMucGFyYW1DYWNoZV89b3V0fX19O1VSSS5wcm90b3R5cGUuc2V0UGFyYW1ldGVyVmFsdWVzPWZ1bmN0aW9uKGtleSx2YWx1ZXMpe2lmKHR5cGVvZiB2YWx1ZXM9PT1cInN0cmluZ1wiKXt2YWx1ZXM9W3ZhbHVlc119dGhpcy5jaGVja1BhcmFtZXRlckNhY2hlXygpO3ZhciBuZXdWYWx1ZUluZGV4PTA7dmFyIHBjPXRoaXMucGFyYW1DYWNoZV87dmFyIHBhcmFtcz1bXTtmb3IodmFyIGk9MCxrPTA7aTxwYy5sZW5ndGg7aSs9Mil7aWYoa2V5PT09cGNbaV0pe2lmKG5ld1ZhbHVlSW5kZXg8dmFsdWVzLmxlbmd0aCl7cGFyYW1zLnB1c2goa2V5LHZhbHVlc1tuZXdWYWx1ZUluZGV4KytdKX19ZWxzZXtwYXJhbXMucHVzaChwY1tpXSxwY1tpKzFdKX19d2hpbGUobmV3VmFsdWVJbmRleDx2YWx1ZXMubGVuZ3RoKXtwYXJhbXMucHVzaChrZXksdmFsdWVzW25ld1ZhbHVlSW5kZXgrK10pfXRoaXMuc2V0QWxsUGFyYW1ldGVycyhwYXJhbXMpO3JldHVybiB0aGlzfTtVUkkucHJvdG90eXBlLnJlbW92ZVBhcmFtZXRlcj1mdW5jdGlvbihrZXkpe3JldHVybiB0aGlzLnNldFBhcmFtZXRlclZhbHVlcyhrZXksW10pfTtVUkkucHJvdG90eXBlLmdldEFsbFBhcmFtZXRlcnM9ZnVuY3Rpb24oKXt0aGlzLmNoZWNrUGFyYW1ldGVyQ2FjaGVfKCk7cmV0dXJuIHRoaXMucGFyYW1DYWNoZV8uc2xpY2UoMCx0aGlzLnBhcmFtQ2FjaGVfLmxlbmd0aCl9O1VSSS5wcm90b3R5cGUuZ2V0UGFyYW1ldGVyVmFsdWVzPWZ1bmN0aW9uKHBhcmFtTmFtZVVuZXNjYXBlZCl7dGhpcy5jaGVja1BhcmFtZXRlckNhY2hlXygpO3ZhciB2YWx1ZXM9W107Zm9yKHZhciBpPTA7aTx0aGlzLnBhcmFtQ2FjaGVfLmxlbmd0aDtpKz0yKXtpZihwYXJhbU5hbWVVbmVzY2FwZWQ9PT10aGlzLnBhcmFtQ2FjaGVfW2ldKXt2YWx1ZXMucHVzaCh0aGlzLnBhcmFtQ2FjaGVfW2krMV0pfX1yZXR1cm4gdmFsdWVzfTtVUkkucHJvdG90eXBlLmdldFBhcmFtZXRlck1hcD1mdW5jdGlvbihwYXJhbU5hbWVVbmVzY2FwZWQpe3RoaXMuY2hlY2tQYXJhbWV0ZXJDYWNoZV8oKTt2YXIgcGFyYW1NYXA9e307Zm9yKHZhciBpPTA7aTx0aGlzLnBhcmFtQ2FjaGVfLmxlbmd0aDtpKz0yKXt2YXIga2V5PXRoaXMucGFyYW1DYWNoZV9baSsrXSx2YWx1ZT10aGlzLnBhcmFtQ2FjaGVfW2krK107aWYoIShrZXkgaW4gcGFyYW1NYXApKXtwYXJhbU1hcFtrZXldPVt2YWx1ZV19ZWxzZXtwYXJhbU1hcFtrZXldLnB1c2godmFsdWUpfX1yZXR1cm4gcGFyYW1NYXB9O1VSSS5wcm90b3R5cGUuZ2V0UGFyYW1ldGVyVmFsdWU9ZnVuY3Rpb24ocGFyYW1OYW1lVW5lc2NhcGVkKXt0aGlzLmNoZWNrUGFyYW1ldGVyQ2FjaGVfKCk7Zm9yKHZhciBpPTA7aTx0aGlzLnBhcmFtQ2FjaGVfLmxlbmd0aDtpKz0yKXtpZihwYXJhbU5hbWVVbmVzY2FwZWQ9PT10aGlzLnBhcmFtQ2FjaGVfW2ldKXtyZXR1cm4gdGhpcy5wYXJhbUNhY2hlX1tpKzFdfX1yZXR1cm4gbnVsbH07VVJJLnByb3RvdHlwZS5nZXRGcmFnbWVudD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmZyYWdtZW50XyYmZGVjb2RlVVJJQ29tcG9uZW50KHRoaXMuZnJhZ21lbnRfKX07VVJJLnByb3RvdHlwZS5nZXRSYXdGcmFnbWVudD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmZyYWdtZW50X307VVJJLnByb3RvdHlwZS5zZXRGcmFnbWVudD1mdW5jdGlvbihuZXdGcmFnbWVudCl7dGhpcy5mcmFnbWVudF89bmV3RnJhZ21lbnQ/ZW5jb2RlVVJJQ29tcG9uZW50KG5ld0ZyYWdtZW50KTpudWxsO3JldHVybiB0aGlzfTtVUkkucHJvdG90eXBlLnNldFJhd0ZyYWdtZW50PWZ1bmN0aW9uKG5ld0ZyYWdtZW50KXt0aGlzLmZyYWdtZW50Xz1uZXdGcmFnbWVudD9uZXdGcmFnbWVudDpudWxsO3JldHVybiB0aGlzfTtVUkkucHJvdG90eXBlLmhhc0ZyYWdtZW50PWZ1bmN0aW9uKCl7cmV0dXJuIG51bGwhPT10aGlzLmZyYWdtZW50X307ZnVuY3Rpb24gbnVsbElmQWJzZW50KG1hdGNoUGFydCl7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIG1hdGNoUGFydCYmbWF0Y2hQYXJ0Lmxlbmd0aD4wP21hdGNoUGFydDpudWxsfXZhciBVUklfUkVfPW5ldyBSZWdFeHAoXCJeXCIrXCIoPzpcIitcIihbXjovPyNdKylcIitcIjopP1wiK1wiKD86Ly9cIitcIig/OihbXi8/I10qKUApP1wiK1wiKFteLz8jOkBdKilcIitcIig/OjooWzAtOV0rKSk/XCIrXCIpP1wiK1wiKFtePyNdKyk/XCIrXCIoPzpcXFxcPyhbXiNdKikpP1wiK1wiKD86IyguKikpP1wiK1wiJFwiKTt2YXIgVVJJX0RJU0FMTE9XRURfSU5fU0NIRU1FX09SX0NSRURFTlRJQUxTXz0vWyNcXC9cXD9AXS9nO3ZhciBVUklfRElTQUxMT1dFRF9JTl9QQVRIXz0vW1xcI1xcP10vZztVUkkucGFyc2U9cGFyc2U7VVJJLmNyZWF0ZT1jcmVhdGU7VVJJLnJlc29sdmU9cmVzb2x2ZTtVUkkuY29sbGFwc2VfZG90cz1jb2xsYXBzZV9kb3RzO1VSSS51dGlscz17bWltZVR5cGVPZjpmdW5jdGlvbih1cmkpe3ZhciB1cmlPYmo9cGFyc2UodXJpKTtpZigvXFwuaHRtbCQvLnRlc3QodXJpT2JqLmdldFBhdGgoKSkpe3JldHVyblwidGV4dC9odG1sXCJ9ZWxzZXtyZXR1cm5cImFwcGxpY2F0aW9uL2phdmFzY3JpcHRcIn19LHJlc29sdmU6ZnVuY3Rpb24oYmFzZSx1cmkpe2lmKGJhc2Upe3JldHVybiByZXNvbHZlKHBhcnNlKGJhc2UpLHBhcnNlKHVyaSkpLnRvU3RyaW5nKCl9ZWxzZXtyZXR1cm5cIlwiK3VyaX19fTtyZXR1cm4gVVJJfSgpO2lmKHR5cGVvZiB3aW5kb3chPT1cInVuZGVmaW5lZFwiKXt3aW5kb3dbXCJVUklcIl09VVJJfXZhciBzYW5pdGl6ZUNzc1Byb3BlcnR5PXVuZGVmaW5lZDt2YXIgc2FuaXRpemVDc3NTZWxlY3Rvckxpc3Q9dW5kZWZpbmVkO3ZhciBzYW5pdGl6ZVN0eWxlc2hlZXQ9dW5kZWZpbmVkO3ZhciBzYW5pdGl6ZVN0eWxlc2hlZXRXaXRoRXh0ZXJuYWxzPXVuZGVmaW5lZDt2YXIgc2FuaXRpemVNZWRpYVF1ZXJ5PXVuZGVmaW5lZDsoZnVuY3Rpb24oKXt2YXIgTk9FRkZFQ1RfVVJMPSd1cmwoXCJhYm91dDpibGFua1wiKSc7dmFyIE5PUk1fVVJMX1JFR0VYUD0vW1xcblxcZlxcclxcXCJcXCcoKSo8Pl0vZzt2YXIgTk9STV9VUkxfUkVQTEFDRU1FTlRTPXtcIlxcblwiOlwiJTBhXCIsXCJcXGZcIjpcIiUwY1wiLFwiXFxyXCI6XCIlMGRcIiwnXCInOlwiJTIyXCIsXCInXCI6XCIlMjdcIixcIihcIjpcIiUyOFwiLFwiKVwiOlwiJTI5XCIsXCIqXCI6XCIlMmFcIixcIjxcIjpcIiUzY1wiLFwiPlwiOlwiJTNlXCJ9O2Z1bmN0aW9uIG5vcm1hbGl6ZVVybChzKXtpZihcInN0cmluZ1wiPT09dHlwZW9mIHMpe3JldHVybid1cmwoXCInK3MucmVwbGFjZShOT1JNX1VSTF9SRUdFWFAsbm9ybWFsaXplVXJsQ2hhcikrJ1wiKSd9ZWxzZXtyZXR1cm4gTk9FRkZFQ1RfVVJMfX1mdW5jdGlvbiBub3JtYWxpemVVcmxDaGFyKGNoKXtyZXR1cm4gTk9STV9VUkxfUkVQTEFDRU1FTlRTW2NoXX12YXIgVVJJX1NDSEVNRV9SRT1uZXcgUmVnRXhwKFwiXlwiK1wiKD86XCIrXCIoW146Lz8jIF0rKVwiK1wiOik/XCIpO3ZhciBBTExPV0VEX1VSSV9TQ0hFTUVTPS9eKD86aHR0cHM/fG1haWx0bykkL2k7ZnVuY3Rpb24gcmVzb2x2ZVVyaShiYXNlVXJpLHVyaSl7aWYoYmFzZVVyaSl7cmV0dXJuIFVSSS51dGlscy5yZXNvbHZlKGJhc2VVcmksdXJpKX1yZXR1cm4gdXJpfWZ1bmN0aW9uIHNhZmVVcmkodXJpLHByb3AsbmFpdmVVcmlSZXdyaXRlcil7aWYoIW5haXZlVXJpUmV3cml0ZXIpe3JldHVybiBudWxsfXZhciBwYXJzZWQ9KFwiXCIrdXJpKS5tYXRjaChVUklfU0NIRU1FX1JFKTtpZihwYXJzZWQmJighcGFyc2VkWzFdfHxBTExPV0VEX1VSSV9TQ0hFTUVTLnRlc3QocGFyc2VkWzFdKSkpe3JldHVybiBuYWl2ZVVyaVJld3JpdGVyKHVyaSxwcm9wKX1lbHNle3JldHVybiBudWxsfX1mdW5jdGlvbiB3aXRob3V0VmVuZG9yUHJlZml4KGlkZW50KXtyZXR1cm4gaWRlbnQucmVwbGFjZSgvXi0oPzphcHBsZXxjc3N8ZXB1YnxraHRtbHxtb3p8bXNvP3xvfHJpbXx3YXB8d2Via2l0fHh2KS0oPz1bYS16XSkvLFwiXCIpfXNhbml0aXplQ3NzUHJvcGVydHk9ZnVuY3Rpb24oKXtmdW5jdGlvbiB1bmlvbkFycmF5cyhhcnJzKXt2YXIgbWFwPXt9O2Zvcih2YXIgaT1hcnJzLmxlbmd0aDstLWk+PTA7KXt2YXIgYXJyPWFycnNbaV07Zm9yKHZhciBqPWFyci5sZW5ndGg7LS1qPj0wOyl7bWFwW2FycltqXV09QUxMT1dFRF9MSVRFUkFMfX1yZXR1cm4gbWFwfXZhciBBTExPV0VEX0xJVEVSQUw9e307cmV0dXJuIGZ1bmN0aW9uIHNhbml0aXplKHByb3BlcnR5LHRva2VucyxvcHRfbmFpdmVVcmlSZXdyaXRlcixvcHRfYmFzZVVyaSxvcHRfaWRTdWZmaXgpe3ZhciBwcm9wZXJ0eUtleT13aXRob3V0VmVuZG9yUHJlZml4KHByb3BlcnR5KTt2YXIgcHJvcGVydHlTY2hlbWE9Y3NzU2NoZW1hW3Byb3BlcnR5S2V5XTtpZighcHJvcGVydHlTY2hlbWF8fFwib2JqZWN0XCIhPT10eXBlb2YgcHJvcGVydHlTY2hlbWEpe3Rva2Vucy5sZW5ndGg9MDtyZXR1cm59dmFyIHByb3BCaXRzPXByb3BlcnR5U2NoZW1hW1wiY3NzUHJvcEJpdHNcIl07ZnVuY3Rpb24gc2FuaXRpemVGdW5jdGlvbkNhbGwodG9rZW5zLHN0YXJ0KXt2YXIgcGFyZW5EZXB0aD0xLGVuZD1zdGFydCsxLG49dG9rZW5zLmxlbmd0aDt3aGlsZShlbmQ8biYmcGFyZW5EZXB0aCl7dmFyIHRva2VuPXRva2Vuc1tlbmQrK107cGFyZW5EZXB0aCs9dG9rZW49PT1cIilcIj8tMTovXlteXCInXSpcXCgkLy50ZXN0KHRva2VuKX1pZighcGFyZW5EZXB0aCl7dmFyIGZuVG9rZW49dG9rZW5zW3N0YXJ0XS50b0xvd2VyQ2FzZSgpO3ZhciBiYXJlRm5Ub2tlbj13aXRob3V0VmVuZG9yUHJlZml4KGZuVG9rZW4pO3ZhciBmblRva2Vucz10b2tlbnMuc3BsaWNlKHN0YXJ0LGVuZC1zdGFydCxcIlwiKTt2YXIgZm5zPXByb3BlcnR5U2NoZW1hW1wiY3NzRm5zXCJdO2Zvcih2YXIgaT0wLG5GbnM9Zm5zLmxlbmd0aDtpPG5GbnM7KytpKXtpZihmbnNbaV0uc3Vic3RyaW5nKDAsYmFyZUZuVG9rZW4ubGVuZ3RoKT09YmFyZUZuVG9rZW4pe2ZuVG9rZW5zWzBdPWZuVG9rZW5zW2ZuVG9rZW5zLmxlbmd0aC0xXT1cIlwiO3Nhbml0aXplKGZuc1tpXSxmblRva2VucyxvcHRfbmFpdmVVcmlSZXdyaXRlcixvcHRfYmFzZVVyaSk7cmV0dXJuIGZuVG9rZW4rZm5Ub2tlbnMuam9pbihcIiBcIikrXCIpXCJ9fX1yZXR1cm5cIlwifXZhciBzdHJpbmdEaXNwb3NpdGlvbj1wcm9wQml0cyYoQ1NTX1BST1BfQklUX1VSTHxDU1NfUFJPUF9CSVRfVU5SRVNFUlZFRF9XT1JEKTt2YXIgaWRlbnREaXNwb3NpdGlvbj1wcm9wQml0cyYoQ1NTX1BST1BfQklUX0dMT0JBTF9OQU1FfENTU19QUk9QX0JJVF9QUk9QRVJUWV9OQU1FKTt2YXIgbGFzdFF1b3RlZD1OYU47dmFyIGk9MCxrPTA7Zm9yKDtpPHRva2Vucy5sZW5ndGg7KytpKXt2YXIgdG9rZW49dG9rZW5zW2ldLnRvTG93ZXJDYXNlKCk7dmFyIGNjPXRva2VuLmNoYXJDb2RlQXQoMCksY2MxLGNjMixpc251bTEsaXNudW0yLGVuZDt2YXIgbGl0R3JvdXAsbGl0TWFwO3Rva2VuPWNjPT09XCIgXCIuY2hhckNvZGVBdCgwKT9cIlwiOmNjPT09J1wiJy5jaGFyQ29kZUF0KDApP3N0cmluZ0Rpc3Bvc2l0aW9uPT09Q1NTX1BST1BfQklUX1VSTD9vcHRfbmFpdmVVcmlSZXdyaXRlcj9ub3JtYWxpemVVcmwoc2FmZVVyaShyZXNvbHZlVXJpKG9wdF9iYXNlVXJpLGRlY29kZUNzcyh0b2tlbnNbaV0uc3Vic3RyaW5nKDEsdG9rZW4ubGVuZ3RoLTEpKSkscHJvcGVydHlLZXksb3B0X25haXZlVXJpUmV3cml0ZXIpKTpcIlwiOnByb3BCaXRzJkNTU19QUk9QX0JJVF9RU1RSSU5HJiYhKHN0cmluZ0Rpc3Bvc2l0aW9uJnN0cmluZ0Rpc3Bvc2l0aW9uLTEpP3Rva2VuOlwiXCI6dG9rZW49PT1cImluaGVyaXRcIj90b2tlbjoobGl0R3JvdXA9cHJvcGVydHlTY2hlbWFbXCJjc3NMaXRHcm91cFwiXSxsaXRNYXA9bGl0R3JvdXA/cHJvcGVydHlTY2hlbWFbXCJjc3NMaXRNYXBcIl18fChwcm9wZXJ0eVNjaGVtYVtcImNzc0xpdE1hcFwiXT11bmlvbkFycmF5cyhsaXRHcm91cCkpOkFMTE9XRURfTElURVJBTCxsaXRNYXBbd2l0aG91dFZlbmRvclByZWZpeCh0b2tlbildPT09QUxMT1dFRF9MSVRFUkFMKT90b2tlbjpjYz09PVwiI1wiLmNoYXJDb2RlQXQoMCkmJi9eIyg/OlswLTlhLWZdezN9KXsxLDJ9JC8udGVzdCh0b2tlbik/cHJvcEJpdHMmQ1NTX1BST1BfQklUX0hBU0hfVkFMVUU/dG9rZW46XCJcIjpcIjBcIi5jaGFyQ29kZUF0KDApPD1jYyYmY2M8PVwiOVwiLmNoYXJDb2RlQXQoMCk/cHJvcEJpdHMmQ1NTX1BST1BfQklUX1FVQU5USVRZP3Rva2VuOlwiXCI6KGNjMT10b2tlbi5jaGFyQ29kZUF0KDEpLGNjMj10b2tlbi5jaGFyQ29kZUF0KDIpLGlzbnVtMT1cIjBcIi5jaGFyQ29kZUF0KDApPD1jYzEmJmNjMTw9XCI5XCIuY2hhckNvZGVBdCgwKSxpc251bTI9XCIwXCIuY2hhckNvZGVBdCgwKTw9Y2MyJiZjYzI8PVwiOVwiLmNoYXJDb2RlQXQoMCksY2M9PT1cIitcIi5jaGFyQ29kZUF0KDApJiYoaXNudW0xfHxjYzE9PT1cIi5cIi5jaGFyQ29kZUF0KDApJiZpc251bTIpKT9wcm9wQml0cyZDU1NfUFJPUF9CSVRfUVVBTlRJVFk/KGlzbnVtMT9cIlwiOlwiMFwiKSt0b2tlbi5zdWJzdHJpbmcoMSk6XCJcIjpjYz09PVwiLVwiLmNoYXJDb2RlQXQoMCkmJihpc251bTF8fGNjMT09PVwiLlwiLmNoYXJDb2RlQXQoMCkmJmlzbnVtMik/cHJvcEJpdHMmQ1NTX1BST1BfQklUX05FR0FUSVZFX1FVQU5USVRZPyhpc251bTE/XCItXCI6XCItMFwiKSt0b2tlbi5zdWJzdHJpbmcoMSk6cHJvcEJpdHMmQ1NTX1BST1BfQklUX1FVQU5USVRZP1wiMFwiOlwiXCI6Y2M9PT1cIi5cIi5jaGFyQ29kZUF0KDApJiZpc251bTE/cHJvcEJpdHMmQ1NTX1BST1BfQklUX1FVQU5USVRZP1wiMFwiK3Rva2VuOlwiXCI6J3VybChcIic9PT10b2tlbi5zdWJzdHJpbmcoMCw1KT9vcHRfbmFpdmVVcmlSZXdyaXRlciYmcHJvcEJpdHMmQ1NTX1BST1BfQklUX1VSTD9ub3JtYWxpemVVcmwoc2FmZVVyaShyZXNvbHZlVXJpKG9wdF9iYXNlVXJpLHRva2Vuc1tpXS5zdWJzdHJpbmcoNSx0b2tlbi5sZW5ndGgtMikpLHByb3BlcnR5S2V5LG9wdF9uYWl2ZVVyaVJld3JpdGVyKSk6XCJcIjp0b2tlbi5jaGFyQXQodG9rZW4ubGVuZ3RoLTEpPT09XCIoXCI/c2FuaXRpemVGdW5jdGlvbkNhbGwodG9rZW5zLGkpOmlkZW50RGlzcG9zaXRpb24mJi9eLT9bYS16X11bXFx3XFwtXSokLy50ZXN0KHRva2VuKSYmIS9fXyQvLnRlc3QodG9rZW4pP29wdF9pZFN1ZmZpeCYmaWRlbnREaXNwb3NpdGlvbj09PUNTU19QUk9QX0JJVF9HTE9CQUxfTkFNRT90b2tlbnNbaV0rb3B0X2lkU3VmZml4OmlkZW50RGlzcG9zaXRpb249PT1DU1NfUFJPUF9CSVRfUFJPUEVSVFlfTkFNRSYmY3NzU2NoZW1hW3Rva2VuXSYmXCJudW1iZXJcIj09PXR5cGVvZiBjc3NTY2hlbWFbdG9rZW5dLmNzc1Byb3BCaXRzP3Rva2VuOlwiXCI6L15cXHcrJC8udGVzdCh0b2tlbikmJnN0cmluZ0Rpc3Bvc2l0aW9uPT09Q1NTX1BST1BfQklUX1VOUkVTRVJWRURfV09SRCYmcHJvcEJpdHMmQ1NTX1BST1BfQklUX1FTVFJJTkc/bGFzdFF1b3RlZCsxPT09az8odG9rZW5zW2xhc3RRdW90ZWRdPXRva2Vuc1tsYXN0UXVvdGVkXS5zdWJzdHJpbmcoMCx0b2tlbnNbbGFzdFF1b3RlZF0ubGVuZ3RoLTEpK1wiIFwiK3Rva2VuKydcIicsdG9rZW49XCJcIik6KGxhc3RRdW90ZWQ9aywnXCInK3Rva2VuKydcIicpOlwiXCI7XG5pZih0b2tlbil7dG9rZW5zW2srK109dG9rZW59fWlmKGs9PT0xJiZ0b2tlbnNbMF09PT1OT0VGRkVDVF9VUkwpe2s9MH10b2tlbnMubGVuZ3RoPWt9fSgpO3ZhciBQU0VVRE9fU0VMRUNUT1JfV0hJVEVMSVNUPW5ldyBSZWdFeHAoXCJeKGFjdGl2ZXxhZnRlcnxiZWZvcmV8Ymxhbmt8Y2hlY2tlZHxkZWZhdWx0fGRpc2FibGVkXCIrXCJ8ZHJvcHxlbXB0eXxlbmFibGVkfGZpcnN0fGZpcnN0LWNoaWxkfGZpcnN0LWxldHRlclwiK1wifGZpcnN0LWxpbmV8Zmlyc3Qtb2YtdHlwZXxmdWxsc2NyZWVufGZvY3VzfGhvdmVyXCIrXCJ8aW4tcmFuZ2V8aW5kZXRlcm1pbmF0ZXxpbnZhbGlkfGxhc3QtY2hpbGR8bGFzdC1vZi10eXBlXCIrXCJ8bGVmdHxsaW5rfG9ubHktY2hpbGR8b25seS1vZi10eXBlfG9wdGlvbmFsfG91dC1vZi1yYW5nZVwiK1wifHBsYWNlaG9sZGVyLXNob3dufHJlYWQtb25seXxyZWFkLXdyaXRlfHJlcXVpcmVkfHJpZ2h0XCIrXCJ8cm9vdHxzY29wZXx1c2VyLWVycm9yfHZhbGlkfHZpc2l0ZWRcIitcIikkXCIpO3ZhciBDT01CSU5BVE9SPXt9O0NPTUJJTkFUT1JbXCI+XCJdPUNPTUJJTkFUT1JbXCIrXCJdPUNPTUJJTkFUT1JbXCJ+XCJdPUNPTUJJTkFUT1I7c2FuaXRpemVDc3NTZWxlY3Rvckxpc3Q9ZnVuY3Rpb24oc2VsZWN0b3JzLHZpcnR1YWxpemF0aW9uLG9wdF9vblVudHJhbnNsYXRhYmxlU2VsZWN0b3Ipe3ZhciBjb250YWluZXJDbGFzcz12aXJ0dWFsaXphdGlvbi5jb250YWluZXJDbGFzczt2YXIgaWRTdWZmaXg9dmlydHVhbGl6YXRpb24uaWRTdWZmaXg7dmFyIHRhZ1BvbGljeT12aXJ0dWFsaXphdGlvbi50YWdQb2xpY3k7dmFyIHNhbml0aXplZD1bXTt2YXIgaz0wLGksaW5CcmFja2V0cz0wLHRvaztmb3IoaT0wO2k8c2VsZWN0b3JzLmxlbmd0aDsrK2kpe3Rvaz1zZWxlY3RvcnNbaV07aWYodG9rPT1cIihcInx8dG9rPT1cIltcIj8oKytpbkJyYWNrZXRzLHRydWUpOnRvaz09XCIpXCJ8fHRvaz09XCJdXCI/KGluQnJhY2tldHMmJi0taW5CcmFja2V0cyx0cnVlKTohKHNlbGVjdG9yc1tpXT09XCIgXCImJihpbkJyYWNrZXRzfHxDT01CSU5BVE9SW3NlbGVjdG9yc1tpLTFdXT09PUNPTUJJTkFUT1J8fENPTUJJTkFUT1Jbc2VsZWN0b3JzW2krMV1dPT09Q09NQklOQVRPUikpKXtzZWxlY3RvcnNbaysrXT1zZWxlY3RvcnNbaV19fXNlbGVjdG9ycy5sZW5ndGg9azt2YXIgbj1zZWxlY3RvcnMubGVuZ3RoLHN0YXJ0PTA7Zm9yKGk9MDtpPG47KytpKXtpZihzZWxlY3RvcnNbaV09PT1cIixcIil7aWYoIXByb2Nlc3NDb21wbGV4U2VsZWN0b3Ioc3RhcnQsaSkpe3JldHVybiBudWxsfXN0YXJ0PWkrMX19aWYoIXByb2Nlc3NDb21wbGV4U2VsZWN0b3Ioc3RhcnQsbikpe3JldHVybiBudWxsfWZ1bmN0aW9uIHByb2Nlc3NDb21wbGV4U2VsZWN0b3Ioc3RhcnQsZW5kKXtpZihzZWxlY3RvcnNbc3RhcnRdPT09XCIgXCIpeysrc3RhcnR9aWYoZW5kLTEhPT1zdGFydCYmc2VsZWN0b3JzW2VuZF09PT1cIiBcIil7LS1lbmR9dmFyIG91dD1bXTt2YXIgbGFzdE9wZXJhdG9yPXN0YXJ0O3ZhciB2YWxpZD10cnVlO2Zvcih2YXIgaT1zdGFydDt2YWxpZCYmaTxlbmQ7KytpKXt2YXIgdG9rPXNlbGVjdG9yc1tpXTtpZihDT01CSU5BVE9SW3Rva109PT1DT01CSU5BVE9SfHx0b2s9PT1cIiBcIil7aWYoIXByb2Nlc3NDb21wb3VuZFNlbGVjdG9yKGxhc3RPcGVyYXRvcixpLHRvaykpe3ZhbGlkPWZhbHNlfWVsc2V7bGFzdE9wZXJhdG9yPWkrMX19fWlmKCFwcm9jZXNzQ29tcG91bmRTZWxlY3RvcihsYXN0T3BlcmF0b3IsZW5kLFwiXCIpKXt2YWxpZD1mYWxzZX1mdW5jdGlvbiBwcm9jZXNzQ29tcG91bmRTZWxlY3RvcihzdGFydCxlbmQsY29tYmluYXRvcil7dmFyIGVsZW1lbnQsY2xhc3NJZCxhdHRycyxwc2V1ZG9TZWxlY3Rvcix0b2ssdmFsaWQ9dHJ1ZTtlbGVtZW50PVwiXCI7aWYoc3RhcnQ8ZW5kKXt0b2s9c2VsZWN0b3JzW3N0YXJ0XTtpZih0b2s9PT1cIipcIil7KytzdGFydDtlbGVtZW50PXRva31lbHNlIGlmKC9eW2EtekEtWl0vLnRlc3QodG9rKSl7dmFyIGRlY2lzaW9uPXRhZ1BvbGljeSh0b2sudG9Mb3dlckNhc2UoKSxbXSk7aWYoZGVjaXNpb24pe2lmKFwidGFnTmFtZVwiaW4gZGVjaXNpb24pe3Rvaz1kZWNpc2lvbltcInRhZ05hbWVcIl19KytzdGFydDtlbGVtZW50PXRva319fWNsYXNzSWQ9XCJcIjthdHRycz1cIlwiO3BzZXVkb1NlbGVjdG9yPVwiXCI7Zm9yKDt2YWxpZCYmc3RhcnQ8ZW5kOysrc3RhcnQpe3Rvaz1zZWxlY3RvcnNbc3RhcnRdO2lmKHRvay5jaGFyQXQoMCk9PT1cIiNcIil7aWYoL14jX3xfXyR8W15cXHcjOlxcLV0vLnRlc3QodG9rKSl7dmFsaWQ9ZmFsc2V9ZWxzZXtjbGFzc0lkKz10b2sraWRTdWZmaXh9fWVsc2UgaWYodG9rPT09XCIuXCIpe2lmKCsrc3RhcnQ8ZW5kJiYvXlswLTlBLVphLXo6X1xcLV0rJC8udGVzdCh0b2s9c2VsZWN0b3JzW3N0YXJ0XSkmJiEvXl98X18kLy50ZXN0KHRvaykpe2NsYXNzSWQrPVwiLlwiK3Rva31lbHNle3ZhbGlkPWZhbHNlfX1lbHNlIGlmKHN0YXJ0KzE8ZW5kJiZzZWxlY3RvcnNbc3RhcnRdPT09XCJbXCIpeysrc3RhcnQ7dmFyIHZBdHRyPXNlbGVjdG9yc1tzdGFydCsrXS50b0xvd2VyQ2FzZSgpO3ZhciBhdHlwZT1odG1sNC5BVFRSSUJTW2VsZW1lbnQrXCI6OlwiK3ZBdHRyXTtpZihhdHlwZSE9PSthdHlwZSl7YXR5cGU9aHRtbDQuQVRUUklCU1tcIio6OlwiK3ZBdHRyXX12YXIgckF0dHI7aWYodmlydHVhbGl6YXRpb24udmlydHVhbGl6ZUF0dHJOYW1lKXtyQXR0cj12aXJ0dWFsaXphdGlvbi52aXJ0dWFsaXplQXR0ck5hbWUoZWxlbWVudCx2QXR0cik7aWYodHlwZW9mIHJBdHRyIT09XCJzdHJpbmdcIil7dmFsaWQ9ZmFsc2U7ckF0dHI9dkF0dHJ9aWYodmFsaWQmJmF0eXBlIT09K2F0eXBlKXthdHlwZT1odG1sNC5hdHlwZVtcIk5PTkVcIl19fWVsc2V7ckF0dHI9dkF0dHI7aWYoYXR5cGUhPT0rYXR5cGUpe3ZhbGlkPWZhbHNlfX12YXIgb3A9XCJcIix2YWx1ZT1cIlwiLGlnbm9yZUNhc2U9ZmFsc2U7aWYoL15bfl4kKnxdPz0kLy50ZXN0KHNlbGVjdG9yc1tzdGFydF0pKXtvcD1zZWxlY3RvcnNbc3RhcnQrK107dmFsdWU9c2VsZWN0b3JzW3N0YXJ0KytdO2lmKC9eWzAtOUEtWmEtejpfXFwtXSskLy50ZXN0KHZhbHVlKSl7dmFsdWU9J1wiJyt2YWx1ZSsnXCInfWVsc2UgaWYodmFsdWU9PT1cIl1cIil7dmFsdWU9J1wiXCInOy0tc3RhcnR9aWYoIS9eXCIoW15cXFwiXFxcXF18XFxcXC4pKlwiJC8udGVzdCh2YWx1ZSkpe3ZhbGlkPWZhbHNlfWlnbm9yZUNhc2U9c2VsZWN0b3JzW3N0YXJ0XT09PVwiaVwiO2lmKGlnbm9yZUNhc2Upeysrc3RhcnR9fWlmKHNlbGVjdG9yc1tzdGFydF0hPT1cIl1cIil7KytzdGFydDt2YWxpZD1mYWxzZX1zd2l0Y2goYXR5cGUpe2Nhc2UgaHRtbDQuYXR5cGVbXCJDTEFTU0VTXCJdOmNhc2UgaHRtbDQuYXR5cGVbXCJMT0NBTF9OQU1FXCJdOmNhc2UgaHRtbDQuYXR5cGVbXCJOT05FXCJdOmJyZWFrO2Nhc2UgaHRtbDQuYXR5cGVbXCJHTE9CQUxfTkFNRVwiXTpjYXNlIGh0bWw0LmF0eXBlW1wiSURcIl06Y2FzZSBodG1sNC5hdHlwZVtcIklEUkVGXCJdOmlmKChvcD09PVwiPVwifHxvcD09PVwifj1cInx8b3A9PT1cIiQ9XCIpJiZ2YWx1ZSE9J1wiXCInJiYhaWdub3JlQ2FzZSl7dmFsdWU9J1wiJyt2YWx1ZS5zdWJzdHJpbmcoMSx2YWx1ZS5sZW5ndGgtMSkraWRTdWZmaXgrJ1wiJ31lbHNlIGlmKG9wPT09XCJ8PVwifHxvcD09PVwiXCIpe31lbHNle3ZhbGlkPWZhbHNlfWJyZWFrO2Nhc2UgaHRtbDQuYXR5cGVbXCJVUklcIl06Y2FzZSBodG1sNC5hdHlwZVtcIlVSSV9GUkFHTUVOVFwiXTppZihvcCE9PVwiXCIpe3ZhbGlkPWZhbHNlfWJyZWFrO2RlZmF1bHQ6dmFsaWQ9ZmFsc2V9aWYodmFsaWQpe2F0dHJzKz1cIltcIityQXR0ci5yZXBsYWNlKC9bXlxcdy1dL2csXCJcXFxcJCZcIikrb3ArdmFsdWUrKGlnbm9yZUNhc2U/XCIgaV1cIjpcIl1cIil9fWVsc2UgaWYoc3RhcnQ8ZW5kJiZzZWxlY3RvcnNbc3RhcnRdPT09XCI6XCIpe3Rvaz1zZWxlY3RvcnNbKytzdGFydF07aWYoUFNFVURPX1NFTEVDVE9SX1dISVRFTElTVC50ZXN0KHRvaykpe3BzZXVkb1NlbGVjdG9yKz1cIjpcIit0b2t9ZWxzZXticmVha319ZWxzZXticmVha319aWYoc3RhcnQhPT1lbmQpe3ZhbGlkPWZhbHNlfWlmKHZhbGlkKXt2YXIgc2VsZWN0b3I9KGVsZW1lbnQrY2xhc3NJZCkucmVwbGFjZSgvW14gLiojXFx3LV0vZyxcIlxcXFwkJlwiKSthdHRycytwc2V1ZG9TZWxlY3Rvcitjb21iaW5hdG9yO2lmKHNlbGVjdG9yKXtvdXQucHVzaChzZWxlY3Rvcil9fXJldHVybiB2YWxpZH1pZih2YWxpZCl7aWYob3V0Lmxlbmd0aCl7dmFyIHNhZmVTZWxlY3Rvcj1vdXQuam9pbihcIlwiKTtpZihjb250YWluZXJDbGFzcyE9PW51bGwpe3NhZmVTZWxlY3Rvcj1cIi5cIitjb250YWluZXJDbGFzcytcIiBcIitzYWZlU2VsZWN0b3J9c2FuaXRpemVkLnB1c2goc2FmZVNlbGVjdG9yKX1yZXR1cm4gdHJ1ZX1lbHNle3JldHVybiFvcHRfb25VbnRyYW5zbGF0YWJsZVNlbGVjdG9yfHxvcHRfb25VbnRyYW5zbGF0YWJsZVNlbGVjdG9yKHNlbGVjdG9ycy5zbGljZShzdGFydCxlbmQpKX19cmV0dXJuIHNhbml0aXplZH07KGZ1bmN0aW9uKCl7dmFyIE1FRElBX1RZUEU9XCIoPzpcIitcImFsbHxhdXJhbHxicmFpbGxlfGVtYm9zc2VkfGhhbmRoZWxkfHByaW50XCIrXCJ8cHJvamVjdGlvbnxzY3JlZW58c3BlZWNofHR0eXx0dlwiK1wiKVwiO3ZhciBNRURJQV9GRUFUVVJFPVwiKD86XCIrXCIoPzptaW4tfG1heC0pP1wiK1wiKD86XCIrKFwiKD86ZGV2aWNlLSk/XCIrXCIoPzphc3BlY3QtcmF0aW98aGVpZ2h0fHdpZHRoKVwiK1wifGNvbG9yKD86LWluZGV4KT9cIitcInxtb25vY2hyb21lXCIrXCJ8b3JpZW50YXRpb25cIitcInxyZXNvbHV0aW9uXCIpK1wiKVwiK1wifGdyaWRcIitcInxob3ZlclwiK1wifGx1bWlub3NpdHlcIitcInxwb2ludGVyXCIrXCJ8c2NhblwiK1wifHNjcmlwdFwiK1wiKVwiO3ZhciBMRU5HVEhfVU5JVD1cIig/OnBbY3h0XXxbY2VtXW18aW58ZHBpfGRwcHh8ZHBjbXwlKVwiO3ZhciBDU1NfVkFMVUU9XCItPyg/OlwiK1wiW2Etel1cXFxcdysoPzotXFxcXHcrKSpcIitcInxcXFxcZCsoPzogLyBcXFxcZCt8KD86XFxcXC5cXFxcZCspP1wiK0xFTkdUSF9VTklUK1wiPylcIitcIilcIjt2YXIgTUVESUFfRVhQUj1cIlxcXFwoIFwiK01FRElBX0ZFQVRVUkUrXCIgKD86XCIrXCI6IFwiK0NTU19WQUxVRStcIiApP1xcXFwpXCI7dmFyIE1FRElBX1FVRVJZPVwiKD86XCIrXCIoPzooPzooPzpvbmx5fG5vdCkgKT9cIitNRURJQV9UWVBFK1wifFwiK01FRElBX0VYUFIrXCIpXCIrXCIoPzogYW5kID9cIitNRURJQV9FWFBSK1wiKSpcIitcIilcIjt2YXIgU1RBUlRTX1dJVEhfS0VZV09SRF9SRUdFWFA9L15cXHcvO3ZhciBNRURJQV9RVUVSWV9MSVNUX1JFR0VYUD1uZXcgUmVnRXhwKFwiXlwiK01FRElBX1FVRVJZK1wiKD86ICwgXCIrTUVESUFfUVVFUlkrXCIpKlwiK1wiJFwiLFwiaVwiKTtzYW5pdGl6ZU1lZGlhUXVlcnk9ZnVuY3Rpb24oY3NzVG9rZW5zKXtjc3NUb2tlbnM9Y3NzVG9rZW5zLnNsaWNlKCk7dmFyIG5Ub2tlbnM9Y3NzVG9rZW5zLmxlbmd0aCxrPTA7Zm9yKHZhciBpPTA7aTxuVG9rZW5zOysraSl7dmFyIHRvaz1jc3NUb2tlbnNbaV07aWYodG9rIT1cIiBcIil7Y3NzVG9rZW5zW2srK109dG9rfX1jc3NUb2tlbnMubGVuZ3RoPWs7dmFyIGNzcz1jc3NUb2tlbnMuam9pbihcIiBcIik7Y3NzPSFjc3MubGVuZ3RoP1wiXCI6IU1FRElBX1FVRVJZX0xJU1RfUkVHRVhQLnRlc3QoY3NzKT9cIm5vdCBhbGxcIjpTVEFSVFNfV0lUSF9LRVlXT1JEX1JFR0VYUC50ZXN0KGNzcyk/Y3NzOlwibm90IGFsbCAsIFwiK2NzcztyZXR1cm4gY3NzfX0pKCk7KGZ1bmN0aW9uKCl7ZnVuY3Rpb24gY3NzUGFyc2VVcmkoY2FuZGlkYXRlKXt2YXIgc3RyaW5nMT0vXlxccypbXCJdKFteXCJdKilbXCJdXFxzKiQvO3ZhciBzdHJpbmcyPS9eXFxzKlsnXShbXiddKilbJ11cXHMqJC87dmFyIHVybDE9L15cXHMqdXJsXFxzKlsoXVtcIl0oW15cIl0qKVtcIl1bKV1cXHMqJC87dmFyIHVybDI9L15cXHMqdXJsXFxzKlsoXVsnXShbXiddKilbJ11bKV1cXHMqJC87dmFyIHVybDM9L15cXHMqdXJsXFxzKlsoXShbXildKilbKV1cXHMqJC87dmFyIG1hdGNoO2lmKG1hdGNoPXN0cmluZzEuZXhlYyhjYW5kaWRhdGUpKXtyZXR1cm4gbWF0Y2hbMV19ZWxzZSBpZihtYXRjaD1zdHJpbmcyLmV4ZWMoY2FuZGlkYXRlKSl7cmV0dXJuIG1hdGNoWzFdfWVsc2UgaWYobWF0Y2g9dXJsMS5leGVjKGNhbmRpZGF0ZSkpe3JldHVybiBtYXRjaFsxXX1lbHNlIGlmKG1hdGNoPXVybDIuZXhlYyhjYW5kaWRhdGUpKXtyZXR1cm4gbWF0Y2hbMV19ZWxzZSBpZihtYXRjaD11cmwzLmV4ZWMoY2FuZGlkYXRlKSl7cmV0dXJuIG1hdGNoWzFdfXJldHVybiBudWxsfWZ1bmN0aW9uIHNhbml0aXplU3R5bGVzaGVldEludGVybmFsKGJhc2VVcmksY3NzVGV4dCx2aXJ0dWFsaXphdGlvbixuYWl2ZVVyaVJld3JpdGVyLG5haXZlVXJpRmV0Y2hlcixjb250aW51YXRpb24sb3B0X2ltcG9ydENvdW50KXt2YXIgc2FmZUNzcz12b2lkIDA7dmFyIGltcG9ydENvdW50PW9wdF9pbXBvcnRDb3VudHx8WzBdO3ZhciBibG9ja1N0YWNrPVtdO3ZhciBlbGlkZT1mYWxzZTtwYXJzZUNzc1N0eWxlc2hlZXQoY3NzVGV4dCx7c3RhcnRTdHlsZXNoZWV0OmZ1bmN0aW9uKCl7c2FmZUNzcz1bXX0sZW5kU3R5bGVzaGVldDpmdW5jdGlvbigpe30sc3RhcnRBdHJ1bGU6ZnVuY3Rpb24oYXRJZGVudCxoZWFkZXJBcnJheSl7aWYoZWxpZGUpe2F0SWRlbnQ9bnVsbH1lbHNlIGlmKGF0SWRlbnQ9PT1cIkBtZWRpYVwiKXtzYWZlQ3NzLnB1c2goXCJAbWVkaWFcIixcIiBcIixzYW5pdGl6ZU1lZGlhUXVlcnkoaGVhZGVyQXJyYXkpKX1lbHNlIGlmKGF0SWRlbnQ9PT1cIkBrZXlmcmFtZXNcInx8YXRJZGVudD09PVwiQC13ZWJraXQta2V5ZnJhbWVzXCIpe3ZhciBhbmltYXRpb25JZD1oZWFkZXJBcnJheVswXTtpZihoZWFkZXJBcnJheS5sZW5ndGg9PT0xJiYhL19fJHxbXlxcd1xcLV0vLnRlc3QoYW5pbWF0aW9uSWQpKXtzYWZlQ3NzLnB1c2goYXRJZGVudCxcIiBcIixhbmltYXRpb25JZCt2aXJ0dWFsaXphdGlvbi5pZFN1ZmZpeCk7YXRJZGVudD1cIkBrZXlmcmFtZXNcIn1lbHNle2F0SWRlbnQ9bnVsbH19ZWxzZXtpZihhdElkZW50PT09XCJAaW1wb3J0XCImJmhlYWRlckFycmF5Lmxlbmd0aD4wKXthdElkZW50PW51bGw7aWYoXCJmdW5jdGlvblwiPT09dHlwZW9mIGNvbnRpbnVhdGlvbil7dmFyIG1lZGlhUXVlcnk9c2FuaXRpemVNZWRpYVF1ZXJ5KGhlYWRlckFycmF5LnNsaWNlKDEpKTtpZihtZWRpYVF1ZXJ5IT09XCJub3QgYWxsXCIpeysraW1wb3J0Q291bnRbMF07dmFyIHBsYWNlaG9sZGVyPVtdO3NhZmVDc3MucHVzaChwbGFjZWhvbGRlcik7dmFyIGNzc1VybD1zYWZlVXJpKHJlc29sdmVVcmkoYmFzZVVyaSxjc3NQYXJzZVVyaShoZWFkZXJBcnJheVswXSkpLGZ1bmN0aW9uKHJlc3VsdCl7dmFyIHNhbml0aXplZD1zYW5pdGl6ZVN0eWxlc2hlZXRJbnRlcm5hbChjc3NVcmwscmVzdWx0Lmh0bWwsdmlydHVhbGl6YXRpb24sbmFpdmVVcmlSZXdyaXRlcixuYWl2ZVVyaUZldGNoZXIsY29udGludWF0aW9uLGltcG9ydENvdW50KTstLWltcG9ydENvdW50WzBdO3ZhciBzYWZlSW1wb3J0ZWRDc3M9bWVkaWFRdWVyeT97dG9TdHJpbmc6ZnVuY3Rpb24oKXtyZXR1cm5cIkBtZWRpYSBcIittZWRpYVF1ZXJ5K1wiIHtcIitzYW5pdGl6ZWQucmVzdWx0K1wifVwifX06c2FuaXRpemVkLnJlc3VsdDtwbGFjZWhvbGRlclswXT1zYWZlSW1wb3J0ZWRDc3M7Y29udGludWF0aW9uKHNhZmVJbXBvcnRlZENzcywhIWltcG9ydENvdW50WzBdKX0sbmFpdmVVcmlGZXRjaGVyKX19ZWxzZXtpZih3aW5kb3cuY29uc29sZSl7d2luZG93LmNvbnNvbGUubG9nKFwiQGltcG9ydCBcIitoZWFkZXJBcnJheS5qb2luKFwiIFwiKStcIiBlbGlkZWRcIil9fX19ZWxpZGU9IWF0SWRlbnQ7YmxvY2tTdGFjay5wdXNoKGF0SWRlbnQpfSxlbmRBdHJ1bGU6ZnVuY3Rpb24oKXtibG9ja1N0YWNrLnBvcCgpO2lmKCFlbGlkZSl7c2FmZUNzcy5wdXNoKFwiO1wiKX1jaGVja0VsaWRlKCl9LHN0YXJ0QmxvY2s6ZnVuY3Rpb24oKXtpZighZWxpZGUpe3NhZmVDc3MucHVzaChcIntcIil9fSxlbmRCbG9jazpmdW5jdGlvbigpe2lmKCFlbGlkZSl7c2FmZUNzcy5wdXNoKFwifVwiKTtlbGlkZT10cnVlfX0sc3RhcnRSdWxlc2V0OmZ1bmN0aW9uKHNlbGVjdG9yQXJyYXkpe2lmKCFlbGlkZSl7dmFyIHNlbGVjdG9yPXZvaWQgMDtpZihibG9ja1N0YWNrW2Jsb2NrU3RhY2subGVuZ3RoLTFdPT09XCJAa2V5ZnJhbWVzXCIpe3NlbGVjdG9yPXNlbGVjdG9yQXJyYXkuam9pbihcIiBcIikubWF0Y2goL14gKig/OmZyb218dG98XFxkKyg/OlxcLlxcZCspPyUpICooPzosICooPzpmcm9tfHRvfFxcZCsoPzpcXC5cXGQrKT8lKSAqKSokL2kpO2VsaWRlPSFzZWxlY3RvcjtpZihzZWxlY3Rvcil7c2VsZWN0b3I9c2VsZWN0b3JbMF0ucmVwbGFjZSgvICsvZyxcIlwiKX19ZWxzZXt2YXIgc2VsZWN0b3JzPXNhbml0aXplQ3NzU2VsZWN0b3JMaXN0KHNlbGVjdG9yQXJyYXksdmlydHVhbGl6YXRpb24pO2lmKCFzZWxlY3RvcnN8fCFzZWxlY3RvcnMubGVuZ3RoKXtlbGlkZT10cnVlfWVsc2V7c2VsZWN0b3I9c2VsZWN0b3JzLmpvaW4oXCIsIFwiKX19aWYoIWVsaWRlKXtzYWZlQ3NzLnB1c2goc2VsZWN0b3IsXCJ7XCIpfX1ibG9ja1N0YWNrLnB1c2gobnVsbCl9LGVuZFJ1bGVzZXQ6ZnVuY3Rpb24oKXtibG9ja1N0YWNrLnBvcCgpO2lmKCFlbGlkZSl7c2FmZUNzcy5wdXNoKFwifVwiKX1jaGVja0VsaWRlKCl9LGRlY2xhcmF0aW9uOmZ1bmN0aW9uKHByb3BlcnR5LHZhbHVlQXJyYXkpe2lmKCFlbGlkZSl7dmFyIGlzSW1wb3J0YW50PWZhbHNlO3ZhciBuVmFsdWVzPXZhbHVlQXJyYXkubGVuZ3RoO2lmKG5WYWx1ZXM+PTImJnZhbHVlQXJyYXlbblZhbHVlcy0yXT09PVwiIVwiJiZ2YWx1ZUFycmF5W25WYWx1ZXMtMV0udG9Mb3dlckNhc2UoKT09PVwiaW1wb3J0YW50XCIpe2lzSW1wb3J0YW50PXRydWU7dmFsdWVBcnJheS5sZW5ndGgtPTJ9c2FuaXRpemVDc3NQcm9wZXJ0eShwcm9wZXJ0eSx2YWx1ZUFycmF5LG5haXZlVXJpUmV3cml0ZXIsYmFzZVVyaSx2aXJ0dWFsaXphdGlvbi5pZFN1ZmZpeCk7aWYodmFsdWVBcnJheS5sZW5ndGgpe3NhZmVDc3MucHVzaChwcm9wZXJ0eSxcIjpcIix2YWx1ZUFycmF5LmpvaW4oXCIgXCIpLGlzSW1wb3J0YW50P1wiICFpbXBvcnRhbnQ7XCI6XCI7XCIpfX19fSk7ZnVuY3Rpb24gY2hlY2tFbGlkZSgpe2VsaWRlPWJsb2NrU3RhY2subGVuZ3RoJiZibG9ja1N0YWNrW2Jsb2NrU3RhY2subGVuZ3RoLTFdPT09bnVsbH1yZXR1cm57cmVzdWx0Ont0b1N0cmluZzpmdW5jdGlvbigpe3JldHVybiBzYWZlQ3NzLmpvaW4oXCJcIil9fSxtb3JlVG9Db21lOiEhaW1wb3J0Q291bnRbMF19fXNhbml0aXplU3R5bGVzaGVldD1mdW5jdGlvbihiYXNlVXJpLGNzc1RleHQsdmlydHVhbGl6YXRpb24sbmFpdmVVcmlSZXdyaXRlcil7cmV0dXJuIHNhbml0aXplU3R5bGVzaGVldEludGVybmFsKGJhc2VVcmksY3NzVGV4dCx2aXJ0dWFsaXphdGlvbixuYWl2ZVVyaVJld3JpdGVyLHVuZGVmaW5lZCx1bmRlZmluZWQpLnJlc3VsdC50b1N0cmluZygpfTtzYW5pdGl6ZVN0eWxlc2hlZXRXaXRoRXh0ZXJuYWxzPWZ1bmN0aW9uKGJhc2VVcmksY3NzVGV4dCx2aXJ0dWFsaXphdGlvbixuYWl2ZVVyaVJld3JpdGVyLG5haXZlVXJpRmV0Y2hlcixjb250aW51YXRpb24pe3JldHVybiBzYW5pdGl6ZVN0eWxlc2hlZXRJbnRlcm5hbChiYXNlVXJpLGNzc1RleHQsdmlydHVhbGl6YXRpb24sbmFpdmVVcmlSZXdyaXRlcixuYWl2ZVVyaUZldGNoZXIsY29udGludWF0aW9uKX19KSgpfSkoKTtpZih0eXBlb2Ygd2luZG93IT09XCJ1bmRlZmluZWRcIil7d2luZG93W1wic2FuaXRpemVDc3NQcm9wZXJ0eVwiXT1zYW5pdGl6ZUNzc1Byb3BlcnR5O3dpbmRvd1tcInNhbml0aXplQ3NzU2VsZWN0b3JMaXN0XCJdPXNhbml0aXplQ3NzU2VsZWN0b3JMaXN0O3dpbmRvd1tcInNhbml0aXplU3R5bGVzaGVldFwiXT1zYW5pdGl6ZVN0eWxlc2hlZXQ7d2luZG93W1wic2FuaXRpemVNZWRpYVF1ZXJ5XCJdPXNhbml0aXplTWVkaWFRdWVyeX1pZihcIklcIi50b0xvd2VyQ2FzZSgpIT09XCJpXCIpe3Rocm93XCJJL2kgcHJvYmxlbVwifXZhciBwYXJzZUNzc1N0eWxlc2hlZXQ7dmFyIHBhcnNlQ3NzRGVjbGFyYXRpb25zOyhmdW5jdGlvbigpe3BhcnNlQ3NzU3R5bGVzaGVldD1mdW5jdGlvbihjc3NUZXh0LGhhbmRsZXIpe3ZhciB0b2tzPWxleENzcyhjc3NUZXh0KTtpZihoYW5kbGVyW1wic3RhcnRTdHlsZXNoZWV0XCJdKXtoYW5kbGVyW1wic3RhcnRTdHlsZXNoZWV0XCJdKCl9Zm9yKHZhciBpPTAsbj10b2tzLmxlbmd0aDtpPG47KXtpPXRva3NbaV09PT1cIiBcIj9pKzE6c3RhdGVtZW50KHRva3MsaSxuLGhhbmRsZXIpfWlmKGhhbmRsZXJbXCJlbmRTdHlsZXNoZWV0XCJdKXtoYW5kbGVyW1wiZW5kU3R5bGVzaGVldFwiXSgpfX07ZnVuY3Rpb24gc3RhdGVtZW50KHRva3MsaSxuLGhhbmRsZXIpe2lmKGk8bil7dmFyIHRvaz10b2tzW2ldO2lmKHRvay5jaGFyQXQoMCk9PT1cIkBcIil7cmV0dXJuIGF0cnVsZSh0b2tzLGksbixoYW5kbGVyLHRydWUpfWVsc2V7cmV0dXJuIHJ1bGVzZXQodG9rcyxpLG4saGFuZGxlcil9fWVsc2V7cmV0dXJuIGl9fWZ1bmN0aW9uIGF0cnVsZSh0b2tzLGksbixoYW5kbGVyLGJsb2Nrb2spe3ZhciBzdGFydD1pKys7d2hpbGUoaTxuJiZ0b2tzW2ldIT09XCJ7XCImJnRva3NbaV0hPT1cIjtcIil7KytpfWlmKGk8biYmKGJsb2Nrb2t8fHRva3NbaV09PT1cIjtcIikpe3ZhciBzPXN0YXJ0KzEsZT1pO2lmKHM8biYmdG9rc1tzXT09PVwiIFwiKXsrK3N9aWYoZT5zJiZ0b2tzW2UtMV09PT1cIiBcIil7LS1lfWlmKGhhbmRsZXJbXCJzdGFydEF0cnVsZVwiXSl7aGFuZGxlcltcInN0YXJ0QXRydWxlXCJdKHRva3Nbc3RhcnRdLnRvTG93ZXJDYXNlKCksdG9rcy5zbGljZShzLGUpKX1pPXRva3NbaV09PT1cIntcIj9ibG9jayh0b2tzLGksbixoYW5kbGVyKTppKzE7aWYoaGFuZGxlcltcImVuZEF0cnVsZVwiXSl7aGFuZGxlcltcImVuZEF0cnVsZVwiXSgpfX1yZXR1cm4gaX1mdW5jdGlvbiBibG9jayh0b2tzLGksbixoYW5kbGVyKXsrK2k7aWYoaGFuZGxlcltcInN0YXJ0QmxvY2tcIl0pe2hhbmRsZXJbXCJzdGFydEJsb2NrXCJdKCl9d2hpbGUoaTxuKXt2YXIgY2g9dG9rc1tpXS5jaGFyQXQoMCk7aWYoY2g9PVwifVwiKXsrK2k7YnJlYWt9aWYoY2g9PT1cIiBcInx8Y2g9PT1cIjtcIil7aT1pKzF9ZWxzZSBpZihjaD09PVwiQFwiKXtpPWF0cnVsZSh0b2tzLGksbixoYW5kbGVyLGZhbHNlKX1lbHNlIGlmKGNoPT09XCJ7XCIpe2k9YmxvY2sodG9rcyxpLG4saGFuZGxlcil9ZWxzZXtpPXJ1bGVzZXQodG9rcyxpLG4saGFuZGxlcil9fWlmKGhhbmRsZXJbXCJlbmRCbG9ja1wiXSl7aGFuZGxlcltcImVuZEJsb2NrXCJdKCl9cmV0dXJuIGl9ZnVuY3Rpb24gcnVsZXNldCh0b2tzLGksbixoYW5kbGVyKXt2YXIgcz1pLGU9c2VsZWN0b3IodG9rcyxpLG4sdHJ1ZSk7aWYoZTwwKXtlPX5lO3JldHVybiBlPT09cz9lKzE6ZX12YXIgdG9rPXRva3NbZV07aWYodG9rIT09XCJ7XCIpe3JldHVybiBlPT09cz9lKzE6ZX1pPWUrMTtpZihlPnMmJnRva3NbZS0xXT09PVwiIFwiKXstLWV9aWYoaGFuZGxlcltcInN0YXJ0UnVsZXNldFwiXSl7aGFuZGxlcltcInN0YXJ0UnVsZXNldFwiXSh0b2tzLnNsaWNlKHMsZSkpfXdoaWxlKGk8bil7dG9rPXRva3NbaV07aWYodG9rPT09XCJ9XCIpeysraTticmVha31pZih0b2s9PT1cIiBcIil7aT1pKzF9ZWxzZXtpPWRlY2xhcmF0aW9uKHRva3MsaSxuLGhhbmRsZXIpfX1pZihoYW5kbGVyW1wiZW5kUnVsZXNldFwiXSl7aGFuZGxlcltcImVuZFJ1bGVzZXRcIl0oKX1yZXR1cm4gaX1mdW5jdGlvbiBzZWxlY3Rvcih0b2tzLGksbixhbGxvd1NlbWkpe3ZhciBzPWk7dmFyIHRvazt2YXIgYnJhY2tldHM9W10sc3RhY2tMYXN0PS0xO2Zvcig7aTxuOysraSl7dG9rPXRva3NbaV0uY2hhckF0KDApO2lmKHRvaz09PVwiW1wifHx0b2s9PT1cIihcIil7YnJhY2tldHNbKytzdGFja0xhc3RdPXRva31lbHNlIGlmKHRvaz09PVwiXVwiJiZicmFja2V0c1tzdGFja0xhc3RdPT09XCJbXCJ8fHRvaz09PVwiKVwiJiZicmFja2V0c1tzdGFja0xhc3RdPT09XCIoXCIpey0tc3RhY2tMYXN0fWVsc2UgaWYodG9rPT09XCJ7XCJ8fHRvaz09PVwifVwifHx0b2s9PT1cIjtcInx8dG9rPT09XCJAXCJ8fHRvaz09PVwiOlwiJiYhYWxsb3dTZW1pKXticmVha319aWYoc3RhY2tMYXN0Pj0wKXtpPX4oaSsxKX1yZXR1cm4gaX12YXIgaWRlbnQ9L14tP1thLXpdL2k7ZnVuY3Rpb24gc2tpcERlY2xhcmF0aW9uKHRva3MsaSxuKXt3aGlsZShpPG4mJnRva3NbaV0hPT1cIjtcIiYmdG9rc1tpXSE9PVwifVwiKXsrK2l9cmV0dXJuIGk8biYmdG9rc1tpXT09PVwiO1wiP2krMTppfWZ1bmN0aW9uIGRlY2xhcmF0aW9uKHRva3MsaSxuLGhhbmRsZXIpe3ZhciBwcm9wZXJ0eT10b2tzW2krK107aWYoIWlkZW50LnRlc3QocHJvcGVydHkpKXtyZXR1cm4gc2tpcERlY2xhcmF0aW9uKHRva3MsaSxuKX12YXIgdG9rO2lmKGk8biYmdG9rc1tpXT09PVwiIFwiKXsrK2l9aWYoaT09bnx8dG9rc1tpXSE9PVwiOlwiKXtyZXR1cm4gc2tpcERlY2xhcmF0aW9uKHRva3MsaSxuKX0rK2k7aWYoaTxuJiZ0b2tzW2ldPT09XCIgXCIpeysraX12YXIgcz1pLGU9c2VsZWN0b3IodG9rcyxpLG4sZmFsc2UpO2lmKGU8MCl7ZT1+ZX1lbHNle3ZhciB2YWx1ZT1bXSx2YWx1ZWxlbj0wO2Zvcih2YXIgaj1zO2o8ZTsrK2ope3Rvaz10b2tzW2pdO2lmKHRvayE9PVwiIFwiKXt2YWx1ZVt2YWx1ZWxlbisrXT10b2t9fWlmKGU8bil7ZG97dG9rPXRva3NbZV07aWYodG9rPT09XCI7XCJ8fHRvaz09PVwifVwiKXticmVha312YWx1ZWxlbj0wfXdoaWxlKCsrZTxuKTtpZih0b2s9PT1cIjtcIil7KytlfX1pZih2YWx1ZWxlbiYmaGFuZGxlcltcImRlY2xhcmF0aW9uXCJdKXtoYW5kbGVyW1wiZGVjbGFyYXRpb25cIl0ocHJvcGVydHkudG9Mb3dlckNhc2UoKSx2YWx1ZSl9fXJldHVybiBlfXBhcnNlQ3NzRGVjbGFyYXRpb25zPWZ1bmN0aW9uKGNzc1RleHQsaGFuZGxlcil7dmFyIHRva3M9bGV4Q3NzKGNzc1RleHQpO2Zvcih2YXIgaT0wLG49dG9rcy5sZW5ndGg7aTxuOyl7aT10b2tzW2ldIT09XCIgXCI/ZGVjbGFyYXRpb24odG9rcyxpLG4saGFuZGxlcik6aSsxfX19KSgpO2lmKHR5cGVvZiB3aW5kb3chPT1cInVuZGVmaW5lZFwiKXt3aW5kb3dbXCJwYXJzZUNzc1N0eWxlc2hlZXRcIl09cGFyc2VDc3NTdHlsZXNoZWV0O3dpbmRvd1tcInBhcnNlQ3NzRGVjbGFyYXRpb25zXCJdPXBhcnNlQ3NzRGVjbGFyYXRpb25zfXZhciBodG1sND17fTtodG1sNC5hdHlwZT17Tk9ORTowLFVSSToxLFVSSV9GUkFHTUVOVDoxMSxTQ1JJUFQ6MixTVFlMRTozLEhUTUw6MTIsSUQ6NCxJRFJFRjo1LElEUkVGUzo2LEdMT0JBTF9OQU1FOjcsTE9DQUxfTkFNRTo4LENMQVNTRVM6OSxGUkFNRV9UQVJHRVQ6MTAsTUVESUFfUVVFUlk6MTN9O2h0bWw0W1wiYXR5cGVcIl09aHRtbDQuYXR5cGU7aHRtbDQuQVRUUklCUz17XCIqOjpjbGFzc1wiOjksXCIqOjpkaXJcIjowLFwiKjo6ZHJhZ2dhYmxlXCI6MCxcIio6OmhpZGRlblwiOjAsXCIqOjppZFwiOjQsXCIqOjppbmVydFwiOjAsXCIqOjppdGVtcHJvcFwiOjAsXCIqOjppdGVtcmVmXCI6NixcIio6Oml0ZW1zY29wZVwiOjAsXCIqOjpsYW5nXCI6MCxcIio6Om9uYmx1clwiOjIsXCIqOjpvbmNoYW5nZVwiOjIsXCIqOjpvbmNsaWNrXCI6MixcIio6Om9uZGJsY2xpY2tcIjoyLFwiKjo6b25lcnJvclwiOjIsXCIqOjpvbmZvY3VzXCI6MixcIio6Om9ua2V5ZG93blwiOjIsXCIqOjpvbmtleXByZXNzXCI6MixcIio6Om9ua2V5dXBcIjoyLFwiKjo6b25sb2FkXCI6MixcIio6Om9ubW91c2Vkb3duXCI6MixcIio6Om9ubW91c2Vtb3ZlXCI6MixcIio6Om9ubW91c2VvdXRcIjoyLFwiKjo6b25tb3VzZW92ZXJcIjoyLFwiKjo6b25tb3VzZXVwXCI6MixcIio6Om9ucmVzZXRcIjoyLFwiKjo6b25zY3JvbGxcIjoyLFwiKjo6b25zZWxlY3RcIjoyLFwiKjo6b25zdWJtaXRcIjoyLFwiKjo6b250b3VjaGNhbmNlbFwiOjIsXCIqOjpvbnRvdWNoZW5kXCI6MixcIio6Om9udG91Y2hlbnRlclwiOjIsXCIqOjpvbnRvdWNobGVhdmVcIjoyLFwiKjo6b250b3VjaG1vdmVcIjoyLFwiKjo6b250b3VjaHN0YXJ0XCI6MixcIio6Om9udW5sb2FkXCI6MixcIio6OnNwZWxsY2hlY2tcIjowLFwiKjo6c3R5bGVcIjozLFwiKjo6dGl0bGVcIjowLFwiKjo6dHJhbnNsYXRlXCI6MCxcImE6OmFjY2Vzc2tleVwiOjAsXCJhOjpjb29yZHNcIjowLFwiYTo6aHJlZlwiOjEsXCJhOjpocmVmbGFuZ1wiOjAsXCJhOjpuYW1lXCI6NyxcImE6Om9uYmx1clwiOjIsXCJhOjpvbmZvY3VzXCI6MixcImE6OnNoYXBlXCI6MCxcImE6OnRhYmluZGV4XCI6MCxcImE6OnRhcmdldFwiOjEwLFwiYTo6dHlwZVwiOjAsXCJhcmVhOjphY2Nlc3NrZXlcIjowLFwiYXJlYTo6YWx0XCI6MCxcImFyZWE6OmNvb3Jkc1wiOjAsXCJhcmVhOjpocmVmXCI6MSxcImFyZWE6Om5vaHJlZlwiOjAsXCJhcmVhOjpvbmJsdXJcIjoyLFwiYXJlYTo6b25mb2N1c1wiOjIsXCJhcmVhOjpzaGFwZVwiOjAsXCJhcmVhOjp0YWJpbmRleFwiOjAsXCJhcmVhOjp0YXJnZXRcIjoxMCxcImF1ZGlvOjpjb250cm9sc1wiOjAsXCJhdWRpbzo6bG9vcFwiOjAsXCJhdWRpbzo6bWVkaWFncm91cFwiOjUsXCJhdWRpbzo6bXV0ZWRcIjowLFwiYXVkaW86OnByZWxvYWRcIjowLFwiYXVkaW86OnNyY1wiOjEsXCJiZG86OmRpclwiOjAsXCJibG9ja3F1b3RlOjpjaXRlXCI6MSxcImJyOjpjbGVhclwiOjAsXCJidXR0b246OmFjY2Vzc2tleVwiOjAsXCJidXR0b246OmRpc2FibGVkXCI6MCxcImJ1dHRvbjo6bmFtZVwiOjgsXCJidXR0b246Om9uYmx1clwiOjIsXCJidXR0b246Om9uZm9jdXNcIjoyLFwiYnV0dG9uOjp0YWJpbmRleFwiOjAsXCJidXR0b246OnR5cGVcIjowLFwiYnV0dG9uOjp2YWx1ZVwiOjAsXCJjYW52YXM6OmhlaWdodFwiOjAsXCJjYW52YXM6OndpZHRoXCI6MCxcImNhcHRpb246OmFsaWduXCI6MCxcImNvbDo6YWxpZ25cIjowLFwiY29sOjpjaGFyXCI6MCxcImNvbDo6Y2hhcm9mZlwiOjAsXCJjb2w6OnNwYW5cIjowLFwiY29sOjp2YWxpZ25cIjowLFwiY29sOjp3aWR0aFwiOjAsXCJjb2xncm91cDo6YWxpZ25cIjowLFwiY29sZ3JvdXA6OmNoYXJcIjowLFwiY29sZ3JvdXA6OmNoYXJvZmZcIjowLFwiY29sZ3JvdXA6OnNwYW5cIjowLFwiY29sZ3JvdXA6OnZhbGlnblwiOjAsXCJjb2xncm91cDo6d2lkdGhcIjowLFwiY29tbWFuZDo6Y2hlY2tlZFwiOjAsXCJjb21tYW5kOjpjb21tYW5kXCI6NSxcImNvbW1hbmQ6OmRpc2FibGVkXCI6MCxcImNvbW1hbmQ6Omljb25cIjoxLFwiY29tbWFuZDo6bGFiZWxcIjowLFwiY29tbWFuZDo6cmFkaW9ncm91cFwiOjAsXCJjb21tYW5kOjp0eXBlXCI6MCxcImRhdGE6OnZhbHVlXCI6MCxcImRlbDo6Y2l0ZVwiOjEsXCJkZWw6OmRhdGV0aW1lXCI6MCxcImRldGFpbHM6Om9wZW5cIjowLFwiZGlyOjpjb21wYWN0XCI6MCxcImRpdjo6YWxpZ25cIjowLFwiZGw6OmNvbXBhY3RcIjowLFwiZmllbGRzZXQ6OmRpc2FibGVkXCI6MCxcImZvbnQ6OmNvbG9yXCI6MCxcImZvbnQ6OmZhY2VcIjowLFwiZm9udDo6c2l6ZVwiOjAsXCJmb3JtOjphY2NlcHRcIjowLFwiZm9ybTo6YWN0aW9uXCI6MSxcImZvcm06OmF1dG9jb21wbGV0ZVwiOjAsXCJmb3JtOjplbmN0eXBlXCI6MCxcImZvcm06Om1ldGhvZFwiOjAsXCJmb3JtOjpuYW1lXCI6NyxcImZvcm06Om5vdmFsaWRhdGVcIjowLFwiZm9ybTo6b25yZXNldFwiOjIsXCJmb3JtOjpvbnN1Ym1pdFwiOjIsXCJmb3JtOjp0YXJnZXRcIjoxMCxcImgxOjphbGlnblwiOjAsXCJoMjo6YWxpZ25cIjowLFwiaDM6OmFsaWduXCI6MCxcImg0OjphbGlnblwiOjAsXCJoNTo6YWxpZ25cIjowLFwiaDY6OmFsaWduXCI6MCxcImhyOjphbGlnblwiOjAsXCJocjo6bm9zaGFkZVwiOjAsXCJocjo6c2l6ZVwiOjAsXCJocjo6d2lkdGhcIjowLFwiaWZyYW1lOjphbGlnblwiOjAsXCJpZnJhbWU6OmZyYW1lYm9yZGVyXCI6MCxcImlmcmFtZTo6aGVpZ2h0XCI6MCxcImlmcmFtZTo6bWFyZ2luaGVpZ2h0XCI6MCxcImlmcmFtZTo6bWFyZ2lud2lkdGhcIjowLFwiaWZyYW1lOjp3aWR0aFwiOjAsXCJpbWc6OmFsaWduXCI6MCxcImltZzo6YWx0XCI6MCxcImltZzo6Ym9yZGVyXCI6MCxcImltZzo6aGVpZ2h0XCI6MCxcImltZzo6aHNwYWNlXCI6MCxcImltZzo6aXNtYXBcIjowLFwiaW1nOjpuYW1lXCI6NyxcImltZzo6c3JjXCI6MSxcImltZzo6dXNlbWFwXCI6MTEsXCJpbWc6OnZzcGFjZVwiOjAsXCJpbWc6OndpZHRoXCI6MCxcImlucHV0OjphY2NlcHRcIjowLFwiaW5wdXQ6OmFjY2Vzc2tleVwiOjAsXCJpbnB1dDo6YWxpZ25cIjowLFwiaW5wdXQ6OmFsdFwiOjAsXCJpbnB1dDo6YXV0b2NvbXBsZXRlXCI6MCxcImlucHV0OjpjaGVja2VkXCI6MCxcImlucHV0OjpkaXNhYmxlZFwiOjAsXCJpbnB1dDo6aW5wdXRtb2RlXCI6MCxcImlucHV0Ojppc21hcFwiOjAsXCJpbnB1dDo6bGlzdFwiOjUsXCJpbnB1dDo6bWF4XCI6MCxcImlucHV0OjptYXhsZW5ndGhcIjowLFwiaW5wdXQ6Om1pblwiOjAsXCJpbnB1dDo6bXVsdGlwbGVcIjowLFwiaW5wdXQ6Om5hbWVcIjo4LFwiaW5wdXQ6Om9uYmx1clwiOjIsXCJpbnB1dDo6b25jaGFuZ2VcIjoyLFwiaW5wdXQ6Om9uZm9jdXNcIjoyLFwiaW5wdXQ6Om9uc2VsZWN0XCI6MixcImlucHV0OjpwbGFjZWhvbGRlclwiOjAsXCJpbnB1dDo6cmVhZG9ubHlcIjowLFwiaW5wdXQ6OnJlcXVpcmVkXCI6MCxcImlucHV0OjpzaXplXCI6MCxcImlucHV0OjpzcmNcIjoxLFwiaW5wdXQ6OnN0ZXBcIjowLFwiaW5wdXQ6OnRhYmluZGV4XCI6MCxcImlucHV0Ojp0eXBlXCI6MCxcImlucHV0Ojp1c2VtYXBcIjoxMSxcImlucHV0Ojp2YWx1ZVwiOjAsXCJpbnM6OmNpdGVcIjoxLFwiaW5zOjpkYXRldGltZVwiOjAsXCJsYWJlbDo6YWNjZXNza2V5XCI6MCxcImxhYmVsOjpmb3JcIjo1LFwibGFiZWw6Om9uYmx1clwiOjIsXCJsYWJlbDo6b25mb2N1c1wiOjIsXCJsZWdlbmQ6OmFjY2Vzc2tleVwiOjAsXCJsZWdlbmQ6OmFsaWduXCI6MCxcImxpOjp0eXBlXCI6MCxcImxpOjp2YWx1ZVwiOjAsXCJtYXA6Om5hbWVcIjo3LFwibWVudTo6Y29tcGFjdFwiOjAsXCJtZW51OjpsYWJlbFwiOjAsXCJtZW51Ojp0eXBlXCI6MCxcIm1ldGVyOjpoaWdoXCI6MCxcIm1ldGVyOjpsb3dcIjowLFwibWV0ZXI6Om1heFwiOjAsXCJtZXRlcjo6bWluXCI6MCxcIm1ldGVyOjp2YWx1ZVwiOjAsXCJvbDo6Y29tcGFjdFwiOjAsXCJvbDo6cmV2ZXJzZWRcIjowLFwib2w6OnN0YXJ0XCI6MCxcIm9sOjp0eXBlXCI6MCxcIm9wdGdyb3VwOjpkaXNhYmxlZFwiOjAsXCJvcHRncm91cDo6bGFiZWxcIjowLFwib3B0aW9uOjpkaXNhYmxlZFwiOjAsXCJvcHRpb246OmxhYmVsXCI6MCxcIm9wdGlvbjo6c2VsZWN0ZWRcIjowLFwib3B0aW9uOjp2YWx1ZVwiOjAsXCJvdXRwdXQ6OmZvclwiOjYsXCJvdXRwdXQ6Om5hbWVcIjo4LFwicDo6YWxpZ25cIjowLFwicHJlOjp3aWR0aFwiOjAsXCJwcm9ncmVzczo6bWF4XCI6MCxcInByb2dyZXNzOjptaW5cIjowLFwicHJvZ3Jlc3M6OnZhbHVlXCI6MCxcInE6OmNpdGVcIjoxLFwic2VsZWN0OjphdXRvY29tcGxldGVcIjowLFwic2VsZWN0OjpkaXNhYmxlZFwiOjAsXCJzZWxlY3Q6Om11bHRpcGxlXCI6MCxcInNlbGVjdDo6bmFtZVwiOjgsXCJzZWxlY3Q6Om9uYmx1clwiOjIsXCJzZWxlY3Q6Om9uY2hhbmdlXCI6MixcInNlbGVjdDo6b25mb2N1c1wiOjIsXCJzZWxlY3Q6OnJlcXVpcmVkXCI6MCxcInNlbGVjdDo6c2l6ZVwiOjAsXCJzZWxlY3Q6OnRhYmluZGV4XCI6MCxcInNvdXJjZTo6dHlwZVwiOjAsXCJ0YWJsZTo6YWxpZ25cIjowLFwidGFibGU6OmJnY29sb3JcIjowLFwidGFibGU6OmJvcmRlclwiOjAsXCJ0YWJsZTo6Y2VsbHBhZGRpbmdcIjowLFwidGFibGU6OmNlbGxzcGFjaW5nXCI6MCxcInRhYmxlOjpmcmFtZVwiOjAsXCJ0YWJsZTo6cnVsZXNcIjowLFwidGFibGU6OnN1bW1hcnlcIjowLFwidGFibGU6OndpZHRoXCI6MCxcInRib2R5OjphbGlnblwiOjAsXCJ0Ym9keTo6Y2hhclwiOjAsXCJ0Ym9keTo6Y2hhcm9mZlwiOjAsXCJ0Ym9keTo6dmFsaWduXCI6MCxcInRkOjphYmJyXCI6MCxcInRkOjphbGlnblwiOjAsXCJ0ZDo6YXhpc1wiOjAsXCJ0ZDo6Ymdjb2xvclwiOjAsXCJ0ZDo6Y2hhclwiOjAsXCJ0ZDo6Y2hhcm9mZlwiOjAsXCJ0ZDo6Y29sc3BhblwiOjAsXCJ0ZDo6aGVhZGVyc1wiOjYsXCJ0ZDo6aGVpZ2h0XCI6MCxcInRkOjpub3dyYXBcIjowLFwidGQ6OnJvd3NwYW5cIjowLFwidGQ6OnNjb3BlXCI6MCxcInRkOjp2YWxpZ25cIjowLFwidGQ6OndpZHRoXCI6MCxcInRleHRhcmVhOjphY2Nlc3NrZXlcIjowLFwidGV4dGFyZWE6OmF1dG9jb21wbGV0ZVwiOjAsXCJ0ZXh0YXJlYTo6Y29sc1wiOjAsXCJ0ZXh0YXJlYTo6ZGlzYWJsZWRcIjowLFwidGV4dGFyZWE6OmlucHV0bW9kZVwiOjAsXCJ0ZXh0YXJlYTo6bmFtZVwiOjgsXCJ0ZXh0YXJlYTo6b25ibHVyXCI6MixcInRleHRhcmVhOjpvbmNoYW5nZVwiOjIsXCJ0ZXh0YXJlYTo6b25mb2N1c1wiOjIsXCJ0ZXh0YXJlYTo6b25zZWxlY3RcIjoyLFwidGV4dGFyZWE6OnBsYWNlaG9sZGVyXCI6MCxcInRleHRhcmVhOjpyZWFkb25seVwiOjAsXCJ0ZXh0YXJlYTo6cmVxdWlyZWRcIjowLFwidGV4dGFyZWE6OnJvd3NcIjowLFwidGV4dGFyZWE6OnRhYmluZGV4XCI6MCxcInRleHRhcmVhOjp3cmFwXCI6MCxcInRmb290OjphbGlnblwiOjAsXCJ0Zm9vdDo6Y2hhclwiOjAsXCJ0Zm9vdDo6Y2hhcm9mZlwiOjAsXCJ0Zm9vdDo6dmFsaWduXCI6MCxcInRoOjphYmJyXCI6MCxcInRoOjphbGlnblwiOjAsXCJ0aDo6YXhpc1wiOjAsXCJ0aDo6Ymdjb2xvclwiOjAsXCJ0aDo6Y2hhclwiOjAsXCJ0aDo6Y2hhcm9mZlwiOjAsXCJ0aDo6Y29sc3BhblwiOjAsXCJ0aDo6aGVhZGVyc1wiOjYsXCJ0aDo6aGVpZ2h0XCI6MCxcInRoOjpub3dyYXBcIjowLFwidGg6OnJvd3NwYW5cIjowLFwidGg6OnNjb3BlXCI6MCxcInRoOjp2YWxpZ25cIjowLFwidGg6OndpZHRoXCI6MCxcInRoZWFkOjphbGlnblwiOjAsXCJ0aGVhZDo6Y2hhclwiOjAsXCJ0aGVhZDo6Y2hhcm9mZlwiOjAsXCJ0aGVhZDo6dmFsaWduXCI6MCxcInRyOjphbGlnblwiOjAsXCJ0cjo6Ymdjb2xvclwiOjAsXCJ0cjo6Y2hhclwiOjAsXCJ0cjo6Y2hhcm9mZlwiOjAsXCJ0cjo6dmFsaWduXCI6MCxcInRyYWNrOjpkZWZhdWx0XCI6MCxcInRyYWNrOjpraW5kXCI6MCxcInRyYWNrOjpsYWJlbFwiOjAsXCJ0cmFjazo6c3JjbGFuZ1wiOjAsXCJ1bDo6Y29tcGFjdFwiOjAsXCJ1bDo6dHlwZVwiOjAsXCJ2aWRlbzo6Y29udHJvbHNcIjowLFwidmlkZW86OmhlaWdodFwiOjAsXCJ2aWRlbzo6bG9vcFwiOjAsXCJ2aWRlbzo6bWVkaWFncm91cFwiOjUsXCJ2aWRlbzo6bXV0ZWRcIjowLFwidmlkZW86OnBvc3RlclwiOjEsXCJ2aWRlbzo6cHJlbG9hZFwiOjAsXCJ2aWRlbzo6c3JjXCI6MSxcInZpZGVvOjp3aWR0aFwiOjB9O2h0bWw0W1wiQVRUUklCU1wiXT1odG1sNC5BVFRSSUJTO2h0bWw0LmVmbGFncz17T1BUSU9OQUxfRU5EVEFHOjEsRU1QVFk6MixDREFUQTo0LFJDREFUQTo4LFVOU0FGRToxNixGT0xEQUJMRTozMixTQ1JJUFQ6NjQsU1RZTEU6MTI4LFZJUlRVQUxJWkVEOjI1Nn07aHRtbDRbXCJlZmxhZ3NcIl09aHRtbDQuZWZsYWdzO2h0bWw0LkVMRU1FTlRTPXthOjAsYWJicjowLGFjcm9ueW06MCxhZGRyZXNzOjAsYXBwbGV0OjI3MixhcmVhOjIsYXJ0aWNsZTowLGFzaWRlOjAsYXVkaW86MCxiOjAsYmFzZToyNzQsYmFzZWZvbnQ6Mjc0LGJkaTowLGJkbzowLGJpZzowLGJsb2NrcXVvdGU6MCxib2R5OjMwNSxicjoyLGJ1dHRvbjowLGNhbnZhczowLGNhcHRpb246MCxjZW50ZXI6MCxjaXRlOjAsY29kZTowLGNvbDoyLGNvbGdyb3VwOjEsY29tbWFuZDoyLGRhdGE6MCxkYXRhbGlzdDowLGRkOjEsZGVsOjAsZGV0YWlsczowLGRmbjowLGRpYWxvZzoyNzIsZGlyOjAsZGl2OjAsZGw6MCxkdDoxLGVtOjAsZmllbGRzZXQ6MCxmaWdjYXB0aW9uOjAsZmlndXJlOjAsZm9udDowLGZvb3RlcjowLGZvcm06MCxmcmFtZToyNzQsZnJhbWVzZXQ6MjcyLGgxOjAsaDI6MCxoMzowLGg0OjAsaDU6MCxoNjowLGhlYWQ6MzA1LGhlYWRlcjowLGhncm91cDowLGhyOjIsaHRtbDozMDUsaTowLGlmcmFtZTo0LGltZzoyLGlucHV0OjIsaW5zOjAsaXNpbmRleDoyNzQsa2JkOjAsa2V5Z2VuOjI3NCxsYWJlbDowLGxlZ2VuZDowLGxpOjEsbGluazoyNzQsbWFwOjAsbWFyazowLG1lbnU6MCxtZXRhOjI3NCxtZXRlcjowLG5hdjowLG5vYnI6MCxub2VtYmVkOjI3Nixub2ZyYW1lczoyNzYsbm9zY3JpcHQ6Mjc2LG9iamVjdDoyNzIsb2w6MCxvcHRncm91cDowLG9wdGlvbjoxLG91dHB1dDowLHA6MSxwYXJhbToyNzQscHJlOjAscHJvZ3Jlc3M6MCxxOjAsczowLHNhbXA6MCxzY3JpcHQ6ODQsc2VjdGlvbjowLHNlbGVjdDowLHNtYWxsOjAsc291cmNlOjIsc3BhbjowLHN0cmlrZTowLHN0cm9uZzowLHN0eWxlOjE0OCxzdWI6MCxzdW1tYXJ5OjAsc3VwOjAsdGFibGU6MCx0Ym9keToxLHRkOjEsdGV4dGFyZWE6OCx0Zm9vdDoxLHRoOjEsdGhlYWQ6MSx0aW1lOjAsdGl0bGU6MjgwLHRyOjEsdHJhY2s6Mix0dDowLHU6MCx1bDowLFwidmFyXCI6MCx2aWRlbzowLHdicjoyfTtodG1sNFtcIkVMRU1FTlRTXCJdPWh0bWw0LkVMRU1FTlRTO2h0bWw0LkVMRU1FTlRfRE9NX0lOVEVSRkFDRVM9e2E6XCJIVE1MQW5jaG9yRWxlbWVudFwiLGFiYnI6XCJIVE1MRWxlbWVudFwiLGFjcm9ueW06XCJIVE1MRWxlbWVudFwiLGFkZHJlc3M6XCJIVE1MRWxlbWVudFwiLGFwcGxldDpcIkhUTUxBcHBsZXRFbGVtZW50XCIsYXJlYTpcIkhUTUxBcmVhRWxlbWVudFwiLGFydGljbGU6XCJIVE1MRWxlbWVudFwiLGFzaWRlOlwiSFRNTEVsZW1lbnRcIixhdWRpbzpcIkhUTUxBdWRpb0VsZW1lbnRcIixiOlwiSFRNTEVsZW1lbnRcIixiYXNlOlwiSFRNTEJhc2VFbGVtZW50XCIsYmFzZWZvbnQ6XCJIVE1MQmFzZUZvbnRFbGVtZW50XCIsYmRpOlwiSFRNTEVsZW1lbnRcIixiZG86XCJIVE1MRWxlbWVudFwiLGJpZzpcIkhUTUxFbGVtZW50XCIsYmxvY2txdW90ZTpcIkhUTUxRdW90ZUVsZW1lbnRcIixib2R5OlwiSFRNTEJvZHlFbGVtZW50XCIsYnI6XCJIVE1MQlJFbGVtZW50XCIsYnV0dG9uOlwiSFRNTEJ1dHRvbkVsZW1lbnRcIixjYW52YXM6XCJIVE1MQ2FudmFzRWxlbWVudFwiLGNhcHRpb246XCJIVE1MVGFibGVDYXB0aW9uRWxlbWVudFwiLGNlbnRlcjpcIkhUTUxFbGVtZW50XCIsY2l0ZTpcIkhUTUxFbGVtZW50XCIsY29kZTpcIkhUTUxFbGVtZW50XCIsY29sOlwiSFRNTFRhYmxlQ29sRWxlbWVudFwiLGNvbGdyb3VwOlwiSFRNTFRhYmxlQ29sRWxlbWVudFwiLGNvbW1hbmQ6XCJIVE1MQ29tbWFuZEVsZW1lbnRcIixkYXRhOlwiSFRNTEVsZW1lbnRcIixkYXRhbGlzdDpcIkhUTUxEYXRhTGlzdEVsZW1lbnRcIixkZDpcIkhUTUxFbGVtZW50XCIsZGVsOlwiSFRNTE1vZEVsZW1lbnRcIixkZXRhaWxzOlwiSFRNTERldGFpbHNFbGVtZW50XCIsZGZuOlwiSFRNTEVsZW1lbnRcIixkaWFsb2c6XCJIVE1MRGlhbG9nRWxlbWVudFwiLGRpcjpcIkhUTUxEaXJlY3RvcnlFbGVtZW50XCIsZGl2OlwiSFRNTERpdkVsZW1lbnRcIixkbDpcIkhUTUxETGlzdEVsZW1lbnRcIixkdDpcIkhUTUxFbGVtZW50XCIsZW06XCJIVE1MRWxlbWVudFwiLGZpZWxkc2V0OlwiSFRNTEZpZWxkU2V0RWxlbWVudFwiLGZpZ2NhcHRpb246XCJIVE1MRWxlbWVudFwiLGZpZ3VyZTpcIkhUTUxFbGVtZW50XCIsZm9udDpcIkhUTUxGb250RWxlbWVudFwiLGZvb3RlcjpcIkhUTUxFbGVtZW50XCIsZm9ybTpcIkhUTUxGb3JtRWxlbWVudFwiLGZyYW1lOlwiSFRNTEZyYW1lRWxlbWVudFwiLGZyYW1lc2V0OlwiSFRNTEZyYW1lU2V0RWxlbWVudFwiLGgxOlwiSFRNTEhlYWRpbmdFbGVtZW50XCIsaDI6XCJIVE1MSGVhZGluZ0VsZW1lbnRcIixoMzpcIkhUTUxIZWFkaW5nRWxlbWVudFwiLGg0OlwiSFRNTEhlYWRpbmdFbGVtZW50XCIsaDU6XCJIVE1MSGVhZGluZ0VsZW1lbnRcIixoNjpcIkhUTUxIZWFkaW5nRWxlbWVudFwiLGhlYWQ6XCJIVE1MSGVhZEVsZW1lbnRcIixoZWFkZXI6XCJIVE1MRWxlbWVudFwiLGhncm91cDpcIkhUTUxFbGVtZW50XCIsaHI6XCJIVE1MSFJFbGVtZW50XCIsaHRtbDpcIkhUTUxIdG1sRWxlbWVudFwiLGk6XCJIVE1MRWxlbWVudFwiLGlmcmFtZTpcIkhUTUxJRnJhbWVFbGVtZW50XCIsaW1nOlwiSFRNTEltYWdlRWxlbWVudFwiLGlucHV0OlwiSFRNTElucHV0RWxlbWVudFwiLGluczpcIkhUTUxNb2RFbGVtZW50XCIsaXNpbmRleDpcIkhUTUxVbmtub3duRWxlbWVudFwiLGtiZDpcIkhUTUxFbGVtZW50XCIsa2V5Z2VuOlwiSFRNTEtleWdlbkVsZW1lbnRcIixsYWJlbDpcIkhUTUxMYWJlbEVsZW1lbnRcIixsZWdlbmQ6XCJIVE1MTGVnZW5kRWxlbWVudFwiLGxpOlwiSFRNTExJRWxlbWVudFwiLGxpbms6XCJIVE1MTGlua0VsZW1lbnRcIixtYXA6XCJIVE1MTWFwRWxlbWVudFwiLG1hcms6XCJIVE1MRWxlbWVudFwiLG1lbnU6XCJIVE1MTWVudUVsZW1lbnRcIixtZXRhOlwiSFRNTE1ldGFFbGVtZW50XCIsbWV0ZXI6XCJIVE1MTWV0ZXJFbGVtZW50XCIsbmF2OlwiSFRNTEVsZW1lbnRcIixub2JyOlwiSFRNTEVsZW1lbnRcIixub2VtYmVkOlwiSFRNTEVsZW1lbnRcIixub2ZyYW1lczpcIkhUTUxFbGVtZW50XCIsbm9zY3JpcHQ6XCJIVE1MRWxlbWVudFwiLG9iamVjdDpcIkhUTUxPYmplY3RFbGVtZW50XCIsb2w6XCJIVE1MT0xpc3RFbGVtZW50XCIsb3B0Z3JvdXA6XCJIVE1MT3B0R3JvdXBFbGVtZW50XCIsb3B0aW9uOlwiSFRNTE9wdGlvbkVsZW1lbnRcIixvdXRwdXQ6XCJIVE1MT3V0cHV0RWxlbWVudFwiLHA6XCJIVE1MUGFyYWdyYXBoRWxlbWVudFwiLHBhcmFtOlwiSFRNTFBhcmFtRWxlbWVudFwiLHByZTpcIkhUTUxQcmVFbGVtZW50XCIscHJvZ3Jlc3M6XCJIVE1MUHJvZ3Jlc3NFbGVtZW50XCIscTpcIkhUTUxRdW90ZUVsZW1lbnRcIixzOlwiSFRNTEVsZW1lbnRcIixzYW1wOlwiSFRNTEVsZW1lbnRcIixzY3JpcHQ6XCJIVE1MU2NyaXB0RWxlbWVudFwiLHNlY3Rpb246XCJIVE1MRWxlbWVudFwiLHNlbGVjdDpcIkhUTUxTZWxlY3RFbGVtZW50XCIsc21hbGw6XCJIVE1MRWxlbWVudFwiLHNvdXJjZTpcIkhUTUxTb3VyY2VFbGVtZW50XCIsc3BhbjpcIkhUTUxTcGFuRWxlbWVudFwiLHN0cmlrZTpcIkhUTUxFbGVtZW50XCIsc3Ryb25nOlwiSFRNTEVsZW1lbnRcIixzdHlsZTpcIkhUTUxTdHlsZUVsZW1lbnRcIixzdWI6XCJIVE1MRWxlbWVudFwiLHN1bW1hcnk6XCJIVE1MRWxlbWVudFwiLHN1cDpcIkhUTUxFbGVtZW50XCIsdGFibGU6XCJIVE1MVGFibGVFbGVtZW50XCIsdGJvZHk6XCJIVE1MVGFibGVTZWN0aW9uRWxlbWVudFwiLHRkOlwiSFRNTFRhYmxlRGF0YUNlbGxFbGVtZW50XCIsdGV4dGFyZWE6XCJIVE1MVGV4dEFyZWFFbGVtZW50XCIsdGZvb3Q6XCJIVE1MVGFibGVTZWN0aW9uRWxlbWVudFwiLHRoOlwiSFRNTFRhYmxlSGVhZGVyQ2VsbEVsZW1lbnRcIix0aGVhZDpcIkhUTUxUYWJsZVNlY3Rpb25FbGVtZW50XCIsdGltZTpcIkhUTUxUaW1lRWxlbWVudFwiLHRpdGxlOlwiSFRNTFRpdGxlRWxlbWVudFwiLHRyOlwiSFRNTFRhYmxlUm93RWxlbWVudFwiLHRyYWNrOlwiSFRNTFRyYWNrRWxlbWVudFwiLHR0OlwiSFRNTEVsZW1lbnRcIix1OlwiSFRNTEVsZW1lbnRcIix1bDpcIkhUTUxVTGlzdEVsZW1lbnRcIixcInZhclwiOlwiSFRNTEVsZW1lbnRcIix2aWRlbzpcIkhUTUxWaWRlb0VsZW1lbnRcIix3YnI6XCJIVE1MRWxlbWVudFwifTtodG1sNFtcIkVMRU1FTlRfRE9NX0lOVEVSRkFDRVNcIl09aHRtbDQuRUxFTUVOVF9ET01fSU5URVJGQUNFUztodG1sNC51ZWZmZWN0cz17Tk9UX0xPQURFRDowLFNBTUVfRE9DVU1FTlQ6MSxORVdfRE9DVU1FTlQ6Mn07aHRtbDRbXCJ1ZWZmZWN0c1wiXT1odG1sNC51ZWZmZWN0cztodG1sNC5VUklFRkZFQ1RTPXtcImE6OmhyZWZcIjoyLFwiYXJlYTo6aHJlZlwiOjIsXCJhdWRpbzo6c3JjXCI6MSxcImJsb2NrcXVvdGU6OmNpdGVcIjowLFwiY29tbWFuZDo6aWNvblwiOjEsXCJkZWw6OmNpdGVcIjowLFwiZm9ybTo6YWN0aW9uXCI6MixcImltZzo6c3JjXCI6MSxcImlucHV0OjpzcmNcIjoxLFwiaW5zOjpjaXRlXCI6MCxcInE6OmNpdGVcIjowLFwidmlkZW86OnBvc3RlclwiOjEsXCJ2aWRlbzo6c3JjXCI6MX07aHRtbDRbXCJVUklFRkZFQ1RTXCJdPWh0bWw0LlVSSUVGRkVDVFM7aHRtbDQubHR5cGVzPXtVTlNBTkRCT1hFRDoyLFNBTkRCT1hFRDoxLERBVEE6MH07aHRtbDRbXCJsdHlwZXNcIl09aHRtbDQubHR5cGVzO2h0bWw0LkxPQURFUlRZUEVTPXtcImE6OmhyZWZcIjoyLFwiYXJlYTo6aHJlZlwiOjIsXCJhdWRpbzo6c3JjXCI6MixcImJsb2NrcXVvdGU6OmNpdGVcIjoyLFwiY29tbWFuZDo6aWNvblwiOjEsXCJkZWw6OmNpdGVcIjoyLFwiZm9ybTo6YWN0aW9uXCI6MixcImltZzo6c3JjXCI6MSxcImlucHV0OjpzcmNcIjoxLFwiaW5zOjpjaXRlXCI6MixcInE6OmNpdGVcIjoyLFwidmlkZW86OnBvc3RlclwiOjEsXCJ2aWRlbzo6c3JjXCI6Mn07aHRtbDRbXCJMT0FERVJUWVBFU1wiXT1odG1sNC5MT0FERVJUWVBFUztpZih0eXBlb2Ygd2luZG93IT09XCJ1bmRlZmluZWRcIil7d2luZG93W1wiaHRtbDRcIl09aHRtbDR9aWYoXCJJXCIudG9Mb3dlckNhc2UoKSE9PVwiaVwiKXt0aHJvd1wiSS9pIHByb2JsZW1cIn12YXIgaHRtbD1mdW5jdGlvbihodG1sNCl7dmFyIHBhcnNlQ3NzRGVjbGFyYXRpb25zLHNhbml0aXplQ3NzUHJvcGVydHksY3NzU2NoZW1hO2lmKFwidW5kZWZpbmVkXCIhPT10eXBlb2Ygd2luZG93KXtwYXJzZUNzc0RlY2xhcmF0aW9ucz13aW5kb3dbXCJwYXJzZUNzc0RlY2xhcmF0aW9uc1wiXTtzYW5pdGl6ZUNzc1Byb3BlcnR5PXdpbmRvd1tcInNhbml0aXplQ3NzUHJvcGVydHlcIl07Y3NzU2NoZW1hPXdpbmRvd1tcImNzc1NjaGVtYVwiXX12YXIgRU5USVRJRVM9e2x0OlwiPFwiLExUOlwiPFwiLGd0OlwiPlwiLEdUOlwiPlwiLGFtcDpcIiZcIixBTVA6XCImXCIscXVvdDonXCInLGFwb3M6XCInXCIsbmJzcDpcIsKgXCJ9O3ZhciBkZWNpbWFsRXNjYXBlUmU9L14jKFxcZCspJC87dmFyIGhleEVzY2FwZVJlPS9eI3goWzAtOUEtRmEtZl0rKSQvO3ZhciBzYWZlRW50aXR5TmFtZVJlPS9eW0EtWmEtel1bQS16YS16MC05XSskLzt2YXIgZW50aXR5TG9va3VwRWxlbWVudD1cInVuZGVmaW5lZFwiIT09dHlwZW9mIHdpbmRvdyYmd2luZG93W1wiZG9jdW1lbnRcIl0/d2luZG93W1wiZG9jdW1lbnRcIl0uY3JlYXRlRWxlbWVudChcInRleHRhcmVhXCIpOm51bGw7ZnVuY3Rpb24gbG9va3VwRW50aXR5KG5hbWUpe2lmKEVOVElUSUVTLmhhc093blByb3BlcnR5KG5hbWUpKXtyZXR1cm4gRU5USVRJRVNbbmFtZV19dmFyIG09bmFtZS5tYXRjaChkZWNpbWFsRXNjYXBlUmUpO2lmKG0pe3JldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KG1bMV0sMTApKX1lbHNlIGlmKCEhKG09bmFtZS5tYXRjaChoZXhFc2NhcGVSZSkpKXtyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChtWzFdLDE2KSl9ZWxzZSBpZihlbnRpdHlMb29rdXBFbGVtZW50JiZzYWZlRW50aXR5TmFtZVJlLnRlc3QobmFtZSkpe2VudGl0eUxvb2t1cEVsZW1lbnQuaW5uZXJIVE1MPVwiJlwiK25hbWUrXCI7XCI7dmFyIHRleHQ9ZW50aXR5TG9va3VwRWxlbWVudC50ZXh0Q29udGVudDtFTlRJVElFU1tuYW1lXT10ZXh0O3JldHVybiB0ZXh0fWVsc2V7cmV0dXJuXCImXCIrbmFtZStcIjtcIn19ZnVuY3Rpb24gZGVjb2RlT25lRW50aXR5KF8sbmFtZSl7cmV0dXJuIGxvb2t1cEVudGl0eShuYW1lKX12YXIgbnVsUmU9L1xcMC9nO2Z1bmN0aW9uIHN0cmlwTlVMcyhzKXtyZXR1cm4gcy5yZXBsYWNlKG51bFJlLFwiXCIpfXZhciBFTlRJVFlfUkVfMT0vJigjWzAtOV0rfCNbeFhdWzAtOUEtRmEtZl0rfFxcdyspOy9nO3ZhciBFTlRJVFlfUkVfMj0vXigjWzAtOV0rfCNbeFhdWzAtOUEtRmEtZl0rfFxcdyspOy87ZnVuY3Rpb24gdW5lc2NhcGVFbnRpdGllcyhzKXtyZXR1cm4gcy5yZXBsYWNlKEVOVElUWV9SRV8xLGRlY29kZU9uZUVudGl0eSl9dmFyIGFtcFJlPS8mL2c7dmFyIGxvb3NlQW1wUmU9LyYoW15hLXojXXwjKD86W14wLTl4XXx4KD86W14wLTlhLWZdfCQpfCQpfCQpL2dpO3ZhciBsdFJlPS9bPF0vZzt2YXIgZ3RSZT0vPi9nO3ZhciBxdW90UmU9L1xcXCIvZztmdW5jdGlvbiBlc2NhcGVBdHRyaWIocyl7cmV0dXJuKFwiXCIrcykucmVwbGFjZShhbXBSZSxcIiZhbXA7XCIpLnJlcGxhY2UobHRSZSxcIiZsdDtcIikucmVwbGFjZShndFJlLFwiJmd0O1wiKS5yZXBsYWNlKHF1b3RSZSxcIiYjMzQ7XCIpfWZ1bmN0aW9uIG5vcm1hbGl6ZVJDRGF0YShyY2RhdGEpe3JldHVybiByY2RhdGEucmVwbGFjZShsb29zZUFtcFJlLFwiJmFtcDskMVwiKS5yZXBsYWNlKGx0UmUsXCImbHQ7XCIpLnJlcGxhY2UoZ3RSZSxcIiZndDtcIil9dmFyIEFUVFJfUkU9bmV3IFJlZ0V4cChcIl5cXFxccypcIitcIihbLS46XFxcXHddKylcIitcIig/OlwiKyhcIlxcXFxzKig9KVxcXFxzKlwiK1wiKFwiKygnKFwiKVteXCJdKihcInwkKScrXCJ8XCIrXCIoJylbXiddKignfCQpXCIrXCJ8XCIrXCIoPz1bYS16XVstXFxcXHddKlxcXFxzKj0pXCIrXCJ8XCIrXCJbXlxcXCInXFxcXHNdKlwiKStcIilcIikrXCIpP1wiLFwiaVwiKTt2YXIgc3BsaXRXaWxsQ2FwdHVyZT1cImEsYlwiLnNwbGl0KC8oLCkvKS5sZW5ndGg9PT0zO3ZhciBFRkxBR1NfVEVYVD1odG1sNC5lZmxhZ3NbXCJDREFUQVwiXXxodG1sNC5lZmxhZ3NbXCJSQ0RBVEFcIl07ZnVuY3Rpb24gbWFrZVNheFBhcnNlcihoYW5kbGVyKXt2YXIgaGNvcHk9e2NkYXRhOmhhbmRsZXIuY2RhdGF8fGhhbmRsZXJbXCJjZGF0YVwiXSxjb21tZW50OmhhbmRsZXIuY29tbWVudHx8aGFuZGxlcltcImNvbW1lbnRcIl0sZW5kRG9jOmhhbmRsZXIuZW5kRG9jfHxoYW5kbGVyW1wiZW5kRG9jXCJdLGVuZFRhZzpoYW5kbGVyLmVuZFRhZ3x8aGFuZGxlcltcImVuZFRhZ1wiXSxwY2RhdGE6aGFuZGxlci5wY2RhdGF8fGhhbmRsZXJbXCJwY2RhdGFcIl0scmNkYXRhOmhhbmRsZXIucmNkYXRhfHxoYW5kbGVyW1wicmNkYXRhXCJdLHN0YXJ0RG9jOmhhbmRsZXIuc3RhcnREb2N8fGhhbmRsZXJbXCJzdGFydERvY1wiXSxzdGFydFRhZzpoYW5kbGVyLnN0YXJ0VGFnfHxoYW5kbGVyW1wic3RhcnRUYWdcIl19O3JldHVybiBmdW5jdGlvbihodG1sVGV4dCxwYXJhbSl7cmV0dXJuIHBhcnNlKGh0bWxUZXh0LGhjb3B5LHBhcmFtKX19dmFyIGNvbnRpbnVhdGlvbk1hcmtlcj17fTtmdW5jdGlvbiBwYXJzZShodG1sVGV4dCxoYW5kbGVyLHBhcmFtKXt2YXIgbSxwLHRhZ05hbWU7dmFyIHBhcnRzPWh0bWxTcGxpdChodG1sVGV4dCk7dmFyIHN0YXRlPXtub01vcmVHVDpmYWxzZSxub01vcmVFbmRDb21tZW50czpmYWxzZX07cGFyc2VDUFMoaGFuZGxlcixwYXJ0cywwLHN0YXRlLHBhcmFtKX1mdW5jdGlvbiBjb250aW51YXRpb25NYWtlcihoLHBhcnRzLGluaXRpYWwsc3RhdGUscGFyYW0pe3JldHVybiBmdW5jdGlvbigpe3BhcnNlQ1BTKGgscGFydHMsaW5pdGlhbCxzdGF0ZSxwYXJhbSl9fWZ1bmN0aW9uIHBhcnNlQ1BTKGgscGFydHMsaW5pdGlhbCxzdGF0ZSxwYXJhbSl7dHJ5e2lmKGguc3RhcnREb2MmJmluaXRpYWw9PTApe2guc3RhcnREb2MocGFyYW0pfXZhciBtLHAsdGFnTmFtZTtmb3IodmFyIHBvcz1pbml0aWFsLGVuZD1wYXJ0cy5sZW5ndGg7cG9zPGVuZDspe3ZhciBjdXJyZW50PXBhcnRzW3BvcysrXTt2YXIgbmV4dD1wYXJ0c1twb3NdO3N3aXRjaChjdXJyZW50KXtjYXNlXCImXCI6aWYoRU5USVRZX1JFXzIudGVzdChuZXh0KSl7aWYoaC5wY2RhdGEpe2gucGNkYXRhKFwiJlwiK25leHQscGFyYW0sY29udGludWF0aW9uTWFya2VyLGNvbnRpbnVhdGlvbk1ha2VyKGgscGFydHMscG9zLHN0YXRlLHBhcmFtKSl9cG9zKyt9ZWxzZXtpZihoLnBjZGF0YSl7aC5wY2RhdGEoXCImYW1wO1wiLHBhcmFtLGNvbnRpbnVhdGlvbk1hcmtlcixjb250aW51YXRpb25NYWtlcihoLHBhcnRzLHBvcyxzdGF0ZSxwYXJhbSkpfX1icmVhaztjYXNlXCI8L1wiOmlmKG09L14oWy1cXHc6XSspW15cXCdcXFwiXSovLmV4ZWMobmV4dCkpe2lmKG1bMF0ubGVuZ3RoPT09bmV4dC5sZW5ndGgmJnBhcnRzW3BvcysxXT09PVwiPlwiKXtwb3MrPTI7dGFnTmFtZT1tWzFdLnRvTG93ZXJDYXNlKCk7aWYoaC5lbmRUYWcpe2guZW5kVGFnKHRhZ05hbWUscGFyYW0sY29udGludWF0aW9uTWFya2VyLGNvbnRpbnVhdGlvbk1ha2VyKGgscGFydHMscG9zLHN0YXRlLHBhcmFtKSl9fWVsc2V7cG9zPXBhcnNlRW5kVGFnKHBhcnRzLHBvcyxoLHBhcmFtLGNvbnRpbnVhdGlvbk1hcmtlcixzdGF0ZSl9fWVsc2V7aWYoaC5wY2RhdGEpe2gucGNkYXRhKFwiJmx0Oy9cIixwYXJhbSxjb250aW51YXRpb25NYXJrZXIsY29udGludWF0aW9uTWFrZXIoaCxwYXJ0cyxwb3Msc3RhdGUscGFyYW0pKX19YnJlYWs7Y2FzZVwiPFwiOmlmKG09L14oWy1cXHc6XSspXFxzKlxcLz8vLmV4ZWMobmV4dCkpe2lmKG1bMF0ubGVuZ3RoPT09bmV4dC5sZW5ndGgmJnBhcnRzW3BvcysxXT09PVwiPlwiKXtwb3MrPTI7dGFnTmFtZT1tWzFdLnRvTG93ZXJDYXNlKCk7aWYoaC5zdGFydFRhZyl7aC5zdGFydFRhZyh0YWdOYW1lLFtdLHBhcmFtLGNvbnRpbnVhdGlvbk1hcmtlcixjb250aW51YXRpb25NYWtlcihoLHBhcnRzLHBvcyxzdGF0ZSxwYXJhbSkpfXZhciBlZmxhZ3M9aHRtbDQuRUxFTUVOVFNbdGFnTmFtZV07aWYoZWZsYWdzJkVGTEFHU19URVhUKXt2YXIgdGFnPXtuYW1lOnRhZ05hbWUsbmV4dDpwb3MsZWZsYWdzOmVmbGFnc307cG9zPXBhcnNlVGV4dChwYXJ0cyx0YWcsaCxwYXJhbSxjb250aW51YXRpb25NYXJrZXIsc3RhdGUpfX1lbHNle3Bvcz1wYXJzZVN0YXJ0VGFnKHBhcnRzLHBvcyxoLHBhcmFtLGNvbnRpbnVhdGlvbk1hcmtlcixzdGF0ZSl9fWVsc2V7aWYoaC5wY2RhdGEpe2gucGNkYXRhKFwiJmx0O1wiLHBhcmFtLGNvbnRpbnVhdGlvbk1hcmtlcixjb250aW51YXRpb25NYWtlcihoLHBhcnRzLHBvcyxzdGF0ZSxwYXJhbSkpfX1icmVhaztjYXNlXCI8IS0tXCI6aWYoIXN0YXRlLm5vTW9yZUVuZENvbW1lbnRzKXtmb3IocD1wb3MrMTtwPGVuZDtwKyspe2lmKHBhcnRzW3BdPT09XCI+XCImJi8tLSQvLnRlc3QocGFydHNbcC0xXSkpe2JyZWFrfX1pZihwPGVuZCl7aWYoaC5jb21tZW50KXt2YXIgY29tbWVudD1wYXJ0cy5zbGljZShwb3MscCkuam9pbihcIlwiKTtoLmNvbW1lbnQoY29tbWVudC5zdWJzdHIoMCxjb21tZW50Lmxlbmd0aC0yKSxwYXJhbSxjb250aW51YXRpb25NYXJrZXIsY29udGludWF0aW9uTWFrZXIoaCxwYXJ0cyxwKzEsc3RhdGUscGFyYW0pKX1wb3M9cCsxfWVsc2V7c3RhdGUubm9Nb3JlRW5kQ29tbWVudHM9dHJ1ZX19aWYoc3RhdGUubm9Nb3JlRW5kQ29tbWVudHMpe2lmKGgucGNkYXRhKXtoLnBjZGF0YShcIiZsdDshLS1cIixwYXJhbSxjb250aW51YXRpb25NYXJrZXIsY29udGludWF0aW9uTWFrZXIoaCxwYXJ0cyxwb3Msc3RhdGUscGFyYW0pKX19YnJlYWs7Y2FzZVwiPCFcIjppZighL15cXHcvLnRlc3QobmV4dCkpe2lmKGgucGNkYXRhKXtoLnBjZGF0YShcIiZsdDshXCIscGFyYW0sY29udGludWF0aW9uTWFya2VyLGNvbnRpbnVhdGlvbk1ha2VyKGgscGFydHMscG9zLHN0YXRlLHBhcmFtKSl9fWVsc2V7aWYoIXN0YXRlLm5vTW9yZUdUKXtmb3IocD1wb3MrMTtwPGVuZDtwKyspe2lmKHBhcnRzW3BdPT09XCI+XCIpe2JyZWFrfX1pZihwPGVuZCl7cG9zPXArMX1lbHNle3N0YXRlLm5vTW9yZUdUPXRydWV9fWlmKHN0YXRlLm5vTW9yZUdUKXtpZihoLnBjZGF0YSl7aC5wY2RhdGEoXCImbHQ7IVwiLHBhcmFtLGNvbnRpbnVhdGlvbk1hcmtlcixjb250aW51YXRpb25NYWtlcihoLHBhcnRzLHBvcyxzdGF0ZSxwYXJhbSkpfX19YnJlYWs7Y2FzZVwiPD9cIjppZighc3RhdGUubm9Nb3JlR1Qpe2ZvcihwPXBvcysxO3A8ZW5kO3ArKyl7aWYocGFydHNbcF09PT1cIj5cIil7YnJlYWt9fWlmKHA8ZW5kKXtwb3M9cCsxfWVsc2V7c3RhdGUubm9Nb3JlR1Q9dHJ1ZX19aWYoc3RhdGUubm9Nb3JlR1Qpe2lmKGgucGNkYXRhKXtoLnBjZGF0YShcIiZsdDs/XCIscGFyYW0sY29udGludWF0aW9uTWFya2VyLGNvbnRpbnVhdGlvbk1ha2VyKGgscGFydHMscG9zLHN0YXRlLHBhcmFtKSl9fWJyZWFrO2Nhc2VcIj5cIjppZihoLnBjZGF0YSl7aC5wY2RhdGEoXCImZ3Q7XCIscGFyYW0sY29udGludWF0aW9uTWFya2VyLGNvbnRpbnVhdGlvbk1ha2VyKGgscGFydHMscG9zLHN0YXRlLHBhcmFtKSl9YnJlYWs7Y2FzZVwiXCI6YnJlYWs7ZGVmYXVsdDppZihoLnBjZGF0YSl7aC5wY2RhdGEoY3VycmVudCxwYXJhbSxjb250aW51YXRpb25NYXJrZXIsY29udGludWF0aW9uTWFrZXIoaCxwYXJ0cyxwb3Msc3RhdGUscGFyYW0pKX1icmVha319aWYoaC5lbmREb2Mpe2guZW5kRG9jKHBhcmFtKX19Y2F0Y2goZSl7aWYoZSE9PWNvbnRpbnVhdGlvbk1hcmtlcil7dGhyb3cgZX19fWZ1bmN0aW9uIGh0bWxTcGxpdChzdHIpe3ZhciByZT0vKDxcXC98PFxcIS0tfDxbIT9dfFsmPD5dKS9nO3N0cis9XCJcIjtpZihzcGxpdFdpbGxDYXB0dXJlKXtyZXR1cm4gc3RyLnNwbGl0KHJlKX1lbHNle3ZhciBwYXJ0cz1bXTt2YXIgbGFzdFBvcz0wO3ZhciBtO3doaWxlKChtPXJlLmV4ZWMoc3RyKSkhPT1udWxsKXtwYXJ0cy5wdXNoKHN0ci5zdWJzdHJpbmcobGFzdFBvcyxtLmluZGV4KSk7cGFydHMucHVzaChtWzBdKTtsYXN0UG9zPW0uaW5kZXgrbVswXS5sZW5ndGh9cGFydHMucHVzaChzdHIuc3Vic3RyaW5nKGxhc3RQb3MpKTtyZXR1cm4gcGFydHN9fWZ1bmN0aW9uIHBhcnNlRW5kVGFnKHBhcnRzLHBvcyxoLHBhcmFtLGNvbnRpbnVhdGlvbk1hcmtlcixzdGF0ZSl7dmFyIHRhZz1wYXJzZVRhZ0FuZEF0dHJzKHBhcnRzLHBvcyk7aWYoIXRhZyl7cmV0dXJuIHBhcnRzLmxlbmd0aH1pZihoLmVuZFRhZyl7aC5lbmRUYWcodGFnLm5hbWUscGFyYW0sY29udGludWF0aW9uTWFya2VyLGNvbnRpbnVhdGlvbk1ha2VyKGgscGFydHMscG9zLHN0YXRlLHBhcmFtKSl9cmV0dXJuIHRhZy5uZXh0fWZ1bmN0aW9uIHBhcnNlU3RhcnRUYWcocGFydHMscG9zLGgscGFyYW0sY29udGludWF0aW9uTWFya2VyLHN0YXRlKXt2YXIgdGFnPXBhcnNlVGFnQW5kQXR0cnMocGFydHMscG9zKTtpZighdGFnKXtyZXR1cm4gcGFydHMubGVuZ3RofWlmKGguc3RhcnRUYWcpe2guc3RhcnRUYWcodGFnLm5hbWUsdGFnLmF0dHJzLHBhcmFtLGNvbnRpbnVhdGlvbk1hcmtlcixjb250aW51YXRpb25NYWtlcihoLHBhcnRzLHRhZy5uZXh0LHN0YXRlLHBhcmFtKSl9aWYodGFnLmVmbGFncyZFRkxBR1NfVEVYVCl7cmV0dXJuIHBhcnNlVGV4dChwYXJ0cyx0YWcsaCxwYXJhbSxjb250aW51YXRpb25NYXJrZXIsc3RhdGUpfWVsc2V7cmV0dXJuIHRhZy5uZXh0fX12YXIgZW5kVGFnUmU9e307ZnVuY3Rpb24gcGFyc2VUZXh0KHBhcnRzLHRhZyxoLHBhcmFtLGNvbnRpbnVhdGlvbk1hcmtlcixzdGF0ZSl7dmFyIGVuZD1wYXJ0cy5sZW5ndGg7aWYoIWVuZFRhZ1JlLmhhc093blByb3BlcnR5KHRhZy5uYW1lKSl7ZW5kVGFnUmVbdGFnLm5hbWVdPW5ldyBSZWdFeHAoXCJeXCIrdGFnLm5hbWUrXCIoPzpbXFxcXHNcXFxcL118JClcIixcImlcIil9dmFyIHJlPWVuZFRhZ1JlW3RhZy5uYW1lXTt2YXIgZmlyc3Q9dGFnLm5leHQ7dmFyIHA9dGFnLm5leHQrMTtmb3IoO3A8ZW5kO3ArKyl7aWYocGFydHNbcC0xXT09PVwiPC9cIiYmcmUudGVzdChwYXJ0c1twXSkpe2JyZWFrfX1pZihwPGVuZCl7cC09MX12YXIgYnVmPXBhcnRzLnNsaWNlKGZpcnN0LHApLmpvaW4oXCJcIik7aWYodGFnLmVmbGFncyZodG1sNC5lZmxhZ3NbXCJDREFUQVwiXSl7aWYoaC5jZGF0YSl7aC5jZGF0YShidWYscGFyYW0sY29udGludWF0aW9uTWFya2VyLGNvbnRpbnVhdGlvbk1ha2VyKGgscGFydHMscCxzdGF0ZSxwYXJhbSkpfX1lbHNlIGlmKHRhZy5lZmxhZ3MmaHRtbDQuZWZsYWdzW1wiUkNEQVRBXCJdKXtpZihoLnJjZGF0YSl7aC5yY2RhdGEobm9ybWFsaXplUkNEYXRhKGJ1ZikscGFyYW0sY29udGludWF0aW9uTWFya2VyLGNvbnRpbnVhdGlvbk1ha2VyKGgscGFydHMscCxzdGF0ZSxwYXJhbSkpfX1lbHNle3Rocm93IG5ldyBFcnJvcihcImJ1Z1wiKX1yZXR1cm4gcH1mdW5jdGlvbiBwYXJzZVRhZ0FuZEF0dHJzKHBhcnRzLHBvcyl7dmFyIG09L14oWy1cXHc6XSspLy5leGVjKHBhcnRzW3Bvc10pO3ZhciB0YWc9e307dGFnLm5hbWU9bVsxXS50b0xvd2VyQ2FzZSgpO3RhZy5lZmxhZ3M9aHRtbDQuRUxFTUVOVFNbdGFnLm5hbWVdO3ZhciBidWY9cGFydHNbcG9zXS5zdWJzdHIobVswXS5sZW5ndGgpO3ZhciBwPXBvcysxO3ZhciBlbmQ9cGFydHMubGVuZ3RoO2Zvcig7cDxlbmQ7cCsrKXtpZihwYXJ0c1twXT09PVwiPlwiKXticmVha31idWYrPXBhcnRzW3BdfWlmKGVuZDw9cCl7cmV0dXJuIHZvaWQgMH12YXIgYXR0cnM9W107d2hpbGUoYnVmIT09XCJcIil7bT1BVFRSX1JFLmV4ZWMoYnVmKTtpZighbSl7YnVmPWJ1Zi5yZXBsYWNlKC9eW1xcc1xcU11bXmEtelxcc10qLyxcIlwiKX1lbHNlIGlmKG1bNF0mJiFtWzVdfHxtWzZdJiYhbVs3XSl7dmFyIHF1b3RlPW1bNF18fG1bNl07dmFyIHNhd1F1b3RlPWZhbHNlO3ZhciBhYnVmPVtidWYscGFydHNbcCsrXV07Zm9yKDtwPGVuZDtwKyspe2lmKHNhd1F1b3RlKXtpZihwYXJ0c1twXT09PVwiPlwiKXticmVha319ZWxzZSBpZigwPD1wYXJ0c1twXS5pbmRleE9mKHF1b3RlKSl7c2F3UXVvdGU9dHJ1ZX1hYnVmLnB1c2gocGFydHNbcF0pfWlmKGVuZDw9cCl7YnJlYWt9YnVmPWFidWYuam9pbihcIlwiKTtjb250aW51ZX1lbHNle3ZhciBhTmFtZT1tWzFdLnRvTG93ZXJDYXNlKCk7dmFyIGFWYWx1ZT1tWzJdP2RlY29kZVZhbHVlKG1bM10pOlwiXCI7YXR0cnMucHVzaChhTmFtZSxhVmFsdWUpO2J1Zj1idWYuc3Vic3RyKG1bMF0ubGVuZ3RoKX19dGFnLmF0dHJzPWF0dHJzO3RhZy5uZXh0PXArMTtyZXR1cm4gdGFnfWZ1bmN0aW9uIGRlY29kZVZhbHVlKHYpe3ZhciBxPXYuY2hhckNvZGVBdCgwKTtpZihxPT09MzR8fHE9PT0zOSl7dj12LnN1YnN0cigxLHYubGVuZ3RoLTIpfXJldHVybiB1bmVzY2FwZUVudGl0aWVzKHN0cmlwTlVMcyh2KSl9ZnVuY3Rpb24gbWFrZUh0bWxTYW5pdGl6ZXIodGFnUG9saWN5KXt2YXIgc3RhY2s7dmFyIGlnbm9yaW5nO3ZhciBlbWl0PWZ1bmN0aW9uKHRleHQsb3V0KXtpZighaWdub3Jpbmcpe291dC5wdXNoKHRleHQpfX07cmV0dXJuIG1ha2VTYXhQYXJzZXIoe3N0YXJ0RG9jOmZ1bmN0aW9uKF8pe3N0YWNrPVtdO2lnbm9yaW5nPWZhbHNlfSxzdGFydFRhZzpmdW5jdGlvbih0YWdOYW1lT3JpZyxhdHRyaWJzLG91dCl7aWYoaWdub3Jpbmcpe3JldHVybn1pZighaHRtbDQuRUxFTUVOVFMuaGFzT3duUHJvcGVydHkodGFnTmFtZU9yaWcpKXtyZXR1cm59dmFyIGVmbGFnc09yaWc9aHRtbDQuRUxFTUVOVFNbdGFnTmFtZU9yaWddO2lmKGVmbGFnc09yaWcmaHRtbDQuZWZsYWdzW1wiRk9MREFCTEVcIl0pe3JldHVybn12YXIgZGVjaXNpb249dGFnUG9saWN5KHRhZ05hbWVPcmlnLGF0dHJpYnMpO2lmKCFkZWNpc2lvbil7aWdub3Jpbmc9IShlZmxhZ3NPcmlnJmh0bWw0LmVmbGFnc1tcIkVNUFRZXCJdKTtcbnJldHVybn1lbHNlIGlmKHR5cGVvZiBkZWNpc2lvbiE9PVwib2JqZWN0XCIpe3Rocm93IG5ldyBFcnJvcihcInRhZ1BvbGljeSBkaWQgbm90IHJldHVybiBvYmplY3QgKG9sZCBBUEk/KVwiKX1pZihcImF0dHJpYnNcImluIGRlY2lzaW9uKXthdHRyaWJzPWRlY2lzaW9uW1wiYXR0cmlic1wiXX1lbHNle3Rocm93IG5ldyBFcnJvcihcInRhZ1BvbGljeSBnYXZlIG5vIGF0dHJpYnNcIil9dmFyIGVmbGFnc1JlcDt2YXIgdGFnTmFtZVJlcDtpZihcInRhZ05hbWVcImluIGRlY2lzaW9uKXt0YWdOYW1lUmVwPWRlY2lzaW9uW1widGFnTmFtZVwiXTtlZmxhZ3NSZXA9aHRtbDQuRUxFTUVOVFNbdGFnTmFtZVJlcF19ZWxzZXt0YWdOYW1lUmVwPXRhZ05hbWVPcmlnO2VmbGFnc1JlcD1lZmxhZ3NPcmlnfWlmKGVmbGFnc09yaWcmaHRtbDQuZWZsYWdzW1wiT1BUSU9OQUxfRU5EVEFHXCJdKXt2YXIgb25TdGFjaz1zdGFja1tzdGFjay5sZW5ndGgtMV07aWYob25TdGFjayYmb25TdGFjay5vcmlnPT09dGFnTmFtZU9yaWcmJihvblN0YWNrLnJlcCE9PXRhZ05hbWVSZXB8fHRhZ05hbWVPcmlnIT09dGFnTmFtZVJlcCkpe291dC5wdXNoKFwiPC9cIixvblN0YWNrLnJlcCxcIj5cIil9fWlmKCEoZWZsYWdzT3JpZyZodG1sNC5lZmxhZ3NbXCJFTVBUWVwiXSkpe3N0YWNrLnB1c2goe29yaWc6dGFnTmFtZU9yaWcscmVwOnRhZ05hbWVSZXB9KX1vdXQucHVzaChcIjxcIix0YWdOYW1lUmVwKTtmb3IodmFyIGk9MCxuPWF0dHJpYnMubGVuZ3RoO2k8bjtpKz0yKXt2YXIgYXR0cmliTmFtZT1hdHRyaWJzW2ldLHZhbHVlPWF0dHJpYnNbaSsxXTtpZih2YWx1ZSE9PW51bGwmJnZhbHVlIT09dm9pZCAwKXtvdXQucHVzaChcIiBcIixhdHRyaWJOYW1lLCc9XCInLGVzY2FwZUF0dHJpYih2YWx1ZSksJ1wiJyl9fW91dC5wdXNoKFwiPlwiKTtpZihlZmxhZ3NPcmlnJmh0bWw0LmVmbGFnc1tcIkVNUFRZXCJdJiYhKGVmbGFnc1JlcCZodG1sNC5lZmxhZ3NbXCJFTVBUWVwiXSkpe291dC5wdXNoKFwiPC9cIix0YWdOYW1lUmVwLFwiPlwiKX19LGVuZFRhZzpmdW5jdGlvbih0YWdOYW1lLG91dCl7aWYoaWdub3Jpbmcpe2lnbm9yaW5nPWZhbHNlO3JldHVybn1pZighaHRtbDQuRUxFTUVOVFMuaGFzT3duUHJvcGVydHkodGFnTmFtZSkpe3JldHVybn12YXIgZWZsYWdzPWh0bWw0LkVMRU1FTlRTW3RhZ05hbWVdO2lmKCEoZWZsYWdzJihodG1sNC5lZmxhZ3NbXCJFTVBUWVwiXXxodG1sNC5lZmxhZ3NbXCJGT0xEQUJMRVwiXSkpKXt2YXIgaW5kZXg7aWYoZWZsYWdzJmh0bWw0LmVmbGFnc1tcIk9QVElPTkFMX0VORFRBR1wiXSl7Zm9yKGluZGV4PXN0YWNrLmxlbmd0aDstLWluZGV4Pj0wOyl7dmFyIHN0YWNrRWxPcmlnVGFnPXN0YWNrW2luZGV4XS5vcmlnO2lmKHN0YWNrRWxPcmlnVGFnPT09dGFnTmFtZSl7YnJlYWt9aWYoIShodG1sNC5FTEVNRU5UU1tzdGFja0VsT3JpZ1RhZ10maHRtbDQuZWZsYWdzW1wiT1BUSU9OQUxfRU5EVEFHXCJdKSl7cmV0dXJufX19ZWxzZXtmb3IoaW5kZXg9c3RhY2subGVuZ3RoOy0taW5kZXg+PTA7KXtpZihzdGFja1tpbmRleF0ub3JpZz09PXRhZ05hbWUpe2JyZWFrfX19aWYoaW5kZXg8MCl7cmV0dXJufWZvcih2YXIgaT1zdGFjay5sZW5ndGg7LS1pPmluZGV4Oyl7dmFyIHN0YWNrRWxSZXBUYWc9c3RhY2tbaV0ucmVwO2lmKCEoaHRtbDQuRUxFTUVOVFNbc3RhY2tFbFJlcFRhZ10maHRtbDQuZWZsYWdzW1wiT1BUSU9OQUxfRU5EVEFHXCJdKSl7b3V0LnB1c2goXCI8L1wiLHN0YWNrRWxSZXBUYWcsXCI+XCIpfX1pZihpbmRleDxzdGFjay5sZW5ndGgpe3RhZ05hbWU9c3RhY2tbaW5kZXhdLnJlcH1zdGFjay5sZW5ndGg9aW5kZXg7b3V0LnB1c2goXCI8L1wiLHRhZ05hbWUsXCI+XCIpfX0scGNkYXRhOmVtaXQscmNkYXRhOmVtaXQsY2RhdGE6ZW1pdCxlbmREb2M6ZnVuY3Rpb24ob3V0KXtmb3IoO3N0YWNrLmxlbmd0aDtzdGFjay5sZW5ndGgtLSl7b3V0LnB1c2goXCI8L1wiLHN0YWNrW3N0YWNrLmxlbmd0aC0xXS5yZXAsXCI+XCIpfX19KX12YXIgQUxMT1dFRF9VUklfU0NIRU1FUz0vXig/Omh0dHBzP3xtYWlsdG8pJC9pO2Z1bmN0aW9uIHNhZmVVcmkodXJpLGVmZmVjdCxsdHlwZSxoaW50cyxuYWl2ZVVyaVJld3JpdGVyKXtpZighbmFpdmVVcmlSZXdyaXRlcil7cmV0dXJuIG51bGx9dHJ5e3ZhciBwYXJzZWQ9VVJJLnBhcnNlKFwiXCIrdXJpKTtpZihwYXJzZWQpe2lmKCFwYXJzZWQuaGFzU2NoZW1lKCl8fEFMTE9XRURfVVJJX1NDSEVNRVMudGVzdChwYXJzZWQuZ2V0U2NoZW1lKCkpKXt2YXIgc2FmZT1uYWl2ZVVyaVJld3JpdGVyKHBhcnNlZCxlZmZlY3QsbHR5cGUsaGludHMpO3JldHVybiBzYWZlP3NhZmUudG9TdHJpbmcoKTpudWxsfX19Y2F0Y2goZSl7cmV0dXJuIG51bGx9cmV0dXJuIG51bGx9ZnVuY3Rpb24gbG9nKGxvZ2dlcix0YWdOYW1lLGF0dHJpYk5hbWUsb2xkVmFsdWUsbmV3VmFsdWUpe2lmKCFhdHRyaWJOYW1lKXtsb2dnZXIodGFnTmFtZStcIiByZW1vdmVkXCIse2NoYW5nZTpcInJlbW92ZWRcIix0YWdOYW1lOnRhZ05hbWV9KX1pZihvbGRWYWx1ZSE9PW5ld1ZhbHVlKXt2YXIgY2hhbmdlZD1cImNoYW5nZWRcIjtpZihvbGRWYWx1ZSYmIW5ld1ZhbHVlKXtjaGFuZ2VkPVwicmVtb3ZlZFwifWVsc2UgaWYoIW9sZFZhbHVlJiZuZXdWYWx1ZSl7Y2hhbmdlZD1cImFkZGVkXCJ9bG9nZ2VyKHRhZ05hbWUrXCIuXCIrYXR0cmliTmFtZStcIiBcIitjaGFuZ2VkLHtjaGFuZ2U6Y2hhbmdlZCx0YWdOYW1lOnRhZ05hbWUsYXR0cmliTmFtZTphdHRyaWJOYW1lLG9sZFZhbHVlOm9sZFZhbHVlLG5ld1ZhbHVlOm5ld1ZhbHVlfSl9fWZ1bmN0aW9uIGxvb2t1cEF0dHJpYnV0ZShtYXAsdGFnTmFtZSxhdHRyaWJOYW1lKXt2YXIgYXR0cmliS2V5O2F0dHJpYktleT10YWdOYW1lK1wiOjpcIithdHRyaWJOYW1lO2lmKG1hcC5oYXNPd25Qcm9wZXJ0eShhdHRyaWJLZXkpKXtyZXR1cm4gbWFwW2F0dHJpYktleV19YXR0cmliS2V5PVwiKjo6XCIrYXR0cmliTmFtZTtpZihtYXAuaGFzT3duUHJvcGVydHkoYXR0cmliS2V5KSl7cmV0dXJuIG1hcFthdHRyaWJLZXldfXJldHVybiB2b2lkIDB9ZnVuY3Rpb24gZ2V0QXR0cmlidXRlVHlwZSh0YWdOYW1lLGF0dHJpYk5hbWUpe3JldHVybiBsb29rdXBBdHRyaWJ1dGUoaHRtbDQuQVRUUklCUyx0YWdOYW1lLGF0dHJpYk5hbWUpfWZ1bmN0aW9uIGdldExvYWRlclR5cGUodGFnTmFtZSxhdHRyaWJOYW1lKXtyZXR1cm4gbG9va3VwQXR0cmlidXRlKGh0bWw0LkxPQURFUlRZUEVTLHRhZ05hbWUsYXR0cmliTmFtZSl9ZnVuY3Rpb24gZ2V0VXJpRWZmZWN0KHRhZ05hbWUsYXR0cmliTmFtZSl7cmV0dXJuIGxvb2t1cEF0dHJpYnV0ZShodG1sNC5VUklFRkZFQ1RTLHRhZ05hbWUsYXR0cmliTmFtZSl9ZnVuY3Rpb24gc2FuaXRpemVBdHRyaWJzKHRhZ05hbWUsYXR0cmlicyxvcHRfbmFpdmVVcmlSZXdyaXRlcixvcHRfbm1Ub2tlblBvbGljeSxvcHRfbG9nZ2VyKXtmb3IodmFyIGk9MDtpPGF0dHJpYnMubGVuZ3RoO2krPTIpe3ZhciBhdHRyaWJOYW1lPWF0dHJpYnNbaV07dmFyIHZhbHVlPWF0dHJpYnNbaSsxXTt2YXIgb2xkVmFsdWU9dmFsdWU7dmFyIGF0eXBlPW51bGwsYXR0cmliS2V5O2lmKChhdHRyaWJLZXk9dGFnTmFtZStcIjo6XCIrYXR0cmliTmFtZSxodG1sNC5BVFRSSUJTLmhhc093blByb3BlcnR5KGF0dHJpYktleSkpfHwoYXR0cmliS2V5PVwiKjo6XCIrYXR0cmliTmFtZSxodG1sNC5BVFRSSUJTLmhhc093blByb3BlcnR5KGF0dHJpYktleSkpKXthdHlwZT1odG1sNC5BVFRSSUJTW2F0dHJpYktleV19aWYoYXR5cGUhPT1udWxsKXtzd2l0Y2goYXR5cGUpe2Nhc2UgaHRtbDQuYXR5cGVbXCJOT05FXCJdOmJyZWFrO2Nhc2UgaHRtbDQuYXR5cGVbXCJTQ1JJUFRcIl06dmFsdWU9bnVsbDtpZihvcHRfbG9nZ2VyKXtsb2cob3B0X2xvZ2dlcix0YWdOYW1lLGF0dHJpYk5hbWUsb2xkVmFsdWUsdmFsdWUpfWJyZWFrO2Nhc2UgaHRtbDQuYXR5cGVbXCJTVFlMRVwiXTppZihcInVuZGVmaW5lZFwiPT09dHlwZW9mIHBhcnNlQ3NzRGVjbGFyYXRpb25zKXt2YWx1ZT1udWxsO2lmKG9wdF9sb2dnZXIpe2xvZyhvcHRfbG9nZ2VyLHRhZ05hbWUsYXR0cmliTmFtZSxvbGRWYWx1ZSx2YWx1ZSl9YnJlYWt9dmFyIHNhbml0aXplZERlY2xhcmF0aW9ucz1bXTtwYXJzZUNzc0RlY2xhcmF0aW9ucyh2YWx1ZSx7ZGVjbGFyYXRpb246ZnVuY3Rpb24ocHJvcGVydHksdG9rZW5zKXt2YXIgbm9ybVByb3A9cHJvcGVydHkudG9Mb3dlckNhc2UoKTtzYW5pdGl6ZUNzc1Byb3BlcnR5KG5vcm1Qcm9wLHRva2VucyxvcHRfbmFpdmVVcmlSZXdyaXRlcj9mdW5jdGlvbih1cmwpe3JldHVybiBzYWZlVXJpKHVybCxodG1sNC51ZWZmZWN0cy5TQU1FX0RPQ1VNRU5ULGh0bWw0Lmx0eXBlcy5TQU5EQk9YRUQse1RZUEU6XCJDU1NcIixDU1NfUFJPUDpub3JtUHJvcH0sb3B0X25haXZlVXJpUmV3cml0ZXIpfTpudWxsKTtpZih0b2tlbnMubGVuZ3RoKXtzYW5pdGl6ZWREZWNsYXJhdGlvbnMucHVzaChub3JtUHJvcCtcIjogXCIrdG9rZW5zLmpvaW4oXCIgXCIpKX19fSk7dmFsdWU9c2FuaXRpemVkRGVjbGFyYXRpb25zLmxlbmd0aD4wP3Nhbml0aXplZERlY2xhcmF0aW9ucy5qb2luKFwiIDsgXCIpOm51bGw7aWYob3B0X2xvZ2dlcil7bG9nKG9wdF9sb2dnZXIsdGFnTmFtZSxhdHRyaWJOYW1lLG9sZFZhbHVlLHZhbHVlKX1icmVhaztjYXNlIGh0bWw0LmF0eXBlW1wiSURcIl06Y2FzZSBodG1sNC5hdHlwZVtcIklEUkVGXCJdOmNhc2UgaHRtbDQuYXR5cGVbXCJJRFJFRlNcIl06Y2FzZSBodG1sNC5hdHlwZVtcIkdMT0JBTF9OQU1FXCJdOmNhc2UgaHRtbDQuYXR5cGVbXCJMT0NBTF9OQU1FXCJdOmNhc2UgaHRtbDQuYXR5cGVbXCJDTEFTU0VTXCJdOnZhbHVlPW9wdF9ubVRva2VuUG9saWN5P29wdF9ubVRva2VuUG9saWN5KHZhbHVlKTp2YWx1ZTtpZihvcHRfbG9nZ2VyKXtsb2cob3B0X2xvZ2dlcix0YWdOYW1lLGF0dHJpYk5hbWUsb2xkVmFsdWUsdmFsdWUpfWJyZWFrO2Nhc2UgaHRtbDQuYXR5cGVbXCJVUklcIl06dmFsdWU9c2FmZVVyaSh2YWx1ZSxnZXRVcmlFZmZlY3QodGFnTmFtZSxhdHRyaWJOYW1lKSxnZXRMb2FkZXJUeXBlKHRhZ05hbWUsYXR0cmliTmFtZSkse1RZUEU6XCJNQVJLVVBcIixYTUxfQVRUUjphdHRyaWJOYW1lLFhNTF9UQUc6dGFnTmFtZX0sb3B0X25haXZlVXJpUmV3cml0ZXIpO2lmKG9wdF9sb2dnZXIpe2xvZyhvcHRfbG9nZ2VyLHRhZ05hbWUsYXR0cmliTmFtZSxvbGRWYWx1ZSx2YWx1ZSl9YnJlYWs7Y2FzZSBodG1sNC5hdHlwZVtcIlVSSV9GUkFHTUVOVFwiXTppZih2YWx1ZSYmXCIjXCI9PT12YWx1ZS5jaGFyQXQoMCkpe3ZhbHVlPXZhbHVlLnN1YnN0cmluZygxKTt2YWx1ZT1vcHRfbm1Ub2tlblBvbGljeT9vcHRfbm1Ub2tlblBvbGljeSh2YWx1ZSk6dmFsdWU7aWYodmFsdWUhPT1udWxsJiZ2YWx1ZSE9PXZvaWQgMCl7dmFsdWU9XCIjXCIrdmFsdWV9fWVsc2V7dmFsdWU9bnVsbH1pZihvcHRfbG9nZ2VyKXtsb2cob3B0X2xvZ2dlcix0YWdOYW1lLGF0dHJpYk5hbWUsb2xkVmFsdWUsdmFsdWUpfWJyZWFrO2RlZmF1bHQ6dmFsdWU9bnVsbDtpZihvcHRfbG9nZ2VyKXtsb2cob3B0X2xvZ2dlcix0YWdOYW1lLGF0dHJpYk5hbWUsb2xkVmFsdWUsdmFsdWUpfWJyZWFrfX1lbHNle3ZhbHVlPW51bGw7aWYob3B0X2xvZ2dlcil7bG9nKG9wdF9sb2dnZXIsdGFnTmFtZSxhdHRyaWJOYW1lLG9sZFZhbHVlLHZhbHVlKX19YXR0cmlic1tpKzFdPXZhbHVlfXJldHVybiBhdHRyaWJzfWZ1bmN0aW9uIG1ha2VUYWdQb2xpY3kob3B0X25haXZlVXJpUmV3cml0ZXIsb3B0X25tVG9rZW5Qb2xpY3ksb3B0X2xvZ2dlcil7cmV0dXJuIGZ1bmN0aW9uKHRhZ05hbWUsYXR0cmlicyl7aWYoIShodG1sNC5FTEVNRU5UU1t0YWdOYW1lXSZodG1sNC5lZmxhZ3NbXCJVTlNBRkVcIl0pKXtyZXR1cm57YXR0cmliczpzYW5pdGl6ZUF0dHJpYnModGFnTmFtZSxhdHRyaWJzLG9wdF9uYWl2ZVVyaVJld3JpdGVyLG9wdF9ubVRva2VuUG9saWN5LG9wdF9sb2dnZXIpfX1lbHNle2lmKG9wdF9sb2dnZXIpe2xvZyhvcHRfbG9nZ2VyLHRhZ05hbWUsdW5kZWZpbmVkLHVuZGVmaW5lZCx1bmRlZmluZWQpfX19fWZ1bmN0aW9uIHNhbml0aXplV2l0aFBvbGljeShpbnB1dEh0bWwsdGFnUG9saWN5KXt2YXIgb3V0cHV0QXJyYXk9W107bWFrZUh0bWxTYW5pdGl6ZXIodGFnUG9saWN5KShpbnB1dEh0bWwsb3V0cHV0QXJyYXkpO3JldHVybiBvdXRwdXRBcnJheS5qb2luKFwiXCIpfWZ1bmN0aW9uIHNhbml0aXplKGlucHV0SHRtbCxvcHRfbmFpdmVVcmlSZXdyaXRlcixvcHRfbm1Ub2tlblBvbGljeSxvcHRfbG9nZ2VyKXt2YXIgdGFnUG9saWN5PW1ha2VUYWdQb2xpY3kob3B0X25haXZlVXJpUmV3cml0ZXIsb3B0X25tVG9rZW5Qb2xpY3ksb3B0X2xvZ2dlcik7cmV0dXJuIHNhbml0aXplV2l0aFBvbGljeShpbnB1dEh0bWwsdGFnUG9saWN5KX12YXIgaHRtbD17fTtodG1sLmVzY2FwZUF0dHJpYj1odG1sW1wiZXNjYXBlQXR0cmliXCJdPWVzY2FwZUF0dHJpYjtodG1sLm1ha2VIdG1sU2FuaXRpemVyPWh0bWxbXCJtYWtlSHRtbFNhbml0aXplclwiXT1tYWtlSHRtbFNhbml0aXplcjtodG1sLm1ha2VTYXhQYXJzZXI9aHRtbFtcIm1ha2VTYXhQYXJzZXJcIl09bWFrZVNheFBhcnNlcjtodG1sLm1ha2VUYWdQb2xpY3k9aHRtbFtcIm1ha2VUYWdQb2xpY3lcIl09bWFrZVRhZ1BvbGljeTtodG1sLm5vcm1hbGl6ZVJDRGF0YT1odG1sW1wibm9ybWFsaXplUkNEYXRhXCJdPW5vcm1hbGl6ZVJDRGF0YTtodG1sLnNhbml0aXplPWh0bWxbXCJzYW5pdGl6ZVwiXT1zYW5pdGl6ZTtodG1sLnNhbml0aXplQXR0cmlicz1odG1sW1wic2FuaXRpemVBdHRyaWJzXCJdPXNhbml0aXplQXR0cmlicztodG1sLnNhbml0aXplV2l0aFBvbGljeT1odG1sW1wic2FuaXRpemVXaXRoUG9saWN5XCJdPXNhbml0aXplV2l0aFBvbGljeTtodG1sLnVuZXNjYXBlRW50aXRpZXM9aHRtbFtcInVuZXNjYXBlRW50aXRpZXNcIl09dW5lc2NhcGVFbnRpdGllcztyZXR1cm4gaHRtbH0oaHRtbDQpO3ZhciBodG1sX3Nhbml0aXplPWh0bWxbXCJzYW5pdGl6ZVwiXTtpZih0eXBlb2Ygd2luZG93IT09XCJ1bmRlZmluZWRcIil7d2luZG93W1wiaHRtbFwiXT1odG1sO3dpbmRvd1tcImh0bWxfc2FuaXRpemVcIl09aHRtbF9zYW5pdGl6ZX0iXX0=
